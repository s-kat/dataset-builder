{"_args_converter": {"line": 816, "args": [{"func_args": {"args": "['--cov=pundle', '-s', '-vv', 'tests']"}, "return_value": "('--cov=pundle', '-s', '-vv', 'tests')"}], "text": "def _args_converter(args: Iterable[str]) -> Tuple[str, ...]:\n    return tuple(args)"}, "_get_plugin_specs_as_list": {"line": 715, "args": [{"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "None"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}], "text": "def _get_plugin_specs_as_list(\n    specs: Union[None, types.ModuleType, str, Sequence[str]]\n) -> List[str]:\n    \"\"\"Parse a plugins specification into a list of plugin names.\"\"\"\n    # None means empty.\n    if specs is None:\n        return []\n    # Workaround for #3899 - a submodule which happens to be called \"pytest_plugins\".\n    if isinstance(specs, types.ModuleType):\n        return []\n    # Comma-separated list.\n    if isinstance(specs, str):\n        return specs.split(\",\") if specs else []\n    # Direct specification.\n    if isinstance(specs, collections.abc.Sequence):\n        return list(specs)\n    raise UsageError(\n        \"Plugins may be specified as a sequence or a ','-separated string of plugin names. Got: %r\"\n        % specs\n    )"}, "_assertion_supported": {"line": 1511, "args": [{"func_args": {}, "return_value": "True"}], "text": "def _assertion_supported() -> bool:\n    try:\n        assert False\n    except AssertionError:\n        return True\n    else:\n        return False"}, "scope2index": {"line": 803, "args": [{"func_args": {"scope": "'session'", "descr": "\"Fixture 'pytestconfig'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'capfd'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'capfdbinary'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'capsys'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'capsysbinary'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'tmp_path'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'tmp_path_factory'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'tmpdir'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'tmpdir_factory'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'monkeypatch'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'recwarn'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'record_property'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'record_testsuite_property'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'record_xml_attribute'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'doctest_namespace'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'cache'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'caplog'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'class'", "descr": "\"Fixture '_mocker'\"", "where": "None"}, "return_value": "3"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture '_mocker'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'module'", "descr": "\"Fixture '_mocker'\"", "where": "None"}, "return_value": "2"}, {"func_args": {"scope": "'package'", "descr": "\"Fixture '_mocker'\"", "where": "None"}, "return_value": "1"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture '_mocker'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'cov'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'no_cover'\"", "where": "None"}, "return_value": "4"}], "text": "def scope2index(scope: str, descr: str, where: Optional[str] = None) -> int:\n    \"\"\"Look up the index of ``scope`` and raise a descriptive value error\n    if not defined.\"\"\"\n    strscopes: Sequence[str] = scopes\n    try:\n        return strscopes.index(scope)\n    except ValueError:\n        fail(\n            \"{} {}got an unexpected scope value '{}'\".format(\n                descr, f\"from {where} \" if where else \"\", scope\n            ),\n            pytrace=False,\n        )"}, "sort_by_scope": {"line": 1539, "args": [{"func_args": {"arg_name": "'mocker'"}, "return_value": "4"}, {"func_args": {"arg_name": "'pytestconfig'"}, "return_value": "0"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'mocker'"}, "return_value": "4"}, {"func_args": {"arg_name": "'pytestconfig'"}, "return_value": "0"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'mocker'"}, "return_value": "4"}, {"func_args": {"arg_name": "'pytestconfig'"}, "return_value": "0"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'mocker'"}, "return_value": "4"}, {"func_args": {"arg_name": "'pytestconfig'"}, "return_value": "0"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'mocker'"}, "return_value": "4"}, {"func_args": {"arg_name": "'pytestconfig'"}, "return_value": "0"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'mocker'"}, "return_value": "4"}, {"func_args": {"arg_name": "'pytestconfig'"}, "return_value": "0"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'mocker'"}, "return_value": "4"}, {"func_args": {"arg_name": "'pytestconfig'"}, "return_value": "0"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'mocker'"}, "return_value": "4"}, {"func_args": {"arg_name": "'pytestconfig'"}, "return_value": "0"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'mocker'"}, "return_value": "4"}, {"func_args": {"arg_name": "'pytestconfig'"}, "return_value": "0"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'mocker'"}, "return_value": "4"}, {"func_args": {"arg_name": "'pytestconfig'"}, "return_value": "0"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'mocker'"}, "return_value": "4"}, {"func_args": {"arg_name": "'pytestconfig'"}, "return_value": "0"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}], "text": "def sort_by_scope(arg_name: str) -> int:\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum"}, "scopemismatch": {"line": 799, "args": [{"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}], "text": "def scopemismatch(currentscope: \"_Scope\", newscope: \"_Scope\") -> bool:\n    return scopes.index(newscope) > scopes.index(currentscope)"}, "mkrel": {"line": 859, "args": [{"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "'tests/test_install.py::test_need_freeze'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "'tests/test_install.py::test_need_freeze'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "'tests/test_install.py::test_frozen'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "'tests/test_install.py::test_frozen'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "'tests/test_install.py::test_vcs'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "'tests/test_install.py::test_vcs'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "'tests/test_install.py::test_vcs_frozen'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "'tests/test_install.py::test_vcs_frozen'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "'tests/test_pipfile.py::test_parse_pipfile'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "'tests/test_pipfile.py::test_parse_pipfile'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "'tests/test_simple.py::test_pypy_python_version'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "'tests/test_simple.py::test_pypy_python_version'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "'tests/test_simple.py::test_cpython_python_version'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "'tests/test_simple.py::test_cpython_python_version'"}, {"func_args": {"nodeid": "'tests/test_vcs_requirements.py::test_parse_vcs_requirement'"}, "return_value": "'tests/test_vcs_requirements.py::test_parse_vcs_requirement'"}, {"func_args": {"nodeid": "'tests/test_vcs_requirements.py::test_parse_vcs_requirement'"}, "return_value": "'tests/test_vcs_requirements.py::test_parse_vcs_requirement'"}], "text": "def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line"}, "pluralize": {"line": 1350, "args": [{"func_args": {"count": "12", "noun": "'passed'"}, "return_value": "(12, 'passed')"}, {"func_args": {"count": "1", "noun": "'warnings'"}, "return_value": "(1, 'warning')"}], "text": "def pluralize(count: int, noun: str) -> Tuple[int, str]:\n    # No need to pluralize words such as `failed` or `passed`.\n    if noun not in [\"error\", \"warnings\", \"test\"]:\n        return count, noun\n\n    # The `warnings` key is plural. To avoid API breakage, we keep it that way but\n    # set it to singular here so we can determine plurality in the same way as we do\n    # for `error`.\n    noun = noun.replace(\"warnings\", \"warning\")\n\n    return count, noun + \"s\" if count != 1 else noun"}, "format_session_duration": {"line": 1377, "args": [{"func_args": {"seconds": "2.018454074859619"}, "return_value": "'2.02s'"}], "text": "def format_session_duration(seconds: float) -> str:\n    \"\"\"Format the given seconds in a human readable manner to show in the final summary.\"\"\"\n    if seconds < 60:\n        return f\"{seconds:.2f}s\"\n    else:\n        dt = datetime.timedelta(seconds=int(seconds))\n        return f\"{seconds:.2f}s ({dt})\""}, "_get_auto_indent": {"line": 113, "args": [{"func_args": {"auto_indent_option": "None"}, "return_value": "0"}, {"func_args": {"auto_indent_option": "None"}, "return_value": "0"}]}, "_get_stderr_fileno": {"line": 68, "args": [{"func_args": {}, "return_value": "2"}, {"func_args": {}, "return_value": "2"}]}, "get_terminal_width": {"line": 15, "args": [{"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}], "text": "def get_terminal_width() -> int:\n    width, _ = shutil.get_terminal_size(fallback=(80, 24))\n\n    # The Windows get_terminal_size may be bogus, let's sanify a bit.\n    if width < 40:\n        width = 80\n\n    return width"}, "is_option": {"line": 135, "args": [{"func_args": {"x": "'tests'"}, "return_value": "False"}, {"func_args": {"x": "'--cov=pundle'"}, "return_value": "True"}], "text": "def is_option(x: str) -> bool:\n        return x.startswith(\"-\")"}, "get_file_part_from_node_id": {"line": 138, "args": [{"func_args": {"x": "'tests'"}, "return_value": "'tests'"}], "text": "def get_file_part_from_node_id(x: str) -> str:\n        return x.split(\"::\")[0]"}, "parts": {"line": 420, "args": [{"func_args": {"s": "'/usr/app/src/test_repos/pundler/tests/lib.py'"}, "return_value": "{'/usr/app/src/test_repos', '/usr', '/usr/app/src/test_repos/pundler/tests/lib.py', '/usr/app/src/test_repos/pundler/tests', '/usr/app/src/test_repos/pundler', '/usr/app/src', '/', '/usr/app'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/pundler/tests/test_install.py'"}, "return_value": "{'/usr/app/src/test_repos', '/usr/app/src/test_repos/pundler/tests/test_install.py', '/usr', '/usr/app/src/test_repos/pundler/tests', '/usr/app/src/test_repos/pundler', '/usr/app/src', '/', '/usr/app'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/pundler/tests/test_pipfile.py'"}, "return_value": "{'/usr/app/src/test_repos', '/usr/app/src/test_repos/pundler/tests/test_pipfile.py', '/usr', '/usr/app/src/test_repos/pundler/tests', '/usr/app/src/test_repos/pundler', '/usr/app/src', '/', '/usr/app'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/pundler/tests/test_setup_py.py'"}, "return_value": "{'/usr/app/src/test_repos', '/usr', '/usr/app/src/test_repos/pundler/tests', '/usr/app/src/test_repos/pundler', '/usr/app/src/test_repos/pundler/tests/test_setup_py.py', '/usr/app/src', '/', '/usr/app'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/pundler/tests/test_simple.py'"}, "return_value": "{'/usr/app/src/test_repos', '/usr', '/usr/app/src/test_repos/pundler/tests', '/usr/app/src/test_repos/pundler/tests/test_simple.py', '/usr/app/src/test_repos/pundler', '/usr/app/src', '/', '/usr/app'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/pundler/tests/test_vcs_requirements.py'"}, "return_value": "{'/usr/app/src/test_repos', '/usr', '/usr/app/src/test_repos/pundler/tests/test_vcs_requirements.py', '/usr/app/src/test_repos/pundler/tests', '/usr/app/src/test_repos/pundler', '/usr/app/src', '/', '/usr/app'}"}], "text": "def parts(s: str) -> Set[str]:\n    parts = s.split(sep)\n    return {sep.join(parts[: i + 1]) or sep for i in range(len(parts))}"}, "_is_same": {"line": 558, "args": [{"func_args": {"f1": "'/usr/app/src/test_repos/pundler/tests/test_install.py'", "f2": "'/usr/app/src/test_repos/pundler/tests/test_install.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/pundler/tests/test_pipfile.py'", "f2": "'/usr/app/src/test_repos/pundler/tests/test_pipfile.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/pundler/tests/test_setup_py.py'", "f2": "'/usr/app/src/test_repos/pundler/tests/test_setup_py.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/pundler/tests/test_simple.py'", "f2": "'/usr/app/src/test_repos/pundler/tests/test_simple.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/pundler/tests/test_vcs_requirements.py'", "f2": "'/usr/app/src/test_repos/pundler/tests/test_vcs_requirements.py'"}, "return_value": "True"}], "text": "def _is_same(f1: str, f2: str) -> bool:\n        return os.path.samefile(f1, f2)"}, "iscommentline": {"line": 162, "args": [{"func_args": {"line": "'[tox]\\n'"}, "return_value": "False"}, {"func_args": {"line": "'envlist = py27,py38\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\n'"}, "return_value": "True"}, {"func_args": {"line": "'[testenv]\\n'"}, "return_value": "False"}, {"func_args": {"line": "'deps = \\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tunittest2\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tpymongo\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tflake8\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tpylint\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tpytest\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tpytest-mock\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tpytest-cov\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tcoverage\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\ttoml\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tviztracer \\n'"}, "return_value": "False"}, {"func_args": {"line": "'commands = \\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tviztracer --ignore_frozen --log_func_args --log_func_retval -o result0.json -- pytest --cov=pundle -s -vv {toxinidir}/tests\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tflake8 pundle.py\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\n'"}, "return_value": "True"}, {"func_args": {"line": "'[flake8]\\n'"}, "return_value": "False"}, {"func_args": {"line": "'exclude = .tox,*.egg,build\\n'"}, "return_value": "False"}, {"func_args": {"line": "'max-line-length = 120\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\n'"}, "return_value": "True"}, {"func_args": {"line": "'[bdist_wheel]\\n'"}, "return_value": "False"}, {"func_args": {"line": "'universal = 1\\n'"}, "return_value": "False"}], "text": "def iscommentline(line):\n    c = line.lstrip()[:1]\n    return c in COMMENTCHARS"}, "_prepare_cov_source": {"line": 125, "args": [{"func_args": {"cov_source": "['pundle']"}, "return_value": "['pundle']"}], "text": "def _prepare_cov_source(cov_source):\n    \"\"\"\n    Prepare cov_source so that:\n\n     --cov --cov=foobar is equivalent to --cov (cov_source=None)\n     --cov=foo --cov=bar is equivalent to cov_source=['foo', 'bar']\n    \"\"\"\n    return None if True in cov_source else [path for path in cov_source if path is not True]"}, "bool_or_none": {"line": 174, "args": [{"func_args": {"b": "True"}, "return_value": "True"}, {"func_args": {"b": "True"}, "return_value": "True"}], "text": "def bool_or_none(b):\n    \"\"\"Return bool(b), but preserve None.\"\"\"\n    if b is None:\n        return None\n    else:\n        return bool(b)"}, "tryint": {"line": 370, "args": [{"func_args": {"s": "'/usr/app/src/test_repos/pundler/.tox/py'"}, "return_value": "'/usr/app/src/test_repos/pundler/.tox/py'"}, {"func_args": {"s": "'38'"}, "return_value": "38"}, {"func_args": {"s": "'/lib/python'"}, "return_value": "'/lib/python'"}, {"func_args": {"s": "'3'"}, "return_value": "3"}, {"func_args": {"s": "'.'"}, "return_value": "'.'"}, {"func_args": {"s": "'8'"}, "return_value": "8"}, {"func_args": {"s": "'/site-packages/coverage'"}, "return_value": "'/site-packages/coverage'"}, {"func_args": {"s": "'/root/.local/bin'"}, "return_value": "'/root/.local/bin'"}, {"func_args": {"s": "'/root/.local/lib/python'"}, "return_value": "'/root/.local/lib/python'"}, {"func_args": {"s": "'3'"}, "return_value": "3"}, {"func_args": {"s": "'.'"}, "return_value": "'.'"}, {"func_args": {"s": "'8'"}, "return_value": "8"}, {"func_args": {"s": "'/site-packages'"}, "return_value": "'/site-packages'"}, {"func_args": {"s": "'/usr/app/src/test_repos/pundler/.tox/py'"}, "return_value": "'/usr/app/src/test_repos/pundler/.tox/py'"}, {"func_args": {"s": "'38'"}, "return_value": "38"}, {"func_args": {"s": "'/bin'"}, "return_value": "'/bin'"}, {"func_args": {"s": "'/usr/app/src/test_repos/pundler/.tox/py'"}, "return_value": "'/usr/app/src/test_repos/pundler/.tox/py'"}, {"func_args": {"s": "'38'"}, "return_value": "38"}, {"func_args": {"s": "'/lib/python'"}, "return_value": "'/lib/python'"}, {"func_args": {"s": "'/usr/app/src/test_repos/pundler/.tox/py'"}, "return_value": "'/usr/app/src/test_repos/pundler/.tox/py'"}, {"func_args": {"s": "'38'"}, "return_value": "38"}, {"func_args": {"s": "'/lib/python'"}, "return_value": "'/lib/python'"}, {"func_args": {"s": "'3'"}, "return_value": "3"}, {"func_args": {"s": "'.'"}, "return_value": "'.'"}, {"func_args": {"s": "'8'"}, "return_value": "8"}, {"func_args": {"s": "'/site-packages'"}, "return_value": "'/site-packages'"}, {"func_args": {"s": "'pundle.py     '"}, "return_value": "'pundle.py     '"}, {"func_args": {"s": "'863'"}, "return_value": "863"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'456'"}, "return_value": "456"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'47'"}, "return_value": "47"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'54'"}, "return_value": "54"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'59'"}, "return_value": "59"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'79'"}, "return_value": "79"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'103'"}, "return_value": "103"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'117'"}, "return_value": "117"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'133'"}, "return_value": "133"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'137'"}, "return_value": "137"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'144'"}, "return_value": "144"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'160'"}, "return_value": "160"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'170'"}, "return_value": "170"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'173'"}, "return_value": "173"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'176'"}, "return_value": "176"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'179'"}, "return_value": "179"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'190'"}, "return_value": "190"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'194'"}, "return_value": "194"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'210'"}, "return_value": "210"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'216'"}, "return_value": "216"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'219'"}, "return_value": "219"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'222'"}, "return_value": "222"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'226'"}, "return_value": "226"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'229'"}, "return_value": "229"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'237'"}, "return_value": "237"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'245'"}, "return_value": "245"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'249'"}, "return_value": "249"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'256'"}, "return_value": "256"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'259'"}, "return_value": "259"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'303'"}, "return_value": "303"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'309'"}, "return_value": "309"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'329'"}, "return_value": "329"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'332'"}, "return_value": "332"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'348'"}, "return_value": "348"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'350'"}, "return_value": "350"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'355'"}, "return_value": "355"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'359'"}, "return_value": "359"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'363'"}, "return_value": "363"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'372'"}, "return_value": "372"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'377'"}, "return_value": "377"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'379'"}, "return_value": "379"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'384'"}, "return_value": "384"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'386'"}, "return_value": "386"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'394'"}, "return_value": "394"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'398'"}, "return_value": "398"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'402'"}, "return_value": "402"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'404'"}, "return_value": "404"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'405'"}, "return_value": "405"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'408'"}, "return_value": "408"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'417'"}, "return_value": "417"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'420'"}, "return_value": "420"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'436'"}, "return_value": "436"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'444'"}, "return_value": "444"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'448'"}, "return_value": "448"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'461'"}, "return_value": "461"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'476'"}, "return_value": "476"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'478'"}, "return_value": "478"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'481'"}, "return_value": "481"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'496'"}, "return_value": "496"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'498'"}, "return_value": "498"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'514'"}, "return_value": "514"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'520'"}, "return_value": "520"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'527'"}, "return_value": "527"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'530'"}, "return_value": "530"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'543'"}, "return_value": "543"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'544'"}, "return_value": "544"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'547'"}, "return_value": "547"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'549'"}, "return_value": "549"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'587'"}, "return_value": "587"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'617'"}, "return_value": "617"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'632'"}, "return_value": "632"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'645'"}, "return_value": "645"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'660'"}, "return_value": "660"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'667'"}, "return_value": "667"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'673'"}, "return_value": "673"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'680'"}, "return_value": "680"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'687'"}, "return_value": "687"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'697'"}, "return_value": "697"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'711'"}, "return_value": "711"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'770'"}, "return_value": "770"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'774'"}, "return_value": "774"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'781'"}, "return_value": "781"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'784'"}, "return_value": "784"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'800'"}, "return_value": "800"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'850'"}, "return_value": "850"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'854'"}, "return_value": "854"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'855'"}, "return_value": "855"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'872'"}, "return_value": "872"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'877'"}, "return_value": "877"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'885'"}, "return_value": "885"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'896'"}, "return_value": "896"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'901'"}, "return_value": "901"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'911'"}, "return_value": "911"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'916'"}, "return_value": "916"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'923'"}, "return_value": "923"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'927'"}, "return_value": "927"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'953'"}, "return_value": "953"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'957'"}, "return_value": "957"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'961'"}, "return_value": "961"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'966'"}, "return_value": "966"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'972'"}, "return_value": "972"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'976'"}, "return_value": "976"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'983'"}, "return_value": "983"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'987'"}, "return_value": "987"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'997'"}, "return_value": "997"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1009'"}, "return_value": "1009"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1037'"}, "return_value": "1037"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1041'"}, "return_value": "1041"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1052'"}, "return_value": "1052"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1069'"}, "return_value": "1069"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1072'"}, "return_value": "1072"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1076'"}, "return_value": "1076"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1084'"}, "return_value": "1084"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1090'"}, "return_value": "1090"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1099'"}, "return_value": "1099"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1101'"}, "return_value": "1101"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1110'"}, "return_value": "1110"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1119'"}, "return_value": "1119"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1125'"}, "return_value": "1125"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1126'"}, "return_value": "1126"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1132'"}, "return_value": "1132"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1136'"}, "return_value": "1136"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1142'"}, "return_value": "1142"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1160'"}, "return_value": "1160"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1164'"}, "return_value": "1164"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1180'"}, "return_value": "1180"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1186'"}, "return_value": "1186"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1203'"}, "return_value": "1203"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1209'"}, "return_value": "1209"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1214'"}, "return_value": "1214"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1220'"}, "return_value": "1220"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1225'"}, "return_value": "1225"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1231'"}, "return_value": "1231"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1234'"}, "return_value": "1234"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1240'"}, "return_value": "1240"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1246'"}, "return_value": "1246"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1258'"}, "return_value": "1258"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1295'"}, "return_value": "1295"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1301'"}, "return_value": "1301"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1304'"}, "return_value": "1304"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1321'"}, "return_value": "1321"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1326'"}, "return_value": "1326"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1332'"}, "return_value": "1332"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1333'"}, "return_value": "1333"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1337'"}, "return_value": "1337"}, {"func_args": {"s": "''"}, "return_value": "''"}], "text": "def tryint(s):\n        \"\"\"If `s` is a number, return an int, else `s` unchanged.\"\"\"\n        try:\n            return int(s)\n        except ValueError:\n            return s"}, "human_key": {"line": 366, "args": [{"func_args": {"s": "'/usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/coverage'"}, "return_value": "['/usr/app/src/test_repos/pundler/.tox/py', 38, '/lib/python', 3, '.', 8, '/site-packages/coverage']"}, {"func_args": {"s": "'/root/.local/bin'"}, "return_value": "['/root/.local/bin']"}, {"func_args": {"s": "'/root/.local/lib/python3.8/site-packages'"}, "return_value": "['/root/.local/lib/python', 3, '.', 8, '/site-packages']"}, {"func_args": {"s": "'/usr/app/src/test_repos/pundler/.tox/py38/bin'"}, "return_value": "['/usr/app/src/test_repos/pundler/.tox/py', 38, '/bin']"}, {"func_args": {"s": "'/usr/app/src/test_repos/pundler/.tox/py38/lib/python'"}, "return_value": "['/usr/app/src/test_repos/pundler/.tox/py', 38, '/lib/python']"}, {"func_args": {"s": "'/usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages'"}, "return_value": "['/usr/app/src/test_repos/pundler/.tox/py', 38, '/lib/python', 3, '.', 8, '/site-packages']"}, {"func_args": {"s": "'pundle.py     863    456    47%   54-59, 79, 103-117, 133, 137, 144, 160-170, 173, 176, 179, 190, 194, 210, 216-219, 222-226, 229-237, 245, 249-256, 259-303, 309, 329-332, 348, 350-355, 359, 363-372, 377, 379, 384-386, 394-398, 402, 404-405, 408-417, 420-436, 444-448, 461, 476-478, 481, 496-498, 514-520, 527-530, 543-544, 547-549, 587, 617, 632, 645, 660, 667, 673-680, 687, 697, 711, 770, 774-781, 784, 800, 850, 854-855, 872, 877, 885-896, 901-911, 916-923, 927-953, 957-961, 966-972, 976-983, 987-997, 1009-1037, 1041-1052, 1069-1072, 1076-1084, 1090, 1099-1101, 1110-1119, 1125-1126, 1132-1136, 1142-1160, 1164-1180, 1186-1203, 1209-1214, 1220-1225, 1231-1234, 1240-1246, 1258-1295, 1301-1304, 1321-1326, 1332-1333, 1337'"}, "return_value": "['pundle.py     ', 863, '    ', 456, '    ', 47, '%   ', 54, '-', 59, ', ', 79, ', ', 103, '-', 117, ', ', 133, ', ', 137, ', ', 144, ', ', 160, '-', 170, ', ', 173, ', ', 176, ', ', 179, ', ', 190, ', ', 194, ', ', 210, ', ', 216, '-', 219, ', ', 222, '-', 226, ', ', 229, '-', 237, ', ', 245, ', ', 249, '-', 256, ', ', 259, '-', 303, ', ', 309, ', ', 329, '-', 332, ', ', 348, ', ', 350, '-', 355, ', ', 359, ', ', 363, '-', 372, ', ', 377, ', ', 379, ', ', 384, '-', 386, ', ', 394, '-', 398, ', ', 402, ', ', 404, '-', 405, ', ', 408, '-', 417, ', ', 420, '-', 436, ', ', 444, '-', 448, ', ', 461, ', ', 476, '-', 478, ', ', 481, ', ', 496, '-', 498, ', ', 514, '-', 520, ', ', 527, '-', 530, ', ', 543, '-', 544, ', ', 547, '-', 549, ', ', 587, ', ', 617, ', ', 632, ', ', 645, ', ', 660, ', ', 667, ', ', 673, '-', 680, ', ', 687, ', ', 697, ', ', 711, ', ', 770, ', ', 774, '-', 781, ', ', 784, ', ', 800, ', ', 850, ', ', 854, '-', 855, ', ', 872, ', ', 877, ', ', 885, '-', 896, ', ', 901, '-', 911, ', ', 916, '-', 923, ', ', 927, '-', 953, ', ', 957, '-', 961, ', ', 966, '-', 972, ', ', 976, '-', 983, ', ', 987, '-', 997, ', ', 1009, '-', 1037, ', ', 1041, '-', 1052, ', ', 1069, '-', 1072, ', ', 1076, '-', 1084, ', ', 1090, ', ', 1099, '-', 1101, ', ', 1110, '-', 1119, ', ', 1125, '-', 1126, ', ', 1132, '-', 1136, ', ', 1142, '-', 1160, ', ', 1164, '-', 1180, ', ', 1186, '-', 1203, ', ', 1209, '-', 1214, ', ', 1220, '-', 1225, ', ', 1231, '-', 1234, ', ', 1240, '-', 1246, ', ', 1258, '-', 1295, ', ', 1301, '-', 1304, ', ', 1321, '-', 1326, ', ', 1332, '-', 1333, ', ', 1337, '']"}], "text": "def human_key(s):\n    \"\"\"Turn a string into a list of string and number chunks.\n        \"z23a\" -> [\"z\", 23, \"a\"]\n    \"\"\"\n    def tryint(s):\n        \"\"\"If `s` is a number, return an int, else `s` unchanged.\"\"\"\n        try:\n            return int(s)\n        except ValueError:\n            return s\n\n    return [tryint(c) for c in re.split(r\"(\\d+)\", s)]"}, "human_sorted": {"line": 379, "args": [{"func_args": {"strings": "{'/usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/coverage'}"}, "return_value": "['/usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/coverage']"}, {"func_args": {"strings": "{'/root/.local/bin', '/root/.local/lib/python3.8/site-packages', '/usr/app/src/test_repos/pundler/.tox/py38/bin', '/usr/app/src/test_repos/pundler/.tox/py38/lib/python', '/usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages'}"}, "return_value": "['/root/.local/bin', '/root/.local/lib/python3.8/site-packages', '/usr/app/src/test_repos/pundler/.tox/py38/bin', '/usr/app/src/test_repos/pundler/.tox/py38/lib/python', '/usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages']"}], "text": "def human_sorted(strings):\n    \"\"\"Sort the given iterable of strings the way that humans expect.\n\n    Numeric components in the strings are sorted as numbers.\n\n    Returns the sorted list.\n\n    \"\"\"\n    return sorted(strings, key=human_key)"}, "nice_pair": {"line": 140, "args": [{"func_args": {"pair": "(54, 59)"}, "return_value": "'54-59'"}, {"func_args": {"pair": "(79, 79)"}, "return_value": "'79'"}, {"func_args": {"pair": "(103, 117)"}, "return_value": "'103-117'"}, {"func_args": {"pair": "(133, 133)"}, "return_value": "'133'"}, {"func_args": {"pair": "(137, 137)"}, "return_value": "'137'"}, {"func_args": {"pair": "(144, 144)"}, "return_value": "'144'"}, {"func_args": {"pair": "(160, 170)"}, "return_value": "'160-170'"}, {"func_args": {"pair": "(173, 173)"}, "return_value": "'173'"}, {"func_args": {"pair": "(176, 176)"}, "return_value": "'176'"}, {"func_args": {"pair": "(179, 179)"}, "return_value": "'179'"}, {"func_args": {"pair": "(190, 190)"}, "return_value": "'190'"}, {"func_args": {"pair": "(194, 194)"}, "return_value": "'194'"}, {"func_args": {"pair": "(210, 210)"}, "return_value": "'210'"}, {"func_args": {"pair": "(216, 219)"}, "return_value": "'216-219'"}, {"func_args": {"pair": "(222, 226)"}, "return_value": "'222-226'"}, {"func_args": {"pair": "(229, 237)"}, "return_value": "'229-237'"}, {"func_args": {"pair": "(245, 245)"}, "return_value": "'245'"}, {"func_args": {"pair": "(249, 256)"}, "return_value": "'249-256'"}, {"func_args": {"pair": "(259, 303)"}, "return_value": "'259-303'"}, {"func_args": {"pair": "(309, 309)"}, "return_value": "'309'"}, {"func_args": {"pair": "(329, 332)"}, "return_value": "'329-332'"}, {"func_args": {"pair": "(348, 348)"}, "return_value": "'348'"}, {"func_args": {"pair": "(350, 355)"}, "return_value": "'350-355'"}, {"func_args": {"pair": "(359, 359)"}, "return_value": "'359'"}, {"func_args": {"pair": "(363, 372)"}, "return_value": "'363-372'"}, {"func_args": {"pair": "(377, 377)"}, "return_value": "'377'"}, {"func_args": {"pair": "(379, 379)"}, "return_value": "'379'"}, {"func_args": {"pair": "(384, 386)"}, "return_value": "'384-386'"}, {"func_args": {"pair": "(394, 398)"}, "return_value": "'394-398'"}, {"func_args": {"pair": "(402, 402)"}, "return_value": "'402'"}, {"func_args": {"pair": "(404, 405)"}, "return_value": "'404-405'"}, {"func_args": {"pair": "(408, 417)"}, "return_value": "'408-417'"}, {"func_args": {"pair": "(420, 436)"}, "return_value": "'420-436'"}, {"func_args": {"pair": "(444, 448)"}, "return_value": "'444-448'"}, {"func_args": {"pair": "(461, 461)"}, "return_value": "'461'"}, {"func_args": {"pair": "(476, 478)"}, "return_value": "'476-478'"}, {"func_args": {"pair": "(481, 481)"}, "return_value": "'481'"}, {"func_args": {"pair": "(496, 498)"}, "return_value": "'496-498'"}, {"func_args": {"pair": "(514, 520)"}, "return_value": "'514-520'"}, {"func_args": {"pair": "(527, 530)"}, "return_value": "'527-530'"}, {"func_args": {"pair": "(543, 544)"}, "return_value": "'543-544'"}, {"func_args": {"pair": "(547, 549)"}, "return_value": "'547-549'"}, {"func_args": {"pair": "(587, 587)"}, "return_value": "'587'"}, {"func_args": {"pair": "(617, 617)"}, "return_value": "'617'"}, {"func_args": {"pair": "(632, 632)"}, "return_value": "'632'"}, {"func_args": {"pair": "(645, 645)"}, "return_value": "'645'"}, {"func_args": {"pair": "(660, 660)"}, "return_value": "'660'"}, {"func_args": {"pair": "(667, 667)"}, "return_value": "'667'"}, {"func_args": {"pair": "(673, 680)"}, "return_value": "'673-680'"}, {"func_args": {"pair": "(687, 687)"}, "return_value": "'687'"}, {"func_args": {"pair": "(697, 697)"}, "return_value": "'697'"}, {"func_args": {"pair": "(711, 711)"}, "return_value": "'711'"}, {"func_args": {"pair": "(770, 770)"}, "return_value": "'770'"}, {"func_args": {"pair": "(774, 781)"}, "return_value": "'774-781'"}, {"func_args": {"pair": "(784, 784)"}, "return_value": "'784'"}, {"func_args": {"pair": "(800, 800)"}, "return_value": "'800'"}, {"func_args": {"pair": "(850, 850)"}, "return_value": "'850'"}, {"func_args": {"pair": "(854, 855)"}, "return_value": "'854-855'"}, {"func_args": {"pair": "(872, 872)"}, "return_value": "'872'"}, {"func_args": {"pair": "(877, 877)"}, "return_value": "'877'"}, {"func_args": {"pair": "(885, 896)"}, "return_value": "'885-896'"}, {"func_args": {"pair": "(901, 911)"}, "return_value": "'901-911'"}, {"func_args": {"pair": "(916, 923)"}, "return_value": "'916-923'"}, {"func_args": {"pair": "(927, 953)"}, "return_value": "'927-953'"}, {"func_args": {"pair": "(957, 961)"}, "return_value": "'957-961'"}, {"func_args": {"pair": "(966, 972)"}, "return_value": "'966-972'"}, {"func_args": {"pair": "(976, 983)"}, "return_value": "'976-983'"}, {"func_args": {"pair": "(987, 997)"}, "return_value": "'987-997'"}, {"func_args": {"pair": "(1009, 1037)"}, "return_value": "'1009-1037'"}, {"func_args": {"pair": "(1041, 1052)"}, "return_value": "'1041-1052'"}, {"func_args": {"pair": "(1069, 1072)"}, "return_value": "'1069-1072'"}, {"func_args": {"pair": "(1076, 1084)"}, "return_value": "'1076-1084'"}, {"func_args": {"pair": "(1090, 1090)"}, "return_value": "'1090'"}, {"func_args": {"pair": "(1099, 1101)"}, "return_value": "'1099-1101'"}, {"func_args": {"pair": "(1110, 1119)"}, "return_value": "'1110-1119'"}, {"func_args": {"pair": "(1125, 1126)"}, "return_value": "'1125-1126'"}, {"func_args": {"pair": "(1132, 1136)"}, "return_value": "'1132-1136'"}, {"func_args": {"pair": "(1142, 1160)"}, "return_value": "'1142-1160'"}, {"func_args": {"pair": "(1164, 1180)"}, "return_value": "'1164-1180'"}, {"func_args": {"pair": "(1186, 1203)"}, "return_value": "'1186-1203'"}, {"func_args": {"pair": "(1209, 1214)"}, "return_value": "'1209-1214'"}, {"func_args": {"pair": "(1220, 1225)"}, "return_value": "'1220-1225'"}, {"func_args": {"pair": "(1231, 1234)"}, "return_value": "'1231-1234'"}, {"func_args": {"pair": "(1240, 1246)"}, "return_value": "'1240-1246'"}, {"func_args": {"pair": "(1258, 1295)"}, "return_value": "'1258-1295'"}, {"func_args": {"pair": "(1301, 1304)"}, "return_value": "'1301-1304'"}, {"func_args": {"pair": "(1321, 1326)"}, "return_value": "'1321-1326'"}, {"func_args": {"pair": "(1332, 1333)"}, "return_value": "'1332-1333'"}, {"func_args": {"pair": "(1337, 1337)"}, "return_value": "'1337'"}], "text": "def nice_pair(pair):\n    \"\"\"Make a nice string representation of a pair of numbers.\n\n    If the numbers are equal, just return the number, otherwise return the pair\n    with a dash between them, indicating the range.\n\n    \"\"\"\n    start, end = pair\n    if start == end:\n        return \"%d\" % start\n    else:\n        return \"%d-%d\" % (start, end)"}, "<lambda>": {"line": 458, "args": [{"func_args": {"x": "1"}, "return_value": "False"}, {"func_args": {"x": "1"}, "return_value": "False"}, {"func_args": {"x": "4"}, "return_value": "False"}, {"func_args": {"x": "2"}, "return_value": "False"}, {"func_args": {"x": "4"}, "return_value": "False"}, {"func_args": {"x": "2"}, "return_value": "False"}, {"func_args": {"x": "4"}, "return_value": "False"}, {"func_args": {"x": "2"}, "return_value": "False"}, {"func_args": {"x": "4"}, "return_value": "False"}, {"func_args": {"x": "2"}, "return_value": "False"}, {"func_args": {"x": "0"}, "return_value": "True"}, {"func_args": {"x": "1"}, "return_value": "False"}, {"func_args": {"x": "1"}, "return_value": "False"}, {"func_args": {"x": "0"}, "return_value": "True"}, {"func_args": {"x": "1"}, "return_value": "False"}, {"func_args": {"x": "1"}, "return_value": "False"}]}, "human_sorted_items": {"line": 389, "args": [{"func_args": {"items": "[('pundle.py     863    456    47%   54-59, 79, 103-117, 133, 137, 144, 160-170, 173, 176, 179, 190, 194, 210, 216-219, 222-226, 229-237, 245, 249-256, 259-303, 309, 329-332, 348, 350-355, 359, 363-372, 377, 379, 384-386, 394-398, 402, 404-405, 408-417, 420-436, 444-448, 461, 476-478, 481, 496-498, 514-520, 527-530, 543-544, 547-549, 587, 617, 632, 645, 660, 667, 673-680, 687, 697, 711, 770, 774-781, 784, 800, 850, 854-855, 872, 877, 885-896, 901-911, 916-923, 927-953, 957-961, 966-972, 976-983, 987-997, 1009-1037, 1041-1052, 1069-1072, 1076-1084, 1090, 1099-1101, 1110-1119, 1125-1126, 1132-1136, 1142-1160, 1164-1180, 1186-1203, 1209-1214, 1220-1225, 1231-1234, 1240-1246, 1258-1295, 1301-1304, 1321-1326, 1332-1333, 1337', ('pundle.py', 863, 456, '47', '54-59, 79, 103-117, 133, 137, 144, 160-170, 173, 176, 179, 190, 194, 210, 216-219, 222-226, 229-237, 245, 249-256, 259-303, 309, 329-332, 348, 350-355, 359, 363-372, 377, 379, 384-386, 394-398, 402, 404-405, 408-417, 420-436, 444-448, 461, 476-478, 481, 496-498, 514-520, 527-530, 543-544, 547-549, 587, 617, 632, 645, 660, 667, 673-680, 687, 697, 711, 770, 774-781, 784, 800, 850, 854-855, 872, 877, 885-896, 901-911, 916-923, 927-953, 957-961, 966-972, 976-983, 987-997, 1009-1037, 1041-1052, 1069-1072, 1076-1084, 1090, 1099-1101, 1110-1119, 1125-1126, 1132-1136, 1142-1160, 1164-1180, 1186-1203, 1209-1214, 1220-1225, 1231-1234, 1240-1246, 1258-1295, 1301-1304, 1321-1326, 1332-1333, 1337', 47.161066048667436))]", "reverse": "False"}, "return_value": "[('pundle.py     863    456    47%   54-59, 79, 103-117, 133, 137, 144, 160-170, 173, 176, 179, 190, 194, 210, 216-219, 222-226, 229-237, 245, 249-256, 259-303, 309, 329-332, 348, 350-355, 359, 363-372, 377, 379, 384-386, 394-398, 402, 404-405, 408-417, 420-436, 444-448, 461, 476-478, 481, 496-498, 514-520, 527-530, 543-544, 547-549, 587, 617, 632, 645, 660, 667, 673-680, 687, 697, 711, 770, 774-781, 784, 800, 850, 854-855, 872, 877, 885-896, 901-911, 916-923, 927-953, 957-961, 966-972, 976-983, 987-997, 1009-1037, 1041-1052, 1069-1072, 1076-1084, 1090, 1099-1101, 1110-1119, 1125-1126, 1132-1136, 1142-1160, 1164-1180, 1186-1203, 1209-1214, 1220-1225, 1231-1234, 1240-1246, 1258-1295, 1301-1304, 1321-1326, 1332-1333, 1337', ('pundle.py', 863, 456, '47', '54-59, 79, 103-117, 133, 137, 144, 160-170, 173, 176, 179, 190, 194, 210, 216-219, 222-226, 229-237, 245, 249-256, 259-303, 309, 329-332, 348, 350-355, 359, 363-372, 377, 379, 384-386, 394-398, 402, 404-405, 408-417, 420-436, 444-448, 461, 476-478, 481, 496-498, 514-520, 527-530, 543-544, 547-549, 587, 617, 632, 645, 660, 667, 673-680, 687, 697, 711, 770, 774-781, 784, 800, 850, 854-855, 872, 877, 885-896, 901-911, 916-923, 927-953, 957-961, 966-972, 976-983, 987-997, 1009-1037, 1041-1052, 1069-1072, 1076-1084, 1090, 1099-1101, 1110-1119, 1125-1126, 1132-1136, 1142-1160, 1164-1180, 1186-1203, 1209-1214, 1220-1225, 1231-1234, 1240-1246, 1258-1295, 1301-1304, 1321-1326, 1332-1333, 1337', 47.161066048667436))]"}], "text": "def human_sorted_items(items, reverse=False):\n    \"\"\"Sort the (string, value) items the way humans expect.\n\n    Returns the sorted list of items.\n    \"\"\"\n    return sorted(items, key=lambda pair: (human_key(pair[0]), pair[1]), reverse=reverse)"}, "config_files_to_try": {"line": 492, "args": [{"func_args": {"config_file": "'.coveragerc'"}, "return_value": "[('.coveragerc', True, False), ('setup.cfg', False, False), ('tox.ini', False, False), ('pyproject.toml', False, False)]"}, {"func_args": {"config_file": "'.coveragerc'"}, "return_value": "[('.coveragerc', True, False), ('setup.cfg', False, False), ('tox.ini', False, False), ('pyproject.toml', False, False)]"}], "text": "def config_files_to_try(config_file):\n    \"\"\"What config files should we try to read?\n\n    Returns a list of tuples:\n        (filename, is_our_file, was_file_specified)\n    \"\"\"\n\n    # Some API users were specifying \".coveragerc\" to mean the same as\n    # True, so make it so.\n    if config_file == \".coveragerc\":\n        config_file = True\n    specified_file = (config_file is not True)\n    if not specified_file:\n        # No file was specified. Check COVERAGE_RCFILE.\n        config_file = os.environ.get('COVERAGE_RCFILE')\n        if config_file:\n            specified_file = True\n    if not specified_file:\n        # Still no file specified. Default to .coveragerc\n        config_file = \".coveragerc\"\n    files_to_try = [\n        (config_file, True, specified_file),\n        (\"setup.cfg\", False, False),\n        (\"tox.ini\", False, False),\n        (\"pyproject.toml\", False, False),\n    ]\n    return files_to_try"}, "short_stack": {"line": 136, "args": [{"func_args": {"limit": "None", "skip": "0"}, "return_value": "'                      <module> : /usr/app/src/test_repos/pundler/.tox/py38/bin/viztracer:8\\n                          main : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/viztracer/main.py:523\\n                           run : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/viztracer/main.py:332\\n                   run_command : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/viztracer/main.py:438\\n                      run_code : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/viztracer/main.py:355\\n                      <module> : /usr/app/src/test_repos/pundler/.tox/py38/bin/pytest:8\\n                  console_main : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:185\\n                          main : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:143\\n                _prepareconfig : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:318\\n                      __call__ : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/pluggy/_hooks.py:265\\n                     _hookexec : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/pluggy/_manager.py:80\\n                    _multicall : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/pluggy/_callers.py:39\\n          pytest_cmdline_parse : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:1003\\n                         parse : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:1283\\n                     _preparse : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:1191\\n                      __call__ : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/pluggy/_hooks.py:265\\n                     _hookexec : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/pluggy/_manager.py:80\\n                    _multicall : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/pluggy/_callers.py:39\\n pytest_load_initial_conftests : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/pytest_cov/plugin.py:149\\n                      __init__ : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/pytest_cov/plugin.py:200\\n                         start : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/pytest_cov/plugin.py:222\\n         ensure_topdir_wrapper : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/pytest_cov/engine.py:44\\n                         start : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/pytest_cov/engine.py:222\\n                         start : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/coverage/control.py:558\\n               _init_for_start : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/coverage/control.py:473\\n                      __init__ : /usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/coverage/collector.py:114'"}], "text": "def short_stack(limit=None, skip=0):\n    \"\"\"Return a string summarizing the call stack.\n\n    The string is multi-line, with one line per stack frame. Each line shows\n    the function name, the file name, and the line number:\n\n        ...\n        start_import_stop : /Users/ned/coverage/trunk/tests/coveragetest.py @95\n        import_local_file : /Users/ned/coverage/trunk/tests/coveragetest.py @81\n        import_local_file : /Users/ned/coverage/trunk/coverage/backward.py @159\n        ...\n\n    `limit` is the number of frames to include, defaulting to all of them.\n\n    `skip` is the number of frames to skip, so that debugging functions can\n    call this and not be included in the result.\n\n    \"\"\"\n    stack = inspect.stack()[limit:skip:-1]\n    return \"\\n\".join(\"%30s : %s:%d\" % (t[3], t[1], t[2]) for t in stack)"}, "actual_path": {"line": 139, "args": [{"func_args": {"path": "'/usr/app/src/test_repos/pundler'"}, "return_value": "'/usr/app/src/test_repos/pundler'"}, {"func_args": {"path": "'/usr/app/src/test_repos/pundler/autoscaler/run.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/autoscaler/run.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/pundler/tests/*'"}, "return_value": "'/usr/app/src/test_repos/pundler/tests/*'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/inspect.py'"}, "return_value": "'/usr/local/lib/python3.8/inspect.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/os.py'"}, "return_value": "'/usr/local/lib/python3.8/os.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/platform.py'"}, "return_value": "'/usr/local/lib/python3.8/platform.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/re.py'"}, "return_value": "'/usr/local/lib/python3.8/re.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/sysconfig.py'"}, "return_value": "'/usr/local/lib/python3.8/sysconfig.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/traceback.py'"}, "return_value": "'/usr/local/lib/python3.8/traceback.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/pundler/pundle.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/pundle.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/pundler'"}, "return_value": "'/usr/app/src/test_repos/pundler'"}, {"func_args": {"path": "'/usr/app/src/test_repos/pundler/pundle.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/pundle.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/pundler/pundle.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/pundle.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/pundler/pundle.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/pundle.py'"}], "text": "def actual_path(path):\n        \"\"\"The actual path for non-Windows platforms.\"\"\"\n        return path"}, "abs_file": {"line": 144, "args": [{"func_args": {"path": "'.'"}, "return_value": "'/usr/app/src/test_repos/pundler'"}, {"func_args": {"path": "'autoscaler/run.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/autoscaler/run.py'"}, {"func_args": {"path": "'tests/*'"}, "return_value": "'/usr/app/src/test_repos/pundler/tests/*'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/inspect.py'"}, "return_value": "'/usr/local/lib/python3.8/inspect.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/os.py'"}, "return_value": "'/usr/local/lib/python3.8/os.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/platform.py'"}, "return_value": "'/usr/local/lib/python3.8/platform.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/re.py'"}, "return_value": "'/usr/local/lib/python3.8/re.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/sysconfig.py'"}, "return_value": "'/usr/local/lib/python3.8/sysconfig.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/traceback.py'"}, "return_value": "'/usr/local/lib/python3.8/traceback.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/pundler/pundle.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/pundle.py'"}, {"func_args": {"path": "'.'"}, "return_value": "'/usr/app/src/test_repos/pundler'"}, {"func_args": {"path": "'/usr/app/src/test_repos/pundler/pundle.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/pundle.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/pundler/pundle.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/pundle.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/pundler/pundle.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/pundle.py'"}]}, "prep_patterns": {"line": 173, "args": [{"func_args": {"patterns": "['autoscaler/run.py', 'tests/*']"}, "return_value": "['/usr/app/src/test_repos/pundler/autoscaler/run.py', '/usr/app/src/test_repos/pundler/tests/*']"}, {"func_args": {"patterns": "None"}, "return_value": "[]"}], "text": "def prep_patterns(patterns):\n    \"\"\"Prepare the file patterns for use in a `FnmatchMatcher`.\n\n    If a pattern starts with a wildcard, it is used as a pattern\n    as-is.  If it does not start with a wildcard, then it is made\n    absolute with the current directory.\n\n    If `patterns` is None, an empty list is returned.\n\n    \"\"\"\n    prepped = []\n    for p in patterns or []:\n        if p.startswith((\"*\", \"?\")):\n            prepped.append(p)\n        else:\n            prepped.append(abs_file(p))\n    return prepped"}, "canonical_filename": {"line": 53, "args": [{"func_args": {"filename": "'/usr/local/lib/python3.8/inspect.py'"}, "return_value": "'/usr/local/lib/python3.8/inspect.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/os.py'"}, "return_value": "'/usr/local/lib/python3.8/os.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/platform.py'"}, "return_value": "'/usr/local/lib/python3.8/platform.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/re.py'"}, "return_value": "'/usr/local/lib/python3.8/re.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/sysconfig.py'"}, "return_value": "'/usr/local/lib/python3.8/sysconfig.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/traceback.py'"}, "return_value": "'/usr/local/lib/python3.8/traceback.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/pundler/pundle.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/pundle.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/pundler/pundle.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/pundle.py'"}]}, "relative_filename": {"line": 39, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/pundler/pundle.py'"}, "return_value": "'pundle.py'"}]}, "filename_suffix": {"line": 1006, "args": [{"func_args": {"suffix": "None"}, "return_value": "None"}, {"func_args": {"suffix": "True"}, "return_value": "'cae2a1e14906.80125.179623'"}, {"func_args": {"suffix": "None"}, "return_value": "None"}, {"func_args": {"suffix": "None"}, "return_value": "None"}], "text": "def filename_suffix(suffix):\n    \"\"\"Compute a filename suffix for a data file.\n\n    If `suffix` is a string or None, simply return it. If `suffix` is True,\n    then build a suffix incorporating the hostname, process id, and a random\n    number.\n\n    Returns a string or None.\n\n    \"\"\"\n    if suffix is True:\n        # If data_suffix was a simple true value, then make a suffix with\n        # plenty of distinguishing information.  We do this here in\n        # `save()` at the last minute so that the pid will be correct even\n        # if the process forks.\n        dice = random.Random(os.urandom(8)).randint(0, 999999)\n        suffix = \"%s.%s.%06d\" % (socket.gethostname(), os.getpid(), dice)\n    return suffix"}, "file_and_path_for_module": {"line": 110, "args": [{"func_args": {"modulename": "'pundle'"}, "return_value": "('/usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/pundle.py', [])"}], "text": "def file_and_path_for_module(modulename):\n    \"\"\"Find the file and search path for `modulename`.\n\n    Returns:\n        filename: The filename of the module, or None.\n        path: A list (possibly empty) of directories to find submodules in.\n\n    \"\"\"\n    filename = None\n    path = []\n    try:\n        spec = importlib.util.find_spec(modulename)\n    except Exception:\n        pass\n    else:\n        if spec is not None:\n            if spec.origin != \"namespace\":\n                filename = spec.origin\n            path = list(spec.submodule_search_locations or ())\n    return filename, path"}, "source_for_file": {"line": 97, "args": [{"func_args": {"filename": "'/usr/local/lib/python3.8/inspect.py'"}, "return_value": "'/usr/local/lib/python3.8/inspect.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/os.py'"}, "return_value": "'/usr/local/lib/python3.8/os.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/platform.py'"}, "return_value": "'/usr/local/lib/python3.8/platform.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/re.py'"}, "return_value": "'/usr/local/lib/python3.8/re.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/sysconfig.py'"}, "return_value": "'/usr/local/lib/python3.8/sysconfig.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/traceback.py'"}, "return_value": "'/usr/local/lib/python3.8/traceback.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/pundler/pundle.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/pundle.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/pundler/pundle.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/pundle.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/pundler/pundle.py'"}, "return_value": "'/usr/app/src/test_repos/pundler/pundle.py'"}], "text": "def source_for_file(filename):\n    \"\"\"Return the source filename for `filename`.\n\n    Given a file name being traced, return the best guess as to the source\n    file to attribute it to.\n\n    \"\"\"\n    if filename.endswith(\".py\"):\n        # .py files are themselves source files.\n        return filename\n\n    elif filename.endswith((\".pyc\", \".pyo\")):\n        # Bytecode files probably have source files near them.\n        py_filename = filename[:-1]\n        if os.path.exists(py_filename):\n            # Found a .py file, use that.\n            return py_filename\n        if env.WINDOWS:\n            # On Windows, it could be a .pyw file.\n            pyw_filename = py_filename + \"w\"\n            if os.path.exists(pyw_filename):\n                return pyw_filename\n        # Didn't find source, but it's probably the .py file we want.\n        return py_filename\n\n    elif filename.endswith(\"$py.class\"):\n        # Jython is easy to guess.\n        return filename[:-9] + \".py\"\n\n    # No idea, just use the file name as-is.\n    return filename"}, "read_python_source": {"line": 20, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/pundler/pundle.py'"}, "return_value": "b'# encoding: utf-8\\n\"\"\"\\nData Model, start here to not get mad\\n=====================================\\n\\nMain entity will be distribution, like Flask. Per key\\nPundle tracks three state parts:\\n    1. requirement, like Flask>0.12.2.\\n    2. frozen version, like ==0.12.2\\n    3. installed distributions, like [flask==0.12.2, flask==0.10.0]\\n\\nRequirement basically is from file, like requirements.txt, setup.py or Pipfile. This requirements\\nhave source like `requirements.txt`. And base requirements can have dependencies. This\\ndependencies are turned to requirements too with source like `Flask-Admin << requirements.txt`.\\nTo track requirements we use `CustomReq` class. It can work with PyPi and VCS requirements.\\nCustomReq can have `self.req = pkg_resources.Requirement` or custom vcs line.\\n\\nDistribution is one of VCSDist or pkg_resources.DistInfoDistribution. VCSDist is to\\ntrack installed VCS packages and pkg_resources.DistInfoDistribution is for PyPi packages.\\n\\nAll three states of distribution are tracked inside `RequirementState` object that includes info\\nabout requirement, frozen version and installed versions.\\n\\n`Suite` keeps state of all distributions like a dictionary of RequirentStates.\\n\\nTo populate Suite and to parse all requirements, frozen versions and what we have installed pundle\\nuses `Parser`. There is plenty of them - `Parser` that works with `requirements.txt`,\\n`SetupParser` that works with `setup.py`, PipfileParser that works with Pipfile and Pipfile.lock.\\n\"\"\"\\n\\nfrom __future__ import print_function\\nimport re\\ntry:\\n    from urllib.parse import urlparse, parse_qsl\\nexcept ImportError:  # pragma: no cover\\n    from urlparse import urlparse, parse_qsl\\nfrom collections import defaultdict\\nfrom base64 import b64encode, b64decode\\nimport platform\\nimport os.path as op\\nimport os\\nfrom os import makedirs\\nimport stat\\nimport tempfile\\nimport shutil\\nimport subprocess\\nimport sys\\nimport shlex\\nimport json\\nimport hashlib\\nimport pkg_resources\\ntry:\\n    from pip import main as pip_exec\\nexcept ImportError:\\n    from pip._internal import main as pip_exec\\n    from types import ModuleType\\n\\n    if isinstance(pip_exec, ModuleType):\\n        pip_exec = pip_exec.main\\n\\n# TODO bundle own version of distlib. Perhaps\\ntry:\\n    from pip._vendor.distlib import locators\\nexcept ImportError:  # pragma: no cover\\n    from pip.vendor.distlib import locators\\n\\ntry:\\n    str_types = (basestring,)\\nexcept NameError:  # pragma: no cover\\n    str_types = (str, bytes)\\n\\ntry:\\n    pkg_resources_parse_version = pkg_resources.SetuptoolsVersion\\nexcept AttributeError:  # pragma: no cover\\n    pkg_resources_parse_version = pkg_resources.packaging.version.Version\\n\\n\\ndef print_message(*a, **kw):\\n    print(*a, **kw)\\n\\n\\nclass PundleException(Exception):\\n    pass\\n\\n\\ndef python_version_string():\\n    \"\"\"We use it to generate per python folder name, where\\n    we will install all packages.\\n    \"\"\"\\n    if platform.python_implementation() == \\'PyPy\\':\\n        version_info = sys.pypy_version_info\\n    else:\\n        version_info = sys.version_info\\n    version_string = \\'{v.major}.{v.minor}.{v.micro}\\'.format(v=version_info)\\n    build, _ = platform.python_build()\\n    build = build.replace(\\':\\', \\'_\\')  # windows do not understand `:` in path\\n    return \\'{}-{}-{}\\'.format(platform.python_implementation(), version_string, build)\\n\\n\\ndef parse_file(filename):\\n    \"\"\"Helper to parse requirements.txt or frozen.txt.\\n    \"\"\"\\n    res = []\\n    with open(filename) as f:\\n        for line in f:\\n            s = line.strip()\\n            if s and not s.startswith(\\'#\\'):\\n                if s.startswith(\\'-r\\'):\\n                    continue\\n                if s.startswith(\\'-e \\'):\\n                    s = s[3:].strip()\\n                if parse_vcs_requirement(s):\\n                    res.append(s)\\n                else:\\n                    req = shlex.split(s, comments=True)\\n                    res.append(req[0])\\n    return res\\n\\n\\ndef test_vcs(req):\\n    \"\"\"Checks if requirement line is for VCS.\\n    \"\"\"\\n    return \\'+\\' in req and req.index(\\'+\\') == 3\\n\\n\\ndef parse_vcs_requirement(req):\\n    \"\"\"Parses VCS line to egg name, version etc.\\n    \"\"\"\\n    if \\'+\\' not in req:\\n        return None\\n    vcs, url = req.split(\\'+\\', 1)\\n    if vcs not in (\\'git\\', \\'svn\\', \\'hg\\'):\\n        return None\\n    parsed_url = urlparse(url)\\n    parsed = dict(parse_qsl(parsed_url.fragment))\\n    if \\'egg\\' not in parsed:\\n        return None\\n    egg = parsed[\\'egg\\'].rsplit(\\'-\\', 1)\\n    if len(egg) > 1:\\n        try:\\n            pkg_resources_parse_version(egg[1])\\n        except pkg_resources._vendor.packaging.version.InvalidVersion:\\n            return parsed[\\'egg\\'].lower(), req, None\\n        return egg[0].lower(), req, egg[1]\\n    else:\\n        return parsed[\\'egg\\'].lower(), req, None\\n\\n\\ndef parse_frozen_vcs(req):\\n    res = parse_vcs_requirement(req)\\n    if not res:\\n        return\\n    return res[0], res[1]\\n\\n\\nclass VCSDist(object):\\n    \"\"\" Represents installed VCS distribution.\\n    \"\"\"\\n    def __init__(self, directory):\\n        self.dir = directory\\n        name = op.split(directory)[-1]\\n        key, encoded = name.split(\\'+\\', 1)\\n        self.key = key.lower()\\n        self.line = b64decode(encoded).decode(\\'utf-8\\')\\n        egg, req, version = parse_vcs_requirement(self.line)\\n        version = version or \\'0.0.0\\'\\n        self.hashcmp = (pkg_resources_parse_version(version), -1, egg, self.dir)\\n        self.version = self.line\\n        self.pkg_resource = next(iter(pkg_resources.find_distributions(self.dir, True)), None)\\n        self.location = self.pkg_resource.location\\n\\n    def requires(self, extras=[]):\\n        return self.pkg_resource.requires(extras=extras)\\n\\n    def activate(self):\\n        return self.pkg_resource.activate()\\n\\n    def __lt__(self, other):\\n        return self.hashcmp.__lt__(other.hashcmp)\\n\\n\\nclass CustomReq(object):\\n    \"\"\"Represents PyPi or VCS requirement.\\n    Can locate and install it.\\n    \"\"\"\\n    def __init__(self, line, env, source=None):\\n        self.line = line\\n        self.egg = None\\n        if isinstance(line, pkg_resources.Requirement):\\n            self.req = line\\n        elif test_vcs(line):\\n            res = parse_vcs_requirement(line)\\n            if not res:\\n                raise PundleException(\\'Bad url %r\\' % line)\\n            egg, req, version = res\\n            self.egg = egg\\n            self.req = None  # pkg_resources.Requirement.parse(res)\\n        else:\\n            self.req = pkg_resources.Requirement.parse(line)\\n        self.sources = set([source])\\n        self.envs = set()\\n        self.add_env(env)\\n\\n    def __contains__(self, something):\\n        if self.req:\\n            return (something in self.req)\\n        elif self.egg:\\n            return something == self.line\\n        else:\\n            return False\\n\\n    def __repr__(self):\\n        return \\'<CustomReq %r>\\' % self.__dict__\\n\\n    def why_str(self):\\n        if len(self.sources) < 2:\\n            return \\'{} << {}\\'.format(self.line, self.why_str_one(list(self.sources)[0]))\\n        causes = list(sorted(self.why_str_one(source) for source in self.sources))\\n        return \\'{} << [{}]\\'.format(self.line, \\' | \\'.join(causes))\\n\\n    def why_str_one(self, source):\\n        if isinstance(source, str_types):\\n            return source\\n        elif isinstance(source, CustomReq):\\n            return source.why_str()\\n        return \\'?\\'\\n\\n    def adjust_with_req(self, req):\\n        if not self.req:\\n            return\\n            raise PundleException(\\'VCS\\')\\n        versions = \\',\\'.join(\\'\\'.join(t) for t in set(self.req.specs + req.req.specs))\\n        self.requirement = pkg_resources.Requirement.parse(\\'{} {}\\'.format(\\n            self.req.project_name, versions\\n        ))\\n        self.sources.update(req.sources)\\n        self.add_env(req.envs)\\n\\n    @property\\n    def key(self):\\n        return self.req.key if self.req else self.egg\\n\\n    @property\\n    def extras(self):\\n        return self.req.extras if self.req else []\\n\\n    def locate(self, suite, prereleases=False):\\n        # requirements can have something after `;` symbol that `locate` does not understand\\n        req = str(self.req).split(\\';\\', 1)[0]\\n        dist = suite.locate(req, prereleases=prereleases)\\n        if not dist:\\n            # have not find any releases so search for pre\\n            dist = suite.locate(req, prereleases=True)\\n        if not dist:\\n            raise PundleException(\\'%s can not be located\\' % self.req)\\n        return dist\\n\\n    def locate_and_install(self, suite, installed=None, prereleases=False):\\n        if self.egg:\\n            key = b64encode(self.line.encode(\\'utf-8\\')).decode()\\n            target_dir = op.join(suite.parser.directory, \\'{}+{}\\'.format(self.egg, key))\\n            target_req = self.line\\n            ready = [\\n                installation\\n                for installation in (installed or [])\\n                if getattr(installation, \\'line\\', None) == self.line\\n            ]\\n        else:\\n            loc_dist = self.locate(suite, prereleases=prereleases)\\n            ready = [\\n                installation\\n                for installation in (installed or [])\\n                if installation.version == loc_dist.version\\n            ]\\n            target_dir = op.join(suite.parser.directory, \\'{}-{}\\'.format(loc_dist.key, loc_dist.version))\\n            # DEL? target_req = \\'%s==%s\\' % (loc_dist.name, loc_dist.version)\\n            # If we use custom index, then we want not to configure PIP with it\\n            # and just give it URL\\n            target_req = loc_dist.download_url\\n        if ready:\\n            return ready[0]\\n        try:\\n            makedirs(target_dir)\\n        except OSError:\\n            pass\\n        tmp_dir = tempfile.mkdtemp()\\n        print(\\'Use temp dir\\', tmp_dir)\\n        try:\\n            print(\\'pip install --no-deps -t %s %s\\' % (tmp_dir, target_req))\\n            pip_exec([\\n                \\'install\\',\\n                \\'--no-deps\\',\\n                \\'-t\\', tmp_dir,\\n                \\'-v\\',\\n                target_req\\n            ])\\n            for item in os.listdir(tmp_dir):\\n                shutil.move(op.join(tmp_dir, item), op.join(target_dir, item))\\n        except Exception as exc:\\n            raise PundleException(\\'%s was not installed due error %s\\' % (self.egg or loc_dist.name, exc))\\n        finally:\\n            shutil.rmtree(tmp_dir, ignore_errors=True)\\n        return next(iter(pkg_resources.find_distributions(target_dir, True)), None)\\n\\n    def add_env(self, env):\\n        if isinstance(env, str):\\n            self.envs.add(env)\\n        else:\\n            self.envs.update(env)\\n\\n\\nclass RequirementState(object):\\n    \"\"\"Holds requirement state, like what version do we have installed, is\\n    some version frozen or not, what requirement constrains do we have.\\n    \"\"\"\\n    def __init__(self, key, req=None, frozen=None, installed=None, hashes=None):\\n        self.key = key\\n        self.requirement = req\\n        self.frozen = frozen\\n        self.hashes = hashes\\n        self.installed = installed or []\\n        self.installed.sort()\\n        self.installed.reverse()\\n\\n    def __repr__(self):\\n        return \\'<RequirementState %r>\\' % self.__dict__\\n\\n    def adjust_with_req(self, req):\\n        if self.requirement:\\n            self.requirement.adjust_with_req(req)\\n        else:\\n            self.requirement = req\\n\\n    def has_correct_freeze(self):\\n        return self.requirement and self.frozen and self.frozen in self.requirement\\n\\n    def check_installed_version(self, suite, install=False):\\n        # install version of package if not installed\\n        dist = None\\n        if self.has_correct_freeze():\\n            dist = [\\n                installation\\n                for installation in self.installed\\n                if pkg_resources.parse_version(installation.version) == pkg_resources.parse_version(self.frozen)\\n            ]\\n            dist = dist[0] if dist else None\\n            if install and not dist:\\n                dist = self.install_frozen(suite)\\n        if install and not dist:\\n            dist = self.requirement.locate_and_install(suite, installed=self.get_installed())\\n            if dist is None:\\n                raise PundleException(\\'Package %s was not installed due some error\\' % self.key)\\n            self.frozen = dist.version\\n            self.installed.append(dist)\\n            self.frozen = dist.version\\n        return dist\\n\\n    def get_installed(self):\\n        return [installation for installation in self.installed if installation.version in self.requirement]\\n\\n    def upgrade(self, suite, prereleases=False):\\n        # check if we have fresh packages on PIPY\\n        dists = self.get_installed()\\n        dist = dists[0] if dists else None\\n        latest = self.requirement.locate(suite, prereleases=prereleases)\\n        if not dist or pkg_resources.parse_version(latest.version) > pkg_resources.parse_version(dist.version):\\n            print_message(\\'Upgrade to\\', latest)\\n            dist = self.requirement.locate_and_install(suite, installed=self.get_installed(), prereleases=prereleases)\\n        # Anyway use latest available dist\\n        self.frozen = dist.version\\n        self.installed.append(dist)\\n        return dist\\n\\n    def reveal_requirements(self, suite, install=False, upgrade=False, already_revealed=None, prereleases=False):\\n        already_revealed = already_revealed.copy() if already_revealed is not None else set()\\n        if self.key in already_revealed:\\n            return\\n        if upgrade:\\n            dist = self.upgrade(suite, prereleases=prereleases)\\n        else:\\n            dist = self.check_installed_version(suite, install=install)\\n        if not dist:\\n            return\\n        already_revealed.add(self.key)\\n        for req in dist.requires(extras=self.requirement.extras):\\n            suite.adjust_with_req(\\n                CustomReq(str(req), self.requirement.envs, source=self.requirement),\\n                install=install,\\n                upgrade=upgrade,\\n                already_revealed=already_revealed,\\n            )\\n\\n    def frozen_dump(self):\\n        if self.requirement.egg:\\n            return self.requirement.line\\n        main = \\'{}=={}\\'.format(self.key, self.frozen)\\n        comment = self.requirement.why_str()\\n        return \\'{:20s} # {}\\'.format(main, comment)\\n\\n    def frozen_dist(self):\\n        if not self.frozen:\\n            return\\n        for dist in self.installed:\\n            if pkg_resources.parse_version(dist.version) == pkg_resources.parse_version(self.frozen):\\n                return dist\\n\\n    def install_frozen(self, suite):\\n        if self.frozen_dist() or not self.frozen:\\n            return\\n        envs = self.requirement.envs if self.requirement else \\'\\'\\n        if test_vcs(self.frozen):\\n            frozen_req = CustomReq(self.frozen, envs)\\n        else:\\n            frozen_req = CustomReq(\"{}=={}\".format(self.key, self.frozen), envs)\\n        dist = frozen_req.locate_and_install(suite)\\n        self.installed.append(dist)\\n        return dist\\n\\n    def activate(self):\\n        dist = self.frozen_dist()\\n        if not dist:\\n            raise PundleException(\\'Distribution is not installed %s\\' % self.key)\\n        dist.activate()\\n        pkg_resources.working_set.add_entry(dist.location)\\n        # find end execute *.pth\\n        sitedir = dist.location  # noqa some PTH search for sitedir\\n        for filename in os.listdir(dist.location):\\n            if not filename.endswith(\\'.pth\\'):\\n                continue\\n            try:\\n                for line in open(op.join(dist.location, filename)):\\n                    if line.startswith(\\'import \\'):\\n                        exec(line.strip())\\n            except Exception as e:\\n                print(\\'Erroneous pth file %r\\' % op.join(dist.location, filename))\\n                print(e)\\n\\n\\nclass AggregatingLocator(object):\\n    def __init__(self, locators):\\n        self.locators = locators\\n\\n    def locate(self, req, **kw):\\n        for locator in self.locators:\\n            print_message(\\'try\\', locator, \\'for\\', req)\\n            revealed = locator.locate(req, **kw)\\n            if revealed:\\n                return revealed\\n\\n\\nclass Suite(object):\\n    \"\"\"Main object that represents current directory pundle state.\\n    It tracks RequirementStates, envs, urls for package locator.\\n    \"\"\"\\n    def __init__(self, parser, envs=[], urls=None):\\n        self.states = {}\\n        self.parser = parser\\n        self.envs = envs\\n        self.urls = urls or [\\'https://pypi.python.org/simple/\\']\\n        if \\'PIP_EXTRA_INDEX_URL\\' in os.environ:\\n            self.urls.append(os.environ[\\'PIP_EXTRA_INDEX_URL\\'])\\n        self.locators = []\\n        for url in self.urls:\\n            self.locators.append(\\n                locators.SimpleScrapingLocator(url, timeout=3.0, scheme=\\'legacy\\')\\n            )\\n        self.locators.append(locators.JSONLocator(scheme=\\'legacy\\'))\\n        self.locator = AggregatingLocator(self.locators)\\n\\n    def use(self, key):\\n        \"\"\"For single mode\\n        You can call suite.use(\\'arrow\\') and then `import arrow`\\n\\n        :key: package name\\n        \"\"\"\\n        self.adjust_with_req(CustomReq(key, \\'\\'))\\n        self.install()\\n        self.activate_all()\\n\\n    def locate(self, *a, **kw):\\n        return self.locator.locate(*a, **kw)\\n\\n    def add(self, key, state):\\n        self.states[key] = state\\n\\n    def __repr__(self):\\n        return \\'<Suite %r>\\' % self.states\\n\\n    def required_states(self):\\n        return [state for state in self.states.values() if state.requirement]\\n\\n    def need_freeze(self, verbose=False):\\n        self.install(install=False)\\n        not_correct = not all(state.has_correct_freeze() for state in self.required_states())\\n        if not_correct and verbose:\\n            for state in self.required_states():\\n                if not state.has_correct_freeze():\\n                    print(\\n                        state.key,\\n                        \\'Need\\',\\n                        state.requirement,\\n                        \\'have not been frozen\\',\\n                        state.frozen,\\n                        \\', installed\\',\\n                        state.installed\\n                    )\\n        # TODO\\n        # unneeded = any(state.frozen for state in self.states.values() if not state.requirement)\\n        # if unneeded:\\n        #     print(\\'!!! Unneeded\\', [state.key for state in self.states.values() if not state.requirement])\\n        return not_correct  # or unneeded\\n\\n    def adjust_with_req(self, req, install=False, upgrade=False, already_revealed=None):\\n        state = self.states.get(req.key)\\n        if not state:\\n            state = RequirementState(req.key, req=req)\\n            self.add(req.key, state)\\n        else:\\n            state.adjust_with_req(req)\\n        state.reveal_requirements(self, install=install, upgrade=upgrade, already_revealed=already_revealed or set())\\n\\n    def install(self, install=True):\\n        for state in self.required_states():\\n            state.reveal_requirements(self, install=install)\\n\\n    def upgrade(self, key=None, prereleases=False):\\n        states = [self.states[key]] if key else self.required_states()\\n        for state in states:\\n            print(\\'Check\\', state.requirement.req)\\n            state.reveal_requirements(self, upgrade=True, prereleases=prereleases)\\n\\n    def get_frozen_states(self, env):\\n        return [\\n            state\\n            for state in self.required_states()\\n            if state.requirement and env in state.requirement.envs\\n        ]\\n\\n    def need_install(self):\\n        return not all(state.frozen_dist() for state in self.states.values() if state.frozen)\\n\\n    def install_frozen(self):\\n        for state in self.states.values():\\n            state.install_frozen(self)\\n\\n    def activate_all(self, envs=(\\'\\',)):\\n        for state in self.required_states():\\n            if \\'\\' in state.requirement.envs or any(env in state.requirement.envs for env in envs):\\n                state.activate()\\n\\n    def save_frozen(self):\\n        \"Saves frozen files to disk\"\\n        states_by_env = dict(\\n            (env, self.get_frozen_states(env))\\n            for env in self.parser.envs()\\n        )\\n        self.parser.save_frozen(states_by_env)\\n\\n\\nclass Parser(object):\\n    \"\"\"Gather environment info, requirements,\\n    frozen packages and create Suite object\\n    \"\"\"\\n    def __init__(\\n            self,\\n            base_path=None,\\n            directory=\\'Pundledir\\',\\n            requirements_files=None,\\n            frozen_files=None,\\n            package=None,\\n    ):\\n        self.base_path = base_path or \\'.\\'\\n        self.directory = directory\\n        self.requirements_files = requirements_files\\n        if frozen_files is None:\\n            self.frozen_files = {\\'\\': \\'frozen.txt\\'}\\n        else:\\n            self.frozen_files = frozen_files\\n        self.package = package\\n        self.package_envs = set([\\'\\'])\\n\\n    def envs(self):\\n        if self.requirements_files:\\n            return list(self.requirements_files.keys()) or [\\'\\']\\n        elif self.package:\\n            return self.package_envs\\n        return [\\'\\']\\n\\n    def get_frozen_file(self, env):\\n        if env in self.frozen_files:\\n            return self.frozen_files[env]\\n        else:\\n            return os.path.join(self.base_path, \\'frozen_%s.txt\\' % env)\\n\\n    def create_suite(self):\\n        reqs = self.parse_requirements()\\n        freezy = self.parse_frozen()\\n        hashes = self.parse_frozen_hashes()\\n        diry = self.parse_directory()\\n        state_keys = set(list(reqs.keys()) + list(freezy.keys()) + list(diry.keys()))\\n        suite = Suite(self, envs=self.envs())\\n        for key in state_keys:\\n            suite.add(\\n                key,\\n                RequirementState(\\n                    key,\\n                    req=reqs.get(key),\\n                    frozen=freezy.get(key),\\n                    installed=diry.get(key, []),\\n                    hashes=hashes.get(key),\\n                ),\\n            )\\n        return suite\\n\\n    def parse_directory(self):\\n        if not op.exists(self.directory):\\n            return {}\\n        dists = [\\n            # this magic takes first element or None\\n            next(iter(\\n                pkg_resources.find_distributions(op.join(self.directory, item), True)\\n            ), None)\\n            for item in os.listdir(self.directory) if \\'-\\' in item\\n        ]\\n        dists.extend(\\n            VCSDist(op.join(self.directory, item))\\n            for item in os.listdir(self.directory) if \\'+\\' in item\\n        )\\n        dists = filter(None, dists)\\n        result = defaultdict(list)\\n        for dist in dists:\\n            result[dist.key].append(dist)\\n        return result\\n\\n    def parse_frozen(self):\\n        frozen_versions = {}\\n        for env in self.envs():\\n            frozen_file = self.get_frozen_file(env)\\n            if op.exists(frozen_file):\\n                frozen = [\\n                    (parse_frozen_vcs(line) or line.split(\\'==\\'))\\n                    for line in parse_file(frozen_file)\\n                ]\\n            else:\\n                frozen = []\\n            for name, version in frozen:\\n                frozen_versions[name.lower()] = version\\n        return frozen_versions\\n\\n    def parse_frozen_hashes(self):\\n        \"\"\"This implementation does not support hashes yet\\n        \"\"\"\\n        return {}\\n\\n    def parse_requirements(self):\\n        all_requirements = {}\\n        for env, req_file in self.requirements_files.items():\\n            requirements = parse_file(req_file)\\n            if env:\\n                source = \\'requirements %s file\\' % env\\n            else:\\n                source = \\'requirements file\\'\\n            for line in requirements:\\n                req = CustomReq(line, env, source=source)\\n                if req.key in all_requirements:\\n                    # if requirements exists in other env, then add this env too\\n                    all_requirements[req.key].add_env(env)\\n                else:\\n                    all_requirements[req.key] = req\\n        return all_requirements\\n\\n    def save_frozen(self, states_by_env):\\n        for env, states in states_by_env.items():\\n            data = \\'\\\\n\\'.join(sorted(\\n                state.frozen_dump()\\n                for state in states\\n            )) + \\'\\\\n\\'\\n            frozen_file = self.get_frozen_file(env)\\n            with open(frozen_file, \\'w\\') as f:\\n                f.write(data)\\n\\n\\nclass SingleParser(Parser):\\n    \"\"\"Parser for console mode.\\n    \"\"\"\\n    def parse_requirements(self):\\n        return {}\\n\\n\\nclass SetupParser(Parser):\\n    \"\"\"Parser for `setup.py`. Because it mostly used to develop package, we\\n    do not freeze packages to setup.py. We use `frozen.txt`.\\n    \"\"\"\\n    def parse_requirements(self):\\n        setup_info = get_info_from_setup(self.package)\\n        if setup_info is None:\\n            raise PundleException(\\'There is no requirements.txt nor setup.py\\')\\n        install_requires = setup_info.get(\\'install_requires\\') or []\\n        reqs = [\\n            CustomReq(str(req), \\'\\', source=\\'setup.py\\')\\n            for req in install_requires\\n        ]\\n        requirements = dict((req.key, req) for req in reqs)\\n        # we use `feature` as environment for pundle\\n        extras_require = (setup_info.get(\\'extras_require\\') or {})\\n        for feature, feature_requires in extras_require.items():\\n            for req_line in feature_requires:\\n                req = CustomReq(req_line, feature, source=\\'setup.py\\')\\n                # if this req already in dict, then add our feature as env\\n                if req.key in requirements:\\n                    requirements[req.key].add_env(feature)\\n                else:\\n                    requirements[req.key] = req\\n            self.package_envs.add(feature)\\n        return requirements\\n\\n\\nclass PipfileParser(Parser):\\n    \"\"\"Parser for Pipfile and Pipfile.lock.\\n    \"\"\"\\n    DEFAULT_PIPFILE_SOURCES = [\\n        {\\n            \\'name\\': \\'pypi\\',\\n            \\'url\\': \\'https://pypi.python.org/simple\\',\\n            \\'verify_ssl\\': True,\\n        },\\n    ]\\n\\n    def __init__(self, **kw):\\n        self.pipfile = kw.pop(\\'pipfile\\')\\n        self.pipfile_envs = set([\\'\\'])\\n        super(PipfileParser, self).__init__(**kw)\\n        # cache\\n        self.loaded_pipfile = None\\n        self.loaded_pipfile_lock = None\\n\\n    def envs(self):\\n        return self.pipfile_envs\\n\\n    def pipfile_content(self):\\n        import toml\\n        if self.loaded_pipfile:\\n            return self.loaded_pipfile\\n        self.loaded_pipfile = toml.load(open(self.pipfile))\\n        return self.loaded_pipfile\\n\\n    def pipfile_lock_content(self):\\n        if self.loaded_pipfile_lock:\\n            return self.loaded_pipfile_lock\\n        try:\\n            self.loaded_pipfile_lock = json.load(open(self.pipfile + \\'.lock\\'))\\n        except Exception:\\n            pass\\n        return self.loaded_pipfile_lock\\n\\n    def parse_requirements(self):\\n        info = self.pipfile_content()\\n        all_requirements = {}\\n        for info_key in info:\\n            if not info_key.endswith(\\'packages\\'):\\n                continue\\n            if \\'-\\' in info_key:\\n                env, _ = info_key.split(\\'-\\', 1)\\n            else:\\n                env = \\'\\'\\n            self.pipfile_envs.add(env)\\n            for key, details in info[info_key].items():\\n                if isinstance(details, str_types):\\n                    if details != \\'*\\':\\n                        key = key + details  # details is a version requirement\\n                    req = CustomReq(key, env, source=\\'Pipfile\\')\\n                else:\\n                    # a dict\\n                    if \\'file\\' in details or \\'path\\' in details:\\n                        raise PundleException(\\'Unsupported Pipfile feature yet %s: %r\\' % (key, details))\\n                    if \\'git\\' in details:\\n                        # wow, this as a git package!\\n                        req = CustomReq(\\'git+%s#egg=%s\\' % (details[\\'git\\'], key), env, source=\\'Pipfile\\')\\n                    else:\\n                        # else just simple requirement\\n                        req = CustomReq(key + details[\\'version\\'], env, source=\\'Pipfile\\')\\n                if req.key in all_requirements:\\n                    # if requirements exists in other env, then add this env too\\n                    all_requirements[req.key].add_env(env)\\n                else:\\n                    all_requirements[req.key] = req\\n        return all_requirements\\n\\n    def parse_frozen(self):\\n        parsed_frozen = self.pipfile_lock_content()\\n        if parsed_frozen is None:\\n            return {}\\n        frozen_versions = {}\\n        for env in parsed_frozen:\\n            if env.startswith(\\'_\\'):\\n                # this is not an env\\n                continue\\n            for key, details in parsed_frozen[env].items():\\n                if \\'vcs\\' in details:\\n                    frozen_versions[key] = details[\\'vcs\\']\\n                else:\\n                    frozen_versions[key] = details.get(\\'version\\', \\'0.0.0\\').lstrip(\\'=\\')\\n        return frozen_versions\\n\\n    def parse_frozen_hashes(self):\\n        parsed_frozen = self.pipfile_lock_content()\\n        if parsed_frozen is None:\\n            return {}\\n        frozen_versions = {}\\n        for env in parsed_frozen:\\n            if env.startswith(\\'_\\'):\\n                # this is not an env\\n                continue\\n            for key, details in parsed_frozen[env].items():\\n                frozen_versions[key] = details.get(\\'hashes\\', [])\\n        return frozen_versions\\n\\n    def hash(self):\\n        \"\"\"Returns the SHA256 of the pipfile\\'s data.\\n        From pipfile.\\n        \"\"\"\\n        pipfile_content = self.pipfile_content()\\n        data = {\\n            \\'_meta\\': {\\n                \\'sources\\': pipfile_content.get(\\'sources\\') or self.DEFAULT_PIPFILE_SOURCES,\\n                \\'requires\\': pipfile_content.get(\\'requires\\') or {},\\n            },\\n            \\'default\\': pipfile_content.get(\\'packages\\') or {},\\n            \\'develop\\': pipfile_content.get(\\'dev-packages\\') or {},\\n        }\\n        content = json.dumps(data, sort_keys=True, separators=(\",\", \":\"))\\n        return hashlib.sha256(content.encode(\"utf8\")).hexdigest()\\n\\n    def save_frozen(self, states_by_env):\\n        \"\"\"Implementation is not complete.\\n        \"\"\"\\n        data = self.pipfile_lock_content() or {}\\n        data.setdefault(\\'_meta\\', {\\n            \\'pipfile-spec\\': 5,\\n            \\'requires\\': {},\\n            \\'sources\\': self.DEFAULT_PIPFILE_SOURCES,\\n        })\\n        data.setdefault(\\'_meta\\', {}).setdefault(\\'hash\\', {})[\\'sha256\\'] = self.hash()\\n        for env, states in states_by_env.items():\\n            if env == \\'\\':\\n                env_key = \\'default\\'\\n            elif env == \\'dev\\':\\n                env_key = \\'develop\\'\\n            else:\\n                env_key = env\\n            reqs = data.setdefault(env_key, {})\\n            for state in states:\\n                if state.requirement.egg:\\n                    egg, url, version = parse_vcs_requirement(state.requirement.line)\\n                    reqs[state.key] = {\\n                        \\'vcs\\': url,\\n                    }\\n                else:\\n                    reqs[state.key] = {\\n                        \\'version\\': \\'==\\' + state.frozen,\\n                        \\'hashes\\': state.hashes or [],\\n                    }\\n        with open(self.pipfile + \\'.lock\\', \\'w\\') as f:\\n            f.write(json.dumps(data, sort_keys=True, indent=4))\\n\\n\\ndef create_parser(**parser_args):\\n    \"\"\"Utility function that tried to figure out what Parser to use\\n    in current directory.\\n    \"\"\"\\n    if parser_args.get(\\'requirements_files\\'):\\n        return Parser(**parser_args)\\n    elif parser_args.get(\\'package\\'):\\n        return SetupParser(**parser_args)\\n    elif parser_args.get(\\'pipfile\\'):\\n        return PipfileParser(**parser_args)\\n    return SingleParser(**parser_args)\\n\\n\\n# Utilities\\ndef get_info_from_setup(path):\\n    \"\"\"Mock setuptools.setup(**kargs) to get\\n    package information about requirements and extras\\n    \"\"\"\\n    preserve = {}\\n\\n    def _save_info(**setup_args):\\n        preserve[\\'args\\'] = setup_args\\n\\n    import setuptools\\n    original_setup = setuptools.setup\\n    setuptools.setup = _save_info\\n    import runpy\\n    runpy.run_path(os.path.join(path, \\'setup.py\\'), run_name=\\'__main__\\')\\n    setuptools.setup = original_setup\\n    return preserve.get(\\'args\\')\\n\\n\\ndef search_files_upward(start_path=None):\\n    \"Search for requirements.txt, setup.py or Pipfile upward\"\\n    if not start_path:\\n        start_path = op.abspath(op.curdir)\\n    if any(\\n            op.exists(op.join(start_path, filename))\\n            for filename in (\\'requirements.txt\\', \\'setup.py\\', \\'Pipfile\\')\\n    ):\\n        return start_path\\n    up_path = op.abspath(op.join(start_path, \\'..\\'))\\n    if op.samefile(start_path, up_path):\\n        return None\\n    return search_files_upward(start_path=up_path)\\n\\n\\ndef find_all_prefixed_files(directory, prefix):\\n    \"find all requirements_*.txt files\"\\n    envs = {}\\n    for entry in os.listdir(directory):\\n        if not entry.startswith(prefix):\\n            continue\\n        name, ext = op.splitext(entry)\\n        env = name[len(prefix):].lstrip(\\'_\\')\\n        envs[env] = op.join(directory, entry)\\n    return envs\\n\\n\\ndef create_parser_parameters():\\n    base_path = search_files_upward()\\n    if not base_path:\\n        raise PundleException(\\'Can not find requirements.txt nor setup.py nor Pipfile\\')\\n    py_version_path = python_version_string()\\n    pundledir_base = os.environ.get(\\'PUNDLEDIR\\') or op.join(op.expanduser(\\'~\\'), \\'.pundledir\\')\\n    if op.exists(op.join(base_path, \\'requirements.txt\\')):\\n        requirements_files = find_all_prefixed_files(base_path, \\'requirements\\')\\n    else:\\n        requirements_files = {}\\n    envs = list(requirements_files.keys()) or [\\'\\']\\n    params = {\\n        \\'base_path\\': base_path,\\n        \\'frozen_files\\': {\\n            env: op.join(base_path, \\'frozen_%s.txt\\' % env if env else \\'frozen.txt\\')\\n            for env in envs\\n        },\\n        \\'directory\\': op.join(pundledir_base, py_version_path),\\n    }\\n    if requirements_files:\\n        params[\\'requirements_files\\'] = requirements_files\\n    elif op.exists(op.join(base_path, \\'setup.py\\')):\\n        params[\\'package\\'] = base_path\\n    elif op.exists(op.join(base_path, \\'Pipfile\\')):\\n        params[\\'pipfile\\'] = op.join(base_path, \\'Pipfile\\')\\n    else:\\n        return\\n    return params\\n\\n\\ndef create_parser_or_exit():\\n    parser_kw = create_parser_parameters()\\n    if not parser_kw:\\n        print_message(\\'You have not requirements.txt. Create it and run again.\\')\\n        exit(1)\\n    return parser_kw\\n\\n\\n# Commands\\ndef upgrade_all(**kw):\\n    key = kw.pop(\\'key\\')\\n    prereleases = kw.pop(\\'prereleases\\')\\n    suite = create_parser(**kw).create_suite()\\n    suite.need_freeze()\\n    suite.upgrade(key=key, prereleases=prereleases)\\n    suite.install()\\n    suite.save_frozen()\\n\\n\\ndef install_all(**kw):\\n    suite = create_parser(**kw).create_suite()\\n    if suite.need_freeze() or suite.need_install():\\n        print_message(\\'Install some packages\\')\\n        suite.install()\\n    else:\\n        print_message(\\'Nothing to do, all packages installed\\')\\n    suite.save_frozen()\\n    return suite\\n\\n\\ndef activate():\\n    parser_kw = create_parser_parameters()\\n    if not parser_kw:\\n        raise PundleException(\\'Can`t create parser parameters\\')\\n    suite = create_parser(**parser_kw).create_suite()\\n    if suite.need_freeze(verbose=True):\\n        raise PundleException(\\'frozen file is outdated\\')\\n    if suite.need_install():\\n        raise PundleException(\\'Some dependencies not installed\\')\\n    envs = (os.environ.get(\\'PUNDLEENV\\') or \\'\\').split(\\',\\')\\n    suite.activate_all(envs=envs)\\n    return suite\\n\\n\\nFIXATE_TEMPLATE = \"\"\"\\n# pundle user customization start\\nimport pundle; pundle.activate()\\n# pundle user customization end\\n\"\"\"\\n\\n\\ndef fixate():\\n    \"puts activation code to usercustomize.py for user\"\\n    print_message(\\'Fixate\\')\\n    import site\\n    userdir = site.getusersitepackages()\\n    if not userdir:\\n        raise PundleException(\\'Can`t fixate due user have not site package directory\\')\\n    try:\\n        makedirs(userdir)\\n    except OSError:\\n        pass\\n    template = FIXATE_TEMPLATE.replace(\\'op.dirname(__file__)\\', \"\\'%s\\'\" % op.abspath(op.dirname(__file__)))\\n    usercustomize_file = op.join(userdir, \\'usercustomize.py\\')\\n    print_message(\\'Will edit %s file\\' % usercustomize_file)\\n    if op.exists(usercustomize_file):\\n        content = open(usercustomize_file).read()\\n        if \\'# pundle user customization start\\' in content:\\n            regex = re.compile(r\\'\\\\n# pundle user customization start.*# pundle user customization end\\\\n\\', re.DOTALL)\\n            content, res = regex.subn(template, content)\\n            open(usercustomize_file, \\'w\\').write(content)\\n        else:\\n            open(usercustomize_file, \\'a\\').write(content)\\n    else:\\n        open(usercustomize_file, \\'w\\').write(template)\\n    link_file = op.join(userdir, \\'pundle.py\\')\\n    if op.lexists(link_file):\\n        print_message(\\'Remove exist link to pundle\\')\\n        os.unlink(link_file)\\n    print_message(\\'Create link to pundle %s\\' % link_file)\\n    os.symlink(op.abspath(__file__), link_file)\\n    print_message(\\'Complete\\')\\n\\n\\ndef entry_points():\\n    suite = activate()\\n    entries = {}\\n    for r in suite.states.values():\\n        d = r.frozen_dist()\\n        if not d:\\n            continue\\n        if isinstance(d, VCSDist):\\n            continue\\n        scripts = d.get_entry_map().get(\\'console_scripts\\', {})\\n        for name in scripts:\\n            entries[name] = d\\n    return entries\\n\\n\\nclass CmdRegister:\\n    commands = {}\\n    ordered = []\\n\\n    @classmethod\\n    def cmdline(cls, *cmd_aliases):\\n        def wrap(func):\\n            for alias in cmd_aliases:\\n                cls.commands[alias] = func\\n                cls.ordered.append(alias)\\n        return wrap\\n\\n    @classmethod\\n    def help(cls):\\n        for alias in cls.ordered:\\n            if not alias:\\n                continue\\n            print(\"{:15s} {}\".format(alias, cls.commands[alias].__doc__))\\n\\n    @classmethod\\n    def main(cls):\\n        alias = \\'\\' if len(sys.argv) == 1 else sys.argv[1]\\n        if alias == \\'help\\':\\n            cls.help()\\n            return\\n        if alias not in cls.commands:\\n            print(\\'Unknown command\\\\nTry this:\\')\\n            cls.help()\\n            sys.exit(1)\\n        cls.commands[alias]()\\n\\n\\n@CmdRegister.cmdline(\\'\\', \\'install\\')\\ndef cmd_install():\\n    \"Install packages by frozen.txt and resolve ones that was not frozen\"\\n    install_all(**create_parser_or_exit())\\n\\n\\n@CmdRegister.cmdline(\\'upgrade\\')\\ndef cmd_upgrade():\\n    \"\"\"\\n    [package [pre]] if package provided will upgrade it and dependencies or all packages from PyPI.\\n    If `pre` provided will look for prereleases.\\n    \"\"\"\\n    key = sys.argv[2] if len(sys.argv) > 2 else None\\n    prereleases = sys.argv[3] == \\'pre\\' if len(sys.argv) > 3 else False\\n    upgrade_all(key=key, prereleases=prereleases, **create_parser_or_exit())\\n\\n\\nCmdRegister.cmdline(\\'fixate\\')(fixate)\\n\\n\\n@CmdRegister.cmdline(\\'exec\\')\\ndef cmd_exec():\\n    \"executes setuptools entry\"\\n    cmd = sys.argv[2]\\n    args = sys.argv[3:]\\n    entries = entry_points()\\n    if cmd not in entries:\\n        print_message(\\'Script is not found. Check if package is installed, or look at the `pundle entry_points`\\')\\n        sys.exit(1)\\n    exc = entries[cmd].get_entry_info(\\'console_scripts\\', cmd).load()\\n    sys.path.insert(0, \\'\\')\\n    sys.argv = [cmd] + args\\n    exc()\\n\\n\\n@CmdRegister.cmdline(\\'entry_points\\')\\ndef cmd_entry_points():\\n    \"prints available setuptools entries\"\\n    for entry, package in entry_points().items():\\n        print(\\'%s (%s)\\' % (entry, package))\\n\\n\\n@CmdRegister.cmdline(\\'edit\\')\\ndef cmd_edit():\\n    \"prints directory path to package\"\\n    parser_kw = create_parser_parameters()\\n    suite = create_parser(**parser_kw).create_suite()\\n    if suite.need_freeze():\\n        raise PundleException(\\'%s file is outdated\\' % suite.parser.frozen_file)\\n    print(suite.states[sys.argv[2]].frozen_dist().location)\\n\\n\\n@CmdRegister.cmdline(\\'info\\')\\ndef cmd_info():\\n    \"prints info about Pundle state\"\\n    parser_kw = create_parser_parameters()\\n    suite = create_parser(**parser_kw).create_suite()\\n    if suite.need_freeze():\\n        print(\\'frozen.txt is outdated\\')\\n    else:\\n        print(\\'frozen.txt is up to date\\')\\n    for state in suite.required_states():\\n        print(\\n            \\'Requirement \"{}\", frozen {}, {}\\'.format(\\n                state.key,\\n                state.frozen,\\n                state.requirement.line if state.requirement else \\'None\\'\\n            )\\n        )\\n        print(\\'Installed versions:\\')\\n        for dist in state.installed:\\n            print(\\'    \\', repr(dist))\\n        if not state.installed:\\n            print(\\'     None\\')\\n\\n\\ndef run_console(glob):\\n    import readline\\n    import rlcompleter\\n    import atexit\\n    import code\\n\\n    history_path = os.path.expanduser(\"~/.python_history\")\\n\\n    def save_history(history_path=history_path):\\n        readline.write_history_file(history_path)\\n    if os.path.exists(history_path):\\n        readline.read_history_file(history_path)\\n\\n    atexit.register(save_history)\\n\\n    readline.set_completer(rlcompleter.Completer(glob).complete)\\n    readline.parse_and_bind(\"tab: complete\")\\n    code.InteractiveConsole(locals=glob).interact()\\n\\n\\n@CmdRegister.cmdline(\\'console\\')\\ndef cmd_console():\\n    \"[ipython|bpython|ptpython] starts python console with activated pundle environment\"\\n    suite = activate()\\n    glob = {\\n        \\'pundle_suite\\': suite,\\n    }\\n    interpreter = sys.argv[2] if len(sys.argv) > 2 else None\\n    if not interpreter:\\n        run_console(glob)\\n    elif interpreter == \\'ipython\\':\\n        from IPython import embed\\n        embed()\\n    elif interpreter == \\'ptpython\\':\\n        from ptpython.repl import embed\\n        embed(glob, {})\\n    elif interpreter == \\'bpython\\':\\n        from bpython import embed\\n        embed(glob)\\n    else:\\n        raise PundleException(\\'Unknown interpreter: {}. Choose one of None, ipython, bpython, ptpython.\\')\\n\\n\\n@CmdRegister.cmdline(\\'run\\')\\ndef cmd_run():\\n    \"executes given script\"\\n    activate()\\n    import runpy\\n    sys.path.insert(0, \\'\\')\\n    script = sys.argv[2]\\n    sys.argv = [sys.argv[2]] + sys.argv[3:]\\n    runpy.run_path(script, run_name=\\'__main__\\')\\n\\n\\n@CmdRegister.cmdline(\\'module\\')\\ndef cmd_module():\\n    \"executes module like `python -m`\"\\n    activate()\\n    import runpy\\n    sys.path.insert(0, \\'\\')\\n    module = sys.argv[2]\\n    sys.argv = [sys.argv[2]] + sys.argv[3:]\\n    runpy.run_module(module, run_name=\\'__main__\\')\\n\\n\\n@CmdRegister.cmdline(\\'env\\')\\ndef cmd_env():\\n    \"populates PYTHONPATH with packages paths and executes command line in subprocess\"\\n    activate()\\n    aug_env = os.environ.copy()\\n    aug_env[\\'PYTHONPATH\\'] = \\':\\'.join(sys.path)\\n    subprocess.call(sys.argv[2:], env=aug_env)\\n\\n\\n@CmdRegister.cmdline(\\'print_env\\')\\ndef cmd_print_env():\\n    \"Prints PYTHONPATH. For usage with mypy and MYPYPATH\"\\n    suite = activate()\\n    path = \\':\\'.join(\\n        state.frozen_dist().location\\n        for state in suite.states.values()\\n        if state.frozen_dist()\\n    )\\n    print(path)\\n\\n\\nENTRY_POINT_TEMPLATE = \\'\\'\\'#! /usr/bin/env python\\nimport pundle; pundle.activate()\\npundle.entry_points()[\\'{entry_point}\\'].get_entry_info(\\'console_scripts\\', \\'{entry_point}\\').load(require=False)()\\n\\'\\'\\'\\n\\n\\n@CmdRegister.cmdline(\\'linkall\\')\\ndef link_all():\\n    \"links all packages to `.pundle_local` dir\"\\n    local_dir = \\'.pundle_local\\'\\n    suite = activate()\\n\\n    try:\\n        makedirs(local_dir)\\n    except OSError:\\n        pass\\n    local_dir_info = {de.name: de for de in os.scandir(local_dir)}\\n    for r in suite.states.values():\\n        d = r.frozen_dist()\\n        if not d:\\n            continue\\n        for dir_entry in os.scandir(d.location):\\n            if dir_entry.name.startswith(\\'__\\') or dir_entry.name.startswith(\\'.\\') or dir_entry.name == \\'bin\\':\\n                continue\\n            dest_path = os.path.join(local_dir, dir_entry.name)\\n            if dir_entry.name in local_dir_info:\\n                sym = local_dir_info.pop(dir_entry.name)\\n                existed = op.realpath(sym.path)\\n                if existed == dir_entry.path:\\n                    continue\\n                os.remove(sym.path)\\n            os.symlink(dir_entry.path, dest_path)\\n    # create entry_points binaries\\n    try:\\n        makedirs(os.path.join(local_dir, \\'bin\\'))\\n    except OSError:\\n        pass\\n    for bin_name, entry_point in entry_points().items():\\n        bin_filename = os.path.join(local_dir, \\'bin\\', bin_name)\\n        open(bin_filename, \\'w\\').write(ENTRY_POINT_TEMPLATE.format(entry_point=bin_name))\\n        file_stat = os.stat(bin_filename)\\n        os.chmod(bin_filename, file_stat.st_mode | stat.S_IEXEC)\\n    local_dir_info.pop(\\'bin\\')\\n\\n    # remove extra links\\n    for de in local_dir_info:\\n        os.remove(de.path)\\n\\n\\n@CmdRegister.cmdline(\\'show_requirements\\')\\ndef show_requirements():\\n    \"shows details requirements info\"\\n    suite = activate()\\n    for name, state in suite.states.items():\\n        if state.requirement:\\n            print(\\n                name,\\n                \\'frozen:\\',\\n                state.frozen,\\n                \\'required:\\',\\n                state.requirement.req if state.requirement.req else \\'VCS\\',\\n                state.requirement.envs,\\n            )\\n\\n\\n# Single mode that you can use in console\\n_single_mode_suite = {}  # cache variable to keep current suite for single_mode\\n\\n\\ndef single_mode():\\n    \"\"\" Create, cache and return Suite instance for single_mode.\\n    \"\"\"\\n    if not _single_mode_suite:\\n        py_version_path = python_version_string()\\n        pundledir_base = os.environ.get(\\'PUNDLEDIR\\') or op.join(op.expanduser(\\'~\\'), \\'.pundledir\\')\\n        directory = op.join(pundledir_base, py_version_path)\\n        _single_mode_suite[\\'cache\\'] = create_parser(directory=directory).create_suite()\\n    return _single_mode_suite[\\'cache\\']\\n\\n\\ndef use(key):\\n    \"\"\" Installs `key` requirement, like `django==1.11` or just `django`\\n    \"\"\"\\n    suite = single_mode()\\n    suite.use(key)\\n\\n\\nif __name__ == \\'__main__\\':\\n    CmdRegister.main()\\n'"}]}, "get_python_source": {"line": 37, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/pundler/pundle.py'"}, "return_value": "'# encoding: utf-8\\n\"\"\"\\nData Model, start here to not get mad\\n=====================================\\n\\nMain entity will be distribution, like Flask. Per key\\nPundle tracks three state parts:\\n    1. requirement, like Flask>0.12.2.\\n    2. frozen version, like ==0.12.2\\n    3. installed distributions, like [flask==0.12.2, flask==0.10.0]\\n\\nRequirement basically is from file, like requirements.txt, setup.py or Pipfile. This requirements\\nhave source like `requirements.txt`. And base requirements can have dependencies. This\\ndependencies are turned to requirements too with source like `Flask-Admin << requirements.txt`.\\nTo track requirements we use `CustomReq` class. It can work with PyPi and VCS requirements.\\nCustomReq can have `self.req = pkg_resources.Requirement` or custom vcs line.\\n\\nDistribution is one of VCSDist or pkg_resources.DistInfoDistribution. VCSDist is to\\ntrack installed VCS packages and pkg_resources.DistInfoDistribution is for PyPi packages.\\n\\nAll three states of distribution are tracked inside `RequirementState` object that includes info\\nabout requirement, frozen version and installed versions.\\n\\n`Suite` keeps state of all distributions like a dictionary of RequirentStates.\\n\\nTo populate Suite and to parse all requirements, frozen versions and what we have installed pundle\\nuses `Parser`. There is plenty of them - `Parser` that works with `requirements.txt`,\\n`SetupParser` that works with `setup.py`, PipfileParser that works with Pipfile and Pipfile.lock.\\n\"\"\"\\n\\nfrom __future__ import print_function\\nimport re\\ntry:\\n    from urllib.parse import urlparse, parse_qsl\\nexcept ImportError:  # pragma: no cover\\n    from urlparse import urlparse, parse_qsl\\nfrom collections import defaultdict\\nfrom base64 import b64encode, b64decode\\nimport platform\\nimport os.path as op\\nimport os\\nfrom os import makedirs\\nimport stat\\nimport tempfile\\nimport shutil\\nimport subprocess\\nimport sys\\nimport shlex\\nimport json\\nimport hashlib\\nimport pkg_resources\\ntry:\\n    from pip import main as pip_exec\\nexcept ImportError:\\n    from pip._internal import main as pip_exec\\n    from types import ModuleType\\n\\n    if isinstance(pip_exec, ModuleType):\\n        pip_exec = pip_exec.main\\n\\n# TODO bundle own version of distlib. Perhaps\\ntry:\\n    from pip._vendor.distlib import locators\\nexcept ImportError:  # pragma: no cover\\n    from pip.vendor.distlib import locators\\n\\ntry:\\n    str_types = (basestring,)\\nexcept NameError:  # pragma: no cover\\n    str_types = (str, bytes)\\n\\ntry:\\n    pkg_resources_parse_version = pkg_resources.SetuptoolsVersion\\nexcept AttributeError:  # pragma: no cover\\n    pkg_resources_parse_version = pkg_resources.packaging.version.Version\\n\\n\\ndef print_message(*a, **kw):\\n    print(*a, **kw)\\n\\n\\nclass PundleException(Exception):\\n    pass\\n\\n\\ndef python_version_string():\\n    \"\"\"We use it to generate per python folder name, where\\n    we will install all packages.\\n    \"\"\"\\n    if platform.python_implementation() == \\'PyPy\\':\\n        version_info = sys.pypy_version_info\\n    else:\\n        version_info = sys.version_info\\n    version_string = \\'{v.major}.{v.minor}.{v.micro}\\'.format(v=version_info)\\n    build, _ = platform.python_build()\\n    build = build.replace(\\':\\', \\'_\\')  # windows do not understand `:` in path\\n    return \\'{}-{}-{}\\'.format(platform.python_implementation(), version_string, build)\\n\\n\\ndef parse_file(filename):\\n    \"\"\"Helper to parse requirements.txt or frozen.txt.\\n    \"\"\"\\n    res = []\\n    with open(filename) as f:\\n        for line in f:\\n            s = line.strip()\\n            if s and not s.startswith(\\'#\\'):\\n                if s.startswith(\\'-r\\'):\\n                    continue\\n                if s.startswith(\\'-e \\'):\\n                    s = s[3:].strip()\\n                if parse_vcs_requirement(s):\\n                    res.append(s)\\n                else:\\n                    req = shlex.split(s, comments=True)\\n                    res.append(req[0])\\n    return res\\n\\n\\ndef test_vcs(req):\\n    \"\"\"Checks if requirement line is for VCS.\\n    \"\"\"\\n    return \\'+\\' in req and req.index(\\'+\\') == 3\\n\\n\\ndef parse_vcs_requirement(req):\\n    \"\"\"Parses VCS line to egg name, version etc.\\n    \"\"\"\\n    if \\'+\\' not in req:\\n        return None\\n    vcs, url = req.split(\\'+\\', 1)\\n    if vcs not in (\\'git\\', \\'svn\\', \\'hg\\'):\\n        return None\\n    parsed_url = urlparse(url)\\n    parsed = dict(parse_qsl(parsed_url.fragment))\\n    if \\'egg\\' not in parsed:\\n        return None\\n    egg = parsed[\\'egg\\'].rsplit(\\'-\\', 1)\\n    if len(egg) > 1:\\n        try:\\n            pkg_resources_parse_version(egg[1])\\n        except pkg_resources._vendor.packaging.version.InvalidVersion:\\n            return parsed[\\'egg\\'].lower(), req, None\\n        return egg[0].lower(), req, egg[1]\\n    else:\\n        return parsed[\\'egg\\'].lower(), req, None\\n\\n\\ndef parse_frozen_vcs(req):\\n    res = parse_vcs_requirement(req)\\n    if not res:\\n        return\\n    return res[0], res[1]\\n\\n\\nclass VCSDist(object):\\n    \"\"\" Represents installed VCS distribution.\\n    \"\"\"\\n    def __init__(self, directory):\\n        self.dir = directory\\n        name = op.split(directory)[-1]\\n        key, encoded = name.split(\\'+\\', 1)\\n        self.key = key.lower()\\n        self.line = b64decode(encoded).decode(\\'utf-8\\')\\n        egg, req, version = parse_vcs_requirement(self.line)\\n        version = version or \\'0.0.0\\'\\n        self.hashcmp = (pkg_resources_parse_version(version), -1, egg, self.dir)\\n        self.version = self.line\\n        self.pkg_resource = next(iter(pkg_resources.find_distributions(self.dir, True)), None)\\n        self.location = self.pkg_resource.location\\n\\n    def requires(self, extras=[]):\\n        return self.pkg_resource.requires(extras=extras)\\n\\n    def activate(self):\\n        return self.pkg_resource.activate()\\n\\n    def __lt__(self, other):\\n        return self.hashcmp.__lt__(other.hashcmp)\\n\\n\\nclass CustomReq(object):\\n    \"\"\"Represents PyPi or VCS requirement.\\n    Can locate and install it.\\n    \"\"\"\\n    def __init__(self, line, env, source=None):\\n        self.line = line\\n        self.egg = None\\n        if isinstance(line, pkg_resources.Requirement):\\n            self.req = line\\n        elif test_vcs(line):\\n            res = parse_vcs_requirement(line)\\n            if not res:\\n                raise PundleException(\\'Bad url %r\\' % line)\\n            egg, req, version = res\\n            self.egg = egg\\n            self.req = None  # pkg_resources.Requirement.parse(res)\\n        else:\\n            self.req = pkg_resources.Requirement.parse(line)\\n        self.sources = set([source])\\n        self.envs = set()\\n        self.add_env(env)\\n\\n    def __contains__(self, something):\\n        if self.req:\\n            return (something in self.req)\\n        elif self.egg:\\n            return something == self.line\\n        else:\\n            return False\\n\\n    def __repr__(self):\\n        return \\'<CustomReq %r>\\' % self.__dict__\\n\\n    def why_str(self):\\n        if len(self.sources) < 2:\\n            return \\'{} << {}\\'.format(self.line, self.why_str_one(list(self.sources)[0]))\\n        causes = list(sorted(self.why_str_one(source) for source in self.sources))\\n        return \\'{} << [{}]\\'.format(self.line, \\' | \\'.join(causes))\\n\\n    def why_str_one(self, source):\\n        if isinstance(source, str_types):\\n            return source\\n        elif isinstance(source, CustomReq):\\n            return source.why_str()\\n        return \\'?\\'\\n\\n    def adjust_with_req(self, req):\\n        if not self.req:\\n            return\\n            raise PundleException(\\'VCS\\')\\n        versions = \\',\\'.join(\\'\\'.join(t) for t in set(self.req.specs + req.req.specs))\\n        self.requirement = pkg_resources.Requirement.parse(\\'{} {}\\'.format(\\n            self.req.project_name, versions\\n        ))\\n        self.sources.update(req.sources)\\n        self.add_env(req.envs)\\n\\n    @property\\n    def key(self):\\n        return self.req.key if self.req else self.egg\\n\\n    @property\\n    def extras(self):\\n        return self.req.extras if self.req else []\\n\\n    def locate(self, suite, prereleases=False):\\n        # requirements can have something after `;` symbol that `locate` does not understand\\n        req = str(self.req).split(\\';\\', 1)[0]\\n        dist = suite.locate(req, prereleases=prereleases)\\n        if not dist:\\n            # have not find any releases so search for pre\\n            dist = suite.locate(req, prereleases=True)\\n        if not dist:\\n            raise PundleException(\\'%s can not be located\\' % self.req)\\n        return dist\\n\\n    def locate_and_install(self, suite, installed=None, prereleases=False):\\n        if self.egg:\\n            key = b64encode(self.line.encode(\\'utf-8\\')).decode()\\n            target_dir = op.join(suite.parser.directory, \\'{}+{}\\'.format(self.egg, key))\\n            target_req = self.line\\n            ready = [\\n                installation\\n                for installation in (installed or [])\\n                if getattr(installation, \\'line\\', None) == self.line\\n            ]\\n        else:\\n            loc_dist = self.locate(suite, prereleases=prereleases)\\n            ready = [\\n                installation\\n                for installation in (installed or [])\\n                if installation.version == loc_dist.version\\n            ]\\n            target_dir = op.join(suite.parser.directory, \\'{}-{}\\'.format(loc_dist.key, loc_dist.version))\\n            # DEL? target_req = \\'%s==%s\\' % (loc_dist.name, loc_dist.version)\\n            # If we use custom index, then we want not to configure PIP with it\\n            # and just give it URL\\n            target_req = loc_dist.download_url\\n        if ready:\\n            return ready[0]\\n        try:\\n            makedirs(target_dir)\\n        except OSError:\\n            pass\\n        tmp_dir = tempfile.mkdtemp()\\n        print(\\'Use temp dir\\', tmp_dir)\\n        try:\\n            print(\\'pip install --no-deps -t %s %s\\' % (tmp_dir, target_req))\\n            pip_exec([\\n                \\'install\\',\\n                \\'--no-deps\\',\\n                \\'-t\\', tmp_dir,\\n                \\'-v\\',\\n                target_req\\n            ])\\n            for item in os.listdir(tmp_dir):\\n                shutil.move(op.join(tmp_dir, item), op.join(target_dir, item))\\n        except Exception as exc:\\n            raise PundleException(\\'%s was not installed due error %s\\' % (self.egg or loc_dist.name, exc))\\n        finally:\\n            shutil.rmtree(tmp_dir, ignore_errors=True)\\n        return next(iter(pkg_resources.find_distributions(target_dir, True)), None)\\n\\n    def add_env(self, env):\\n        if isinstance(env, str):\\n            self.envs.add(env)\\n        else:\\n            self.envs.update(env)\\n\\n\\nclass RequirementState(object):\\n    \"\"\"Holds requirement state, like what version do we have installed, is\\n    some version frozen or not, what requirement constrains do we have.\\n    \"\"\"\\n    def __init__(self, key, req=None, frozen=None, installed=None, hashes=None):\\n        self.key = key\\n        self.requirement = req\\n        self.frozen = frozen\\n        self.hashes = hashes\\n        self.installed = installed or []\\n        self.installed.sort()\\n        self.installed.reverse()\\n\\n    def __repr__(self):\\n        return \\'<RequirementState %r>\\' % self.__dict__\\n\\n    def adjust_with_req(self, req):\\n        if self.requirement:\\n            self.requirement.adjust_with_req(req)\\n        else:\\n            self.requirement = req\\n\\n    def has_correct_freeze(self):\\n        return self.requirement and self.frozen and self.frozen in self.requirement\\n\\n    def check_installed_version(self, suite, install=False):\\n        # install version of package if not installed\\n        dist = None\\n        if self.has_correct_freeze():\\n            dist = [\\n                installation\\n                for installation in self.installed\\n                if pkg_resources.parse_version(installation.version) == pkg_resources.parse_version(self.frozen)\\n            ]\\n            dist = dist[0] if dist else None\\n            if install and not dist:\\n                dist = self.install_frozen(suite)\\n        if install and not dist:\\n            dist = self.requirement.locate_and_install(suite, installed=self.get_installed())\\n            if dist is None:\\n                raise PundleException(\\'Package %s was not installed due some error\\' % self.key)\\n            self.frozen = dist.version\\n            self.installed.append(dist)\\n            self.frozen = dist.version\\n        return dist\\n\\n    def get_installed(self):\\n        return [installation for installation in self.installed if installation.version in self.requirement]\\n\\n    def upgrade(self, suite, prereleases=False):\\n        # check if we have fresh packages on PIPY\\n        dists = self.get_installed()\\n        dist = dists[0] if dists else None\\n        latest = self.requirement.locate(suite, prereleases=prereleases)\\n        if not dist or pkg_resources.parse_version(latest.version) > pkg_resources.parse_version(dist.version):\\n            print_message(\\'Upgrade to\\', latest)\\n            dist = self.requirement.locate_and_install(suite, installed=self.get_installed(), prereleases=prereleases)\\n        # Anyway use latest available dist\\n        self.frozen = dist.version\\n        self.installed.append(dist)\\n        return dist\\n\\n    def reveal_requirements(self, suite, install=False, upgrade=False, already_revealed=None, prereleases=False):\\n        already_revealed = already_revealed.copy() if already_revealed is not None else set()\\n        if self.key in already_revealed:\\n            return\\n        if upgrade:\\n            dist = self.upgrade(suite, prereleases=prereleases)\\n        else:\\n            dist = self.check_installed_version(suite, install=install)\\n        if not dist:\\n            return\\n        already_revealed.add(self.key)\\n        for req in dist.requires(extras=self.requirement.extras):\\n            suite.adjust_with_req(\\n                CustomReq(str(req), self.requirement.envs, source=self.requirement),\\n                install=install,\\n                upgrade=upgrade,\\n                already_revealed=already_revealed,\\n            )\\n\\n    def frozen_dump(self):\\n        if self.requirement.egg:\\n            return self.requirement.line\\n        main = \\'{}=={}\\'.format(self.key, self.frozen)\\n        comment = self.requirement.why_str()\\n        return \\'{:20s} # {}\\'.format(main, comment)\\n\\n    def frozen_dist(self):\\n        if not self.frozen:\\n            return\\n        for dist in self.installed:\\n            if pkg_resources.parse_version(dist.version) == pkg_resources.parse_version(self.frozen):\\n                return dist\\n\\n    def install_frozen(self, suite):\\n        if self.frozen_dist() or not self.frozen:\\n            return\\n        envs = self.requirement.envs if self.requirement else \\'\\'\\n        if test_vcs(self.frozen):\\n            frozen_req = CustomReq(self.frozen, envs)\\n        else:\\n            frozen_req = CustomReq(\"{}=={}\".format(self.key, self.frozen), envs)\\n        dist = frozen_req.locate_and_install(suite)\\n        self.installed.append(dist)\\n        return dist\\n\\n    def activate(self):\\n        dist = self.frozen_dist()\\n        if not dist:\\n            raise PundleException(\\'Distribution is not installed %s\\' % self.key)\\n        dist.activate()\\n        pkg_resources.working_set.add_entry(dist.location)\\n        # find end execute *.pth\\n        sitedir = dist.location  # noqa some PTH search for sitedir\\n        for filename in os.listdir(dist.location):\\n            if not filename.endswith(\\'.pth\\'):\\n                continue\\n            try:\\n                for line in open(op.join(dist.location, filename)):\\n                    if line.startswith(\\'import \\'):\\n                        exec(line.strip())\\n            except Exception as e:\\n                print(\\'Erroneous pth file %r\\' % op.join(dist.location, filename))\\n                print(e)\\n\\n\\nclass AggregatingLocator(object):\\n    def __init__(self, locators):\\n        self.locators = locators\\n\\n    def locate(self, req, **kw):\\n        for locator in self.locators:\\n            print_message(\\'try\\', locator, \\'for\\', req)\\n            revealed = locator.locate(req, **kw)\\n            if revealed:\\n                return revealed\\n\\n\\nclass Suite(object):\\n    \"\"\"Main object that represents current directory pundle state.\\n    It tracks RequirementStates, envs, urls for package locator.\\n    \"\"\"\\n    def __init__(self, parser, envs=[], urls=None):\\n        self.states = {}\\n        self.parser = parser\\n        self.envs = envs\\n        self.urls = urls or [\\'https://pypi.python.org/simple/\\']\\n        if \\'PIP_EXTRA_INDEX_URL\\' in os.environ:\\n            self.urls.append(os.environ[\\'PIP_EXTRA_INDEX_URL\\'])\\n        self.locators = []\\n        for url in self.urls:\\n            self.locators.append(\\n                locators.SimpleScrapingLocator(url, timeout=3.0, scheme=\\'legacy\\')\\n            )\\n        self.locators.append(locators.JSONLocator(scheme=\\'legacy\\'))\\n        self.locator = AggregatingLocator(self.locators)\\n\\n    def use(self, key):\\n        \"\"\"For single mode\\n        You can call suite.use(\\'arrow\\') and then `import arrow`\\n\\n        :key: package name\\n        \"\"\"\\n        self.adjust_with_req(CustomReq(key, \\'\\'))\\n        self.install()\\n        self.activate_all()\\n\\n    def locate(self, *a, **kw):\\n        return self.locator.locate(*a, **kw)\\n\\n    def add(self, key, state):\\n        self.states[key] = state\\n\\n    def __repr__(self):\\n        return \\'<Suite %r>\\' % self.states\\n\\n    def required_states(self):\\n        return [state for state in self.states.values() if state.requirement]\\n\\n    def need_freeze(self, verbose=False):\\n        self.install(install=False)\\n        not_correct = not all(state.has_correct_freeze() for state in self.required_states())\\n        if not_correct and verbose:\\n            for state in self.required_states():\\n                if not state.has_correct_freeze():\\n                    print(\\n                        state.key,\\n                        \\'Need\\',\\n                        state.requirement,\\n                        \\'have not been frozen\\',\\n                        state.frozen,\\n                        \\', installed\\',\\n                        state.installed\\n                    )\\n        # TODO\\n        # unneeded = any(state.frozen for state in self.states.values() if not state.requirement)\\n        # if unneeded:\\n        #     print(\\'!!! Unneeded\\', [state.key for state in self.states.values() if not state.requirement])\\n        return not_correct  # or unneeded\\n\\n    def adjust_with_req(self, req, install=False, upgrade=False, already_revealed=None):\\n        state = self.states.get(req.key)\\n        if not state:\\n            state = RequirementState(req.key, req=req)\\n            self.add(req.key, state)\\n        else:\\n            state.adjust_with_req(req)\\n        state.reveal_requirements(self, install=install, upgrade=upgrade, already_revealed=already_revealed or set())\\n\\n    def install(self, install=True):\\n        for state in self.required_states():\\n            state.reveal_requirements(self, install=install)\\n\\n    def upgrade(self, key=None, prereleases=False):\\n        states = [self.states[key]] if key else self.required_states()\\n        for state in states:\\n            print(\\'Check\\', state.requirement.req)\\n            state.reveal_requirements(self, upgrade=True, prereleases=prereleases)\\n\\n    def get_frozen_states(self, env):\\n        return [\\n            state\\n            for state in self.required_states()\\n            if state.requirement and env in state.requirement.envs\\n        ]\\n\\n    def need_install(self):\\n        return not all(state.frozen_dist() for state in self.states.values() if state.frozen)\\n\\n    def install_frozen(self):\\n        for state in self.states.values():\\n            state.install_frozen(self)\\n\\n    def activate_all(self, envs=(\\'\\',)):\\n        for state in self.required_states():\\n            if \\'\\' in state.requirement.envs or any(env in state.requirement.envs for env in envs):\\n                state.activate()\\n\\n    def save_frozen(self):\\n        \"Saves frozen files to disk\"\\n        states_by_env = dict(\\n            (env, self.get_frozen_states(env))\\n            for env in self.parser.envs()\\n        )\\n        self.parser.save_frozen(states_by_env)\\n\\n\\nclass Parser(object):\\n    \"\"\"Gather environment info, requirements,\\n    frozen packages and create Suite object\\n    \"\"\"\\n    def __init__(\\n            self,\\n            base_path=None,\\n            directory=\\'Pundledir\\',\\n            requirements_files=None,\\n            frozen_files=None,\\n            package=None,\\n    ):\\n        self.base_path = base_path or \\'.\\'\\n        self.directory = directory\\n        self.requirements_files = requirements_files\\n        if frozen_files is None:\\n            self.frozen_files = {\\'\\': \\'frozen.txt\\'}\\n        else:\\n            self.frozen_files = frozen_files\\n        self.package = package\\n        self.package_envs = set([\\'\\'])\\n\\n    def envs(self):\\n        if self.requirements_files:\\n            return list(self.requirements_files.keys()) or [\\'\\']\\n        elif self.package:\\n            return self.package_envs\\n        return [\\'\\']\\n\\n    def get_frozen_file(self, env):\\n        if env in self.frozen_files:\\n            return self.frozen_files[env]\\n        else:\\n            return os.path.join(self.base_path, \\'frozen_%s.txt\\' % env)\\n\\n    def create_suite(self):\\n        reqs = self.parse_requirements()\\n        freezy = self.parse_frozen()\\n        hashes = self.parse_frozen_hashes()\\n        diry = self.parse_directory()\\n        state_keys = set(list(reqs.keys()) + list(freezy.keys()) + list(diry.keys()))\\n        suite = Suite(self, envs=self.envs())\\n        for key in state_keys:\\n            suite.add(\\n                key,\\n                RequirementState(\\n                    key,\\n                    req=reqs.get(key),\\n                    frozen=freezy.get(key),\\n                    installed=diry.get(key, []),\\n                    hashes=hashes.get(key),\\n                ),\\n            )\\n        return suite\\n\\n    def parse_directory(self):\\n        if not op.exists(self.directory):\\n            return {}\\n        dists = [\\n            # this magic takes first element or None\\n            next(iter(\\n                pkg_resources.find_distributions(op.join(self.directory, item), True)\\n            ), None)\\n            for item in os.listdir(self.directory) if \\'-\\' in item\\n        ]\\n        dists.extend(\\n            VCSDist(op.join(self.directory, item))\\n            for item in os.listdir(self.directory) if \\'+\\' in item\\n        )\\n        dists = filter(None, dists)\\n        result = defaultdict(list)\\n        for dist in dists:\\n            result[dist.key].append(dist)\\n        return result\\n\\n    def parse_frozen(self):\\n        frozen_versions = {}\\n        for env in self.envs():\\n            frozen_file = self.get_frozen_file(env)\\n            if op.exists(frozen_file):\\n                frozen = [\\n                    (parse_frozen_vcs(line) or line.split(\\'==\\'))\\n                    for line in parse_file(frozen_file)\\n                ]\\n            else:\\n                frozen = []\\n            for name, version in frozen:\\n                frozen_versions[name.lower()] = version\\n        return frozen_versions\\n\\n    def parse_frozen_hashes(self):\\n        \"\"\"This implementation does not support hashes yet\\n        \"\"\"\\n        return {}\\n\\n    def parse_requirements(self):\\n        all_requirements = {}\\n        for env, req_file in self.requirements_files.items():\\n            requirements = parse_file(req_file)\\n            if env:\\n                source = \\'requirements %s file\\' % env\\n            else:\\n                source = \\'requirements file\\'\\n            for line in requirements:\\n                req = CustomReq(line, env, source=source)\\n                if req.key in all_requirements:\\n                    # if requirements exists in other env, then add this env too\\n                    all_requirements[req.key].add_env(env)\\n                else:\\n                    all_requirements[req.key] = req\\n        return all_requirements\\n\\n    def save_frozen(self, states_by_env):\\n        for env, states in states_by_env.items():\\n            data = \\'\\\\n\\'.join(sorted(\\n                state.frozen_dump()\\n                for state in states\\n            )) + \\'\\\\n\\'\\n            frozen_file = self.get_frozen_file(env)\\n            with open(frozen_file, \\'w\\') as f:\\n                f.write(data)\\n\\n\\nclass SingleParser(Parser):\\n    \"\"\"Parser for console mode.\\n    \"\"\"\\n    def parse_requirements(self):\\n        return {}\\n\\n\\nclass SetupParser(Parser):\\n    \"\"\"Parser for `setup.py`. Because it mostly used to develop package, we\\n    do not freeze packages to setup.py. We use `frozen.txt`.\\n    \"\"\"\\n    def parse_requirements(self):\\n        setup_info = get_info_from_setup(self.package)\\n        if setup_info is None:\\n            raise PundleException(\\'There is no requirements.txt nor setup.py\\')\\n        install_requires = setup_info.get(\\'install_requires\\') or []\\n        reqs = [\\n            CustomReq(str(req), \\'\\', source=\\'setup.py\\')\\n            for req in install_requires\\n        ]\\n        requirements = dict((req.key, req) for req in reqs)\\n        # we use `feature` as environment for pundle\\n        extras_require = (setup_info.get(\\'extras_require\\') or {})\\n        for feature, feature_requires in extras_require.items():\\n            for req_line in feature_requires:\\n                req = CustomReq(req_line, feature, source=\\'setup.py\\')\\n                # if this req already in dict, then add our feature as env\\n                if req.key in requirements:\\n                    requirements[req.key].add_env(feature)\\n                else:\\n                    requirements[req.key] = req\\n            self.package_envs.add(feature)\\n        return requirements\\n\\n\\nclass PipfileParser(Parser):\\n    \"\"\"Parser for Pipfile and Pipfile.lock.\\n    \"\"\"\\n    DEFAULT_PIPFILE_SOURCES = [\\n        {\\n            \\'name\\': \\'pypi\\',\\n            \\'url\\': \\'https://pypi.python.org/simple\\',\\n            \\'verify_ssl\\': True,\\n        },\\n    ]\\n\\n    def __init__(self, **kw):\\n        self.pipfile = kw.pop(\\'pipfile\\')\\n        self.pipfile_envs = set([\\'\\'])\\n        super(PipfileParser, self).__init__(**kw)\\n        # cache\\n        self.loaded_pipfile = None\\n        self.loaded_pipfile_lock = None\\n\\n    def envs(self):\\n        return self.pipfile_envs\\n\\n    def pipfile_content(self):\\n        import toml\\n        if self.loaded_pipfile:\\n            return self.loaded_pipfile\\n        self.loaded_pipfile = toml.load(open(self.pipfile))\\n        return self.loaded_pipfile\\n\\n    def pipfile_lock_content(self):\\n        if self.loaded_pipfile_lock:\\n            return self.loaded_pipfile_lock\\n        try:\\n            self.loaded_pipfile_lock = json.load(open(self.pipfile + \\'.lock\\'))\\n        except Exception:\\n            pass\\n        return self.loaded_pipfile_lock\\n\\n    def parse_requirements(self):\\n        info = self.pipfile_content()\\n        all_requirements = {}\\n        for info_key in info:\\n            if not info_key.endswith(\\'packages\\'):\\n                continue\\n            if \\'-\\' in info_key:\\n                env, _ = info_key.split(\\'-\\', 1)\\n            else:\\n                env = \\'\\'\\n            self.pipfile_envs.add(env)\\n            for key, details in info[info_key].items():\\n                if isinstance(details, str_types):\\n                    if details != \\'*\\':\\n                        key = key + details  # details is a version requirement\\n                    req = CustomReq(key, env, source=\\'Pipfile\\')\\n                else:\\n                    # a dict\\n                    if \\'file\\' in details or \\'path\\' in details:\\n                        raise PundleException(\\'Unsupported Pipfile feature yet %s: %r\\' % (key, details))\\n                    if \\'git\\' in details:\\n                        # wow, this as a git package!\\n                        req = CustomReq(\\'git+%s#egg=%s\\' % (details[\\'git\\'], key), env, source=\\'Pipfile\\')\\n                    else:\\n                        # else just simple requirement\\n                        req = CustomReq(key + details[\\'version\\'], env, source=\\'Pipfile\\')\\n                if req.key in all_requirements:\\n                    # if requirements exists in other env, then add this env too\\n                    all_requirements[req.key].add_env(env)\\n                else:\\n                    all_requirements[req.key] = req\\n        return all_requirements\\n\\n    def parse_frozen(self):\\n        parsed_frozen = self.pipfile_lock_content()\\n        if parsed_frozen is None:\\n            return {}\\n        frozen_versions = {}\\n        for env in parsed_frozen:\\n            if env.startswith(\\'_\\'):\\n                # this is not an env\\n                continue\\n            for key, details in parsed_frozen[env].items():\\n                if \\'vcs\\' in details:\\n                    frozen_versions[key] = details[\\'vcs\\']\\n                else:\\n                    frozen_versions[key] = details.get(\\'version\\', \\'0.0.0\\').lstrip(\\'=\\')\\n        return frozen_versions\\n\\n    def parse_frozen_hashes(self):\\n        parsed_frozen = self.pipfile_lock_content()\\n        if parsed_frozen is None:\\n            return {}\\n        frozen_versions = {}\\n        for env in parsed_frozen:\\n            if env.startswith(\\'_\\'):\\n                # this is not an env\\n                continue\\n            for key, details in parsed_frozen[env].items():\\n                frozen_versions[key] = details.get(\\'hashes\\', [])\\n        return frozen_versions\\n\\n    def hash(self):\\n        \"\"\"Returns the SHA256 of the pipfile\\'s data.\\n        From pipfile.\\n        \"\"\"\\n        pipfile_content = self.pipfile_content()\\n        data = {\\n            \\'_meta\\': {\\n                \\'sources\\': pipfile_content.get(\\'sources\\') or self.DEFAULT_PIPFILE_SOURCES,\\n                \\'requires\\': pipfile_content.get(\\'requires\\') or {},\\n            },\\n            \\'default\\': pipfile_content.get(\\'packages\\') or {},\\n            \\'develop\\': pipfile_content.get(\\'dev-packages\\') or {},\\n        }\\n        content = json.dumps(data, sort_keys=True, separators=(\",\", \":\"))\\n        return hashlib.sha256(content.encode(\"utf8\")).hexdigest()\\n\\n    def save_frozen(self, states_by_env):\\n        \"\"\"Implementation is not complete.\\n        \"\"\"\\n        data = self.pipfile_lock_content() or {}\\n        data.setdefault(\\'_meta\\', {\\n            \\'pipfile-spec\\': 5,\\n            \\'requires\\': {},\\n            \\'sources\\': self.DEFAULT_PIPFILE_SOURCES,\\n        })\\n        data.setdefault(\\'_meta\\', {}).setdefault(\\'hash\\', {})[\\'sha256\\'] = self.hash()\\n        for env, states in states_by_env.items():\\n            if env == \\'\\':\\n                env_key = \\'default\\'\\n            elif env == \\'dev\\':\\n                env_key = \\'develop\\'\\n            else:\\n                env_key = env\\n            reqs = data.setdefault(env_key, {})\\n            for state in states:\\n                if state.requirement.egg:\\n                    egg, url, version = parse_vcs_requirement(state.requirement.line)\\n                    reqs[state.key] = {\\n                        \\'vcs\\': url,\\n                    }\\n                else:\\n                    reqs[state.key] = {\\n                        \\'version\\': \\'==\\' + state.frozen,\\n                        \\'hashes\\': state.hashes or [],\\n                    }\\n        with open(self.pipfile + \\'.lock\\', \\'w\\') as f:\\n            f.write(json.dumps(data, sort_keys=True, indent=4))\\n\\n\\ndef create_parser(**parser_args):\\n    \"\"\"Utility function that tried to figure out what Parser to use\\n    in current directory.\\n    \"\"\"\\n    if parser_args.get(\\'requirements_files\\'):\\n        return Parser(**parser_args)\\n    elif parser_args.get(\\'package\\'):\\n        return SetupParser(**parser_args)\\n    elif parser_args.get(\\'pipfile\\'):\\n        return PipfileParser(**parser_args)\\n    return SingleParser(**parser_args)\\n\\n\\n# Utilities\\ndef get_info_from_setup(path):\\n    \"\"\"Mock setuptools.setup(**kargs) to get\\n    package information about requirements and extras\\n    \"\"\"\\n    preserve = {}\\n\\n    def _save_info(**setup_args):\\n        preserve[\\'args\\'] = setup_args\\n\\n    import setuptools\\n    original_setup = setuptools.setup\\n    setuptools.setup = _save_info\\n    import runpy\\n    runpy.run_path(os.path.join(path, \\'setup.py\\'), run_name=\\'__main__\\')\\n    setuptools.setup = original_setup\\n    return preserve.get(\\'args\\')\\n\\n\\ndef search_files_upward(start_path=None):\\n    \"Search for requirements.txt, setup.py or Pipfile upward\"\\n    if not start_path:\\n        start_path = op.abspath(op.curdir)\\n    if any(\\n            op.exists(op.join(start_path, filename))\\n            for filename in (\\'requirements.txt\\', \\'setup.py\\', \\'Pipfile\\')\\n    ):\\n        return start_path\\n    up_path = op.abspath(op.join(start_path, \\'..\\'))\\n    if op.samefile(start_path, up_path):\\n        return None\\n    return search_files_upward(start_path=up_path)\\n\\n\\ndef find_all_prefixed_files(directory, prefix):\\n    \"find all requirements_*.txt files\"\\n    envs = {}\\n    for entry in os.listdir(directory):\\n        if not entry.startswith(prefix):\\n            continue\\n        name, ext = op.splitext(entry)\\n        env = name[len(prefix):].lstrip(\\'_\\')\\n        envs[env] = op.join(directory, entry)\\n    return envs\\n\\n\\ndef create_parser_parameters():\\n    base_path = search_files_upward()\\n    if not base_path:\\n        raise PundleException(\\'Can not find requirements.txt nor setup.py nor Pipfile\\')\\n    py_version_path = python_version_string()\\n    pundledir_base = os.environ.get(\\'PUNDLEDIR\\') or op.join(op.expanduser(\\'~\\'), \\'.pundledir\\')\\n    if op.exists(op.join(base_path, \\'requirements.txt\\')):\\n        requirements_files = find_all_prefixed_files(base_path, \\'requirements\\')\\n    else:\\n        requirements_files = {}\\n    envs = list(requirements_files.keys()) or [\\'\\']\\n    params = {\\n        \\'base_path\\': base_path,\\n        \\'frozen_files\\': {\\n            env: op.join(base_path, \\'frozen_%s.txt\\' % env if env else \\'frozen.txt\\')\\n            for env in envs\\n        },\\n        \\'directory\\': op.join(pundledir_base, py_version_path),\\n    }\\n    if requirements_files:\\n        params[\\'requirements_files\\'] = requirements_files\\n    elif op.exists(op.join(base_path, \\'setup.py\\')):\\n        params[\\'package\\'] = base_path\\n    elif op.exists(op.join(base_path, \\'Pipfile\\')):\\n        params[\\'pipfile\\'] = op.join(base_path, \\'Pipfile\\')\\n    else:\\n        return\\n    return params\\n\\n\\ndef create_parser_or_exit():\\n    parser_kw = create_parser_parameters()\\n    if not parser_kw:\\n        print_message(\\'You have not requirements.txt. Create it and run again.\\')\\n        exit(1)\\n    return parser_kw\\n\\n\\n# Commands\\ndef upgrade_all(**kw):\\n    key = kw.pop(\\'key\\')\\n    prereleases = kw.pop(\\'prereleases\\')\\n    suite = create_parser(**kw).create_suite()\\n    suite.need_freeze()\\n    suite.upgrade(key=key, prereleases=prereleases)\\n    suite.install()\\n    suite.save_frozen()\\n\\n\\ndef install_all(**kw):\\n    suite = create_parser(**kw).create_suite()\\n    if suite.need_freeze() or suite.need_install():\\n        print_message(\\'Install some packages\\')\\n        suite.install()\\n    else:\\n        print_message(\\'Nothing to do, all packages installed\\')\\n    suite.save_frozen()\\n    return suite\\n\\n\\ndef activate():\\n    parser_kw = create_parser_parameters()\\n    if not parser_kw:\\n        raise PundleException(\\'Can`t create parser parameters\\')\\n    suite = create_parser(**parser_kw).create_suite()\\n    if suite.need_freeze(verbose=True):\\n        raise PundleException(\\'frozen file is outdated\\')\\n    if suite.need_install():\\n        raise PundleException(\\'Some dependencies not installed\\')\\n    envs = (os.environ.get(\\'PUNDLEENV\\') or \\'\\').split(\\',\\')\\n    suite.activate_all(envs=envs)\\n    return suite\\n\\n\\nFIXATE_TEMPLATE = \"\"\"\\n# pundle user customization start\\nimport pundle; pundle.activate()\\n# pundle user customization end\\n\"\"\"\\n\\n\\ndef fixate():\\n    \"puts activation code to usercustomize.py for user\"\\n    print_message(\\'Fixate\\')\\n    import site\\n    userdir = site.getusersitepackages()\\n    if not userdir:\\n        raise PundleException(\\'Can`t fixate due user have not site package directory\\')\\n    try:\\n        makedirs(userdir)\\n    except OSError:\\n        pass\\n    template = FIXATE_TEMPLATE.replace(\\'op.dirname(__file__)\\', \"\\'%s\\'\" % op.abspath(op.dirname(__file__)))\\n    usercustomize_file = op.join(userdir, \\'usercustomize.py\\')\\n    print_message(\\'Will edit %s file\\' % usercustomize_file)\\n    if op.exists(usercustomize_file):\\n        content = open(usercustomize_file).read()\\n        if \\'# pundle user customization start\\' in content:\\n            regex = re.compile(r\\'\\\\n# pundle user customization start.*# pundle user customization end\\\\n\\', re.DOTALL)\\n            content, res = regex.subn(template, content)\\n            open(usercustomize_file, \\'w\\').write(content)\\n        else:\\n            open(usercustomize_file, \\'a\\').write(content)\\n    else:\\n        open(usercustomize_file, \\'w\\').write(template)\\n    link_file = op.join(userdir, \\'pundle.py\\')\\n    if op.lexists(link_file):\\n        print_message(\\'Remove exist link to pundle\\')\\n        os.unlink(link_file)\\n    print_message(\\'Create link to pundle %s\\' % link_file)\\n    os.symlink(op.abspath(__file__), link_file)\\n    print_message(\\'Complete\\')\\n\\n\\ndef entry_points():\\n    suite = activate()\\n    entries = {}\\n    for r in suite.states.values():\\n        d = r.frozen_dist()\\n        if not d:\\n            continue\\n        if isinstance(d, VCSDist):\\n            continue\\n        scripts = d.get_entry_map().get(\\'console_scripts\\', {})\\n        for name in scripts:\\n            entries[name] = d\\n    return entries\\n\\n\\nclass CmdRegister:\\n    commands = {}\\n    ordered = []\\n\\n    @classmethod\\n    def cmdline(cls, *cmd_aliases):\\n        def wrap(func):\\n            for alias in cmd_aliases:\\n                cls.commands[alias] = func\\n                cls.ordered.append(alias)\\n        return wrap\\n\\n    @classmethod\\n    def help(cls):\\n        for alias in cls.ordered:\\n            if not alias:\\n                continue\\n            print(\"{:15s} {}\".format(alias, cls.commands[alias].__doc__))\\n\\n    @classmethod\\n    def main(cls):\\n        alias = \\'\\' if len(sys.argv) == 1 else sys.argv[1]\\n        if alias == \\'help\\':\\n            cls.help()\\n            return\\n        if alias not in cls.commands:\\n            print(\\'Unknown command\\\\nTry this:\\')\\n            cls.help()\\n            sys.exit(1)\\n        cls.commands[alias]()\\n\\n\\n@CmdRegister.cmdline(\\'\\', \\'install\\')\\ndef cmd_install():\\n    \"Install packages by frozen.txt and resolve ones that was not frozen\"\\n    install_all(**create_parser_or_exit())\\n\\n\\n@CmdRegister.cmdline(\\'upgrade\\')\\ndef cmd_upgrade():\\n    \"\"\"\\n    [package [pre]] if package provided will upgrade it and dependencies or all packages from PyPI.\\n    If `pre` provided will look for prereleases.\\n    \"\"\"\\n    key = sys.argv[2] if len(sys.argv) > 2 else None\\n    prereleases = sys.argv[3] == \\'pre\\' if len(sys.argv) > 3 else False\\n    upgrade_all(key=key, prereleases=prereleases, **create_parser_or_exit())\\n\\n\\nCmdRegister.cmdline(\\'fixate\\')(fixate)\\n\\n\\n@CmdRegister.cmdline(\\'exec\\')\\ndef cmd_exec():\\n    \"executes setuptools entry\"\\n    cmd = sys.argv[2]\\n    args = sys.argv[3:]\\n    entries = entry_points()\\n    if cmd not in entries:\\n        print_message(\\'Script is not found. Check if package is installed, or look at the `pundle entry_points`\\')\\n        sys.exit(1)\\n    exc = entries[cmd].get_entry_info(\\'console_scripts\\', cmd).load()\\n    sys.path.insert(0, \\'\\')\\n    sys.argv = [cmd] + args\\n    exc()\\n\\n\\n@CmdRegister.cmdline(\\'entry_points\\')\\ndef cmd_entry_points():\\n    \"prints available setuptools entries\"\\n    for entry, package in entry_points().items():\\n        print(\\'%s (%s)\\' % (entry, package))\\n\\n\\n@CmdRegister.cmdline(\\'edit\\')\\ndef cmd_edit():\\n    \"prints directory path to package\"\\n    parser_kw = create_parser_parameters()\\n    suite = create_parser(**parser_kw).create_suite()\\n    if suite.need_freeze():\\n        raise PundleException(\\'%s file is outdated\\' % suite.parser.frozen_file)\\n    print(suite.states[sys.argv[2]].frozen_dist().location)\\n\\n\\n@CmdRegister.cmdline(\\'info\\')\\ndef cmd_info():\\n    \"prints info about Pundle state\"\\n    parser_kw = create_parser_parameters()\\n    suite = create_parser(**parser_kw).create_suite()\\n    if suite.need_freeze():\\n        print(\\'frozen.txt is outdated\\')\\n    else:\\n        print(\\'frozen.txt is up to date\\')\\n    for state in suite.required_states():\\n        print(\\n            \\'Requirement \"{}\", frozen {}, {}\\'.format(\\n                state.key,\\n                state.frozen,\\n                state.requirement.line if state.requirement else \\'None\\'\\n            )\\n        )\\n        print(\\'Installed versions:\\')\\n        for dist in state.installed:\\n            print(\\'    \\', repr(dist))\\n        if not state.installed:\\n            print(\\'     None\\')\\n\\n\\ndef run_console(glob):\\n    import readline\\n    import rlcompleter\\n    import atexit\\n    import code\\n\\n    history_path = os.path.expanduser(\"~/.python_history\")\\n\\n    def save_history(history_path=history_path):\\n        readline.write_history_file(history_path)\\n    if os.path.exists(history_path):\\n        readline.read_history_file(history_path)\\n\\n    atexit.register(save_history)\\n\\n    readline.set_completer(rlcompleter.Completer(glob).complete)\\n    readline.parse_and_bind(\"tab: complete\")\\n    code.InteractiveConsole(locals=glob).interact()\\n\\n\\n@CmdRegister.cmdline(\\'console\\')\\ndef cmd_console():\\n    \"[ipython|bpython|ptpython] starts python console with activated pundle environment\"\\n    suite = activate()\\n    glob = {\\n        \\'pundle_suite\\': suite,\\n    }\\n    interpreter = sys.argv[2] if len(sys.argv) > 2 else None\\n    if not interpreter:\\n        run_console(glob)\\n    elif interpreter == \\'ipython\\':\\n        from IPython import embed\\n        embed()\\n    elif interpreter == \\'ptpython\\':\\n        from ptpython.repl import embed\\n        embed(glob, {})\\n    elif interpreter == \\'bpython\\':\\n        from bpython import embed\\n        embed(glob)\\n    else:\\n        raise PundleException(\\'Unknown interpreter: {}. Choose one of None, ipython, bpython, ptpython.\\')\\n\\n\\n@CmdRegister.cmdline(\\'run\\')\\ndef cmd_run():\\n    \"executes given script\"\\n    activate()\\n    import runpy\\n    sys.path.insert(0, \\'\\')\\n    script = sys.argv[2]\\n    sys.argv = [sys.argv[2]] + sys.argv[3:]\\n    runpy.run_path(script, run_name=\\'__main__\\')\\n\\n\\n@CmdRegister.cmdline(\\'module\\')\\ndef cmd_module():\\n    \"executes module like `python -m`\"\\n    activate()\\n    import runpy\\n    sys.path.insert(0, \\'\\')\\n    module = sys.argv[2]\\n    sys.argv = [sys.argv[2]] + sys.argv[3:]\\n    runpy.run_module(module, run_name=\\'__main__\\')\\n\\n\\n@CmdRegister.cmdline(\\'env\\')\\ndef cmd_env():\\n    \"populates PYTHONPATH with packages paths and executes command line in subprocess\"\\n    activate()\\n    aug_env = os.environ.copy()\\n    aug_env[\\'PYTHONPATH\\'] = \\':\\'.join(sys.path)\\n    subprocess.call(sys.argv[2:], env=aug_env)\\n\\n\\n@CmdRegister.cmdline(\\'print_env\\')\\ndef cmd_print_env():\\n    \"Prints PYTHONPATH. For usage with mypy and MYPYPATH\"\\n    suite = activate()\\n    path = \\':\\'.join(\\n        state.frozen_dist().location\\n        for state in suite.states.values()\\n        if state.frozen_dist()\\n    )\\n    print(path)\\n\\n\\nENTRY_POINT_TEMPLATE = \\'\\'\\'#! /usr/bin/env python\\nimport pundle; pundle.activate()\\npundle.entry_points()[\\'{entry_point}\\'].get_entry_info(\\'console_scripts\\', \\'{entry_point}\\').load(require=False)()\\n\\'\\'\\'\\n\\n\\n@CmdRegister.cmdline(\\'linkall\\')\\ndef link_all():\\n    \"links all packages to `.pundle_local` dir\"\\n    local_dir = \\'.pundle_local\\'\\n    suite = activate()\\n\\n    try:\\n        makedirs(local_dir)\\n    except OSError:\\n        pass\\n    local_dir_info = {de.name: de for de in os.scandir(local_dir)}\\n    for r in suite.states.values():\\n        d = r.frozen_dist()\\n        if not d:\\n            continue\\n        for dir_entry in os.scandir(d.location):\\n            if dir_entry.name.startswith(\\'__\\') or dir_entry.name.startswith(\\'.\\') or dir_entry.name == \\'bin\\':\\n                continue\\n            dest_path = os.path.join(local_dir, dir_entry.name)\\n            if dir_entry.name in local_dir_info:\\n                sym = local_dir_info.pop(dir_entry.name)\\n                existed = op.realpath(sym.path)\\n                if existed == dir_entry.path:\\n                    continue\\n                os.remove(sym.path)\\n            os.symlink(dir_entry.path, dest_path)\\n    # create entry_points binaries\\n    try:\\n        makedirs(os.path.join(local_dir, \\'bin\\'))\\n    except OSError:\\n        pass\\n    for bin_name, entry_point in entry_points().items():\\n        bin_filename = os.path.join(local_dir, \\'bin\\', bin_name)\\n        open(bin_filename, \\'w\\').write(ENTRY_POINT_TEMPLATE.format(entry_point=bin_name))\\n        file_stat = os.stat(bin_filename)\\n        os.chmod(bin_filename, file_stat.st_mode | stat.S_IEXEC)\\n    local_dir_info.pop(\\'bin\\')\\n\\n    # remove extra links\\n    for de in local_dir_info:\\n        os.remove(de.path)\\n\\n\\n@CmdRegister.cmdline(\\'show_requirements\\')\\ndef show_requirements():\\n    \"shows details requirements info\"\\n    suite = activate()\\n    for name, state in suite.states.items():\\n        if state.requirement:\\n            print(\\n                name,\\n                \\'frozen:\\',\\n                state.frozen,\\n                \\'required:\\',\\n                state.requirement.req if state.requirement.req else \\'VCS\\',\\n                state.requirement.envs,\\n            )\\n\\n\\n# Single mode that you can use in console\\n_single_mode_suite = {}  # cache variable to keep current suite for single_mode\\n\\n\\ndef single_mode():\\n    \"\"\" Create, cache and return Suite instance for single_mode.\\n    \"\"\"\\n    if not _single_mode_suite:\\n        py_version_path = python_version_string()\\n        pundledir_base = os.environ.get(\\'PUNDLEDIR\\') or op.join(op.expanduser(\\'~\\'), \\'.pundledir\\')\\n        directory = op.join(pundledir_base, py_version_path)\\n        _single_mode_suite[\\'cache\\'] = create_parser(directory=directory).create_suite()\\n    return _single_mode_suite[\\'cache\\']\\n\\n\\ndef use(key):\\n    \"\"\" Installs `key` requirement, like `django==1.11` or just `django`\\n    \"\"\"\\n    suite = single_mode()\\n    suite.use(key)\\n\\n\\nif __name__ == \\'__main__\\':\\n    CmdRegister.main()\\n'"}]}, "normalize_mark_list": {"line": 355, "args": [{"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}], "text": "def normalize_mark_list(mark_list: Iterable[Union[Mark, MarkDecorator]]) -> List[Mark]:\n    \"\"\"Normalize marker decorating helpers to mark objects.\n\n    :type List[Union[Mark, Markdecorator]] mark_list:\n    :rtype: List[Mark]\n    \"\"\"\n    extracted = [\n        getattr(mark, \"mark\", mark) for mark in mark_list\n    ]  # unpack MarkDecorator\n    for mark in extracted:\n        if not isinstance(mark, Mark):\n            raise TypeError(f\"got {mark!r} instead of Mark\")\n    return [x for x in extracted if isinstance(x, Mark)]"}, "iterparentnodeids": {"line": 44, "args": [{"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "'tests/test_install.py'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "'tests/test_install.py::test_need_freeze'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "'tests/test_install.py'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "'tests/test_install.py::test_need_freeze'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "'tests/test_install.py'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "'tests/test_install.py::test_need_freeze'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_need_freeze'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "'tests/test_install.py'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "'tests/test_install.py::test_frozen'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "'tests/test_install.py'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "'tests/test_install.py::test_frozen'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "'tests/test_install.py'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "'tests/test_install.py::test_frozen'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_frozen'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "'tests/test_install.py'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "'tests/test_install.py::test_vcs'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "'tests/test_install.py'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "'tests/test_install.py::test_vcs'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "'tests/test_install.py'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "'tests/test_install.py::test_vcs'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "'tests/test_install.py'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "'tests/test_install.py::test_vcs_frozen'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "'tests/test_install.py'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "'tests/test_install.py::test_vcs_frozen'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "'tests/test_install.py'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "'tests/test_install.py::test_vcs_frozen'"}, {"func_args": {"nodeid": "'tests/test_install.py::test_vcs_frozen'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "'tests/test_pipfile.py'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "'tests/test_pipfile.py::test_parse_pipfile'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "'tests/test_pipfile.py'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "'tests/test_pipfile.py::test_parse_pipfile'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "'tests/test_pipfile.py'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "'tests/test_pipfile.py::test_parse_pipfile'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "'tests/test_pipfile.py'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "'tests/test_pipfile.py'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "'tests/test_pipfile.py'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_parse_pipfile_no_lock'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "'tests/test_pipfile.py'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "'tests/test_pipfile.py'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "'tests/test_pipfile.py'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, {"func_args": {"nodeid": "'tests/test_pipfile.py::test_save_pipfile_lock'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "'tests/test_setup_py.py'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "'tests/test_setup_py.py'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "'tests/test_setup_py.py'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_need_freeze'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "'tests/test_setup_py.py'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "'tests/test_setup_py.py'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "'tests/test_setup_py.py'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, {"func_args": {"nodeid": "'tests/test_setup_py.py::test_parse_setup_frozen'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "'tests/test_simple.py'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "'tests/test_simple.py::test_pypy_python_version'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "'tests/test_simple.py'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "'tests/test_simple.py::test_pypy_python_version'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "'tests/test_simple.py'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "'tests/test_simple.py::test_pypy_python_version'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_pypy_python_version'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "'tests/test_simple.py'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "'tests/test_simple.py::test_cpython_python_version'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "'tests/test_simple.py'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "'tests/test_simple.py::test_cpython_python_version'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "'tests/test_simple.py'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "'tests/test_simple.py::test_cpython_python_version'"}, {"func_args": {"nodeid": "'tests/test_simple.py::test_cpython_python_version'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_vcs_requirements.py::test_parse_vcs_requirement'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_vcs_requirements.py::test_parse_vcs_requirement'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_vcs_requirements.py::test_parse_vcs_requirement'"}, "return_value": "'tests/test_vcs_requirements.py'"}, {"func_args": {"nodeid": "'tests/test_vcs_requirements.py::test_parse_vcs_requirement'"}, "return_value": "'tests/test_vcs_requirements.py::test_parse_vcs_requirement'"}, {"func_args": {"nodeid": "'tests/test_vcs_requirements.py::test_parse_vcs_requirement'"}, "return_value": "None"}], "text": "def iterparentnodeids(nodeid: str) -> Iterator[str]:\n    \"\"\"Return the parent node IDs of a given node ID, inclusive.\n\n    For the node ID\n\n        \"testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source\"\n\n    the result would be\n\n        \"\"\n        \"testing\"\n        \"testing/code\"\n        \"testing/code/test_excinfo.py\"\n        \"testing/code/test_excinfo.py::TestFormattedExcinfo\"\n        \"testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source\"\n\n    Note that :: parts are only considered at the last / component.\n    \"\"\"\n    pos = 0\n    sep = SEP\n    yield \"\"\n    while True:\n        at = nodeid.find(sep, pos)\n        if at == -1 and sep == SEP:\n            sep = \"::\"\n        elif at == -1:\n            if nodeid:\n                yield nodeid\n            break\n        else:\n            if at:\n                yield nodeid[:at]\n            pos = at + len(sep)"}, "parse_ini_boolean": {"line": 28, "args": [{"func_args": {"value": "True"}, "return_value": "True"}, {"func_args": {"value": "False"}, "return_value": "False"}], "text": "def parse_ini_boolean(value: Union[bool, str]) -> bool:\n    if isinstance(value, bool):\n        return value\n    if value.lower() == \"true\":\n        return True\n    if value.lower() == \"false\":\n        return False\n    raise ValueError(\"unknown string for bool: %r\" % value)"}, "wcswidth": {"line": 43, "args": [{"func_args": {"s": "''"}, "return_value": "0"}], "text": "def wcswidth(s: str) -> int:\n    \"\"\"Determine how many columns are needed to display a string in a terminal.\n\n    Returns -1 if the string contains non-printable characters.\n    \"\"\"\n    width = 0\n    for c in unicodedata.normalize(\"NFC\", s):\n        wc = wcwidth(c)\n        if wc < 0:\n            return -1\n        width += wc\n    return width"}, "parse_file": {"line": 1, "args": [{"func_args": {"filename": "'requirements.txt'"}, "return_value": "['trafaret']"}, {"func_args": {"filename": "'frozen.txt'"}, "return_value": "[]"}, {"func_args": {"filename": "'requirements.txt'"}, "return_value": "['trafaret']"}, {"func_args": {"filename": "'frozen.txt'"}, "return_value": "['trafaret==0.1']"}, {"func_args": {"filename": "'requirements.txt'"}, "return_value": "['git+https://github.com/karanlyons/django-save-the-change@e48502d2568d76bd9c7093f4c002a5b0061bc468#egg=django-save-the-change']"}, {"func_args": {"filename": "'frozen.txt'"}, "return_value": "[]"}, {"func_args": {"filename": "'requirements.txt'"}, "return_value": "['git+https://github.com/karanlyons/django-save-the-change@e48502d2568d76bd9c7093f4c002a5b0061bc468#egg=django-save-the-change']"}, {"func_args": {"filename": "'frozen.txt'"}, "return_value": "['git+https://github.com/karanlyons/django-save-the-change@e48502d2568d76bd9c7093f4c002a5b0061bc468#egg=django-save-the-change']"}, {"func_args": {"filename": "'frozen.txt'"}, "return_value": "[]"}, {"func_args": {"filename": "'./frozen_objectid.txt'"}, "return_value": "[]"}, {"func_args": {"filename": "'frozen.txt'"}, "return_value": "['trafaret==0.1.1']"}, {"func_args": {"filename": "'./frozen_objectid.txt'"}, "return_value": "['mongodb==0.1.0']"}], "text": "def parse_file(filename):\n        print('Parse', filename)\n        return files[filename]"}, "test_vcs": {"line": 119, "args": [{"func_args": {"req": "'trafaret'"}, "return_value": "False"}, {"func_args": {"req": "'trafaret'"}, "return_value": "False"}, {"func_args": {"req": "'git+https://github.com/karanlyons/django-save-the-change@e48502d2568d76bd9c7093f4c002a5b0061bc468#egg=django-save-the-change'"}, "return_value": "True"}, {"func_args": {"req": "'git+https://github.com/karanlyons/django-save-the-change@e48502d2568d76bd9c7093f4c002a5b0061bc468#egg=django-save-the-change'"}, "return_value": "True"}, {"func_args": {"req": "'requests'"}, "return_value": "False"}, {"func_args": {"req": "'pytest'"}, "return_value": "False"}, {"func_args": {"req": "'requests'"}, "return_value": "False"}, {"func_args": {"req": "'pytest'"}, "return_value": "False"}, {"func_args": {"req": "'requests'"}, "return_value": "False"}, {"func_args": {"req": "'pytest'"}, "return_value": "False"}, {"func_args": {"req": "'trafaret'"}, "return_value": "False"}, {"func_args": {"req": "'mongodb'"}, "return_value": "False"}, {"func_args": {"req": "'trafaret'"}, "return_value": "False"}, {"func_args": {"req": "'mongodb'"}, "return_value": "False"}], "text": "def test_vcs(req):\n    \"\"\"Checks if requirement line is for VCS.\n    \"\"\"\n    return '+' in req and req.index('+') == 3"}, "parse_vcs_requirement": {"line": 125, "args": [{"func_args": {"req": "'trafaret==0.1'"}, "return_value": "None"}, {"func_args": {"req": "'git+https://github.com/karanlyons/django-save-the-change@e48502d2568d76bd9c7093f4c002a5b0061bc468#egg=django-save-the-change'"}, "return_value": "('django-save-the-change', 'git+https://github.com/karanlyons/django-save-the-change@e48502d2568d76bd9c7093f4c002a5b0061bc468#egg=django-save-the-change', None)"}, {"func_args": {"req": "'git+https://github.com/karanlyons/django-save-the-change@e48502d2568d76bd9c7093f4c002a5b0061bc468#egg=django-save-the-change'"}, "return_value": "('django-save-the-change', 'git+https://github.com/karanlyons/django-save-the-change@e48502d2568d76bd9c7093f4c002a5b0061bc468#egg=django-save-the-change', None)"}, {"func_args": {"req": "'git+https://github.com/karanlyons/django-save-the-change@e48502d2568d76bd9c7093f4c002a5b0061bc468#egg=django-save-the-change'"}, "return_value": "('django-save-the-change', 'git+https://github.com/karanlyons/django-save-the-change@e48502d2568d76bd9c7093f4c002a5b0061bc468#egg=django-save-the-change', None)"}, {"func_args": {"req": "'trafaret==0.1.1'"}, "return_value": "None"}, {"func_args": {"req": "'mongodb==0.1.0'"}, "return_value": "None"}, {"func_args": {"req": "'git+https://github.com/pampam/PKG.git@master#egg=PKG'"}, "return_value": "('pkg', 'git+https://github.com/pampam/PKG.git@master#egg=PKG', None)"}], "text": "def parse_vcs_requirement(req):\n    \"\"\"Parses VCS line to egg name, version etc.\n    \"\"\"\n    if '+' not in req:\n        return None\n    vcs, url = req.split('+', 1)\n    if vcs not in ('git', 'svn', 'hg'):\n        return None\n    parsed_url = urlparse(url)\n    parsed = dict(parse_qsl(parsed_url.fragment))\n    if 'egg' not in parsed:\n        return None\n    egg = parsed['egg'].rsplit('-', 1)\n    if len(egg) > 1:\n        try:\n            pkg_resources_parse_version(egg[1])\n        except pkg_resources._vendor.packaging.version.InvalidVersion:\n            return parsed['egg'].lower(), req, None\n        return egg[0].lower(), req, egg[1]\n    else:\n        return parsed['egg'].lower(), req, None"}, "parse_frozen_vcs": {"line": 148, "args": [{"func_args": {"req": "'trafaret==0.1'"}, "return_value": "None"}, {"func_args": {"req": "'git+https://github.com/karanlyons/django-save-the-change@e48502d2568d76bd9c7093f4c002a5b0061bc468#egg=django-save-the-change'"}, "return_value": "('django-save-the-change', 'git+https://github.com/karanlyons/django-save-the-change@e48502d2568d76bd9c7093f4c002a5b0061bc468#egg=django-save-the-change')"}, {"func_args": {"req": "'trafaret==0.1.1'"}, "return_value": "None"}, {"func_args": {"req": "'mongodb==0.1.0'"}, "return_value": "None"}], "text": "def parse_frozen_vcs(req):\n    res = parse_vcs_requirement(req)\n    if not res:\n        return\n    return res[0], res[1]"}, "python_version_string": {"line": 85, "args": [{"func_args": {}, "return_value": "'PyPy-1.2.3-build1'"}, {"func_args": {}, "return_value": "'CPython-1.2.3-build1'"}], "text": "def python_version_string():\n    \"\"\"We use it to generate per python folder name, where\n    we will install all packages.\n    \"\"\"\n    if platform.python_implementation() == 'PyPy':\n        version_info = sys.pypy_version_info\n    else:\n        version_info = sys.version_info\n    version_string = '{v.major}.{v.minor}.{v.micro}'.format(v=version_info)\n    build, _ = platform.python_build()\n    build = build.replace(':', '_')  # windows do not understand `:` in path\n    return '{}-{}-{}'.format(platform.python_implementation(), version_string, build)"}, "_nonblank": {"line": 2398, "args": [{"func_args": {"str": "'trafaret'"}, "return_value": "True"}, {"func_args": {"str": "'trafaret'"}, "return_value": "True"}, {"func_args": {"str": "'requests'"}, "return_value": "True"}, {"func_args": {"str": "'pytest'"}, "return_value": "True"}, {"func_args": {"str": "'requests'"}, "return_value": "True"}, {"func_args": {"str": "'pytest'"}, "return_value": "True"}, {"func_args": {"str": "'requests'"}, "return_value": "True"}, {"func_args": {"str": "'pytest'"}, "return_value": "True"}, {"func_args": {"str": "'trafaret'"}, "return_value": "True"}, {"func_args": {"str": "'mongodb'"}, "return_value": "True"}, {"func_args": {"str": "'trafaret'"}, "return_value": "True"}, {"func_args": {"str": "'mongodb'"}, "return_value": "True"}], "text": "def _nonblank(str):\n    return str and not str.startswith('#')"}, "safe_name": {"line": 1308, "args": [{"func_args": {"name": "'trafaret'"}, "return_value": "'trafaret'"}, {"func_args": {"name": "'trafaret'"}, "return_value": "'trafaret'"}, {"func_args": {"name": "'requests'"}, "return_value": "'requests'"}, {"func_args": {"name": "'pytest'"}, "return_value": "'pytest'"}, {"func_args": {"name": "'requests'"}, "return_value": "'requests'"}, {"func_args": {"name": "'pytest'"}, "return_value": "'pytest'"}, {"func_args": {"name": "'requests'"}, "return_value": "'requests'"}, {"func_args": {"name": "'pytest'"}, "return_value": "'pytest'"}, {"func_args": {"name": "'trafaret'"}, "return_value": "'trafaret'"}, {"func_args": {"name": "'mongodb'"}, "return_value": "'mongodb'"}, {"func_args": {"name": "'trafaret'"}, "return_value": "'trafaret'"}, {"func_args": {"name": "'mongodb'"}, "return_value": "'mongodb'"}], "text": "def safe_name(name):\n    \"\"\"Convert an arbitrary string to a standard distribution name\n\n    Any runs of non-alphanumeric/. characters are replaced with a single '-'.\n    \"\"\"\n    return re.sub('[^A-Za-z0-9.]+', '-', name)"}, "wrapper": {"line": 1068, "args": [{"func_args": {"args": "('trafaret', 8, ([], {}))"}, "return_value": "8"}, {"func_args": {"args": "('trafaret', 8, ([], {}))"}, "return_value": "''"}, {"func_args": {"args": "('trafaret', 8, ([], {}))"}, "return_value": "8"}, {"func_args": {"args": "('trafaret', 8, ([8, '', 8], {'_original_start': [8], '_original_end': [8], 'specifier': [([8, '', 8], {'_original_start': [8], '_original_end': [8]})]}))"}, "return_value": "''"}, {"func_args": {"args": "('trafaret', 8, ([], {}))"}, "return_value": "8"}, {"func_args": {"args": "('trafaret', 8, ([], {}))"}, "return_value": "''"}, {"func_args": {"args": "('trafaret', 8, ([], {}))"}, "return_value": "8"}, {"func_args": {"args": "('trafaret', 8, ([8, '', 8], {'_original_start': [8], '_original_end': [8], 'specifier': [([8, '', 8], {'_original_start': [8], '_original_end': [8]})]}))"}, "return_value": "''"}, {"func_args": {"args": "('requests', 8, ([], {}))"}, "return_value": "8"}, {"func_args": {"args": "('requests', 8, ([], {}))"}, "return_value": "''"}, {"func_args": {"args": "('requests', 8, ([], {}))"}, "return_value": "8"}, {"func_args": {"args": "('requests', 8, ([8, '', 8], {'_original_start': [8], '_original_end': [8], 'specifier': [([8, '', 8], {'_original_start': [8], '_original_end': [8]})]}))"}, "return_value": "''"}, {"func_args": {"args": "('pytest', 6, ([], {}))"}, "return_value": "6"}, {"func_args": {"args": "('pytest', 6, ([], {}))"}, "return_value": "''"}, {"func_args": {"args": "('pytest', 6, ([], {}))"}, "return_value": "6"}, {"func_args": {"args": "('pytest', 6, ([6, '', 6], {'_original_start': [6], '_original_end': [6], 'specifier': [([6, '', 6], {'_original_start': [6], '_original_end': [6]})]}))"}, "return_value": "''"}, {"func_args": {"args": "('requests', 8, ([], {}))"}, "return_value": "8"}, {"func_args": {"args": "('requests', 8, ([], {}))"}, "return_value": "''"}, {"func_args": {"args": "('requests', 8, ([], {}))"}, "return_value": "8"}, {"func_args": {"args": "('requests', 8, ([8, '', 8], {'_original_start': [8], '_original_end': [8], 'specifier': [([8, '', 8], {'_original_start': [8], '_original_end': [8]})]}))"}, "return_value": "''"}, {"func_args": {"args": "('pytest', 6, ([], {}))"}, "return_value": "6"}, {"func_args": {"args": "('pytest', 6, ([], {}))"}, "return_value": "''"}, {"func_args": {"args": "('pytest', 6, ([], {}))"}, "return_value": "6"}, {"func_args": {"args": "('pytest', 6, ([6, '', 6], {'_original_start': [6], '_original_end': [6], 'specifier': [([6, '', 6], {'_original_start': [6], '_original_end': [6]})]}))"}, "return_value": "''"}, {"func_args": {"args": "('requests', 8, ([], {}))"}, "return_value": "8"}, {"func_args": {"args": "('requests', 8, ([], {}))"}, "return_value": "''"}, {"func_args": {"args": "('requests', 8, ([], {}))"}, "return_value": "8"}, {"func_args": {"args": "('requests', 8, ([8, '', 8], {'_original_start': [8], '_original_end': [8], 'specifier': [([8, '', 8], {'_original_start': [8], '_original_end': [8]})]}))"}, "return_value": "''"}, {"func_args": {"args": "('pytest', 6, ([], {}))"}, "return_value": "6"}, {"func_args": {"args": "('pytest', 6, ([], {}))"}, "return_value": "''"}, {"func_args": {"args": "('pytest', 6, ([], {}))"}, "return_value": "6"}, {"func_args": {"args": "('pytest', 6, ([6, '', 6], {'_original_start': [6], '_original_end': [6], 'specifier': [([6, '', 6], {'_original_start': [6], '_original_end': [6]})]}))"}, "return_value": "''"}, {"func_args": {"args": "('trafaret', 8, ([], {}))"}, "return_value": "8"}, {"func_args": {"args": "('trafaret', 8, ([], {}))"}, "return_value": "''"}, {"func_args": {"args": "('trafaret', 8, ([], {}))"}, "return_value": "8"}, {"func_args": {"args": "('trafaret', 8, ([8, '', 8], {'_original_start': [8], '_original_end': [8], 'specifier': [([8, '', 8], {'_original_start': [8], '_original_end': [8]})]}))"}, "return_value": "''"}, {"func_args": {"args": "('mongodb', 7, ([], {}))"}, "return_value": "7"}, {"func_args": {"args": "('mongodb', 7, ([], {}))"}, "return_value": "''"}, {"func_args": {"args": "('mongodb', 7, ([], {}))"}, "return_value": "7"}, {"func_args": {"args": "('mongodb', 7, ([7, '', 7], {'_original_start': [7], '_original_end': [7], 'specifier': [([7, '', 7], {'_original_start': [7], '_original_end': [7]})]}))"}, "return_value": "''"}, {"func_args": {"args": "('trafaret', 8, ([], {}))"}, "return_value": "8"}, {"func_args": {"args": "('trafaret', 8, ([], {}))"}, "return_value": "''"}, {"func_args": {"args": "('trafaret', 8, ([], {}))"}, "return_value": "8"}, {"func_args": {"args": "('trafaret', 8, ([8, '', 8], {'_original_start': [8], '_original_end': [8], 'specifier': [([8, '', 8], {'_original_start': [8], '_original_end': [8]})]}))"}, "return_value": "''"}, {"func_args": {"args": "('mongodb', 7, ([], {}))"}, "return_value": "7"}, {"func_args": {"args": "('mongodb', 7, ([], {}))"}, "return_value": "''"}, {"func_args": {"args": "('mongodb', 7, ([], {}))"}, "return_value": "7"}, {"func_args": {"args": "('mongodb', 7, ([7, '', 7], {'_original_start': [7], '_original_end': [7], 'specifier': [([7, '', 7], {'_original_start': [7], '_original_end': [7]})]}))"}, "return_value": "''"}], "text": "def wrapper(*args):\r\n        while 1:\r\n            try:\r\n                ret = func(*args[limit[0]:])\r\n                foundArity[0] = True\r\n                return ret\r\n            except TypeError:\r\n                # re-raise TypeErrors if they did not come from our arity testing\r\n                if foundArity[0]:\r\n                    raise\r\n                else:\r\n                    try:\r\n                        tb = sys.exc_info()[-1]\r\n                        if not extract_tb(tb, limit=2)[-1][:2] == pa_call_line_synth:\r\n                            raise\r\n                    finally:\r\n                        del tb\r\n\r\n                if limit[0] <= maxargs:\r\n                    limit[0] += 1\r\n                    continue\r\n                raise"}, "ensure_slash": {"line": 803, "args": [{"func_args": {"s": "'https://pypi.python.org/simple/'"}, "return_value": "'https://pypi.python.org/simple/'"}, {"func_args": {"s": "'https://pypi.python.org/simple/'"}, "return_value": "'https://pypi.python.org/simple/'"}, {"func_args": {"s": "'https://pypi.python.org/simple/'"}, "return_value": "'https://pypi.python.org/simple/'"}, {"func_args": {"s": "'https://pypi.python.org/simple/'"}, "return_value": "'https://pypi.python.org/simple/'"}, {"func_args": {"s": "'https://pypi.python.org/simple/'"}, "return_value": "'https://pypi.python.org/simple/'"}, {"func_args": {"s": "'https://pypi.python.org/simple/'"}, "return_value": "'https://pypi.python.org/simple/'"}, {"func_args": {"s": "'https://pypi.python.org/simple/'"}, "return_value": "'https://pypi.python.org/simple/'"}, {"func_args": {"s": "'https://pypi.python.org/simple/'"}, "return_value": "'https://pypi.python.org/simple/'"}, {"func_args": {"s": "'https://pypi.python.org/simple/'"}, "return_value": "'https://pypi.python.org/simple/'"}], "text": "def ensure_slash(s):\n    if not s.endswith('/'):\n        return s + '/'\n    return s"}, "_strictly_valid_num": {"line": 89, "args": [{"func_args": {"n": "' \"https://pypi.python.org/simple\"'"}, "return_value": "True"}, {"func_args": {"n": "' true'"}, "return_value": "True"}, {"func_args": {"n": "' \"pypi\"'"}, "return_value": "True"}, {"func_args": {"n": "' \"*\"'"}, "return_value": "True"}, {"func_args": {"n": "' \"*\"'"}, "return_value": "True"}, {"func_args": {"n": "' \"https://pypi.python.org/simple\"'"}, "return_value": "True"}, {"func_args": {"n": "' true'"}, "return_value": "True"}, {"func_args": {"n": "' \"pypi\"'"}, "return_value": "True"}, {"func_args": {"n": "' \"*\"'"}, "return_value": "True"}, {"func_args": {"n": "' \"*\"'"}, "return_value": "True"}, {"func_args": {"n": "' \"https://pypi.python.org/simple\"'"}, "return_value": "True"}, {"func_args": {"n": "' true'"}, "return_value": "True"}, {"func_args": {"n": "' \"pypi\"'"}, "return_value": "True"}, {"func_args": {"n": "' \"*\"'"}, "return_value": "True"}, {"func_args": {"n": "' \"*\"'"}, "return_value": "True"}], "text": "def _strictly_valid_num(n):\n    n = n.strip()\n    if not n:\n        return False\n    if n[0] == '_':\n        return False\n    if n[-1] == '_':\n        return False\n    if \"_.\" in n or \"._\" in n:\n        return False\n    if len(n) == 1:\n        return True\n    if n[0] == '0' and n[1] not in ['.', 'o', 'b', 'x']:\n        return False\n    if n[0] == '+' or n[0] == '-':\n        n = n[1:]\n        if len(n) > 1 and n[0] == '0' and n[1] != '.':\n            return False\n    if '__' in n:\n        return False\n    return True"}, "_unescape": {"line": 608, "args": [{"func_args": {"v": "'\"https://pypi.python.org/simple\"'"}, "return_value": "'\"https://pypi.python.org/simple\"'"}, {"func_args": {"v": "'\"pypi\"'"}, "return_value": "'\"pypi\"'"}, {"func_args": {"v": "'\"*\"'"}, "return_value": "'\"*\"'"}, {"func_args": {"v": "'\"*\"'"}, "return_value": "'\"*\"'"}, {"func_args": {"v": "'\"https://pypi.python.org/simple\"'"}, "return_value": "'\"https://pypi.python.org/simple\"'"}, {"func_args": {"v": "'\"pypi\"'"}, "return_value": "'\"pypi\"'"}, {"func_args": {"v": "'\"*\"'"}, "return_value": "'\"*\"'"}, {"func_args": {"v": "'\"*\"'"}, "return_value": "'\"*\"'"}, {"func_args": {"v": "'\"https://pypi.python.org/simple\"'"}, "return_value": "'\"https://pypi.python.org/simple\"'"}, {"func_args": {"v": "'\"pypi\"'"}, "return_value": "'\"pypi\"'"}, {"func_args": {"v": "'\"*\"'"}, "return_value": "'\"*\"'"}, {"func_args": {"v": "'\"*\"'"}, "return_value": "'\"*\"'"}], "text": "def _unescape(v):\n    \"\"\"Unescape characters in a TOML string.\"\"\"\n    i = 0\n    backslash = False\n    while i < len(v):\n        if backslash:\n            backslash = False\n            if v[i] in _escapes:\n                v = v[:i - 1] + _escape_to_escapedchars[v[i]] + v[i + 1:]\n            elif v[i] == '\\\\':\n                v = v[:i - 1] + v[i:]\n            elif v[i] == 'u' or v[i] == 'U':\n                i += 1\n            else:\n                raise ValueError(\"Reserved escape sequence used\")\n            continue\n        elif v[i] == '\\\\':\n            backslash = True\n        i += 1\n    return v"}, "_to_blob": {"line": 21, "args": [{"func_args": {"b": "b'\\x04\\x00\\x00\\x80\\xe7\\xff?\\xc0xOL\\xec\\x13\\x00\\x00I\\xde\\xfd\\xe4\\xb3\\x00\\x90\\xc4\\xbc\\xbb\\xf7\\xb1 \\x10\\x80\\x9b\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x0e\\xf3o\\xc1\\xba,P\\x02\\xc0\\xe5\\x00\\x02\\x8b\\x00\\x08\\x00\\x80\\x0b\\x98\\xdf[\\x00\\xd9\\xf6\\x00\\x80\\x02\\\\\\xf0Y\\x84.\\x13\\xf0\\xdd\\xe7\\xfa\\xff\\xa7\\x85\\xea\\xfa\\xc7\\xa5\\xcfc\\x01X\\xcc\\xbd^\\xce>\\xde\\xf6\\xfb\\xf7\\xef\\x0b@\\xec\\xef\\xec\\xef\\xc5\\xb7\\xe5\\xfb9\\xb8\\x89\\x1e\\x02\\x00\\x08\\x00\\x04@\\x00\\x00\\x00\\x10 \\x80\\x00\\x04\\x00\\x81\\x00\\x00\\x00\\x00\\x01\\x80\\xfb\\x1b\\x0c\\x80a\\x00\\x19\\x00\\x0c\\x06\\x18\\x00\\x00\\x08\\x00\\x80\\x01\\x00\\xc0\\x00\\x060`\\x00\\x82\\x01\\x00\\x00\\x00\\x00\\x0c\\x00H\\x00\\x02\\x01'"}, "return_value": "b'\\x04\\x00\\x00\\x80\\xe7\\xff?\\xc0xOL\\xec\\x13\\x00\\x00I\\xde\\xfd\\xe4\\xb3\\x00\\x90\\xc4\\xbc\\xbb\\xf7\\xb1 \\x10\\x80\\x9b\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x0e\\xf3o\\xc1\\xba,P\\x02\\xc0\\xe5\\x00\\x02\\x8b\\x00\\x08\\x00\\x80\\x0b\\x98\\xdf[\\x00\\xd9\\xf6\\x00\\x80\\x02\\\\\\xf0Y\\x84.\\x13\\xf0\\xdd\\xe7\\xfa\\xff\\xa7\\x85\\xea\\xfa\\xc7\\xa5\\xcfc\\x01X\\xcc\\xbd^\\xce>\\xde\\xf6\\xfb\\xf7\\xef\\x0b@\\xec\\xef\\xec\\xef\\xc5\\xb7\\xe5\\xfb9\\xb8\\x89\\x1e\\x02\\x00\\x08\\x00\\x04@\\x00\\x00\\x00\\x10 \\x80\\x00\\x04\\x00\\x81\\x00\\x00\\x00\\x00\\x01\\x80\\xfb\\x1b\\x0c\\x80a\\x00\\x19\\x00\\x0c\\x06\\x18\\x00\\x00\\x08\\x00\\x80\\x01\\x00\\xc0\\x00\\x060`\\x00\\x82\\x01\\x00\\x00\\x00\\x00\\x0c\\x00H\\x00\\x02\\x01'"}], "text": "def _to_blob(b):\n    \"\"\"Convert a bytestring into a type SQLite will accept for a blob.\"\"\"\n    return b"}, "nums_to_numbits": {"line": 28, "args": [{"func_args": {"nums": "{2, 31, 32, 33, 34, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 62, 63, 67, 68, 69, 70, 72, 73, 74, 75, 78, 82, 83, 86, 90, 91, 93, 94, 95, 96, 97, 100, 120, 123, 126, 129, 130, 131, 132, 134, 135, 136, 138, 139, 140, 141, 142, 143, 146, 149, 150, 151, 152, 153, 156, 157, 159, 172, 175, 178, 182, 183, 186, 187, 188, 189, 191, 192, 193, 195, 196, 197, 199, 200, 201, 202, 204, 205, 206, 207, 208, 212, 213, 215, 221, 228, 239, 240, 241, 243, 244, 247, 258, 305, 306, 307, 312, 313, 316, 317, 318, 319, 320, 321, 322, 323, 325, 326, 328, 334, 335, 337, 339, 340, 341, 343, 346, 347, 349, 356, 358, 361, 374, 375, 376, 378, 381, 382, 383, 393, 400, 401, 403, 407, 419, 439, 440, 441, 443, 451, 452, 455, 456, 457, 458, 459, 460, 462, 463, 464, 465, 467, 468, 470, 480, 483, 484, 486, 487, 489, 490, 492, 493, 494, 495, 511, 513, 522, 523, 524, 526, 532, 533, 534, 535, 536, 539, 540, 542, 546, 551, 553, 554, 555, 557, 560, 561, 564, 572, 573, 574, 575, 576, 578, 579, 580, 582, 583, 584, 585, 586, 589, 590, 591, 593, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 613, 615, 616, 618, 623, 625, 627, 629, 630, 631, 633, 635, 636, 637, 638, 639, 640, 641, 642, 646, 647, 648, 650, 653, 655, 656, 657, 658, 659, 662, 663, 664, 665, 669, 670, 672, 683, 684, 686, 690, 691, 694, 695, 696, 698, 699, 700, 701, 703, 705, 706, 707, 708, 710, 713, 714, 715, 718, 719, 721, 722, 723, 724, 725, 729, 730, 731, 732, 734, 735, 737, 738, 740, 741, 742, 743, 744, 745, 747, 748, 749, 750, 751, 752, 753, 754, 756, 757, 758, 759, 760, 761, 762, 763, 765, 766, 767, 768, 769, 771, 782, 786, 787, 789, 790, 791, 792, 793, 794, 795, 797, 798, 799, 802, 803, 805, 806, 807, 808, 809, 810, 811, 813, 814, 815, 816, 818, 822, 823, 824, 825, 826, 828, 829, 831, 832, 834, 837, 838, 839, 840, 841, 843, 844, 845, 846, 847, 848, 851, 852, 853, 859, 860, 861, 863, 864, 867, 871, 873, 874, 875, 876, 881, 899, 914, 926, 956, 965, 975, 986, 1000, 1007, 1040, 1055, 1056, 1057, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1067, 1068, 1074, 1075, 1087, 1088, 1093, 1094, 1104, 1107, 1108, 1122, 1123, 1129, 1130, 1139, 1140, 1163, 1183, 1184, 1206, 1207, 1217, 1218, 1228, 1229, 1237, 1238, 1249, 1255, 1256, 1298, 1299, 1315, 1318, 1329, 1336}"}, "return_value": "b'\\x04\\x00\\x00\\x80\\xe7\\xff?\\xc0xOL\\xec\\x13\\x00\\x00I\\xde\\xfd\\xe4\\xb3\\x00\\x90\\xc4\\xbc\\xbb\\xf7\\xb1 \\x10\\x80\\x9b\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x0e\\xf3o\\xc1\\xba,P\\x02\\xc0\\xe5\\x00\\x02\\x8b\\x00\\x08\\x00\\x80\\x0b\\x98\\xdf[\\x00\\xd9\\xf6\\x00\\x80\\x02\\\\\\xf0Y\\x84.\\x13\\xf0\\xdd\\xe7\\xfa\\xff\\xa7\\x85\\xea\\xfa\\xc7\\xa5\\xcfc\\x01X\\xcc\\xbd^\\xce>\\xde\\xf6\\xfb\\xf7\\xef\\x0b@\\xec\\xef\\xec\\xef\\xc5\\xb7\\xe5\\xfb9\\xb8\\x89\\x1e\\x02\\x00\\x08\\x00\\x04@\\x00\\x00\\x00\\x10 \\x80\\x00\\x04\\x00\\x81\\x00\\x00\\x00\\x00\\x01\\x80\\xfb\\x1b\\x0c\\x80a\\x00\\x19\\x00\\x0c\\x06\\x18\\x00\\x00\\x08\\x00\\x80\\x01\\x00\\xc0\\x00\\x060`\\x00\\x82\\x01\\x00\\x00\\x00\\x00\\x0c\\x00H\\x00\\x02\\x01'"}]}, "numbits_to_nums": {"line": 49, "args": [{"func_args": {"numbits": "b'\\x04\\x00\\x00\\x80\\xe7\\xff?\\xc0xOL\\xec\\x13\\x00\\x00I\\xde\\xfd\\xe4\\xb3\\x00\\x90\\xc4\\xbc\\xbb\\xf7\\xb1 \\x10\\x80\\x9b\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x0e\\xf3o\\xc1\\xba,P\\x02\\xc0\\xe5\\x00\\x02\\x8b\\x00\\x08\\x00\\x80\\x0b\\x98\\xdf[\\x00\\xd9\\xf6\\x00\\x80\\x02\\\\\\xf0Y\\x84.\\x13\\xf0\\xdd\\xe7\\xfa\\xff\\xa7\\x85\\xea\\xfa\\xc7\\xa5\\xcfc\\x01X\\xcc\\xbd^\\xce>\\xde\\xf6\\xfb\\xf7\\xef\\x0b@\\xec\\xef\\xec\\xef\\xc5\\xb7\\xe5\\xfb9\\xb8\\x89\\x1e\\x02\\x00\\x08\\x00\\x04@\\x00\\x00\\x00\\x10 \\x80\\x00\\x04\\x00\\x81\\x00\\x00\\x00\\x00\\x01\\x80\\xfb\\x1b\\x0c\\x80a\\x00\\x19\\x00\\x0c\\x06\\x18\\x00\\x00\\x08\\x00\\x80\\x01\\x00\\xc0\\x00\\x060`\\x00\\x82\\x01\\x00\\x00\\x00\\x00\\x0c\\x00H\\x00\\x02\\x01'"}, "return_value": "[2, 31, 32, 33, 34, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 62, 63, 67, 68, 69, 70, 72, 73, 74, 75, 78, 82, 83, 86, 90, 91, 93, 94, 95, 96, 97, 100, 120, 123, 126, 129, 130, 131, 132, 134, 135, 136, 138, 139, 140, 141, 142, 143, 146, 149, 150, 151, 152, 153, 156, 157, 159, 172, 175, 178, 182, 183, 186, 187, 188, 189, 191, 192, 193, 195, 196, 197, 199, 200, 201, 202, 204, 205, 206, 207, 208, 212, 213, 215, 221, 228, 239, 240, 241, 243, 244, 247, 258, 305, 306, 307, 312, 313, 316, 317, 318, 319, 320, 321, 322, 323, 325, 326, 328, 334, 335, 337, 339, 340, 341, 343, 346, 347, 349, 356, 358, 361, 374, 375, 376, 378, 381, 382, 383, 393, 400, 401, 403, 407, 419, 439, 440, 441, 443, 451, 452, 455, 456, 457, 458, 459, 460, 462, 463, 464, 465, 467, 468, 470, 480, 483, 484, 486, 487, 489, 490, 492, 493, 494, 495, 511, 513, 522, 523, 524, 526, 532, 533, 534, 535, 536, 539, 540, 542, 546, 551, 553, 554, 555, 557, 560, 561, 564, 572, 573, 574, 575, 576, 578, 579, 580, 582, 583, 584, 585, 586, 589, 590, 591, 593, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 613, 615, 616, 618, 623, 625, 627, 629, 630, 631, 633, 635, 636, 637, 638, 639, 640, 641, 642, 646, 647, 648, 650, 653, 655, 656, 657, 658, 659, 662, 663, 664, 665, 669, 670, 672, 683, 684, 686, 690, 691, 694, 695, 696, 698, 699, 700, 701, 703, 705, 706, 707, 708, 710, 713, 714, 715, 718, 719, 721, 722, 723, 724, 725, 729, 730, 731, 732, 734, 735, 737, 738, 740, 741, 742, 743, 744, 745, 747, 748, 749, 750, 751, 752, 753, 754, 756, 757, 758, 759, 760, 761, 762, 763, 765, 766, 767, 768, 769, 771, 782, 786, 787, 789, 790, 791, 792, 793, 794, 795, 797, 798, 799, 802, 803, 805, 806, 807, 808, 809, 810, 811, 813, 814, 815, 816, 818, 822, 823, 824, 825, 826, 828, 829, 831, 832, 834, 837, 838, 839, 840, 841, 843, 844, 845, 846, 847, 848, 851, 852, 853, 859, 860, 861, 863, 864, 867, 871, 873, 874, 875, 876, 881, 899, 914, 926, 956, 965, 975, 986, 1000, 1007, 1040, 1055, 1056, 1057, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1067, 1068, 1074, 1075, 1087, 1088, 1093, 1094, 1104, 1107, 1108, 1122, 1123, 1129, 1130, 1139, 1140, 1163, 1183, 1184, 1206, 1207, 1217, 1218, 1228, 1229, 1237, 1238, 1249, 1255, 1256, 1298, 1299, 1315, 1318, 1329, 1336]"}]}, "combinable_files": {"line": 55, "args": [{"func_args": {"data_file": "'/usr/app/src/test_repos/pundler/.coverage'", "data_paths": "None"}, "return_value": "['/usr/app/src/test_repos/pundler/.coverage.cae2a1e14906.80125.179623']"}], "text": "def combinable_files(data_file, data_paths=None):\n    \"\"\"Make a list of data files to be combined.\n\n    `data_file` is a path to a data file.  `data_paths` is a list of files or\n    directories of files.\n\n    Returns a list of absolute file paths.\n    \"\"\"\n    data_dir, local = os.path.split(os.path.abspath(data_file))\n\n    data_paths = data_paths or [data_dir]\n    files_to_combine = []\n    for p in data_paths:\n        if os.path.isfile(p):\n            files_to_combine.append(os.path.abspath(p))\n        elif os.path.isdir(p):\n            pattern = os.path.join(os.path.abspath(p), f\"{local}.*\")\n            files_to_combine.extend(glob.glob(pattern))\n        else:\n            raise NoDataError(f\"Couldn't combine from non-existent path '{p}'\")\n    return files_to_combine"}, "_line_ranges": {"line": 270, "args": [{"func_args": {"statements": "{2, 31, 32, 33, 34, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 58, 59, 62, 63, 67, 68, 72, 73, 78, 79, 82, 83, 86, 90, 91, 93, 94, 95, 96, 97, 100, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 115, 116, 117, 120, 123, 126, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 146, 149, 150, 151, 152, 153, 156, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 172, 173, 175, 176, 178, 179, 182, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 199, 200, 201, 202, 204, 205, 206, 207, 208, 210, 212, 213, 215, 216, 217, 218, 219, 221, 222, 223, 224, 225, 226, 228, 229, 230, 232, 233, 236, 237, 239, 240, 241, 243, 244, 245, 247, 249, 250, 251, 253, 254, 255, 256, 258, 259, 260, 261, 262, 263, 269, 270, 275, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 297, 298, 299, 300, 302, 303, 305, 306, 307, 309, 312, 316, 317, 318, 319, 320, 321, 322, 323, 325, 326, 328, 329, 330, 332, 334, 335, 337, 339, 340, 341, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 358, 359, 361, 363, 364, 365, 366, 367, 368, 370, 371, 372, 374, 375, 376, 377, 378, 379, 381, 382, 383, 384, 385, 386, 393, 394, 395, 396, 397, 398, 400, 401, 402, 403, 404, 405, 407, 408, 409, 410, 411, 412, 414, 415, 416, 417, 419, 420, 421, 422, 423, 424, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 439, 440, 441, 443, 444, 445, 446, 447, 448, 451, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 467, 468, 470, 476, 477, 478, 480, 481, 483, 484, 486, 487, 489, 490, 492, 493, 494, 495, 496, 497, 498, 511, 513, 514, 515, 516, 517, 519, 520, 522, 523, 524, 526, 527, 528, 529, 530, 532, 533, 539, 540, 542, 543, 544, 546, 547, 548, 549, 551, 553, 557, 560, 564, 572, 573, 574, 575, 576, 578, 579, 580, 582, 583, 584, 585, 586, 587, 589, 590, 591, 593, 595, 596, 597, 598, 599, 600, 601, 602, 603, 613, 615, 616, 617, 618, 625, 629, 630, 631, 632, 633, 635, 636, 637, 638, 639, 640, 645, 646, 647, 648, 650, 653, 655, 656, 657, 658, 659, 660, 662, 663, 664, 665, 667, 669, 670, 672, 673, 674, 678, 679, 680, 683, 686, 687, 690, 694, 695, 696, 697, 698, 699, 703, 705, 706, 707, 708, 710, 711, 713, 714, 715, 718, 721, 729, 730, 731, 732, 734, 735, 737, 738, 740, 741, 742, 743, 744, 745, 747, 748, 749, 750, 751, 752, 753, 754, 756, 757, 758, 759, 760, 761, 762, 763, 765, 766, 767, 768, 769, 770, 771, 774, 775, 776, 778, 781, 782, 784, 786, 787, 789, 790, 791, 792, 793, 794, 795, 797, 798, 799, 800, 802, 803, 805, 806, 807, 808, 809, 810, 811, 813, 814, 815, 816, 818, 822, 823, 831, 832, 834, 837, 838, 843, 844, 845, 846, 847, 848, 850, 851, 852, 853, 854, 855, 859, 863, 864, 867, 871, 872, 873, 874, 875, 876, 877, 881, 885, 887, 888, 890, 891, 892, 893, 894, 895, 896, 899, 901, 902, 903, 907, 908, 909, 910, 911, 914, 916, 917, 918, 919, 920, 921, 922, 923, 926, 927, 928, 929, 930, 931, 932, 933, 935, 936, 937, 945, 946, 947, 948, 949, 950, 952, 953, 956, 957, 958, 959, 960, 961, 965, 966, 967, 968, 969, 970, 971, 972, 975, 976, 977, 978, 979, 981, 982, 983, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 1000, 1007, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1028, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1055, 1056, 1057, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1067, 1068, 1069, 1070, 1071, 1072, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1087, 1088, 1090, 1093, 1094, 1099, 1100, 1101, 1104, 1107, 1108, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1122, 1123, 1125, 1126, 1129, 1130, 1132, 1133, 1134, 1135, 1136, 1139, 1140, 1142, 1143, 1144, 1145, 1147, 1148, 1149, 1156, 1157, 1158, 1159, 1160, 1163, 1164, 1165, 1166, 1167, 1169, 1171, 1172, 1173, 1174, 1176, 1178, 1179, 1180, 1183, 1184, 1186, 1187, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1203, 1206, 1207, 1209, 1210, 1211, 1212, 1213, 1214, 1217, 1218, 1220, 1221, 1222, 1223, 1224, 1225, 1228, 1229, 1231, 1232, 1233, 1234, 1237, 1238, 1240, 1241, 1246, 1249, 1255, 1256, 1258, 1259, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1294, 1295, 1298, 1299, 1301, 1302, 1303, 1304, 1315, 1318, 1321, 1322, 1323, 1324, 1325, 1326, 1329, 1332, 1333, 1336, 1337}", "lines": "{54, 55, 56, 58, 59, 79, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 115, 116, 117, 133, 137, 144, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 173, 176, 179, 190, 194, 210, 216, 217, 218, 219, 222, 223, 224, 225, 226, 229, 230, 232, 233, 236, 237, 245, 249, 250, 251, 253, 254, 255, 256, 259, 260, 261, 262, 263, 269, 270, 275, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 297, 298, 299, 300, 302, 303, 309, 329, 330, 332, 348, 350, 351, 352, 353, 354, 355, 359, 363, 364, 365, 366, 367, 368, 370, 371, 372, 377, 379, 384, 385, 386, 394, 395, 396, 397, 398, 402, 404, 405, 408, 409, 410, 411, 412, 414, 415, 416, 417, 420, 421, 422, 423, 424, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 444, 445, 446, 447, 448, 461, 476, 477, 478, 481, 496, 497, 498, 514, 515, 516, 517, 519, 520, 527, 528, 529, 530, 543, 544, 547, 548, 549, 587, 617, 632, 645, 660, 667, 673, 674, 678, 679, 680, 687, 697, 711, 770, 774, 775, 776, 778, 781, 784, 800, 850, 854, 855, 872, 877, 885, 887, 888, 890, 891, 892, 893, 894, 895, 896, 901, 902, 903, 907, 908, 909, 910, 911, 916, 917, 918, 919, 920, 921, 922, 923, 927, 928, 929, 930, 931, 932, 933, 935, 936, 937, 945, 946, 947, 948, 949, 950, 952, 953, 957, 958, 959, 960, 961, 966, 967, 968, 969, 970, 971, 972, 976, 977, 978, 979, 981, 982, 983, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1028, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1069, 1070, 1071, 1072, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1090, 1099, 1100, 1101, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1125, 1126, 1132, 1133, 1134, 1135, 1136, 1142, 1143, 1144, 1145, 1147, 1148, 1149, 1156, 1157, 1158, 1159, 1160, 1164, 1165, 1166, 1167, 1169, 1171, 1172, 1173, 1174, 1176, 1178, 1179, 1180, 1186, 1187, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1203, 1209, 1210, 1211, 1212, 1213, 1214, 1220, 1221, 1222, 1223, 1224, 1225, 1231, 1232, 1233, 1234, 1240, 1241, 1246, 1258, 1259, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1294, 1295, 1301, 1302, 1303, 1304, 1321, 1322, 1323, 1324, 1325, 1326, 1332, 1333, 1337}"}, "return_value": "[(54, 59), (79, 79), (103, 117), (133, 133), (137, 137), (144, 144), (160, 170), (173, 173), (176, 176), (179, 179), (190, 190), (194, 194), (210, 210), (216, 219), (222, 226), (229, 237), (245, 245), (249, 256), (259, 303), (309, 309), (329, 332), (348, 348), (350, 355), (359, 359), (363, 372), (377, 377), (379, 379), (384, 386), (394, 398), (402, 402), (404, 405), (408, 417), (420, 436), (444, 448), (461, 461), (476, 478), (481, 481), (496, 498), (514, 520), (527, 530), (543, 544), (547, 549), (587, 587), (617, 617), (632, 632), (645, 645), (660, 660), (667, 667), (673, 680), (687, 687), (697, 697), (711, 711), (770, 770), (774, 781), (784, 784), (800, 800), (850, 850), (854, 855), (872, 872), (877, 877), (885, 896), (901, 911), (916, 923), (927, 953), (957, 961), (966, 972), (976, 983), (987, 997), (1009, 1037), (1041, 1052), (1069, 1072), (1076, 1084), (1090, 1090), (1099, 1101), (1110, 1119), (1125, 1126), (1132, 1136), (1142, 1160), (1164, 1180), (1186, 1203), (1209, 1214), (1220, 1225), (1231, 1234), (1240, 1246), (1258, 1295), (1301, 1304), (1321, 1326), (1332, 1333), (1337, 1337)]"}], "text": "def _line_ranges(statements, lines):\n    \"\"\"Produce a list of ranges for `format_lines`.\"\"\"\n    statements = sorted(statements)\n    lines = sorted(lines)\n\n    pairs = []\n    start = None\n    lidx = 0\n    for stmt in statements:\n        if lidx >= len(lines):\n            break\n        if stmt == lines[lidx]:\n            lidx += 1\n            if not start:\n                start = stmt\n            end = stmt\n        elif start:\n            pairs.append((start, end))\n            start = None\n    if start:\n        pairs.append((start, end))\n    return pairs"}, "format_lines": {"line": 294, "args": [{"func_args": {"statements": "{2, 31, 32, 33, 34, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 58, 59, 62, 63, 67, 68, 72, 73, 78, 79, 82, 83, 86, 90, 91, 93, 94, 95, 96, 97, 100, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 115, 116, 117, 120, 123, 126, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 146, 149, 150, 151, 152, 153, 156, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 172, 173, 175, 176, 178, 179, 182, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 199, 200, 201, 202, 204, 205, 206, 207, 208, 210, 212, 213, 215, 216, 217, 218, 219, 221, 222, 223, 224, 225, 226, 228, 229, 230, 232, 233, 236, 237, 239, 240, 241, 243, 244, 245, 247, 249, 250, 251, 253, 254, 255, 256, 258, 259, 260, 261, 262, 263, 269, 270, 275, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 297, 298, 299, 300, 302, 303, 305, 306, 307, 309, 312, 316, 317, 318, 319, 320, 321, 322, 323, 325, 326, 328, 329, 330, 332, 334, 335, 337, 339, 340, 341, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 358, 359, 361, 363, 364, 365, 366, 367, 368, 370, 371, 372, 374, 375, 376, 377, 378, 379, 381, 382, 383, 384, 385, 386, 393, 394, 395, 396, 397, 398, 400, 401, 402, 403, 404, 405, 407, 408, 409, 410, 411, 412, 414, 415, 416, 417, 419, 420, 421, 422, 423, 424, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 439, 440, 441, 443, 444, 445, 446, 447, 448, 451, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 467, 468, 470, 476, 477, 478, 480, 481, 483, 484, 486, 487, 489, 490, 492, 493, 494, 495, 496, 497, 498, 511, 513, 514, 515, 516, 517, 519, 520, 522, 523, 524, 526, 527, 528, 529, 530, 532, 533, 539, 540, 542, 543, 544, 546, 547, 548, 549, 551, 553, 557, 560, 564, 572, 573, 574, 575, 576, 578, 579, 580, 582, 583, 584, 585, 586, 587, 589, 590, 591, 593, 595, 596, 597, 598, 599, 600, 601, 602, 603, 613, 615, 616, 617, 618, 625, 629, 630, 631, 632, 633, 635, 636, 637, 638, 639, 640, 645, 646, 647, 648, 650, 653, 655, 656, 657, 658, 659, 660, 662, 663, 664, 665, 667, 669, 670, 672, 673, 674, 678, 679, 680, 683, 686, 687, 690, 694, 695, 696, 697, 698, 699, 703, 705, 706, 707, 708, 710, 711, 713, 714, 715, 718, 721, 729, 730, 731, 732, 734, 735, 737, 738, 740, 741, 742, 743, 744, 745, 747, 748, 749, 750, 751, 752, 753, 754, 756, 757, 758, 759, 760, 761, 762, 763, 765, 766, 767, 768, 769, 770, 771, 774, 775, 776, 778, 781, 782, 784, 786, 787, 789, 790, 791, 792, 793, 794, 795, 797, 798, 799, 800, 802, 803, 805, 806, 807, 808, 809, 810, 811, 813, 814, 815, 816, 818, 822, 823, 831, 832, 834, 837, 838, 843, 844, 845, 846, 847, 848, 850, 851, 852, 853, 854, 855, 859, 863, 864, 867, 871, 872, 873, 874, 875, 876, 877, 881, 885, 887, 888, 890, 891, 892, 893, 894, 895, 896, 899, 901, 902, 903, 907, 908, 909, 910, 911, 914, 916, 917, 918, 919, 920, 921, 922, 923, 926, 927, 928, 929, 930, 931, 932, 933, 935, 936, 937, 945, 946, 947, 948, 949, 950, 952, 953, 956, 957, 958, 959, 960, 961, 965, 966, 967, 968, 969, 970, 971, 972, 975, 976, 977, 978, 979, 981, 982, 983, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 1000, 1007, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1028, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1055, 1056, 1057, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1067, 1068, 1069, 1070, 1071, 1072, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1087, 1088, 1090, 1093, 1094, 1099, 1100, 1101, 1104, 1107, 1108, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1122, 1123, 1125, 1126, 1129, 1130, 1132, 1133, 1134, 1135, 1136, 1139, 1140, 1142, 1143, 1144, 1145, 1147, 1148, 1149, 1156, 1157, 1158, 1159, 1160, 1163, 1164, 1165, 1166, 1167, 1169, 1171, 1172, 1173, 1174, 1176, 1178, 1179, 1180, 1183, 1184, 1186, 1187, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1203, 1206, 1207, 1209, 1210, 1211, 1212, 1213, 1214, 1217, 1218, 1220, 1221, 1222, 1223, 1224, 1225, 1228, 1229, 1231, 1232, 1233, 1234, 1237, 1238, 1240, 1241, 1246, 1249, 1255, 1256, 1258, 1259, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1294, 1295, 1298, 1299, 1301, 1302, 1303, 1304, 1315, 1318, 1321, 1322, 1323, 1324, 1325, 1326, 1329, 1332, 1333, 1336, 1337}", "lines": "{54, 55, 56, 58, 59, 79, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 115, 116, 117, 133, 137, 144, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 173, 176, 179, 190, 194, 210, 216, 217, 218, 219, 222, 223, 224, 225, 226, 229, 230, 232, 233, 236, 237, 245, 249, 250, 251, 253, 254, 255, 256, 259, 260, 261, 262, 263, 269, 270, 275, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 297, 298, 299, 300, 302, 303, 309, 329, 330, 332, 348, 350, 351, 352, 353, 354, 355, 359, 363, 364, 365, 366, 367, 368, 370, 371, 372, 377, 379, 384, 385, 386, 394, 395, 396, 397, 398, 402, 404, 405, 408, 409, 410, 411, 412, 414, 415, 416, 417, 420, 421, 422, 423, 424, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 444, 445, 446, 447, 448, 461, 476, 477, 478, 481, 496, 497, 498, 514, 515, 516, 517, 519, 520, 527, 528, 529, 530, 543, 544, 547, 548, 549, 587, 617, 632, 645, 660, 667, 673, 674, 678, 679, 680, 687, 697, 711, 770, 774, 775, 776, 778, 781, 784, 800, 850, 854, 855, 872, 877, 885, 887, 888, 890, 891, 892, 893, 894, 895, 896, 901, 902, 903, 907, 908, 909, 910, 911, 916, 917, 918, 919, 920, 921, 922, 923, 927, 928, 929, 930, 931, 932, 933, 935, 936, 937, 945, 946, 947, 948, 949, 950, 952, 953, 957, 958, 959, 960, 961, 966, 967, 968, 969, 970, 971, 972, 976, 977, 978, 979, 981, 982, 983, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1028, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1069, 1070, 1071, 1072, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1090, 1099, 1100, 1101, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1125, 1126, 1132, 1133, 1134, 1135, 1136, 1142, 1143, 1144, 1145, 1147, 1148, 1149, 1156, 1157, 1158, 1159, 1160, 1164, 1165, 1166, 1167, 1169, 1171, 1172, 1173, 1174, 1176, 1178, 1179, 1180, 1186, 1187, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1203, 1209, 1210, 1211, 1212, 1213, 1214, 1220, 1221, 1222, 1223, 1224, 1225, 1231, 1232, 1233, 1234, 1240, 1241, 1246, 1258, 1259, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1294, 1295, 1301, 1302, 1303, 1304, 1321, 1322, 1323, 1324, 1325, 1326, 1332, 1333, 1337}", "arcs": "None"}, "return_value": "'54-59, 79, 103-117, 133, 137, 144, 160-170, 173, 176, 179, 190, 194, 210, 216-219, 222-226, 229-237, 245, 249-256, 259-303, 309, 329-332, 348, 350-355, 359, 363-372, 377, 379, 384-386, 394-398, 402, 404-405, 408-417, 420-436, 444-448, 461, 476-478, 481, 496-498, 514-520, 527-530, 543-544, 547-549, 587, 617, 632, 645, 660, 667, 673-680, 687, 697, 711, 770, 774-781, 784, 800, 850, 854-855, 872, 877, 885-896, 901-911, 916-923, 927-953, 957-961, 966-972, 976-983, 987-997, 1009-1037, 1041-1052, 1069-1072, 1076-1084, 1090, 1099-1101, 1110-1119, 1125-1126, 1132-1136, 1142-1160, 1164-1180, 1186-1203, 1209-1214, 1220-1225, 1231-1234, 1240-1246, 1258-1295, 1301-1304, 1321-1326, 1332-1333, 1337'"}], "text": "def format_lines(statements, lines, arcs=None):\n    \"\"\"Nicely format a list of line numbers.\n\n    Format a list of line numbers for printing by coalescing groups of lines as\n    long as the lines represent consecutive statements.  This will coalesce\n    even if there are gaps between statements.\n\n    For example, if `statements` is [1,2,3,4,5,10,11,12,13,14] and\n    `lines` is [1,2,5,10,11,13,14] then the result will be \"1-2, 5-11, 13-14\".\n\n    Both `lines` and `statements` can be any iterable. All of the elements of\n    `lines` must be in `statements`, and all of the values must be positive\n    integers.\n\n    If `arcs` is provided, they are (start,[end,end,end]) pairs that will be\n    included in the output as long as start isn't in `lines`.\n\n    \"\"\"\n    line_items = [(pair[0], nice_pair(pair)) for pair in _line_ranges(statements, lines)]\n    if arcs:\n        line_exits = sorted(arcs)\n        for line, exits in line_exits:\n            for ex in sorted(exits):\n                if line not in lines and ex not in lines:\n                    dest = (ex if ex > 0 else \"exit\")\n                    line_items.append((line, f\"{line}->{dest}\"))\n\n    ret = ', '.join(t[-1] for t in sorted(line_items))\n    return ret"}, "source_encoding": {"line": 184, "args": [{"func_args": {"source": "b'# encoding: utf-8\\n\"\"\"\\nData Model, start here to not get mad\\n=====================================\\n\\nMain entity will be distribution, like Flask. Per key\\nPundle tracks three state parts:\\n    1. requirement, like Flask>0.12.2.\\n    2. frozen version, like ==0.12.2\\n    3. installed distributions, like [flask==0.12.2, flask==0.10.0]\\n\\nRequirement basically is from file, like requirements.txt, setup.py or Pipfile. This requirements\\nhave source like `requirements.txt`. And base requirements can have dependencies. This\\ndependencies are turned to requirements too with source like `Flask-Admin << requirements.txt`.\\nTo track requirements we use `CustomReq` class. It can work with PyPi and VCS requirements.\\nCustomReq can have `self.req = pkg_resources.Requirement` or custom vcs line.\\n\\nDistribution is one of VCSDist or pkg_resources.DistInfoDistribution. VCSDist is to\\ntrack installed VCS packages and pkg_resources.DistInfoDistribution is for PyPi packages.\\n\\nAll three states of distribution are tracked inside `RequirementState` object that includes info\\nabout requirement, frozen version and installed versions.\\n\\n`Suite` keeps state of all distributions like a dictionary of RequirentStates.\\n\\nTo populate Suite and to parse all requirements, frozen versions and what we have installed pundle\\nuses `Parser`. There is plenty of them - `Parser` that works with `requirements.txt`,\\n`SetupParser` that works with `setup.py`, PipfileParser that works with Pipfile and Pipfile.lock.\\n\"\"\"\\n\\nfrom __future__ import print_function\\nimport re\\ntry:\\n    from urllib.parse import urlparse, parse_qsl\\nexcept ImportError:  # pragma: no cover\\n    from urlparse import urlparse, parse_qsl\\nfrom collections import defaultdict\\nfrom base64 import b64encode, b64decode\\nimport platform\\nimport os.path as op\\nimport os\\nfrom os import makedirs\\nimport stat\\nimport tempfile\\nimport shutil\\nimport subprocess\\nimport sys\\nimport shlex\\nimport json\\nimport hashlib\\nimport pkg_resources\\ntry:\\n    from pip import main as pip_exec\\nexcept ImportError:\\n    from pip._internal import main as pip_exec\\n    from types import ModuleType\\n\\n    if isinstance(pip_exec, ModuleType):\\n        pip_exec = pip_exec.main\\n\\n# TODO bundle own version of distlib. Perhaps\\ntry:\\n    from pip._vendor.distlib import locators\\nexcept ImportError:  # pragma: no cover\\n    from pip.vendor.distlib import locators\\n\\ntry:\\n    str_types = (basestring,)\\nexcept NameError:  # pragma: no cover\\n    str_types = (str, bytes)\\n\\ntry:\\n    pkg_resources_parse_version = pkg_resources.SetuptoolsVersion\\nexcept AttributeError:  # pragma: no cover\\n    pkg_resources_parse_version = pkg_resources.packaging.version.Version\\n\\n\\ndef print_message(*a, **kw):\\n    print(*a, **kw)\\n\\n\\nclass PundleException(Exception):\\n    pass\\n\\n\\ndef python_version_string():\\n    \"\"\"We use it to generate per python folder name, where\\n    we will install all packages.\\n    \"\"\"\\n    if platform.python_implementation() == \\'PyPy\\':\\n        version_info = sys.pypy_version_info\\n    else:\\n        version_info = sys.version_info\\n    version_string = \\'{v.major}.{v.minor}.{v.micro}\\'.format(v=version_info)\\n    build, _ = platform.python_build()\\n    build = build.replace(\\':\\', \\'_\\')  # windows do not understand `:` in path\\n    return \\'{}-{}-{}\\'.format(platform.python_implementation(), version_string, build)\\n\\n\\ndef parse_file(filename):\\n    \"\"\"Helper to parse requirements.txt or frozen.txt.\\n    \"\"\"\\n    res = []\\n    with open(filename) as f:\\n        for line in f:\\n            s = line.strip()\\n            if s and not s.startswith(\\'#\\'):\\n                if s.startswith(\\'-r\\'):\\n                    continue\\n                if s.startswith(\\'-e \\'):\\n                    s = s[3:].strip()\\n                if parse_vcs_requirement(s):\\n                    res.append(s)\\n                else:\\n                    req = shlex.split(s, comments=True)\\n                    res.append(req[0])\\n    return res\\n\\n\\ndef test_vcs(req):\\n    \"\"\"Checks if requirement line is for VCS.\\n    \"\"\"\\n    return \\'+\\' in req and req.index(\\'+\\') == 3\\n\\n\\ndef parse_vcs_requirement(req):\\n    \"\"\"Parses VCS line to egg name, version etc.\\n    \"\"\"\\n    if \\'+\\' not in req:\\n        return None\\n    vcs, url = req.split(\\'+\\', 1)\\n    if vcs not in (\\'git\\', \\'svn\\', \\'hg\\'):\\n        return None\\n    parsed_url = urlparse(url)\\n    parsed = dict(parse_qsl(parsed_url.fragment))\\n    if \\'egg\\' not in parsed:\\n        return None\\n    egg = parsed[\\'egg\\'].rsplit(\\'-\\', 1)\\n    if len(egg) > 1:\\n        try:\\n            pkg_resources_parse_version(egg[1])\\n        except pkg_resources._vendor.packaging.version.InvalidVersion:\\n            return parsed[\\'egg\\'].lower(), req, None\\n        return egg[0].lower(), req, egg[1]\\n    else:\\n        return parsed[\\'egg\\'].lower(), req, None\\n\\n\\ndef parse_frozen_vcs(req):\\n    res = parse_vcs_requirement(req)\\n    if not res:\\n        return\\n    return res[0], res[1]\\n\\n\\nclass VCSDist(object):\\n    \"\"\" Represents installed VCS distribution.\\n    \"\"\"\\n    def __init__(self, directory):\\n        self.dir = directory\\n        name = op.split(directory)[-1]\\n        key, encoded = name.split(\\'+\\', 1)\\n        self.key = key.lower()\\n        self.line = b64decode(encoded).decode(\\'utf-8\\')\\n        egg, req, version = parse_vcs_requirement(self.line)\\n        version = version or \\'0.0.0\\'\\n        self.hashcmp = (pkg_resources_parse_version(version), -1, egg, self.dir)\\n        self.version = self.line\\n        self.pkg_resource = next(iter(pkg_resources.find_distributions(self.dir, True)), None)\\n        self.location = self.pkg_resource.location\\n\\n    def requires(self, extras=[]):\\n        return self.pkg_resource.requires(extras=extras)\\n\\n    def activate(self):\\n        return self.pkg_resource.activate()\\n\\n    def __lt__(self, other):\\n        return self.hashcmp.__lt__(other.hashcmp)\\n\\n\\nclass CustomReq(object):\\n    \"\"\"Represents PyPi or VCS requirement.\\n    Can locate and install it.\\n    \"\"\"\\n    def __init__(self, line, env, source=None):\\n        self.line = line\\n        self.egg = None\\n        if isinstance(line, pkg_resources.Requirement):\\n            self.req = line\\n        elif test_vcs(line):\\n            res = parse_vcs_requirement(line)\\n            if not res:\\n                raise PundleException(\\'Bad url %r\\' % line)\\n            egg, req, version = res\\n            self.egg = egg\\n            self.req = None  # pkg_resources.Requirement.parse(res)\\n        else:\\n            self.req = pkg_resources.Requirement.parse(line)\\n        self.sources = set([source])\\n        self.envs = set()\\n        self.add_env(env)\\n\\n    def __contains__(self, something):\\n        if self.req:\\n            return (something in self.req)\\n        elif self.egg:\\n            return something == self.line\\n        else:\\n            return False\\n\\n    def __repr__(self):\\n        return \\'<CustomReq %r>\\' % self.__dict__\\n\\n    def why_str(self):\\n        if len(self.sources) < 2:\\n            return \\'{} << {}\\'.format(self.line, self.why_str_one(list(self.sources)[0]))\\n        causes = list(sorted(self.why_str_one(source) for source in self.sources))\\n        return \\'{} << [{}]\\'.format(self.line, \\' | \\'.join(causes))\\n\\n    def why_str_one(self, source):\\n        if isinstance(source, str_types):\\n            return source\\n        elif isinstance(source, CustomReq):\\n            return source.why_str()\\n        return \\'?\\'\\n\\n    def adjust_with_req(self, req):\\n        if not self.req:\\n            return\\n            raise PundleException(\\'VCS\\')\\n        versions = \\',\\'.join(\\'\\'.join(t) for t in set(self.req.specs + req.req.specs))\\n        self.requirement = pkg_resources.Requirement.parse(\\'{} {}\\'.format(\\n            self.req.project_name, versions\\n        ))\\n        self.sources.update(req.sources)\\n        self.add_env(req.envs)\\n\\n    @property\\n    def key(self):\\n        return self.req.key if self.req else self.egg\\n\\n    @property\\n    def extras(self):\\n        return self.req.extras if self.req else []\\n\\n    def locate(self, suite, prereleases=False):\\n        # requirements can have something after `;` symbol that `locate` does not understand\\n        req = str(self.req).split(\\';\\', 1)[0]\\n        dist = suite.locate(req, prereleases=prereleases)\\n        if not dist:\\n            # have not find any releases so search for pre\\n            dist = suite.locate(req, prereleases=True)\\n        if not dist:\\n            raise PundleException(\\'%s can not be located\\' % self.req)\\n        return dist\\n\\n    def locate_and_install(self, suite, installed=None, prereleases=False):\\n        if self.egg:\\n            key = b64encode(self.line.encode(\\'utf-8\\')).decode()\\n            target_dir = op.join(suite.parser.directory, \\'{}+{}\\'.format(self.egg, key))\\n            target_req = self.line\\n            ready = [\\n                installation\\n                for installation in (installed or [])\\n                if getattr(installation, \\'line\\', None) == self.line\\n            ]\\n        else:\\n            loc_dist = self.locate(suite, prereleases=prereleases)\\n            ready = [\\n                installation\\n                for installation in (installed or [])\\n                if installation.version == loc_dist.version\\n            ]\\n            target_dir = op.join(suite.parser.directory, \\'{}-{}\\'.format(loc_dist.key, loc_dist.version))\\n            # DEL? target_req = \\'%s==%s\\' % (loc_dist.name, loc_dist.version)\\n            # If we use custom index, then we want not to configure PIP with it\\n            # and just give it URL\\n            target_req = loc_dist.download_url\\n        if ready:\\n            return ready[0]\\n        try:\\n            makedirs(target_dir)\\n        except OSError:\\n            pass\\n        tmp_dir = tempfile.mkdtemp()\\n        print(\\'Use temp dir\\', tmp_dir)\\n        try:\\n            print(\\'pip install --no-deps -t %s %s\\' % (tmp_dir, target_req))\\n            pip_exec([\\n                \\'install\\',\\n                \\'--no-deps\\',\\n                \\'-t\\', tmp_dir,\\n                \\'-v\\',\\n                target_req\\n            ])\\n            for item in os.listdir(tmp_dir):\\n                shutil.move(op.join(tmp_dir, item), op.join(target_dir, item))\\n        except Exception as exc:\\n            raise PundleException(\\'%s was not installed due error %s\\' % (self.egg or loc_dist.name, exc))\\n        finally:\\n            shutil.rmtree(tmp_dir, ignore_errors=True)\\n        return next(iter(pkg_resources.find_distributions(target_dir, True)), None)\\n\\n    def add_env(self, env):\\n        if isinstance(env, str):\\n            self.envs.add(env)\\n        else:\\n            self.envs.update(env)\\n\\n\\nclass RequirementState(object):\\n    \"\"\"Holds requirement state, like what version do we have installed, is\\n    some version frozen or not, what requirement constrains do we have.\\n    \"\"\"\\n    def __init__(self, key, req=None, frozen=None, installed=None, hashes=None):\\n        self.key = key\\n        self.requirement = req\\n        self.frozen = frozen\\n        self.hashes = hashes\\n        self.installed = installed or []\\n        self.installed.sort()\\n        self.installed.reverse()\\n\\n    def __repr__(self):\\n        return \\'<RequirementState %r>\\' % self.__dict__\\n\\n    def adjust_with_req(self, req):\\n        if self.requirement:\\n            self.requirement.adjust_with_req(req)\\n        else:\\n            self.requirement = req\\n\\n    def has_correct_freeze(self):\\n        return self.requirement and self.frozen and self.frozen in self.requirement\\n\\n    def check_installed_version(self, suite, install=False):\\n        # install version of package if not installed\\n        dist = None\\n        if self.has_correct_freeze():\\n            dist = [\\n                installation\\n                for installation in self.installed\\n                if pkg_resources.parse_version(installation.version) == pkg_resources.parse_version(self.frozen)\\n            ]\\n            dist = dist[0] if dist else None\\n            if install and not dist:\\n                dist = self.install_frozen(suite)\\n        if install and not dist:\\n            dist = self.requirement.locate_and_install(suite, installed=self.get_installed())\\n            if dist is None:\\n                raise PundleException(\\'Package %s was not installed due some error\\' % self.key)\\n            self.frozen = dist.version\\n            self.installed.append(dist)\\n            self.frozen = dist.version\\n        return dist\\n\\n    def get_installed(self):\\n        return [installation for installation in self.installed if installation.version in self.requirement]\\n\\n    def upgrade(self, suite, prereleases=False):\\n        # check if we have fresh packages on PIPY\\n        dists = self.get_installed()\\n        dist = dists[0] if dists else None\\n        latest = self.requirement.locate(suite, prereleases=prereleases)\\n        if not dist or pkg_resources.parse_version(latest.version) > pkg_resources.parse_version(dist.version):\\n            print_message(\\'Upgrade to\\', latest)\\n            dist = self.requirement.locate_and_install(suite, installed=self.get_installed(), prereleases=prereleases)\\n        # Anyway use latest available dist\\n        self.frozen = dist.version\\n        self.installed.append(dist)\\n        return dist\\n\\n    def reveal_requirements(self, suite, install=False, upgrade=False, already_revealed=None, prereleases=False):\\n        already_revealed = already_revealed.copy() if already_revealed is not None else set()\\n        if self.key in already_revealed:\\n            return\\n        if upgrade:\\n            dist = self.upgrade(suite, prereleases=prereleases)\\n        else:\\n            dist = self.check_installed_version(suite, install=install)\\n        if not dist:\\n            return\\n        already_revealed.add(self.key)\\n        for req in dist.requires(extras=self.requirement.extras):\\n            suite.adjust_with_req(\\n                CustomReq(str(req), self.requirement.envs, source=self.requirement),\\n                install=install,\\n                upgrade=upgrade,\\n                already_revealed=already_revealed,\\n            )\\n\\n    def frozen_dump(self):\\n        if self.requirement.egg:\\n            return self.requirement.line\\n        main = \\'{}=={}\\'.format(self.key, self.frozen)\\n        comment = self.requirement.why_str()\\n        return \\'{:20s} # {}\\'.format(main, comment)\\n\\n    def frozen_dist(self):\\n        if not self.frozen:\\n            return\\n        for dist in self.installed:\\n            if pkg_resources.parse_version(dist.version) == pkg_resources.parse_version(self.frozen):\\n                return dist\\n\\n    def install_frozen(self, suite):\\n        if self.frozen_dist() or not self.frozen:\\n            return\\n        envs = self.requirement.envs if self.requirement else \\'\\'\\n        if test_vcs(self.frozen):\\n            frozen_req = CustomReq(self.frozen, envs)\\n        else:\\n            frozen_req = CustomReq(\"{}=={}\".format(self.key, self.frozen), envs)\\n        dist = frozen_req.locate_and_install(suite)\\n        self.installed.append(dist)\\n        return dist\\n\\n    def activate(self):\\n        dist = self.frozen_dist()\\n        if not dist:\\n            raise PundleException(\\'Distribution is not installed %s\\' % self.key)\\n        dist.activate()\\n        pkg_resources.working_set.add_entry(dist.location)\\n        # find end execute *.pth\\n        sitedir = dist.location  # noqa some PTH search for sitedir\\n        for filename in os.listdir(dist.location):\\n            if not filename.endswith(\\'.pth\\'):\\n                continue\\n            try:\\n                for line in open(op.join(dist.location, filename)):\\n                    if line.startswith(\\'import \\'):\\n                        exec(line.strip())\\n            except Exception as e:\\n                print(\\'Erroneous pth file %r\\' % op.join(dist.location, filename))\\n                print(e)\\n\\n\\nclass AggregatingLocator(object):\\n    def __init__(self, locators):\\n        self.locators = locators\\n\\n    def locate(self, req, **kw):\\n        for locator in self.locators:\\n            print_message(\\'try\\', locator, \\'for\\', req)\\n            revealed = locator.locate(req, **kw)\\n            if revealed:\\n                return revealed\\n\\n\\nclass Suite(object):\\n    \"\"\"Main object that represents current directory pundle state.\\n    It tracks RequirementStates, envs, urls for package locator.\\n    \"\"\"\\n    def __init__(self, parser, envs=[], urls=None):\\n        self.states = {}\\n        self.parser = parser\\n        self.envs = envs\\n        self.urls = urls or [\\'https://pypi.python.org/simple/\\']\\n        if \\'PIP_EXTRA_INDEX_URL\\' in os.environ:\\n            self.urls.append(os.environ[\\'PIP_EXTRA_INDEX_URL\\'])\\n        self.locators = []\\n        for url in self.urls:\\n            self.locators.append(\\n                locators.SimpleScrapingLocator(url, timeout=3.0, scheme=\\'legacy\\')\\n            )\\n        self.locators.append(locators.JSONLocator(scheme=\\'legacy\\'))\\n        self.locator = AggregatingLocator(self.locators)\\n\\n    def use(self, key):\\n        \"\"\"For single mode\\n        You can call suite.use(\\'arrow\\') and then `import arrow`\\n\\n        :key: package name\\n        \"\"\"\\n        self.adjust_with_req(CustomReq(key, \\'\\'))\\n        self.install()\\n        self.activate_all()\\n\\n    def locate(self, *a, **kw):\\n        return self.locator.locate(*a, **kw)\\n\\n    def add(self, key, state):\\n        self.states[key] = state\\n\\n    def __repr__(self):\\n        return \\'<Suite %r>\\' % self.states\\n\\n    def required_states(self):\\n        return [state for state in self.states.values() if state.requirement]\\n\\n    def need_freeze(self, verbose=False):\\n        self.install(install=False)\\n        not_correct = not all(state.has_correct_freeze() for state in self.required_states())\\n        if not_correct and verbose:\\n            for state in self.required_states():\\n                if not state.has_correct_freeze():\\n                    print(\\n                        state.key,\\n                        \\'Need\\',\\n                        state.requirement,\\n                        \\'have not been frozen\\',\\n                        state.frozen,\\n                        \\', installed\\',\\n                        state.installed\\n                    )\\n        # TODO\\n        # unneeded = any(state.frozen for state in self.states.values() if not state.requirement)\\n        # if unneeded:\\n        #     print(\\'!!! Unneeded\\', [state.key for state in self.states.values() if not state.requirement])\\n        return not_correct  # or unneeded\\n\\n    def adjust_with_req(self, req, install=False, upgrade=False, already_revealed=None):\\n        state = self.states.get(req.key)\\n        if not state:\\n            state = RequirementState(req.key, req=req)\\n            self.add(req.key, state)\\n        else:\\n            state.adjust_with_req(req)\\n        state.reveal_requirements(self, install=install, upgrade=upgrade, already_revealed=already_revealed or set())\\n\\n    def install(self, install=True):\\n        for state in self.required_states():\\n            state.reveal_requirements(self, install=install)\\n\\n    def upgrade(self, key=None, prereleases=False):\\n        states = [self.states[key]] if key else self.required_states()\\n        for state in states:\\n            print(\\'Check\\', state.requirement.req)\\n            state.reveal_requirements(self, upgrade=True, prereleases=prereleases)\\n\\n    def get_frozen_states(self, env):\\n        return [\\n            state\\n            for state in self.required_states()\\n            if state.requirement and env in state.requirement.envs\\n        ]\\n\\n    def need_install(self):\\n        return not all(state.frozen_dist() for state in self.states.values() if state.frozen)\\n\\n    def install_frozen(self):\\n        for state in self.states.values():\\n            state.install_frozen(self)\\n\\n    def activate_all(self, envs=(\\'\\',)):\\n        for state in self.required_states():\\n            if \\'\\' in state.requirement.envs or any(env in state.requirement.envs for env in envs):\\n                state.activate()\\n\\n    def save_frozen(self):\\n        \"Saves frozen files to disk\"\\n        states_by_env = dict(\\n            (env, self.get_frozen_states(env))\\n            for env in self.parser.envs()\\n        )\\n        self.parser.save_frozen(states_by_env)\\n\\n\\nclass Parser(object):\\n    \"\"\"Gather environment info, requirements,\\n    frozen packages and create Suite object\\n    \"\"\"\\n    def __init__(\\n            self,\\n            base_path=None,\\n            directory=\\'Pundledir\\',\\n            requirements_files=None,\\n            frozen_files=None,\\n            package=None,\\n    ):\\n        self.base_path = base_path or \\'.\\'\\n        self.directory = directory\\n        self.requirements_files = requirements_files\\n        if frozen_files is None:\\n            self.frozen_files = {\\'\\': \\'frozen.txt\\'}\\n        else:\\n            self.frozen_files = frozen_files\\n        self.package = package\\n        self.package_envs = set([\\'\\'])\\n\\n    def envs(self):\\n        if self.requirements_files:\\n            return list(self.requirements_files.keys()) or [\\'\\']\\n        elif self.package:\\n            return self.package_envs\\n        return [\\'\\']\\n\\n    def get_frozen_file(self, env):\\n        if env in self.frozen_files:\\n            return self.frozen_files[env]\\n        else:\\n            return os.path.join(self.base_path, \\'frozen_%s.txt\\' % env)\\n\\n    def create_suite(self):\\n        reqs = self.parse_requirements()\\n        freezy = self.parse_frozen()\\n        hashes = self.parse_frozen_hashes()\\n        diry = self.parse_directory()\\n        state_keys = set(list(reqs.keys()) + list(freezy.keys()) + list(diry.keys()))\\n        suite = Suite(self, envs=self.envs())\\n        for key in state_keys:\\n            suite.add(\\n                key,\\n                RequirementState(\\n                    key,\\n                    req=reqs.get(key),\\n                    frozen=freezy.get(key),\\n                    installed=diry.get(key, []),\\n                    hashes=hashes.get(key),\\n                ),\\n            )\\n        return suite\\n\\n    def parse_directory(self):\\n        if not op.exists(self.directory):\\n            return {}\\n        dists = [\\n            # this magic takes first element or None\\n            next(iter(\\n                pkg_resources.find_distributions(op.join(self.directory, item), True)\\n            ), None)\\n            for item in os.listdir(self.directory) if \\'-\\' in item\\n        ]\\n        dists.extend(\\n            VCSDist(op.join(self.directory, item))\\n            for item in os.listdir(self.directory) if \\'+\\' in item\\n        )\\n        dists = filter(None, dists)\\n        result = defaultdict(list)\\n        for dist in dists:\\n            result[dist.key].append(dist)\\n        return result\\n\\n    def parse_frozen(self):\\n        frozen_versions = {}\\n        for env in self.envs():\\n            frozen_file = self.get_frozen_file(env)\\n            if op.exists(frozen_file):\\n                frozen = [\\n                    (parse_frozen_vcs(line) or line.split(\\'==\\'))\\n                    for line in parse_file(frozen_file)\\n                ]\\n            else:\\n                frozen = []\\n            for name, version in frozen:\\n                frozen_versions[name.lower()] = version\\n        return frozen_versions\\n\\n    def parse_frozen_hashes(self):\\n        \"\"\"This implementation does not support hashes yet\\n        \"\"\"\\n        return {}\\n\\n    def parse_requirements(self):\\n        all_requirements = {}\\n        for env, req_file in self.requirements_files.items():\\n            requirements = parse_file(req_file)\\n            if env:\\n                source = \\'requirements %s file\\' % env\\n            else:\\n                source = \\'requirements file\\'\\n            for line in requirements:\\n                req = CustomReq(line, env, source=source)\\n                if req.key in all_requirements:\\n                    # if requirements exists in other env, then add this env too\\n                    all_requirements[req.key].add_env(env)\\n                else:\\n                    all_requirements[req.key] = req\\n        return all_requirements\\n\\n    def save_frozen(self, states_by_env):\\n        for env, states in states_by_env.items():\\n            data = \\'\\\\n\\'.join(sorted(\\n                state.frozen_dump()\\n                for state in states\\n            )) + \\'\\\\n\\'\\n            frozen_file = self.get_frozen_file(env)\\n            with open(frozen_file, \\'w\\') as f:\\n                f.write(data)\\n\\n\\nclass SingleParser(Parser):\\n    \"\"\"Parser for console mode.\\n    \"\"\"\\n    def parse_requirements(self):\\n        return {}\\n\\n\\nclass SetupParser(Parser):\\n    \"\"\"Parser for `setup.py`. Because it mostly used to develop package, we\\n    do not freeze packages to setup.py. We use `frozen.txt`.\\n    \"\"\"\\n    def parse_requirements(self):\\n        setup_info = get_info_from_setup(self.package)\\n        if setup_info is None:\\n            raise PundleException(\\'There is no requirements.txt nor setup.py\\')\\n        install_requires = setup_info.get(\\'install_requires\\') or []\\n        reqs = [\\n            CustomReq(str(req), \\'\\', source=\\'setup.py\\')\\n            for req in install_requires\\n        ]\\n        requirements = dict((req.key, req) for req in reqs)\\n        # we use `feature` as environment for pundle\\n        extras_require = (setup_info.get(\\'extras_require\\') or {})\\n        for feature, feature_requires in extras_require.items():\\n            for req_line in feature_requires:\\n                req = CustomReq(req_line, feature, source=\\'setup.py\\')\\n                # if this req already in dict, then add our feature as env\\n                if req.key in requirements:\\n                    requirements[req.key].add_env(feature)\\n                else:\\n                    requirements[req.key] = req\\n            self.package_envs.add(feature)\\n        return requirements\\n\\n\\nclass PipfileParser(Parser):\\n    \"\"\"Parser for Pipfile and Pipfile.lock.\\n    \"\"\"\\n    DEFAULT_PIPFILE_SOURCES = [\\n        {\\n            \\'name\\': \\'pypi\\',\\n            \\'url\\': \\'https://pypi.python.org/simple\\',\\n            \\'verify_ssl\\': True,\\n        },\\n    ]\\n\\n    def __init__(self, **kw):\\n        self.pipfile = kw.pop(\\'pipfile\\')\\n        self.pipfile_envs = set([\\'\\'])\\n        super(PipfileParser, self).__init__(**kw)\\n        # cache\\n        self.loaded_pipfile = None\\n        self.loaded_pipfile_lock = None\\n\\n    def envs(self):\\n        return self.pipfile_envs\\n\\n    def pipfile_content(self):\\n        import toml\\n        if self.loaded_pipfile:\\n            return self.loaded_pipfile\\n        self.loaded_pipfile = toml.load(open(self.pipfile))\\n        return self.loaded_pipfile\\n\\n    def pipfile_lock_content(self):\\n        if self.loaded_pipfile_lock:\\n            return self.loaded_pipfile_lock\\n        try:\\n            self.loaded_pipfile_lock = json.load(open(self.pipfile + \\'.lock\\'))\\n        except Exception:\\n            pass\\n        return self.loaded_pipfile_lock\\n\\n    def parse_requirements(self):\\n        info = self.pipfile_content()\\n        all_requirements = {}\\n        for info_key in info:\\n            if not info_key.endswith(\\'packages\\'):\\n                continue\\n            if \\'-\\' in info_key:\\n                env, _ = info_key.split(\\'-\\', 1)\\n            else:\\n                env = \\'\\'\\n            self.pipfile_envs.add(env)\\n            for key, details in info[info_key].items():\\n                if isinstance(details, str_types):\\n                    if details != \\'*\\':\\n                        key = key + details  # details is a version requirement\\n                    req = CustomReq(key, env, source=\\'Pipfile\\')\\n                else:\\n                    # a dict\\n                    if \\'file\\' in details or \\'path\\' in details:\\n                        raise PundleException(\\'Unsupported Pipfile feature yet %s: %r\\' % (key, details))\\n                    if \\'git\\' in details:\\n                        # wow, this as a git package!\\n                        req = CustomReq(\\'git+%s#egg=%s\\' % (details[\\'git\\'], key), env, source=\\'Pipfile\\')\\n                    else:\\n                        # else just simple requirement\\n                        req = CustomReq(key + details[\\'version\\'], env, source=\\'Pipfile\\')\\n                if req.key in all_requirements:\\n                    # if requirements exists in other env, then add this env too\\n                    all_requirements[req.key].add_env(env)\\n                else:\\n                    all_requirements[req.key] = req\\n        return all_requirements\\n\\n    def parse_frozen(self):\\n        parsed_frozen = self.pipfile_lock_content()\\n        if parsed_frozen is None:\\n            return {}\\n        frozen_versions = {}\\n        for env in parsed_frozen:\\n            if env.startswith(\\'_\\'):\\n                # this is not an env\\n                continue\\n            for key, details in parsed_frozen[env].items():\\n                if \\'vcs\\' in details:\\n                    frozen_versions[key] = details[\\'vcs\\']\\n                else:\\n                    frozen_versions[key] = details.get(\\'version\\', \\'0.0.0\\').lstrip(\\'=\\')\\n        return frozen_versions\\n\\n    def parse_frozen_hashes(self):\\n        parsed_frozen = self.pipfile_lock_content()\\n        if parsed_frozen is None:\\n            return {}\\n        frozen_versions = {}\\n        for env in parsed_frozen:\\n            if env.startswith(\\'_\\'):\\n                # this is not an env\\n                continue\\n            for key, details in parsed_frozen[env].items():\\n                frozen_versions[key] = details.get(\\'hashes\\', [])\\n        return frozen_versions\\n\\n    def hash(self):\\n        \"\"\"Returns the SHA256 of the pipfile\\'s data.\\n        From pipfile.\\n        \"\"\"\\n        pipfile_content = self.pipfile_content()\\n        data = {\\n            \\'_meta\\': {\\n                \\'sources\\': pipfile_content.get(\\'sources\\') or self.DEFAULT_PIPFILE_SOURCES,\\n                \\'requires\\': pipfile_content.get(\\'requires\\') or {},\\n            },\\n            \\'default\\': pipfile_content.get(\\'packages\\') or {},\\n            \\'develop\\': pipfile_content.get(\\'dev-packages\\') or {},\\n        }\\n        content = json.dumps(data, sort_keys=True, separators=(\",\", \":\"))\\n        return hashlib.sha256(content.encode(\"utf8\")).hexdigest()\\n\\n    def save_frozen(self, states_by_env):\\n        \"\"\"Implementation is not complete.\\n        \"\"\"\\n        data = self.pipfile_lock_content() or {}\\n        data.setdefault(\\'_meta\\', {\\n            \\'pipfile-spec\\': 5,\\n            \\'requires\\': {},\\n            \\'sources\\': self.DEFAULT_PIPFILE_SOURCES,\\n        })\\n        data.setdefault(\\'_meta\\', {}).setdefault(\\'hash\\', {})[\\'sha256\\'] = self.hash()\\n        for env, states in states_by_env.items():\\n            if env == \\'\\':\\n                env_key = \\'default\\'\\n            elif env == \\'dev\\':\\n                env_key = \\'develop\\'\\n            else:\\n                env_key = env\\n            reqs = data.setdefault(env_key, {})\\n            for state in states:\\n                if state.requirement.egg:\\n                    egg, url, version = parse_vcs_requirement(state.requirement.line)\\n                    reqs[state.key] = {\\n                        \\'vcs\\': url,\\n                    }\\n                else:\\n                    reqs[state.key] = {\\n                        \\'version\\': \\'==\\' + state.frozen,\\n                        \\'hashes\\': state.hashes or [],\\n                    }\\n        with open(self.pipfile + \\'.lock\\', \\'w\\') as f:\\n            f.write(json.dumps(data, sort_keys=True, indent=4))\\n\\n\\ndef create_parser(**parser_args):\\n    \"\"\"Utility function that tried to figure out what Parser to use\\n    in current directory.\\n    \"\"\"\\n    if parser_args.get(\\'requirements_files\\'):\\n        return Parser(**parser_args)\\n    elif parser_args.get(\\'package\\'):\\n        return SetupParser(**parser_args)\\n    elif parser_args.get(\\'pipfile\\'):\\n        return PipfileParser(**parser_args)\\n    return SingleParser(**parser_args)\\n\\n\\n# Utilities\\ndef get_info_from_setup(path):\\n    \"\"\"Mock setuptools.setup(**kargs) to get\\n    package information about requirements and extras\\n    \"\"\"\\n    preserve = {}\\n\\n    def _save_info(**setup_args):\\n        preserve[\\'args\\'] = setup_args\\n\\n    import setuptools\\n    original_setup = setuptools.setup\\n    setuptools.setup = _save_info\\n    import runpy\\n    runpy.run_path(os.path.join(path, \\'setup.py\\'), run_name=\\'__main__\\')\\n    setuptools.setup = original_setup\\n    return preserve.get(\\'args\\')\\n\\n\\ndef search_files_upward(start_path=None):\\n    \"Search for requirements.txt, setup.py or Pipfile upward\"\\n    if not start_path:\\n        start_path = op.abspath(op.curdir)\\n    if any(\\n            op.exists(op.join(start_path, filename))\\n            for filename in (\\'requirements.txt\\', \\'setup.py\\', \\'Pipfile\\')\\n    ):\\n        return start_path\\n    up_path = op.abspath(op.join(start_path, \\'..\\'))\\n    if op.samefile(start_path, up_path):\\n        return None\\n    return search_files_upward(start_path=up_path)\\n\\n\\ndef find_all_prefixed_files(directory, prefix):\\n    \"find all requirements_*.txt files\"\\n    envs = {}\\n    for entry in os.listdir(directory):\\n        if not entry.startswith(prefix):\\n            continue\\n        name, ext = op.splitext(entry)\\n        env = name[len(prefix):].lstrip(\\'_\\')\\n        envs[env] = op.join(directory, entry)\\n    return envs\\n\\n\\ndef create_parser_parameters():\\n    base_path = search_files_upward()\\n    if not base_path:\\n        raise PundleException(\\'Can not find requirements.txt nor setup.py nor Pipfile\\')\\n    py_version_path = python_version_string()\\n    pundledir_base = os.environ.get(\\'PUNDLEDIR\\') or op.join(op.expanduser(\\'~\\'), \\'.pundledir\\')\\n    if op.exists(op.join(base_path, \\'requirements.txt\\')):\\n        requirements_files = find_all_prefixed_files(base_path, \\'requirements\\')\\n    else:\\n        requirements_files = {}\\n    envs = list(requirements_files.keys()) or [\\'\\']\\n    params = {\\n        \\'base_path\\': base_path,\\n        \\'frozen_files\\': {\\n            env: op.join(base_path, \\'frozen_%s.txt\\' % env if env else \\'frozen.txt\\')\\n            for env in envs\\n        },\\n        \\'directory\\': op.join(pundledir_base, py_version_path),\\n    }\\n    if requirements_files:\\n        params[\\'requirements_files\\'] = requirements_files\\n    elif op.exists(op.join(base_path, \\'setup.py\\')):\\n        params[\\'package\\'] = base_path\\n    elif op.exists(op.join(base_path, \\'Pipfile\\')):\\n        params[\\'pipfile\\'] = op.join(base_path, \\'Pipfile\\')\\n    else:\\n        return\\n    return params\\n\\n\\ndef create_parser_or_exit():\\n    parser_kw = create_parser_parameters()\\n    if not parser_kw:\\n        print_message(\\'You have not requirements.txt. Create it and run again.\\')\\n        exit(1)\\n    return parser_kw\\n\\n\\n# Commands\\ndef upgrade_all(**kw):\\n    key = kw.pop(\\'key\\')\\n    prereleases = kw.pop(\\'prereleases\\')\\n    suite = create_parser(**kw).create_suite()\\n    suite.need_freeze()\\n    suite.upgrade(key=key, prereleases=prereleases)\\n    suite.install()\\n    suite.save_frozen()\\n\\n\\ndef install_all(**kw):\\n    suite = create_parser(**kw).create_suite()\\n    if suite.need_freeze() or suite.need_install():\\n        print_message(\\'Install some packages\\')\\n        suite.install()\\n    else:\\n        print_message(\\'Nothing to do, all packages installed\\')\\n    suite.save_frozen()\\n    return suite\\n\\n\\ndef activate():\\n    parser_kw = create_parser_parameters()\\n    if not parser_kw:\\n        raise PundleException(\\'Can`t create parser parameters\\')\\n    suite = create_parser(**parser_kw).create_suite()\\n    if suite.need_freeze(verbose=True):\\n        raise PundleException(\\'frozen file is outdated\\')\\n    if suite.need_install():\\n        raise PundleException(\\'Some dependencies not installed\\')\\n    envs = (os.environ.get(\\'PUNDLEENV\\') or \\'\\').split(\\',\\')\\n    suite.activate_all(envs=envs)\\n    return suite\\n\\n\\nFIXATE_TEMPLATE = \"\"\"\\n# pundle user customization start\\nimport pundle; pundle.activate()\\n# pundle user customization end\\n\"\"\"\\n\\n\\ndef fixate():\\n    \"puts activation code to usercustomize.py for user\"\\n    print_message(\\'Fixate\\')\\n    import site\\n    userdir = site.getusersitepackages()\\n    if not userdir:\\n        raise PundleException(\\'Can`t fixate due user have not site package directory\\')\\n    try:\\n        makedirs(userdir)\\n    except OSError:\\n        pass\\n    template = FIXATE_TEMPLATE.replace(\\'op.dirname(__file__)\\', \"\\'%s\\'\" % op.abspath(op.dirname(__file__)))\\n    usercustomize_file = op.join(userdir, \\'usercustomize.py\\')\\n    print_message(\\'Will edit %s file\\' % usercustomize_file)\\n    if op.exists(usercustomize_file):\\n        content = open(usercustomize_file).read()\\n        if \\'# pundle user customization start\\' in content:\\n            regex = re.compile(r\\'\\\\n# pundle user customization start.*# pundle user customization end\\\\n\\', re.DOTALL)\\n            content, res = regex.subn(template, content)\\n            open(usercustomize_file, \\'w\\').write(content)\\n        else:\\n            open(usercustomize_file, \\'a\\').write(content)\\n    else:\\n        open(usercustomize_file, \\'w\\').write(template)\\n    link_file = op.join(userdir, \\'pundle.py\\')\\n    if op.lexists(link_file):\\n        print_message(\\'Remove exist link to pundle\\')\\n        os.unlink(link_file)\\n    print_message(\\'Create link to pundle %s\\' % link_file)\\n    os.symlink(op.abspath(__file__), link_file)\\n    print_message(\\'Complete\\')\\n\\n\\ndef entry_points():\\n    suite = activate()\\n    entries = {}\\n    for r in suite.states.values():\\n        d = r.frozen_dist()\\n        if not d:\\n            continue\\n        if isinstance(d, VCSDist):\\n            continue\\n        scripts = d.get_entry_map().get(\\'console_scripts\\', {})\\n        for name in scripts:\\n            entries[name] = d\\n    return entries\\n\\n\\nclass CmdRegister:\\n    commands = {}\\n    ordered = []\\n\\n    @classmethod\\n    def cmdline(cls, *cmd_aliases):\\n        def wrap(func):\\n            for alias in cmd_aliases:\\n                cls.commands[alias] = func\\n                cls.ordered.append(alias)\\n        return wrap\\n\\n    @classmethod\\n    def help(cls):\\n        for alias in cls.ordered:\\n            if not alias:\\n                continue\\n            print(\"{:15s} {}\".format(alias, cls.commands[alias].__doc__))\\n\\n    @classmethod\\n    def main(cls):\\n        alias = \\'\\' if len(sys.argv) == 1 else sys.argv[1]\\n        if alias == \\'help\\':\\n            cls.help()\\n            return\\n        if alias not in cls.commands:\\n            print(\\'Unknown command\\\\nTry this:\\')\\n            cls.help()\\n            sys.exit(1)\\n        cls.commands[alias]()\\n\\n\\n@CmdRegister.cmdline(\\'\\', \\'install\\')\\ndef cmd_install():\\n    \"Install packages by frozen.txt and resolve ones that was not frozen\"\\n    install_all(**create_parser_or_exit())\\n\\n\\n@CmdRegister.cmdline(\\'upgrade\\')\\ndef cmd_upgrade():\\n    \"\"\"\\n    [package [pre]] if package provided will upgrade it and dependencies or all packages from PyPI.\\n    If `pre` provided will look for prereleases.\\n    \"\"\"\\n    key = sys.argv[2] if len(sys.argv) > 2 else None\\n    prereleases = sys.argv[3] == \\'pre\\' if len(sys.argv) > 3 else False\\n    upgrade_all(key=key, prereleases=prereleases, **create_parser_or_exit())\\n\\n\\nCmdRegister.cmdline(\\'fixate\\')(fixate)\\n\\n\\n@CmdRegister.cmdline(\\'exec\\')\\ndef cmd_exec():\\n    \"executes setuptools entry\"\\n    cmd = sys.argv[2]\\n    args = sys.argv[3:]\\n    entries = entry_points()\\n    if cmd not in entries:\\n        print_message(\\'Script is not found. Check if package is installed, or look at the `pundle entry_points`\\')\\n        sys.exit(1)\\n    exc = entries[cmd].get_entry_info(\\'console_scripts\\', cmd).load()\\n    sys.path.insert(0, \\'\\')\\n    sys.argv = [cmd] + args\\n    exc()\\n\\n\\n@CmdRegister.cmdline(\\'entry_points\\')\\ndef cmd_entry_points():\\n    \"prints available setuptools entries\"\\n    for entry, package in entry_points().items():\\n        print(\\'%s (%s)\\' % (entry, package))\\n\\n\\n@CmdRegister.cmdline(\\'edit\\')\\ndef cmd_edit():\\n    \"prints directory path to package\"\\n    parser_kw = create_parser_parameters()\\n    suite = create_parser(**parser_kw).create_suite()\\n    if suite.need_freeze():\\n        raise PundleException(\\'%s file is outdated\\' % suite.parser.frozen_file)\\n    print(suite.states[sys.argv[2]].frozen_dist().location)\\n\\n\\n@CmdRegister.cmdline(\\'info\\')\\ndef cmd_info():\\n    \"prints info about Pundle state\"\\n    parser_kw = create_parser_parameters()\\n    suite = create_parser(**parser_kw).create_suite()\\n    if suite.need_freeze():\\n        print(\\'frozen.txt is outdated\\')\\n    else:\\n        print(\\'frozen.txt is up to date\\')\\n    for state in suite.required_states():\\n        print(\\n            \\'Requirement \"{}\", frozen {}, {}\\'.format(\\n                state.key,\\n                state.frozen,\\n                state.requirement.line if state.requirement else \\'None\\'\\n            )\\n        )\\n        print(\\'Installed versions:\\')\\n        for dist in state.installed:\\n            print(\\'    \\', repr(dist))\\n        if not state.installed:\\n            print(\\'     None\\')\\n\\n\\ndef run_console(glob):\\n    import readline\\n    import rlcompleter\\n    import atexit\\n    import code\\n\\n    history_path = os.path.expanduser(\"~/.python_history\")\\n\\n    def save_history(history_path=history_path):\\n        readline.write_history_file(history_path)\\n    if os.path.exists(history_path):\\n        readline.read_history_file(history_path)\\n\\n    atexit.register(save_history)\\n\\n    readline.set_completer(rlcompleter.Completer(glob).complete)\\n    readline.parse_and_bind(\"tab: complete\")\\n    code.InteractiveConsole(locals=glob).interact()\\n\\n\\n@CmdRegister.cmdline(\\'console\\')\\ndef cmd_console():\\n    \"[ipython|bpython|ptpython] starts python console with activated pundle environment\"\\n    suite = activate()\\n    glob = {\\n        \\'pundle_suite\\': suite,\\n    }\\n    interpreter = sys.argv[2] if len(sys.argv) > 2 else None\\n    if not interpreter:\\n        run_console(glob)\\n    elif interpreter == \\'ipython\\':\\n        from IPython import embed\\n        embed()\\n    elif interpreter == \\'ptpython\\':\\n        from ptpython.repl import embed\\n        embed(glob, {})\\n    elif interpreter == \\'bpython\\':\\n        from bpython import embed\\n        embed(glob)\\n    else:\\n        raise PundleException(\\'Unknown interpreter: {}. Choose one of None, ipython, bpython, ptpython.\\')\\n\\n\\n@CmdRegister.cmdline(\\'run\\')\\ndef cmd_run():\\n    \"executes given script\"\\n    activate()\\n    import runpy\\n    sys.path.insert(0, \\'\\')\\n    script = sys.argv[2]\\n    sys.argv = [sys.argv[2]] + sys.argv[3:]\\n    runpy.run_path(script, run_name=\\'__main__\\')\\n\\n\\n@CmdRegister.cmdline(\\'module\\')\\ndef cmd_module():\\n    \"executes module like `python -m`\"\\n    activate()\\n    import runpy\\n    sys.path.insert(0, \\'\\')\\n    module = sys.argv[2]\\n    sys.argv = [sys.argv[2]] + sys.argv[3:]\\n    runpy.run_module(module, run_name=\\'__main__\\')\\n\\n\\n@CmdRegister.cmdline(\\'env\\')\\ndef cmd_env():\\n    \"populates PYTHONPATH with packages paths and executes command line in subprocess\"\\n    activate()\\n    aug_env = os.environ.copy()\\n    aug_env[\\'PYTHONPATH\\'] = \\':\\'.join(sys.path)\\n    subprocess.call(sys.argv[2:], env=aug_env)\\n\\n\\n@CmdRegister.cmdline(\\'print_env\\')\\ndef cmd_print_env():\\n    \"Prints PYTHONPATH. For usage with mypy and MYPYPATH\"\\n    suite = activate()\\n    path = \\':\\'.join(\\n        state.frozen_dist().location\\n        for state in suite.states.values()\\n        if state.frozen_dist()\\n    )\\n    print(path)\\n\\n\\nENTRY_POINT_TEMPLATE = \\'\\'\\'#! /usr/bin/env python\\nimport pundle; pundle.activate()\\npundle.entry_points()[\\'{entry_point}\\'].get_entry_info(\\'console_scripts\\', \\'{entry_point}\\').load(require=False)()\\n\\'\\'\\'\\n\\n\\n@CmdRegister.cmdline(\\'linkall\\')\\ndef link_all():\\n    \"links all packages to `.pundle_local` dir\"\\n    local_dir = \\'.pundle_local\\'\\n    suite = activate()\\n\\n    try:\\n        makedirs(local_dir)\\n    except OSError:\\n        pass\\n    local_dir_info = {de.name: de for de in os.scandir(local_dir)}\\n    for r in suite.states.values():\\n        d = r.frozen_dist()\\n        if not d:\\n            continue\\n        for dir_entry in os.scandir(d.location):\\n            if dir_entry.name.startswith(\\'__\\') or dir_entry.name.startswith(\\'.\\') or dir_entry.name == \\'bin\\':\\n                continue\\n            dest_path = os.path.join(local_dir, dir_entry.name)\\n            if dir_entry.name in local_dir_info:\\n                sym = local_dir_info.pop(dir_entry.name)\\n                existed = op.realpath(sym.path)\\n                if existed == dir_entry.path:\\n                    continue\\n                os.remove(sym.path)\\n            os.symlink(dir_entry.path, dest_path)\\n    # create entry_points binaries\\n    try:\\n        makedirs(os.path.join(local_dir, \\'bin\\'))\\n    except OSError:\\n        pass\\n    for bin_name, entry_point in entry_points().items():\\n        bin_filename = os.path.join(local_dir, \\'bin\\', bin_name)\\n        open(bin_filename, \\'w\\').write(ENTRY_POINT_TEMPLATE.format(entry_point=bin_name))\\n        file_stat = os.stat(bin_filename)\\n        os.chmod(bin_filename, file_stat.st_mode | stat.S_IEXEC)\\n    local_dir_info.pop(\\'bin\\')\\n\\n    # remove extra links\\n    for de in local_dir_info:\\n        os.remove(de.path)\\n\\n\\n@CmdRegister.cmdline(\\'show_requirements\\')\\ndef show_requirements():\\n    \"shows details requirements info\"\\n    suite = activate()\\n    for name, state in suite.states.items():\\n        if state.requirement:\\n            print(\\n                name,\\n                \\'frozen:\\',\\n                state.frozen,\\n                \\'required:\\',\\n                state.requirement.req if state.requirement.req else \\'VCS\\',\\n                state.requirement.envs,\\n            )\\n\\n\\n# Single mode that you can use in console\\n_single_mode_suite = {}  # cache variable to keep current suite for single_mode\\n\\n\\ndef single_mode():\\n    \"\"\" Create, cache and return Suite instance for single_mode.\\n    \"\"\"\\n    if not _single_mode_suite:\\n        py_version_path = python_version_string()\\n        pundledir_base = os.environ.get(\\'PUNDLEDIR\\') or op.join(op.expanduser(\\'~\\'), \\'.pundledir\\')\\n        directory = op.join(pundledir_base, py_version_path)\\n        _single_mode_suite[\\'cache\\'] = create_parser(directory=directory).create_suite()\\n    return _single_mode_suite[\\'cache\\']\\n\\n\\ndef use(key):\\n    \"\"\" Installs `key` requirement, like `django==1.11` or just `django`\\n    \"\"\"\\n    suite = single_mode()\\n    suite.use(key)\\n\\n\\nif __name__ == \\'__main__\\':\\n    CmdRegister.main()\\n'"}, "return_value": "'utf-8'"}]}, "neuter_encoding_declaration": {"line": 214, "args": [{"func_args": {"source": "'# encoding: utf-8\\n\"\"\"\\nData Model, start here to not get mad\\n=====================================\\n\\nMain entity will be distribution, like Flask. Per key\\nPundle tracks three state parts:\\n    1. requirement, like Flask>0.12.2.\\n    2. frozen version, like ==0.12.2\\n    3. installed distributions, like [flask==0.12.2, flask==0.10.0]\\n\\nRequirement basically is from file, like requirements.txt, setup.py or Pipfile. This requirements\\nhave source like `requirements.txt`. And base requirements can have dependencies. This\\ndependencies are turned to requirements too with source like `Flask-Admin << requirements.txt`.\\nTo track requirements we use `CustomReq` class. It can work with PyPi and VCS requirements.\\nCustomReq can have `self.req = pkg_resources.Requirement` or custom vcs line.\\n\\nDistribution is one of VCSDist or pkg_resources.DistInfoDistribution. VCSDist is to\\ntrack installed VCS packages and pkg_resources.DistInfoDistribution is for PyPi packages.\\n\\nAll three states of distribution are tracked inside `RequirementState` object that includes info\\nabout requirement, frozen version and installed versions.\\n\\n`Suite` keeps state of all distributions like a dictionary of RequirentStates.\\n\\nTo populate Suite and to parse all requirements, frozen versions and what we have installed pundle\\nuses `Parser`. There is plenty of them - `Parser` that works with `requirements.txt`,\\n`SetupParser` that works with `setup.py`, PipfileParser that works with Pipfile and Pipfile.lock.\\n\"\"\"\\n\\nfrom __future__ import print_function\\nimport re\\ntry:\\n    from urllib.parse import urlparse, parse_qsl\\nexcept ImportError:  # pragma: no cover\\n    from urlparse import urlparse, parse_qsl\\nfrom collections import defaultdict\\nfrom base64 import b64encode, b64decode\\nimport platform\\nimport os.path as op\\nimport os\\nfrom os import makedirs\\nimport stat\\nimport tempfile\\nimport shutil\\nimport subprocess\\nimport sys\\nimport shlex\\nimport json\\nimport hashlib\\nimport pkg_resources\\ntry:\\n    from pip import main as pip_exec\\nexcept ImportError:\\n    from pip._internal import main as pip_exec\\n    from types import ModuleType\\n\\n    if isinstance(pip_exec, ModuleType):\\n        pip_exec = pip_exec.main\\n\\n# TODO bundle own version of distlib. Perhaps\\ntry:\\n    from pip._vendor.distlib import locators\\nexcept ImportError:  # pragma: no cover\\n    from pip.vendor.distlib import locators\\n\\ntry:\\n    str_types = (basestring,)\\nexcept NameError:  # pragma: no cover\\n    str_types = (str, bytes)\\n\\ntry:\\n    pkg_resources_parse_version = pkg_resources.SetuptoolsVersion\\nexcept AttributeError:  # pragma: no cover\\n    pkg_resources_parse_version = pkg_resources.packaging.version.Version\\n\\n\\ndef print_message(*a, **kw):\\n    print(*a, **kw)\\n\\n\\nclass PundleException(Exception):\\n    pass\\n\\n\\ndef python_version_string():\\n    \"\"\"We use it to generate per python folder name, where\\n    we will install all packages.\\n    \"\"\"\\n    if platform.python_implementation() == \\'PyPy\\':\\n        version_info = sys.pypy_version_info\\n    else:\\n        version_info = sys.version_info\\n    version_string = \\'{v.major}.{v.minor}.{v.micro}\\'.format(v=version_info)\\n    build, _ = platform.python_build()\\n    build = build.replace(\\':\\', \\'_\\')  # windows do not understand `:` in path\\n    return \\'{}-{}-{}\\'.format(platform.python_implementation(), version_string, build)\\n\\n\\ndef parse_file(filename):\\n    \"\"\"Helper to parse requirements.txt or frozen.txt.\\n    \"\"\"\\n    res = []\\n    with open(filename) as f:\\n        for line in f:\\n            s = line.strip()\\n            if s and not s.startswith(\\'#\\'):\\n                if s.startswith(\\'-r\\'):\\n                    continue\\n                if s.startswith(\\'-e \\'):\\n                    s = s[3:].strip()\\n                if parse_vcs_requirement(s):\\n                    res.append(s)\\n                else:\\n                    req = shlex.split(s, comments=True)\\n                    res.append(req[0])\\n    return res\\n\\n\\ndef test_vcs(req):\\n    \"\"\"Checks if requirement line is for VCS.\\n    \"\"\"\\n    return \\'+\\' in req and req.index(\\'+\\') == 3\\n\\n\\ndef parse_vcs_requirement(req):\\n    \"\"\"Parses VCS line to egg name, version etc.\\n    \"\"\"\\n    if \\'+\\' not in req:\\n        return None\\n    vcs, url = req.split(\\'+\\', 1)\\n    if vcs not in (\\'git\\', \\'svn\\', \\'hg\\'):\\n        return None\\n    parsed_url = urlparse(url)\\n    parsed = dict(parse_qsl(parsed_url.fragment))\\n    if \\'egg\\' not in parsed:\\n        return None\\n    egg = parsed[\\'egg\\'].rsplit(\\'-\\', 1)\\n    if len(egg) > 1:\\n        try:\\n            pkg_resources_parse_version(egg[1])\\n        except pkg_resources._vendor.packaging.version.InvalidVersion:\\n            return parsed[\\'egg\\'].lower(), req, None\\n        return egg[0].lower(), req, egg[1]\\n    else:\\n        return parsed[\\'egg\\'].lower(), req, None\\n\\n\\ndef parse_frozen_vcs(req):\\n    res = parse_vcs_requirement(req)\\n    if not res:\\n        return\\n    return res[0], res[1]\\n\\n\\nclass VCSDist(object):\\n    \"\"\" Represents installed VCS distribution.\\n    \"\"\"\\n    def __init__(self, directory):\\n        self.dir = directory\\n        name = op.split(directory)[-1]\\n        key, encoded = name.split(\\'+\\', 1)\\n        self.key = key.lower()\\n        self.line = b64decode(encoded).decode(\\'utf-8\\')\\n        egg, req, version = parse_vcs_requirement(self.line)\\n        version = version or \\'0.0.0\\'\\n        self.hashcmp = (pkg_resources_parse_version(version), -1, egg, self.dir)\\n        self.version = self.line\\n        self.pkg_resource = next(iter(pkg_resources.find_distributions(self.dir, True)), None)\\n        self.location = self.pkg_resource.location\\n\\n    def requires(self, extras=[]):\\n        return self.pkg_resource.requires(extras=extras)\\n\\n    def activate(self):\\n        return self.pkg_resource.activate()\\n\\n    def __lt__(self, other):\\n        return self.hashcmp.__lt__(other.hashcmp)\\n\\n\\nclass CustomReq(object):\\n    \"\"\"Represents PyPi or VCS requirement.\\n    Can locate and install it.\\n    \"\"\"\\n    def __init__(self, line, env, source=None):\\n        self.line = line\\n        self.egg = None\\n        if isinstance(line, pkg_resources.Requirement):\\n            self.req = line\\n        elif test_vcs(line):\\n            res = parse_vcs_requirement(line)\\n            if not res:\\n                raise PundleException(\\'Bad url %r\\' % line)\\n            egg, req, version = res\\n            self.egg = egg\\n            self.req = None  # pkg_resources.Requirement.parse(res)\\n        else:\\n            self.req = pkg_resources.Requirement.parse(line)\\n        self.sources = set([source])\\n        self.envs = set()\\n        self.add_env(env)\\n\\n    def __contains__(self, something):\\n        if self.req:\\n            return (something in self.req)\\n        elif self.egg:\\n            return something == self.line\\n        else:\\n            return False\\n\\n    def __repr__(self):\\n        return \\'<CustomReq %r>\\' % self.__dict__\\n\\n    def why_str(self):\\n        if len(self.sources) < 2:\\n            return \\'{} << {}\\'.format(self.line, self.why_str_one(list(self.sources)[0]))\\n        causes = list(sorted(self.why_str_one(source) for source in self.sources))\\n        return \\'{} << [{}]\\'.format(self.line, \\' | \\'.join(causes))\\n\\n    def why_str_one(self, source):\\n        if isinstance(source, str_types):\\n            return source\\n        elif isinstance(source, CustomReq):\\n            return source.why_str()\\n        return \\'?\\'\\n\\n    def adjust_with_req(self, req):\\n        if not self.req:\\n            return\\n            raise PundleException(\\'VCS\\')\\n        versions = \\',\\'.join(\\'\\'.join(t) for t in set(self.req.specs + req.req.specs))\\n        self.requirement = pkg_resources.Requirement.parse(\\'{} {}\\'.format(\\n            self.req.project_name, versions\\n        ))\\n        self.sources.update(req.sources)\\n        self.add_env(req.envs)\\n\\n    @property\\n    def key(self):\\n        return self.req.key if self.req else self.egg\\n\\n    @property\\n    def extras(self):\\n        return self.req.extras if self.req else []\\n\\n    def locate(self, suite, prereleases=False):\\n        # requirements can have something after `;` symbol that `locate` does not understand\\n        req = str(self.req).split(\\';\\', 1)[0]\\n        dist = suite.locate(req, prereleases=prereleases)\\n        if not dist:\\n            # have not find any releases so search for pre\\n            dist = suite.locate(req, prereleases=True)\\n        if not dist:\\n            raise PundleException(\\'%s can not be located\\' % self.req)\\n        return dist\\n\\n    def locate_and_install(self, suite, installed=None, prereleases=False):\\n        if self.egg:\\n            key = b64encode(self.line.encode(\\'utf-8\\')).decode()\\n            target_dir = op.join(suite.parser.directory, \\'{}+{}\\'.format(self.egg, key))\\n            target_req = self.line\\n            ready = [\\n                installation\\n                for installation in (installed or [])\\n                if getattr(installation, \\'line\\', None) == self.line\\n            ]\\n        else:\\n            loc_dist = self.locate(suite, prereleases=prereleases)\\n            ready = [\\n                installation\\n                for installation in (installed or [])\\n                if installation.version == loc_dist.version\\n            ]\\n            target_dir = op.join(suite.parser.directory, \\'{}-{}\\'.format(loc_dist.key, loc_dist.version))\\n            # DEL? target_req = \\'%s==%s\\' % (loc_dist.name, loc_dist.version)\\n            # If we use custom index, then we want not to configure PIP with it\\n            # and just give it URL\\n            target_req = loc_dist.download_url\\n        if ready:\\n            return ready[0]\\n        try:\\n            makedirs(target_dir)\\n        except OSError:\\n            pass\\n        tmp_dir = tempfile.mkdtemp()\\n        print(\\'Use temp dir\\', tmp_dir)\\n        try:\\n            print(\\'pip install --no-deps -t %s %s\\' % (tmp_dir, target_req))\\n            pip_exec([\\n                \\'install\\',\\n                \\'--no-deps\\',\\n                \\'-t\\', tmp_dir,\\n                \\'-v\\',\\n                target_req\\n            ])\\n            for item in os.listdir(tmp_dir):\\n                shutil.move(op.join(tmp_dir, item), op.join(target_dir, item))\\n        except Exception as exc:\\n            raise PundleException(\\'%s was not installed due error %s\\' % (self.egg or loc_dist.name, exc))\\n        finally:\\n            shutil.rmtree(tmp_dir, ignore_errors=True)\\n        return next(iter(pkg_resources.find_distributions(target_dir, True)), None)\\n\\n    def add_env(self, env):\\n        if isinstance(env, str):\\n            self.envs.add(env)\\n        else:\\n            self.envs.update(env)\\n\\n\\nclass RequirementState(object):\\n    \"\"\"Holds requirement state, like what version do we have installed, is\\n    some version frozen or not, what requirement constrains do we have.\\n    \"\"\"\\n    def __init__(self, key, req=None, frozen=None, installed=None, hashes=None):\\n        self.key = key\\n        self.requirement = req\\n        self.frozen = frozen\\n        self.hashes = hashes\\n        self.installed = installed or []\\n        self.installed.sort()\\n        self.installed.reverse()\\n\\n    def __repr__(self):\\n        return \\'<RequirementState %r>\\' % self.__dict__\\n\\n    def adjust_with_req(self, req):\\n        if self.requirement:\\n            self.requirement.adjust_with_req(req)\\n        else:\\n            self.requirement = req\\n\\n    def has_correct_freeze(self):\\n        return self.requirement and self.frozen and self.frozen in self.requirement\\n\\n    def check_installed_version(self, suite, install=False):\\n        # install version of package if not installed\\n        dist = None\\n        if self.has_correct_freeze():\\n            dist = [\\n                installation\\n                for installation in self.installed\\n                if pkg_resources.parse_version(installation.version) == pkg_resources.parse_version(self.frozen)\\n            ]\\n            dist = dist[0] if dist else None\\n            if install and not dist:\\n                dist = self.install_frozen(suite)\\n        if install and not dist:\\n            dist = self.requirement.locate_and_install(suite, installed=self.get_installed())\\n            if dist is None:\\n                raise PundleException(\\'Package %s was not installed due some error\\' % self.key)\\n            self.frozen = dist.version\\n            self.installed.append(dist)\\n            self.frozen = dist.version\\n        return dist\\n\\n    def get_installed(self):\\n        return [installation for installation in self.installed if installation.version in self.requirement]\\n\\n    def upgrade(self, suite, prereleases=False):\\n        # check if we have fresh packages on PIPY\\n        dists = self.get_installed()\\n        dist = dists[0] if dists else None\\n        latest = self.requirement.locate(suite, prereleases=prereleases)\\n        if not dist or pkg_resources.parse_version(latest.version) > pkg_resources.parse_version(dist.version):\\n            print_message(\\'Upgrade to\\', latest)\\n            dist = self.requirement.locate_and_install(suite, installed=self.get_installed(), prereleases=prereleases)\\n        # Anyway use latest available dist\\n        self.frozen = dist.version\\n        self.installed.append(dist)\\n        return dist\\n\\n    def reveal_requirements(self, suite, install=False, upgrade=False, already_revealed=None, prereleases=False):\\n        already_revealed = already_revealed.copy() if already_revealed is not None else set()\\n        if self.key in already_revealed:\\n            return\\n        if upgrade:\\n            dist = self.upgrade(suite, prereleases=prereleases)\\n        else:\\n            dist = self.check_installed_version(suite, install=install)\\n        if not dist:\\n            return\\n        already_revealed.add(self.key)\\n        for req in dist.requires(extras=self.requirement.extras):\\n            suite.adjust_with_req(\\n                CustomReq(str(req), self.requirement.envs, source=self.requirement),\\n                install=install,\\n                upgrade=upgrade,\\n                already_revealed=already_revealed,\\n            )\\n\\n    def frozen_dump(self):\\n        if self.requirement.egg:\\n            return self.requirement.line\\n        main = \\'{}=={}\\'.format(self.key, self.frozen)\\n        comment = self.requirement.why_str()\\n        return \\'{:20s} # {}\\'.format(main, comment)\\n\\n    def frozen_dist(self):\\n        if not self.frozen:\\n            return\\n        for dist in self.installed:\\n            if pkg_resources.parse_version(dist.version) == pkg_resources.parse_version(self.frozen):\\n                return dist\\n\\n    def install_frozen(self, suite):\\n        if self.frozen_dist() or not self.frozen:\\n            return\\n        envs = self.requirement.envs if self.requirement else \\'\\'\\n        if test_vcs(self.frozen):\\n            frozen_req = CustomReq(self.frozen, envs)\\n        else:\\n            frozen_req = CustomReq(\"{}=={}\".format(self.key, self.frozen), envs)\\n        dist = frozen_req.locate_and_install(suite)\\n        self.installed.append(dist)\\n        return dist\\n\\n    def activate(self):\\n        dist = self.frozen_dist()\\n        if not dist:\\n            raise PundleException(\\'Distribution is not installed %s\\' % self.key)\\n        dist.activate()\\n        pkg_resources.working_set.add_entry(dist.location)\\n        # find end execute *.pth\\n        sitedir = dist.location  # noqa some PTH search for sitedir\\n        for filename in os.listdir(dist.location):\\n            if not filename.endswith(\\'.pth\\'):\\n                continue\\n            try:\\n                for line in open(op.join(dist.location, filename)):\\n                    if line.startswith(\\'import \\'):\\n                        exec(line.strip())\\n            except Exception as e:\\n                print(\\'Erroneous pth file %r\\' % op.join(dist.location, filename))\\n                print(e)\\n\\n\\nclass AggregatingLocator(object):\\n    def __init__(self, locators):\\n        self.locators = locators\\n\\n    def locate(self, req, **kw):\\n        for locator in self.locators:\\n            print_message(\\'try\\', locator, \\'for\\', req)\\n            revealed = locator.locate(req, **kw)\\n            if revealed:\\n                return revealed\\n\\n\\nclass Suite(object):\\n    \"\"\"Main object that represents current directory pundle state.\\n    It tracks RequirementStates, envs, urls for package locator.\\n    \"\"\"\\n    def __init__(self, parser, envs=[], urls=None):\\n        self.states = {}\\n        self.parser = parser\\n        self.envs = envs\\n        self.urls = urls or [\\'https://pypi.python.org/simple/\\']\\n        if \\'PIP_EXTRA_INDEX_URL\\' in os.environ:\\n            self.urls.append(os.environ[\\'PIP_EXTRA_INDEX_URL\\'])\\n        self.locators = []\\n        for url in self.urls:\\n            self.locators.append(\\n                locators.SimpleScrapingLocator(url, timeout=3.0, scheme=\\'legacy\\')\\n            )\\n        self.locators.append(locators.JSONLocator(scheme=\\'legacy\\'))\\n        self.locator = AggregatingLocator(self.locators)\\n\\n    def use(self, key):\\n        \"\"\"For single mode\\n        You can call suite.use(\\'arrow\\') and then `import arrow`\\n\\n        :key: package name\\n        \"\"\"\\n        self.adjust_with_req(CustomReq(key, \\'\\'))\\n        self.install()\\n        self.activate_all()\\n\\n    def locate(self, *a, **kw):\\n        return self.locator.locate(*a, **kw)\\n\\n    def add(self, key, state):\\n        self.states[key] = state\\n\\n    def __repr__(self):\\n        return \\'<Suite %r>\\' % self.states\\n\\n    def required_states(self):\\n        return [state for state in self.states.values() if state.requirement]\\n\\n    def need_freeze(self, verbose=False):\\n        self.install(install=False)\\n        not_correct = not all(state.has_correct_freeze() for state in self.required_states())\\n        if not_correct and verbose:\\n            for state in self.required_states():\\n                if not state.has_correct_freeze():\\n                    print(\\n                        state.key,\\n                        \\'Need\\',\\n                        state.requirement,\\n                        \\'have not been frozen\\',\\n                        state.frozen,\\n                        \\', installed\\',\\n                        state.installed\\n                    )\\n        # TODO\\n        # unneeded = any(state.frozen for state in self.states.values() if not state.requirement)\\n        # if unneeded:\\n        #     print(\\'!!! Unneeded\\', [state.key for state in self.states.values() if not state.requirement])\\n        return not_correct  # or unneeded\\n\\n    def adjust_with_req(self, req, install=False, upgrade=False, already_revealed=None):\\n        state = self.states.get(req.key)\\n        if not state:\\n            state = RequirementState(req.key, req=req)\\n            self.add(req.key, state)\\n        else:\\n            state.adjust_with_req(req)\\n        state.reveal_requirements(self, install=install, upgrade=upgrade, already_revealed=already_revealed or set())\\n\\n    def install(self, install=True):\\n        for state in self.required_states():\\n            state.reveal_requirements(self, install=install)\\n\\n    def upgrade(self, key=None, prereleases=False):\\n        states = [self.states[key]] if key else self.required_states()\\n        for state in states:\\n            print(\\'Check\\', state.requirement.req)\\n            state.reveal_requirements(self, upgrade=True, prereleases=prereleases)\\n\\n    def get_frozen_states(self, env):\\n        return [\\n            state\\n            for state in self.required_states()\\n            if state.requirement and env in state.requirement.envs\\n        ]\\n\\n    def need_install(self):\\n        return not all(state.frozen_dist() for state in self.states.values() if state.frozen)\\n\\n    def install_frozen(self):\\n        for state in self.states.values():\\n            state.install_frozen(self)\\n\\n    def activate_all(self, envs=(\\'\\',)):\\n        for state in self.required_states():\\n            if \\'\\' in state.requirement.envs or any(env in state.requirement.envs for env in envs):\\n                state.activate()\\n\\n    def save_frozen(self):\\n        \"Saves frozen files to disk\"\\n        states_by_env = dict(\\n            (env, self.get_frozen_states(env))\\n            for env in self.parser.envs()\\n        )\\n        self.parser.save_frozen(states_by_env)\\n\\n\\nclass Parser(object):\\n    \"\"\"Gather environment info, requirements,\\n    frozen packages and create Suite object\\n    \"\"\"\\n    def __init__(\\n            self,\\n            base_path=None,\\n            directory=\\'Pundledir\\',\\n            requirements_files=None,\\n            frozen_files=None,\\n            package=None,\\n    ):\\n        self.base_path = base_path or \\'.\\'\\n        self.directory = directory\\n        self.requirements_files = requirements_files\\n        if frozen_files is None:\\n            self.frozen_files = {\\'\\': \\'frozen.txt\\'}\\n        else:\\n            self.frozen_files = frozen_files\\n        self.package = package\\n        self.package_envs = set([\\'\\'])\\n\\n    def envs(self):\\n        if self.requirements_files:\\n            return list(self.requirements_files.keys()) or [\\'\\']\\n        elif self.package:\\n            return self.package_envs\\n        return [\\'\\']\\n\\n    def get_frozen_file(self, env):\\n        if env in self.frozen_files:\\n            return self.frozen_files[env]\\n        else:\\n            return os.path.join(self.base_path, \\'frozen_%s.txt\\' % env)\\n\\n    def create_suite(self):\\n        reqs = self.parse_requirements()\\n        freezy = self.parse_frozen()\\n        hashes = self.parse_frozen_hashes()\\n        diry = self.parse_directory()\\n        state_keys = set(list(reqs.keys()) + list(freezy.keys()) + list(diry.keys()))\\n        suite = Suite(self, envs=self.envs())\\n        for key in state_keys:\\n            suite.add(\\n                key,\\n                RequirementState(\\n                    key,\\n                    req=reqs.get(key),\\n                    frozen=freezy.get(key),\\n                    installed=diry.get(key, []),\\n                    hashes=hashes.get(key),\\n                ),\\n            )\\n        return suite\\n\\n    def parse_directory(self):\\n        if not op.exists(self.directory):\\n            return {}\\n        dists = [\\n            # this magic takes first element or None\\n            next(iter(\\n                pkg_resources.find_distributions(op.join(self.directory, item), True)\\n            ), None)\\n            for item in os.listdir(self.directory) if \\'-\\' in item\\n        ]\\n        dists.extend(\\n            VCSDist(op.join(self.directory, item))\\n            for item in os.listdir(self.directory) if \\'+\\' in item\\n        )\\n        dists = filter(None, dists)\\n        result = defaultdict(list)\\n        for dist in dists:\\n            result[dist.key].append(dist)\\n        return result\\n\\n    def parse_frozen(self):\\n        frozen_versions = {}\\n        for env in self.envs():\\n            frozen_file = self.get_frozen_file(env)\\n            if op.exists(frozen_file):\\n                frozen = [\\n                    (parse_frozen_vcs(line) or line.split(\\'==\\'))\\n                    for line in parse_file(frozen_file)\\n                ]\\n            else:\\n                frozen = []\\n            for name, version in frozen:\\n                frozen_versions[name.lower()] = version\\n        return frozen_versions\\n\\n    def parse_frozen_hashes(self):\\n        \"\"\"This implementation does not support hashes yet\\n        \"\"\"\\n        return {}\\n\\n    def parse_requirements(self):\\n        all_requirements = {}\\n        for env, req_file in self.requirements_files.items():\\n            requirements = parse_file(req_file)\\n            if env:\\n                source = \\'requirements %s file\\' % env\\n            else:\\n                source = \\'requirements file\\'\\n            for line in requirements:\\n                req = CustomReq(line, env, source=source)\\n                if req.key in all_requirements:\\n                    # if requirements exists in other env, then add this env too\\n                    all_requirements[req.key].add_env(env)\\n                else:\\n                    all_requirements[req.key] = req\\n        return all_requirements\\n\\n    def save_frozen(self, states_by_env):\\n        for env, states in states_by_env.items():\\n            data = \\'\\\\n\\'.join(sorted(\\n                state.frozen_dump()\\n                for state in states\\n            )) + \\'\\\\n\\'\\n            frozen_file = self.get_frozen_file(env)\\n            with open(frozen_file, \\'w\\') as f:\\n                f.write(data)\\n\\n\\nclass SingleParser(Parser):\\n    \"\"\"Parser for console mode.\\n    \"\"\"\\n    def parse_requirements(self):\\n        return {}\\n\\n\\nclass SetupParser(Parser):\\n    \"\"\"Parser for `setup.py`. Because it mostly used to develop package, we\\n    do not freeze packages to setup.py. We use `frozen.txt`.\\n    \"\"\"\\n    def parse_requirements(self):\\n        setup_info = get_info_from_setup(self.package)\\n        if setup_info is None:\\n            raise PundleException(\\'There is no requirements.txt nor setup.py\\')\\n        install_requires = setup_info.get(\\'install_requires\\') or []\\n        reqs = [\\n            CustomReq(str(req), \\'\\', source=\\'setup.py\\')\\n            for req in install_requires\\n        ]\\n        requirements = dict((req.key, req) for req in reqs)\\n        # we use `feature` as environment for pundle\\n        extras_require = (setup_info.get(\\'extras_require\\') or {})\\n        for feature, feature_requires in extras_require.items():\\n            for req_line in feature_requires:\\n                req = CustomReq(req_line, feature, source=\\'setup.py\\')\\n                # if this req already in dict, then add our feature as env\\n                if req.key in requirements:\\n                    requirements[req.key].add_env(feature)\\n                else:\\n                    requirements[req.key] = req\\n            self.package_envs.add(feature)\\n        return requirements\\n\\n\\nclass PipfileParser(Parser):\\n    \"\"\"Parser for Pipfile and Pipfile.lock.\\n    \"\"\"\\n    DEFAULT_PIPFILE_SOURCES = [\\n        {\\n            \\'name\\': \\'pypi\\',\\n            \\'url\\': \\'https://pypi.python.org/simple\\',\\n            \\'verify_ssl\\': True,\\n        },\\n    ]\\n\\n    def __init__(self, **kw):\\n        self.pipfile = kw.pop(\\'pipfile\\')\\n        self.pipfile_envs = set([\\'\\'])\\n        super(PipfileParser, self).__init__(**kw)\\n        # cache\\n        self.loaded_pipfile = None\\n        self.loaded_pipfile_lock = None\\n\\n    def envs(self):\\n        return self.pipfile_envs\\n\\n    def pipfile_content(self):\\n        import toml\\n        if self.loaded_pipfile:\\n            return self.loaded_pipfile\\n        self.loaded_pipfile = toml.load(open(self.pipfile))\\n        return self.loaded_pipfile\\n\\n    def pipfile_lock_content(self):\\n        if self.loaded_pipfile_lock:\\n            return self.loaded_pipfile_lock\\n        try:\\n            self.loaded_pipfile_lock = json.load(open(self.pipfile + \\'.lock\\'))\\n        except Exception:\\n            pass\\n        return self.loaded_pipfile_lock\\n\\n    def parse_requirements(self):\\n        info = self.pipfile_content()\\n        all_requirements = {}\\n        for info_key in info:\\n            if not info_key.endswith(\\'packages\\'):\\n                continue\\n            if \\'-\\' in info_key:\\n                env, _ = info_key.split(\\'-\\', 1)\\n            else:\\n                env = \\'\\'\\n            self.pipfile_envs.add(env)\\n            for key, details in info[info_key].items():\\n                if isinstance(details, str_types):\\n                    if details != \\'*\\':\\n                        key = key + details  # details is a version requirement\\n                    req = CustomReq(key, env, source=\\'Pipfile\\')\\n                else:\\n                    # a dict\\n                    if \\'file\\' in details or \\'path\\' in details:\\n                        raise PundleException(\\'Unsupported Pipfile feature yet %s: %r\\' % (key, details))\\n                    if \\'git\\' in details:\\n                        # wow, this as a git package!\\n                        req = CustomReq(\\'git+%s#egg=%s\\' % (details[\\'git\\'], key), env, source=\\'Pipfile\\')\\n                    else:\\n                        # else just simple requirement\\n                        req = CustomReq(key + details[\\'version\\'], env, source=\\'Pipfile\\')\\n                if req.key in all_requirements:\\n                    # if requirements exists in other env, then add this env too\\n                    all_requirements[req.key].add_env(env)\\n                else:\\n                    all_requirements[req.key] = req\\n        return all_requirements\\n\\n    def parse_frozen(self):\\n        parsed_frozen = self.pipfile_lock_content()\\n        if parsed_frozen is None:\\n            return {}\\n        frozen_versions = {}\\n        for env in parsed_frozen:\\n            if env.startswith(\\'_\\'):\\n                # this is not an env\\n                continue\\n            for key, details in parsed_frozen[env].items():\\n                if \\'vcs\\' in details:\\n                    frozen_versions[key] = details[\\'vcs\\']\\n                else:\\n                    frozen_versions[key] = details.get(\\'version\\', \\'0.0.0\\').lstrip(\\'=\\')\\n        return frozen_versions\\n\\n    def parse_frozen_hashes(self):\\n        parsed_frozen = self.pipfile_lock_content()\\n        if parsed_frozen is None:\\n            return {}\\n        frozen_versions = {}\\n        for env in parsed_frozen:\\n            if env.startswith(\\'_\\'):\\n                # this is not an env\\n                continue\\n            for key, details in parsed_frozen[env].items():\\n                frozen_versions[key] = details.get(\\'hashes\\', [])\\n        return frozen_versions\\n\\n    def hash(self):\\n        \"\"\"Returns the SHA256 of the pipfile\\'s data.\\n        From pipfile.\\n        \"\"\"\\n        pipfile_content = self.pipfile_content()\\n        data = {\\n            \\'_meta\\': {\\n                \\'sources\\': pipfile_content.get(\\'sources\\') or self.DEFAULT_PIPFILE_SOURCES,\\n                \\'requires\\': pipfile_content.get(\\'requires\\') or {},\\n            },\\n            \\'default\\': pipfile_content.get(\\'packages\\') or {},\\n            \\'develop\\': pipfile_content.get(\\'dev-packages\\') or {},\\n        }\\n        content = json.dumps(data, sort_keys=True, separators=(\",\", \":\"))\\n        return hashlib.sha256(content.encode(\"utf8\")).hexdigest()\\n\\n    def save_frozen(self, states_by_env):\\n        \"\"\"Implementation is not complete.\\n        \"\"\"\\n        data = self.pipfile_lock_content() or {}\\n        data.setdefault(\\'_meta\\', {\\n            \\'pipfile-spec\\': 5,\\n            \\'requires\\': {},\\n            \\'sources\\': self.DEFAULT_PIPFILE_SOURCES,\\n        })\\n        data.setdefault(\\'_meta\\', {}).setdefault(\\'hash\\', {})[\\'sha256\\'] = self.hash()\\n        for env, states in states_by_env.items():\\n            if env == \\'\\':\\n                env_key = \\'default\\'\\n            elif env == \\'dev\\':\\n                env_key = \\'develop\\'\\n            else:\\n                env_key = env\\n            reqs = data.setdefault(env_key, {})\\n            for state in states:\\n                if state.requirement.egg:\\n                    egg, url, version = parse_vcs_requirement(state.requirement.line)\\n                    reqs[state.key] = {\\n                        \\'vcs\\': url,\\n                    }\\n                else:\\n                    reqs[state.key] = {\\n                        \\'version\\': \\'==\\' + state.frozen,\\n                        \\'hashes\\': state.hashes or [],\\n                    }\\n        with open(self.pipfile + \\'.lock\\', \\'w\\') as f:\\n            f.write(json.dumps(data, sort_keys=True, indent=4))\\n\\n\\ndef create_parser(**parser_args):\\n    \"\"\"Utility function that tried to figure out what Parser to use\\n    in current directory.\\n    \"\"\"\\n    if parser_args.get(\\'requirements_files\\'):\\n        return Parser(**parser_args)\\n    elif parser_args.get(\\'package\\'):\\n        return SetupParser(**parser_args)\\n    elif parser_args.get(\\'pipfile\\'):\\n        return PipfileParser(**parser_args)\\n    return SingleParser(**parser_args)\\n\\n\\n# Utilities\\ndef get_info_from_setup(path):\\n    \"\"\"Mock setuptools.setup(**kargs) to get\\n    package information about requirements and extras\\n    \"\"\"\\n    preserve = {}\\n\\n    def _save_info(**setup_args):\\n        preserve[\\'args\\'] = setup_args\\n\\n    import setuptools\\n    original_setup = setuptools.setup\\n    setuptools.setup = _save_info\\n    import runpy\\n    runpy.run_path(os.path.join(path, \\'setup.py\\'), run_name=\\'__main__\\')\\n    setuptools.setup = original_setup\\n    return preserve.get(\\'args\\')\\n\\n\\ndef search_files_upward(start_path=None):\\n    \"Search for requirements.txt, setup.py or Pipfile upward\"\\n    if not start_path:\\n        start_path = op.abspath(op.curdir)\\n    if any(\\n            op.exists(op.join(start_path, filename))\\n            for filename in (\\'requirements.txt\\', \\'setup.py\\', \\'Pipfile\\')\\n    ):\\n        return start_path\\n    up_path = op.abspath(op.join(start_path, \\'..\\'))\\n    if op.samefile(start_path, up_path):\\n        return None\\n    return search_files_upward(start_path=up_path)\\n\\n\\ndef find_all_prefixed_files(directory, prefix):\\n    \"find all requirements_*.txt files\"\\n    envs = {}\\n    for entry in os.listdir(directory):\\n        if not entry.startswith(prefix):\\n            continue\\n        name, ext = op.splitext(entry)\\n        env = name[len(prefix):].lstrip(\\'_\\')\\n        envs[env] = op.join(directory, entry)\\n    return envs\\n\\n\\ndef create_parser_parameters():\\n    base_path = search_files_upward()\\n    if not base_path:\\n        raise PundleException(\\'Can not find requirements.txt nor setup.py nor Pipfile\\')\\n    py_version_path = python_version_string()\\n    pundledir_base = os.environ.get(\\'PUNDLEDIR\\') or op.join(op.expanduser(\\'~\\'), \\'.pundledir\\')\\n    if op.exists(op.join(base_path, \\'requirements.txt\\')):\\n        requirements_files = find_all_prefixed_files(base_path, \\'requirements\\')\\n    else:\\n        requirements_files = {}\\n    envs = list(requirements_files.keys()) or [\\'\\']\\n    params = {\\n        \\'base_path\\': base_path,\\n        \\'frozen_files\\': {\\n            env: op.join(base_path, \\'frozen_%s.txt\\' % env if env else \\'frozen.txt\\')\\n            for env in envs\\n        },\\n        \\'directory\\': op.join(pundledir_base, py_version_path),\\n    }\\n    if requirements_files:\\n        params[\\'requirements_files\\'] = requirements_files\\n    elif op.exists(op.join(base_path, \\'setup.py\\')):\\n        params[\\'package\\'] = base_path\\n    elif op.exists(op.join(base_path, \\'Pipfile\\')):\\n        params[\\'pipfile\\'] = op.join(base_path, \\'Pipfile\\')\\n    else:\\n        return\\n    return params\\n\\n\\ndef create_parser_or_exit():\\n    parser_kw = create_parser_parameters()\\n    if not parser_kw:\\n        print_message(\\'You have not requirements.txt. Create it and run again.\\')\\n        exit(1)\\n    return parser_kw\\n\\n\\n# Commands\\ndef upgrade_all(**kw):\\n    key = kw.pop(\\'key\\')\\n    prereleases = kw.pop(\\'prereleases\\')\\n    suite = create_parser(**kw).create_suite()\\n    suite.need_freeze()\\n    suite.upgrade(key=key, prereleases=prereleases)\\n    suite.install()\\n    suite.save_frozen()\\n\\n\\ndef install_all(**kw):\\n    suite = create_parser(**kw).create_suite()\\n    if suite.need_freeze() or suite.need_install():\\n        print_message(\\'Install some packages\\')\\n        suite.install()\\n    else:\\n        print_message(\\'Nothing to do, all packages installed\\')\\n    suite.save_frozen()\\n    return suite\\n\\n\\ndef activate():\\n    parser_kw = create_parser_parameters()\\n    if not parser_kw:\\n        raise PundleException(\\'Can`t create parser parameters\\')\\n    suite = create_parser(**parser_kw).create_suite()\\n    if suite.need_freeze(verbose=True):\\n        raise PundleException(\\'frozen file is outdated\\')\\n    if suite.need_install():\\n        raise PundleException(\\'Some dependencies not installed\\')\\n    envs = (os.environ.get(\\'PUNDLEENV\\') or \\'\\').split(\\',\\')\\n    suite.activate_all(envs=envs)\\n    return suite\\n\\n\\nFIXATE_TEMPLATE = \"\"\"\\n# pundle user customization start\\nimport pundle; pundle.activate()\\n# pundle user customization end\\n\"\"\"\\n\\n\\ndef fixate():\\n    \"puts activation code to usercustomize.py for user\"\\n    print_message(\\'Fixate\\')\\n    import site\\n    userdir = site.getusersitepackages()\\n    if not userdir:\\n        raise PundleException(\\'Can`t fixate due user have not site package directory\\')\\n    try:\\n        makedirs(userdir)\\n    except OSError:\\n        pass\\n    template = FIXATE_TEMPLATE.replace(\\'op.dirname(__file__)\\', \"\\'%s\\'\" % op.abspath(op.dirname(__file__)))\\n    usercustomize_file = op.join(userdir, \\'usercustomize.py\\')\\n    print_message(\\'Will edit %s file\\' % usercustomize_file)\\n    if op.exists(usercustomize_file):\\n        content = open(usercustomize_file).read()\\n        if \\'# pundle user customization start\\' in content:\\n            regex = re.compile(r\\'\\\\n# pundle user customization start.*# pundle user customization end\\\\n\\', re.DOTALL)\\n            content, res = regex.subn(template, content)\\n            open(usercustomize_file, \\'w\\').write(content)\\n        else:\\n            open(usercustomize_file, \\'a\\').write(content)\\n    else:\\n        open(usercustomize_file, \\'w\\').write(template)\\n    link_file = op.join(userdir, \\'pundle.py\\')\\n    if op.lexists(link_file):\\n        print_message(\\'Remove exist link to pundle\\')\\n        os.unlink(link_file)\\n    print_message(\\'Create link to pundle %s\\' % link_file)\\n    os.symlink(op.abspath(__file__), link_file)\\n    print_message(\\'Complete\\')\\n\\n\\ndef entry_points():\\n    suite = activate()\\n    entries = {}\\n    for r in suite.states.values():\\n        d = r.frozen_dist()\\n        if not d:\\n            continue\\n        if isinstance(d, VCSDist):\\n            continue\\n        scripts = d.get_entry_map().get(\\'console_scripts\\', {})\\n        for name in scripts:\\n            entries[name] = d\\n    return entries\\n\\n\\nclass CmdRegister:\\n    commands = {}\\n    ordered = []\\n\\n    @classmethod\\n    def cmdline(cls, *cmd_aliases):\\n        def wrap(func):\\n            for alias in cmd_aliases:\\n                cls.commands[alias] = func\\n                cls.ordered.append(alias)\\n        return wrap\\n\\n    @classmethod\\n    def help(cls):\\n        for alias in cls.ordered:\\n            if not alias:\\n                continue\\n            print(\"{:15s} {}\".format(alias, cls.commands[alias].__doc__))\\n\\n    @classmethod\\n    def main(cls):\\n        alias = \\'\\' if len(sys.argv) == 1 else sys.argv[1]\\n        if alias == \\'help\\':\\n            cls.help()\\n            return\\n        if alias not in cls.commands:\\n            print(\\'Unknown command\\\\nTry this:\\')\\n            cls.help()\\n            sys.exit(1)\\n        cls.commands[alias]()\\n\\n\\n@CmdRegister.cmdline(\\'\\', \\'install\\')\\ndef cmd_install():\\n    \"Install packages by frozen.txt and resolve ones that was not frozen\"\\n    install_all(**create_parser_or_exit())\\n\\n\\n@CmdRegister.cmdline(\\'upgrade\\')\\ndef cmd_upgrade():\\n    \"\"\"\\n    [package [pre]] if package provided will upgrade it and dependencies or all packages from PyPI.\\n    If `pre` provided will look for prereleases.\\n    \"\"\"\\n    key = sys.argv[2] if len(sys.argv) > 2 else None\\n    prereleases = sys.argv[3] == \\'pre\\' if len(sys.argv) > 3 else False\\n    upgrade_all(key=key, prereleases=prereleases, **create_parser_or_exit())\\n\\n\\nCmdRegister.cmdline(\\'fixate\\')(fixate)\\n\\n\\n@CmdRegister.cmdline(\\'exec\\')\\ndef cmd_exec():\\n    \"executes setuptools entry\"\\n    cmd = sys.argv[2]\\n    args = sys.argv[3:]\\n    entries = entry_points()\\n    if cmd not in entries:\\n        print_message(\\'Script is not found. Check if package is installed, or look at the `pundle entry_points`\\')\\n        sys.exit(1)\\n    exc = entries[cmd].get_entry_info(\\'console_scripts\\', cmd).load()\\n    sys.path.insert(0, \\'\\')\\n    sys.argv = [cmd] + args\\n    exc()\\n\\n\\n@CmdRegister.cmdline(\\'entry_points\\')\\ndef cmd_entry_points():\\n    \"prints available setuptools entries\"\\n    for entry, package in entry_points().items():\\n        print(\\'%s (%s)\\' % (entry, package))\\n\\n\\n@CmdRegister.cmdline(\\'edit\\')\\ndef cmd_edit():\\n    \"prints directory path to package\"\\n    parser_kw = create_parser_parameters()\\n    suite = create_parser(**parser_kw).create_suite()\\n    if suite.need_freeze():\\n        raise PundleException(\\'%s file is outdated\\' % suite.parser.frozen_file)\\n    print(suite.states[sys.argv[2]].frozen_dist().location)\\n\\n\\n@CmdRegister.cmdline(\\'info\\')\\ndef cmd_info():\\n    \"prints info about Pundle state\"\\n    parser_kw = create_parser_parameters()\\n    suite = create_parser(**parser_kw).create_suite()\\n    if suite.need_freeze():\\n        print(\\'frozen.txt is outdated\\')\\n    else:\\n        print(\\'frozen.txt is up to date\\')\\n    for state in suite.required_states():\\n        print(\\n            \\'Requirement \"{}\", frozen {}, {}\\'.format(\\n                state.key,\\n                state.frozen,\\n                state.requirement.line if state.requirement else \\'None\\'\\n            )\\n        )\\n        print(\\'Installed versions:\\')\\n        for dist in state.installed:\\n            print(\\'    \\', repr(dist))\\n        if not state.installed:\\n            print(\\'     None\\')\\n\\n\\ndef run_console(glob):\\n    import readline\\n    import rlcompleter\\n    import atexit\\n    import code\\n\\n    history_path = os.path.expanduser(\"~/.python_history\")\\n\\n    def save_history(history_path=history_path):\\n        readline.write_history_file(history_path)\\n    if os.path.exists(history_path):\\n        readline.read_history_file(history_path)\\n\\n    atexit.register(save_history)\\n\\n    readline.set_completer(rlcompleter.Completer(glob).complete)\\n    readline.parse_and_bind(\"tab: complete\")\\n    code.InteractiveConsole(locals=glob).interact()\\n\\n\\n@CmdRegister.cmdline(\\'console\\')\\ndef cmd_console():\\n    \"[ipython|bpython|ptpython] starts python console with activated pundle environment\"\\n    suite = activate()\\n    glob = {\\n        \\'pundle_suite\\': suite,\\n    }\\n    interpreter = sys.argv[2] if len(sys.argv) > 2 else None\\n    if not interpreter:\\n        run_console(glob)\\n    elif interpreter == \\'ipython\\':\\n        from IPython import embed\\n        embed()\\n    elif interpreter == \\'ptpython\\':\\n        from ptpython.repl import embed\\n        embed(glob, {})\\n    elif interpreter == \\'bpython\\':\\n        from bpython import embed\\n        embed(glob)\\n    else:\\n        raise PundleException(\\'Unknown interpreter: {}. Choose one of None, ipython, bpython, ptpython.\\')\\n\\n\\n@CmdRegister.cmdline(\\'run\\')\\ndef cmd_run():\\n    \"executes given script\"\\n    activate()\\n    import runpy\\n    sys.path.insert(0, \\'\\')\\n    script = sys.argv[2]\\n    sys.argv = [sys.argv[2]] + sys.argv[3:]\\n    runpy.run_path(script, run_name=\\'__main__\\')\\n\\n\\n@CmdRegister.cmdline(\\'module\\')\\ndef cmd_module():\\n    \"executes module like `python -m`\"\\n    activate()\\n    import runpy\\n    sys.path.insert(0, \\'\\')\\n    module = sys.argv[2]\\n    sys.argv = [sys.argv[2]] + sys.argv[3:]\\n    runpy.run_module(module, run_name=\\'__main__\\')\\n\\n\\n@CmdRegister.cmdline(\\'env\\')\\ndef cmd_env():\\n    \"populates PYTHONPATH with packages paths and executes command line in subprocess\"\\n    activate()\\n    aug_env = os.environ.copy()\\n    aug_env[\\'PYTHONPATH\\'] = \\':\\'.join(sys.path)\\n    subprocess.call(sys.argv[2:], env=aug_env)\\n\\n\\n@CmdRegister.cmdline(\\'print_env\\')\\ndef cmd_print_env():\\n    \"Prints PYTHONPATH. For usage with mypy and MYPYPATH\"\\n    suite = activate()\\n    path = \\':\\'.join(\\n        state.frozen_dist().location\\n        for state in suite.states.values()\\n        if state.frozen_dist()\\n    )\\n    print(path)\\n\\n\\nENTRY_POINT_TEMPLATE = \\'\\'\\'#! /usr/bin/env python\\nimport pundle; pundle.activate()\\npundle.entry_points()[\\'{entry_point}\\'].get_entry_info(\\'console_scripts\\', \\'{entry_point}\\').load(require=False)()\\n\\'\\'\\'\\n\\n\\n@CmdRegister.cmdline(\\'linkall\\')\\ndef link_all():\\n    \"links all packages to `.pundle_local` dir\"\\n    local_dir = \\'.pundle_local\\'\\n    suite = activate()\\n\\n    try:\\n        makedirs(local_dir)\\n    except OSError:\\n        pass\\n    local_dir_info = {de.name: de for de in os.scandir(local_dir)}\\n    for r in suite.states.values():\\n        d = r.frozen_dist()\\n        if not d:\\n            continue\\n        for dir_entry in os.scandir(d.location):\\n            if dir_entry.name.startswith(\\'__\\') or dir_entry.name.startswith(\\'.\\') or dir_entry.name == \\'bin\\':\\n                continue\\n            dest_path = os.path.join(local_dir, dir_entry.name)\\n            if dir_entry.name in local_dir_info:\\n                sym = local_dir_info.pop(dir_entry.name)\\n                existed = op.realpath(sym.path)\\n                if existed == dir_entry.path:\\n                    continue\\n                os.remove(sym.path)\\n            os.symlink(dir_entry.path, dest_path)\\n    # create entry_points binaries\\n    try:\\n        makedirs(os.path.join(local_dir, \\'bin\\'))\\n    except OSError:\\n        pass\\n    for bin_name, entry_point in entry_points().items():\\n        bin_filename = os.path.join(local_dir, \\'bin\\', bin_name)\\n        open(bin_filename, \\'w\\').write(ENTRY_POINT_TEMPLATE.format(entry_point=bin_name))\\n        file_stat = os.stat(bin_filename)\\n        os.chmod(bin_filename, file_stat.st_mode | stat.S_IEXEC)\\n    local_dir_info.pop(\\'bin\\')\\n\\n    # remove extra links\\n    for de in local_dir_info:\\n        os.remove(de.path)\\n\\n\\n@CmdRegister.cmdline(\\'show_requirements\\')\\ndef show_requirements():\\n    \"shows details requirements info\"\\n    suite = activate()\\n    for name, state in suite.states.items():\\n        if state.requirement:\\n            print(\\n                name,\\n                \\'frozen:\\',\\n                state.frozen,\\n                \\'required:\\',\\n                state.requirement.req if state.requirement.req else \\'VCS\\',\\n                state.requirement.envs,\\n            )\\n\\n\\n# Single mode that you can use in console\\n_single_mode_suite = {}  # cache variable to keep current suite for single_mode\\n\\n\\ndef single_mode():\\n    \"\"\" Create, cache and return Suite instance for single_mode.\\n    \"\"\"\\n    if not _single_mode_suite:\\n        py_version_path = python_version_string()\\n        pundledir_base = os.environ.get(\\'PUNDLEDIR\\') or op.join(op.expanduser(\\'~\\'), \\'.pundledir\\')\\n        directory = op.join(pundledir_base, py_version_path)\\n        _single_mode_suite[\\'cache\\'] = create_parser(directory=directory).create_suite()\\n    return _single_mode_suite[\\'cache\\']\\n\\n\\ndef use(key):\\n    \"\"\" Installs `key` requirement, like `django==1.11` or just `django`\\n    \"\"\"\\n    suite = single_mode()\\n    suite.use(key)\\n\\n\\nif __name__ == \\'__main__\\':\\n    CmdRegister.main()\\n'"}, "return_value": "'# (deleted declaration)\\n\"\"\"\\nData Model, start here to not get mad\\n=====================================\\n\\nMain entity will be distribution, like Flask. Per key\\nPundle tracks three state parts:\\n    1. requirement, like Flask>0.12.2.\\n    2. frozen version, like ==0.12.2\\n    3. installed distributions, like [flask==0.12.2, flask==0.10.0]\\n\\nRequirement basically is from file, like requirements.txt, setup.py or Pipfile. This requirements\\nhave source like `requirements.txt`. And base requirements can have dependencies. This\\ndependencies are turned to requirements too with source like `Flask-Admin << requirements.txt`.\\nTo track requirements we use `CustomReq` class. It can work with PyPi and VCS requirements.\\nCustomReq can have `self.req = pkg_resources.Requirement` or custom vcs line.\\n\\nDistribution is one of VCSDist or pkg_resources.DistInfoDistribution. VCSDist is to\\ntrack installed VCS packages and pkg_resources.DistInfoDistribution is for PyPi packages.\\n\\nAll three states of distribution are tracked inside `RequirementState` object that includes info\\nabout requirement, frozen version and installed versions.\\n\\n`Suite` keeps state of all distributions like a dictionary of RequirentStates.\\n\\nTo populate Suite and to parse all requirements, frozen versions and what we have installed pundle\\nuses `Parser`. There is plenty of them - `Parser` that works with `requirements.txt`,\\n`SetupParser` that works with `setup.py`, PipfileParser that works with Pipfile and Pipfile.lock.\\n\"\"\"\\n\\nfrom __future__ import print_function\\nimport re\\ntry:\\n    from urllib.parse import urlparse, parse_qsl\\nexcept ImportError:  # pragma: no cover\\n    from urlparse import urlparse, parse_qsl\\nfrom collections import defaultdict\\nfrom base64 import b64encode, b64decode\\nimport platform\\nimport os.path as op\\nimport os\\nfrom os import makedirs\\nimport stat\\nimport tempfile\\nimport shutil\\nimport subprocess\\nimport sys\\nimport shlex\\nimport json\\nimport hashlib\\nimport pkg_resources\\ntry:\\n    from pip import main as pip_exec\\nexcept ImportError:\\n    from pip._internal import main as pip_exec\\n    from types import ModuleType\\n\\n    if isinstance(pip_exec, ModuleType):\\n        pip_exec = pip_exec.main\\n\\n# TODO bundle own version of distlib. Perhaps\\ntry:\\n    from pip._vendor.distlib import locators\\nexcept ImportError:  # pragma: no cover\\n    from pip.vendor.distlib import locators\\n\\ntry:\\n    str_types = (basestring,)\\nexcept NameError:  # pragma: no cover\\n    str_types = (str, bytes)\\n\\ntry:\\n    pkg_resources_parse_version = pkg_resources.SetuptoolsVersion\\nexcept AttributeError:  # pragma: no cover\\n    pkg_resources_parse_version = pkg_resources.packaging.version.Version\\n\\n\\ndef print_message(*a, **kw):\\n    print(*a, **kw)\\n\\n\\nclass PundleException(Exception):\\n    pass\\n\\n\\ndef python_version_string():\\n    \"\"\"We use it to generate per python folder name, where\\n    we will install all packages.\\n    \"\"\"\\n    if platform.python_implementation() == \\'PyPy\\':\\n        version_info = sys.pypy_version_info\\n    else:\\n        version_info = sys.version_info\\n    version_string = \\'{v.major}.{v.minor}.{v.micro}\\'.format(v=version_info)\\n    build, _ = platform.python_build()\\n    build = build.replace(\\':\\', \\'_\\')  # windows do not understand `:` in path\\n    return \\'{}-{}-{}\\'.format(platform.python_implementation(), version_string, build)\\n\\n\\ndef parse_file(filename):\\n    \"\"\"Helper to parse requirements.txt or frozen.txt.\\n    \"\"\"\\n    res = []\\n    with open(filename) as f:\\n        for line in f:\\n            s = line.strip()\\n            if s and not s.startswith(\\'#\\'):\\n                if s.startswith(\\'-r\\'):\\n                    continue\\n                if s.startswith(\\'-e \\'):\\n                    s = s[3:].strip()\\n                if parse_vcs_requirement(s):\\n                    res.append(s)\\n                else:\\n                    req = shlex.split(s, comments=True)\\n                    res.append(req[0])\\n    return res\\n\\n\\ndef test_vcs(req):\\n    \"\"\"Checks if requirement line is for VCS.\\n    \"\"\"\\n    return \\'+\\' in req and req.index(\\'+\\') == 3\\n\\n\\ndef parse_vcs_requirement(req):\\n    \"\"\"Parses VCS line to egg name, version etc.\\n    \"\"\"\\n    if \\'+\\' not in req:\\n        return None\\n    vcs, url = req.split(\\'+\\', 1)\\n    if vcs not in (\\'git\\', \\'svn\\', \\'hg\\'):\\n        return None\\n    parsed_url = urlparse(url)\\n    parsed = dict(parse_qsl(parsed_url.fragment))\\n    if \\'egg\\' not in parsed:\\n        return None\\n    egg = parsed[\\'egg\\'].rsplit(\\'-\\', 1)\\n    if len(egg) > 1:\\n        try:\\n            pkg_resources_parse_version(egg[1])\\n        except pkg_resources._vendor.packaging.version.InvalidVersion:\\n            return parsed[\\'egg\\'].lower(), req, None\\n        return egg[0].lower(), req, egg[1]\\n    else:\\n        return parsed[\\'egg\\'].lower(), req, None\\n\\n\\ndef parse_frozen_vcs(req):\\n    res = parse_vcs_requirement(req)\\n    if not res:\\n        return\\n    return res[0], res[1]\\n\\n\\nclass VCSDist(object):\\n    \"\"\" Represents installed VCS distribution.\\n    \"\"\"\\n    def __init__(self, directory):\\n        self.dir = directory\\n        name = op.split(directory)[-1]\\n        key, encoded = name.split(\\'+\\', 1)\\n        self.key = key.lower()\\n        self.line = b64decode(encoded).decode(\\'utf-8\\')\\n        egg, req, version = parse_vcs_requirement(self.line)\\n        version = version or \\'0.0.0\\'\\n        self.hashcmp = (pkg_resources_parse_version(version), -1, egg, self.dir)\\n        self.version = self.line\\n        self.pkg_resource = next(iter(pkg_resources.find_distributions(self.dir, True)), None)\\n        self.location = self.pkg_resource.location\\n\\n    def requires(self, extras=[]):\\n        return self.pkg_resource.requires(extras=extras)\\n\\n    def activate(self):\\n        return self.pkg_resource.activate()\\n\\n    def __lt__(self, other):\\n        return self.hashcmp.__lt__(other.hashcmp)\\n\\n\\nclass CustomReq(object):\\n    \"\"\"Represents PyPi or VCS requirement.\\n    Can locate and install it.\\n    \"\"\"\\n    def __init__(self, line, env, source=None):\\n        self.line = line\\n        self.egg = None\\n        if isinstance(line, pkg_resources.Requirement):\\n            self.req = line\\n        elif test_vcs(line):\\n            res = parse_vcs_requirement(line)\\n            if not res:\\n                raise PundleException(\\'Bad url %r\\' % line)\\n            egg, req, version = res\\n            self.egg = egg\\n            self.req = None  # pkg_resources.Requirement.parse(res)\\n        else:\\n            self.req = pkg_resources.Requirement.parse(line)\\n        self.sources = set([source])\\n        self.envs = set()\\n        self.add_env(env)\\n\\n    def __contains__(self, something):\\n        if self.req:\\n            return (something in self.req)\\n        elif self.egg:\\n            return something == self.line\\n        else:\\n            return False\\n\\n    def __repr__(self):\\n        return \\'<CustomReq %r>\\' % self.__dict__\\n\\n    def why_str(self):\\n        if len(self.sources) < 2:\\n            return \\'{} << {}\\'.format(self.line, self.why_str_one(list(self.sources)[0]))\\n        causes = list(sorted(self.why_str_one(source) for source in self.sources))\\n        return \\'{} << [{}]\\'.format(self.line, \\' | \\'.join(causes))\\n\\n    def why_str_one(self, source):\\n        if isinstance(source, str_types):\\n            return source\\n        elif isinstance(source, CustomReq):\\n            return source.why_str()\\n        return \\'?\\'\\n\\n    def adjust_with_req(self, req):\\n        if not self.req:\\n            return\\n            raise PundleException(\\'VCS\\')\\n        versions = \\',\\'.join(\\'\\'.join(t) for t in set(self.req.specs + req.req.specs))\\n        self.requirement = pkg_resources.Requirement.parse(\\'{} {}\\'.format(\\n            self.req.project_name, versions\\n        ))\\n        self.sources.update(req.sources)\\n        self.add_env(req.envs)\\n\\n    @property\\n    def key(self):\\n        return self.req.key if self.req else self.egg\\n\\n    @property\\n    def extras(self):\\n        return self.req.extras if self.req else []\\n\\n    def locate(self, suite, prereleases=False):\\n        # requirements can have something after `;` symbol that `locate` does not understand\\n        req = str(self.req).split(\\';\\', 1)[0]\\n        dist = suite.locate(req, prereleases=prereleases)\\n        if not dist:\\n            # have not find any releases so search for pre\\n            dist = suite.locate(req, prereleases=True)\\n        if not dist:\\n            raise PundleException(\\'%s can not be located\\' % self.req)\\n        return dist\\n\\n    def locate_and_install(self, suite, installed=None, prereleases=False):\\n        if self.egg:\\n            key = b64encode(self.line.encode(\\'utf-8\\')).decode()\\n            target_dir = op.join(suite.parser.directory, \\'{}+{}\\'.format(self.egg, key))\\n            target_req = self.line\\n            ready = [\\n                installation\\n                for installation in (installed or [])\\n                if getattr(installation, \\'line\\', None) == self.line\\n            ]\\n        else:\\n            loc_dist = self.locate(suite, prereleases=prereleases)\\n            ready = [\\n                installation\\n                for installation in (installed or [])\\n                if installation.version == loc_dist.version\\n            ]\\n            target_dir = op.join(suite.parser.directory, \\'{}-{}\\'.format(loc_dist.key, loc_dist.version))\\n            # DEL? target_req = \\'%s==%s\\' % (loc_dist.name, loc_dist.version)\\n            # If we use custom index, then we want not to configure PIP with it\\n            # and just give it URL\\n            target_req = loc_dist.download_url\\n        if ready:\\n            return ready[0]\\n        try:\\n            makedirs(target_dir)\\n        except OSError:\\n            pass\\n        tmp_dir = tempfile.mkdtemp()\\n        print(\\'Use temp dir\\', tmp_dir)\\n        try:\\n            print(\\'pip install --no-deps -t %s %s\\' % (tmp_dir, target_req))\\n            pip_exec([\\n                \\'install\\',\\n                \\'--no-deps\\',\\n                \\'-t\\', tmp_dir,\\n                \\'-v\\',\\n                target_req\\n            ])\\n            for item in os.listdir(tmp_dir):\\n                shutil.move(op.join(tmp_dir, item), op.join(target_dir, item))\\n        except Exception as exc:\\n            raise PundleException(\\'%s was not installed due error %s\\' % (self.egg or loc_dist.name, exc))\\n        finally:\\n            shutil.rmtree(tmp_dir, ignore_errors=True)\\n        return next(iter(pkg_resources.find_distributions(target_dir, True)), None)\\n\\n    def add_env(self, env):\\n        if isinstance(env, str):\\n            self.envs.add(env)\\n        else:\\n            self.envs.update(env)\\n\\n\\nclass RequirementState(object):\\n    \"\"\"Holds requirement state, like what version do we have installed, is\\n    some version frozen or not, what requirement constrains do we have.\\n    \"\"\"\\n    def __init__(self, key, req=None, frozen=None, installed=None, hashes=None):\\n        self.key = key\\n        self.requirement = req\\n        self.frozen = frozen\\n        self.hashes = hashes\\n        self.installed = installed or []\\n        self.installed.sort()\\n        self.installed.reverse()\\n\\n    def __repr__(self):\\n        return \\'<RequirementState %r>\\' % self.__dict__\\n\\n    def adjust_with_req(self, req):\\n        if self.requirement:\\n            self.requirement.adjust_with_req(req)\\n        else:\\n            self.requirement = req\\n\\n    def has_correct_freeze(self):\\n        return self.requirement and self.frozen and self.frozen in self.requirement\\n\\n    def check_installed_version(self, suite, install=False):\\n        # install version of package if not installed\\n        dist = None\\n        if self.has_correct_freeze():\\n            dist = [\\n                installation\\n                for installation in self.installed\\n                if pkg_resources.parse_version(installation.version) == pkg_resources.parse_version(self.frozen)\\n            ]\\n            dist = dist[0] if dist else None\\n            if install and not dist:\\n                dist = self.install_frozen(suite)\\n        if install and not dist:\\n            dist = self.requirement.locate_and_install(suite, installed=self.get_installed())\\n            if dist is None:\\n                raise PundleException(\\'Package %s was not installed due some error\\' % self.key)\\n            self.frozen = dist.version\\n            self.installed.append(dist)\\n            self.frozen = dist.version\\n        return dist\\n\\n    def get_installed(self):\\n        return [installation for installation in self.installed if installation.version in self.requirement]\\n\\n    def upgrade(self, suite, prereleases=False):\\n        # check if we have fresh packages on PIPY\\n        dists = self.get_installed()\\n        dist = dists[0] if dists else None\\n        latest = self.requirement.locate(suite, prereleases=prereleases)\\n        if not dist or pkg_resources.parse_version(latest.version) > pkg_resources.parse_version(dist.version):\\n            print_message(\\'Upgrade to\\', latest)\\n            dist = self.requirement.locate_and_install(suite, installed=self.get_installed(), prereleases=prereleases)\\n        # Anyway use latest available dist\\n        self.frozen = dist.version\\n        self.installed.append(dist)\\n        return dist\\n\\n    def reveal_requirements(self, suite, install=False, upgrade=False, already_revealed=None, prereleases=False):\\n        already_revealed = already_revealed.copy() if already_revealed is not None else set()\\n        if self.key in already_revealed:\\n            return\\n        if upgrade:\\n            dist = self.upgrade(suite, prereleases=prereleases)\\n        else:\\n            dist = self.check_installed_version(suite, install=install)\\n        if not dist:\\n            return\\n        already_revealed.add(self.key)\\n        for req in dist.requires(extras=self.requirement.extras):\\n            suite.adjust_with_req(\\n                CustomReq(str(req), self.requirement.envs, source=self.requirement),\\n                install=install,\\n                upgrade=upgrade,\\n                already_revealed=already_revealed,\\n            )\\n\\n    def frozen_dump(self):\\n        if self.requirement.egg:\\n            return self.requirement.line\\n        main = \\'{}=={}\\'.format(self.key, self.frozen)\\n        comment = self.requirement.why_str()\\n        return \\'{:20s} # {}\\'.format(main, comment)\\n\\n    def frozen_dist(self):\\n        if not self.frozen:\\n            return\\n        for dist in self.installed:\\n            if pkg_resources.parse_version(dist.version) == pkg_resources.parse_version(self.frozen):\\n                return dist\\n\\n    def install_frozen(self, suite):\\n        if self.frozen_dist() or not self.frozen:\\n            return\\n        envs = self.requirement.envs if self.requirement else \\'\\'\\n        if test_vcs(self.frozen):\\n            frozen_req = CustomReq(self.frozen, envs)\\n        else:\\n            frozen_req = CustomReq(\"{}=={}\".format(self.key, self.frozen), envs)\\n        dist = frozen_req.locate_and_install(suite)\\n        self.installed.append(dist)\\n        return dist\\n\\n    def activate(self):\\n        dist = self.frozen_dist()\\n        if not dist:\\n            raise PundleException(\\'Distribution is not installed %s\\' % self.key)\\n        dist.activate()\\n        pkg_resources.working_set.add_entry(dist.location)\\n        # find end execute *.pth\\n        sitedir = dist.location  # noqa some PTH search for sitedir\\n        for filename in os.listdir(dist.location):\\n            if not filename.endswith(\\'.pth\\'):\\n                continue\\n            try:\\n                for line in open(op.join(dist.location, filename)):\\n                    if line.startswith(\\'import \\'):\\n                        exec(line.strip())\\n            except Exception as e:\\n                print(\\'Erroneous pth file %r\\' % op.join(dist.location, filename))\\n                print(e)\\n\\n\\nclass AggregatingLocator(object):\\n    def __init__(self, locators):\\n        self.locators = locators\\n\\n    def locate(self, req, **kw):\\n        for locator in self.locators:\\n            print_message(\\'try\\', locator, \\'for\\', req)\\n            revealed = locator.locate(req, **kw)\\n            if revealed:\\n                return revealed\\n\\n\\nclass Suite(object):\\n    \"\"\"Main object that represents current directory pundle state.\\n    It tracks RequirementStates, envs, urls for package locator.\\n    \"\"\"\\n    def __init__(self, parser, envs=[], urls=None):\\n        self.states = {}\\n        self.parser = parser\\n        self.envs = envs\\n        self.urls = urls or [\\'https://pypi.python.org/simple/\\']\\n        if \\'PIP_EXTRA_INDEX_URL\\' in os.environ:\\n            self.urls.append(os.environ[\\'PIP_EXTRA_INDEX_URL\\'])\\n        self.locators = []\\n        for url in self.urls:\\n            self.locators.append(\\n                locators.SimpleScrapingLocator(url, timeout=3.0, scheme=\\'legacy\\')\\n            )\\n        self.locators.append(locators.JSONLocator(scheme=\\'legacy\\'))\\n        self.locator = AggregatingLocator(self.locators)\\n\\n    def use(self, key):\\n        \"\"\"For single mode\\n        You can call suite.use(\\'arrow\\') and then `import arrow`\\n\\n        :key: package name\\n        \"\"\"\\n        self.adjust_with_req(CustomReq(key, \\'\\'))\\n        self.install()\\n        self.activate_all()\\n\\n    def locate(self, *a, **kw):\\n        return self.locator.locate(*a, **kw)\\n\\n    def add(self, key, state):\\n        self.states[key] = state\\n\\n    def __repr__(self):\\n        return \\'<Suite %r>\\' % self.states\\n\\n    def required_states(self):\\n        return [state for state in self.states.values() if state.requirement]\\n\\n    def need_freeze(self, verbose=False):\\n        self.install(install=False)\\n        not_correct = not all(state.has_correct_freeze() for state in self.required_states())\\n        if not_correct and verbose:\\n            for state in self.required_states():\\n                if not state.has_correct_freeze():\\n                    print(\\n                        state.key,\\n                        \\'Need\\',\\n                        state.requirement,\\n                        \\'have not been frozen\\',\\n                        state.frozen,\\n                        \\', installed\\',\\n                        state.installed\\n                    )\\n        # TODO\\n        # unneeded = any(state.frozen for state in self.states.values() if not state.requirement)\\n        # if unneeded:\\n        #     print(\\'!!! Unneeded\\', [state.key for state in self.states.values() if not state.requirement])\\n        return not_correct  # or unneeded\\n\\n    def adjust_with_req(self, req, install=False, upgrade=False, already_revealed=None):\\n        state = self.states.get(req.key)\\n        if not state:\\n            state = RequirementState(req.key, req=req)\\n            self.add(req.key, state)\\n        else:\\n            state.adjust_with_req(req)\\n        state.reveal_requirements(self, install=install, upgrade=upgrade, already_revealed=already_revealed or set())\\n\\n    def install(self, install=True):\\n        for state in self.required_states():\\n            state.reveal_requirements(self, install=install)\\n\\n    def upgrade(self, key=None, prereleases=False):\\n        states = [self.states[key]] if key else self.required_states()\\n        for state in states:\\n            print(\\'Check\\', state.requirement.req)\\n            state.reveal_requirements(self, upgrade=True, prereleases=prereleases)\\n\\n    def get_frozen_states(self, env):\\n        return [\\n            state\\n            for state in self.required_states()\\n            if state.requirement and env in state.requirement.envs\\n        ]\\n\\n    def need_install(self):\\n        return not all(state.frozen_dist() for state in self.states.values() if state.frozen)\\n\\n    def install_frozen(self):\\n        for state in self.states.values():\\n            state.install_frozen(self)\\n\\n    def activate_all(self, envs=(\\'\\',)):\\n        for state in self.required_states():\\n            if \\'\\' in state.requirement.envs or any(env in state.requirement.envs for env in envs):\\n                state.activate()\\n\\n    def save_frozen(self):\\n        \"Saves frozen files to disk\"\\n        states_by_env = dict(\\n            (env, self.get_frozen_states(env))\\n            for env in self.parser.envs()\\n        )\\n        self.parser.save_frozen(states_by_env)\\n\\n\\nclass Parser(object):\\n    \"\"\"Gather environment info, requirements,\\n    frozen packages and create Suite object\\n    \"\"\"\\n    def __init__(\\n            self,\\n            base_path=None,\\n            directory=\\'Pundledir\\',\\n            requirements_files=None,\\n            frozen_files=None,\\n            package=None,\\n    ):\\n        self.base_path = base_path or \\'.\\'\\n        self.directory = directory\\n        self.requirements_files = requirements_files\\n        if frozen_files is None:\\n            self.frozen_files = {\\'\\': \\'frozen.txt\\'}\\n        else:\\n            self.frozen_files = frozen_files\\n        self.package = package\\n        self.package_envs = set([\\'\\'])\\n\\n    def envs(self):\\n        if self.requirements_files:\\n            return list(self.requirements_files.keys()) or [\\'\\']\\n        elif self.package:\\n            return self.package_envs\\n        return [\\'\\']\\n\\n    def get_frozen_file(self, env):\\n        if env in self.frozen_files:\\n            return self.frozen_files[env]\\n        else:\\n            return os.path.join(self.base_path, \\'frozen_%s.txt\\' % env)\\n\\n    def create_suite(self):\\n        reqs = self.parse_requirements()\\n        freezy = self.parse_frozen()\\n        hashes = self.parse_frozen_hashes()\\n        diry = self.parse_directory()\\n        state_keys = set(list(reqs.keys()) + list(freezy.keys()) + list(diry.keys()))\\n        suite = Suite(self, envs=self.envs())\\n        for key in state_keys:\\n            suite.add(\\n                key,\\n                RequirementState(\\n                    key,\\n                    req=reqs.get(key),\\n                    frozen=freezy.get(key),\\n                    installed=diry.get(key, []),\\n                    hashes=hashes.get(key),\\n                ),\\n            )\\n        return suite\\n\\n    def parse_directory(self):\\n        if not op.exists(self.directory):\\n            return {}\\n        dists = [\\n            # this magic takes first element or None\\n            next(iter(\\n                pkg_resources.find_distributions(op.join(self.directory, item), True)\\n            ), None)\\n            for item in os.listdir(self.directory) if \\'-\\' in item\\n        ]\\n        dists.extend(\\n            VCSDist(op.join(self.directory, item))\\n            for item in os.listdir(self.directory) if \\'+\\' in item\\n        )\\n        dists = filter(None, dists)\\n        result = defaultdict(list)\\n        for dist in dists:\\n            result[dist.key].append(dist)\\n        return result\\n\\n    def parse_frozen(self):\\n        frozen_versions = {}\\n        for env in self.envs():\\n            frozen_file = self.get_frozen_file(env)\\n            if op.exists(frozen_file):\\n                frozen = [\\n                    (parse_frozen_vcs(line) or line.split(\\'==\\'))\\n                    for line in parse_file(frozen_file)\\n                ]\\n            else:\\n                frozen = []\\n            for name, version in frozen:\\n                frozen_versions[name.lower()] = version\\n        return frozen_versions\\n\\n    def parse_frozen_hashes(self):\\n        \"\"\"This implementation does not support hashes yet\\n        \"\"\"\\n        return {}\\n\\n    def parse_requirements(self):\\n        all_requirements = {}\\n        for env, req_file in self.requirements_files.items():\\n            requirements = parse_file(req_file)\\n            if env:\\n                source = \\'requirements %s file\\' % env\\n            else:\\n                source = \\'requirements file\\'\\n            for line in requirements:\\n                req = CustomReq(line, env, source=source)\\n                if req.key in all_requirements:\\n                    # if requirements exists in other env, then add this env too\\n                    all_requirements[req.key].add_env(env)\\n                else:\\n                    all_requirements[req.key] = req\\n        return all_requirements\\n\\n    def save_frozen(self, states_by_env):\\n        for env, states in states_by_env.items():\\n            data = \\'\\\\n\\'.join(sorted(\\n                state.frozen_dump()\\n                for state in states\\n            )) + \\'\\\\n\\'\\n            frozen_file = self.get_frozen_file(env)\\n            with open(frozen_file, \\'w\\') as f:\\n                f.write(data)\\n\\n\\nclass SingleParser(Parser):\\n    \"\"\"Parser for console mode.\\n    \"\"\"\\n    def parse_requirements(self):\\n        return {}\\n\\n\\nclass SetupParser(Parser):\\n    \"\"\"Parser for `setup.py`. Because it mostly used to develop package, we\\n    do not freeze packages to setup.py. We use `frozen.txt`.\\n    \"\"\"\\n    def parse_requirements(self):\\n        setup_info = get_info_from_setup(self.package)\\n        if setup_info is None:\\n            raise PundleException(\\'There is no requirements.txt nor setup.py\\')\\n        install_requires = setup_info.get(\\'install_requires\\') or []\\n        reqs = [\\n            CustomReq(str(req), \\'\\', source=\\'setup.py\\')\\n            for req in install_requires\\n        ]\\n        requirements = dict((req.key, req) for req in reqs)\\n        # we use `feature` as environment for pundle\\n        extras_require = (setup_info.get(\\'extras_require\\') or {})\\n        for feature, feature_requires in extras_require.items():\\n            for req_line in feature_requires:\\n                req = CustomReq(req_line, feature, source=\\'setup.py\\')\\n                # if this req already in dict, then add our feature as env\\n                if req.key in requirements:\\n                    requirements[req.key].add_env(feature)\\n                else:\\n                    requirements[req.key] = req\\n            self.package_envs.add(feature)\\n        return requirements\\n\\n\\nclass PipfileParser(Parser):\\n    \"\"\"Parser for Pipfile and Pipfile.lock.\\n    \"\"\"\\n    DEFAULT_PIPFILE_SOURCES = [\\n        {\\n            \\'name\\': \\'pypi\\',\\n            \\'url\\': \\'https://pypi.python.org/simple\\',\\n            \\'verify_ssl\\': True,\\n        },\\n    ]\\n\\n    def __init__(self, **kw):\\n        self.pipfile = kw.pop(\\'pipfile\\')\\n        self.pipfile_envs = set([\\'\\'])\\n        super(PipfileParser, self).__init__(**kw)\\n        # cache\\n        self.loaded_pipfile = None\\n        self.loaded_pipfile_lock = None\\n\\n    def envs(self):\\n        return self.pipfile_envs\\n\\n    def pipfile_content(self):\\n        import toml\\n        if self.loaded_pipfile:\\n            return self.loaded_pipfile\\n        self.loaded_pipfile = toml.load(open(self.pipfile))\\n        return self.loaded_pipfile\\n\\n    def pipfile_lock_content(self):\\n        if self.loaded_pipfile_lock:\\n            return self.loaded_pipfile_lock\\n        try:\\n            self.loaded_pipfile_lock = json.load(open(self.pipfile + \\'.lock\\'))\\n        except Exception:\\n            pass\\n        return self.loaded_pipfile_lock\\n\\n    def parse_requirements(self):\\n        info = self.pipfile_content()\\n        all_requirements = {}\\n        for info_key in info:\\n            if not info_key.endswith(\\'packages\\'):\\n                continue\\n            if \\'-\\' in info_key:\\n                env, _ = info_key.split(\\'-\\', 1)\\n            else:\\n                env = \\'\\'\\n            self.pipfile_envs.add(env)\\n            for key, details in info[info_key].items():\\n                if isinstance(details, str_types):\\n                    if details != \\'*\\':\\n                        key = key + details  # details is a version requirement\\n                    req = CustomReq(key, env, source=\\'Pipfile\\')\\n                else:\\n                    # a dict\\n                    if \\'file\\' in details or \\'path\\' in details:\\n                        raise PundleException(\\'Unsupported Pipfile feature yet %s: %r\\' % (key, details))\\n                    if \\'git\\' in details:\\n                        # wow, this as a git package!\\n                        req = CustomReq(\\'git+%s#egg=%s\\' % (details[\\'git\\'], key), env, source=\\'Pipfile\\')\\n                    else:\\n                        # else just simple requirement\\n                        req = CustomReq(key + details[\\'version\\'], env, source=\\'Pipfile\\')\\n                if req.key in all_requirements:\\n                    # if requirements exists in other env, then add this env too\\n                    all_requirements[req.key].add_env(env)\\n                else:\\n                    all_requirements[req.key] = req\\n        return all_requirements\\n\\n    def parse_frozen(self):\\n        parsed_frozen = self.pipfile_lock_content()\\n        if parsed_frozen is None:\\n            return {}\\n        frozen_versions = {}\\n        for env in parsed_frozen:\\n            if env.startswith(\\'_\\'):\\n                # this is not an env\\n                continue\\n            for key, details in parsed_frozen[env].items():\\n                if \\'vcs\\' in details:\\n                    frozen_versions[key] = details[\\'vcs\\']\\n                else:\\n                    frozen_versions[key] = details.get(\\'version\\', \\'0.0.0\\').lstrip(\\'=\\')\\n        return frozen_versions\\n\\n    def parse_frozen_hashes(self):\\n        parsed_frozen = self.pipfile_lock_content()\\n        if parsed_frozen is None:\\n            return {}\\n        frozen_versions = {}\\n        for env in parsed_frozen:\\n            if env.startswith(\\'_\\'):\\n                # this is not an env\\n                continue\\n            for key, details in parsed_frozen[env].items():\\n                frozen_versions[key] = details.get(\\'hashes\\', [])\\n        return frozen_versions\\n\\n    def hash(self):\\n        \"\"\"Returns the SHA256 of the pipfile\\'s data.\\n        From pipfile.\\n        \"\"\"\\n        pipfile_content = self.pipfile_content()\\n        data = {\\n            \\'_meta\\': {\\n                \\'sources\\': pipfile_content.get(\\'sources\\') or self.DEFAULT_PIPFILE_SOURCES,\\n                \\'requires\\': pipfile_content.get(\\'requires\\') or {},\\n            },\\n            \\'default\\': pipfile_content.get(\\'packages\\') or {},\\n            \\'develop\\': pipfile_content.get(\\'dev-packages\\') or {},\\n        }\\n        content = json.dumps(data, sort_keys=True, separators=(\",\", \":\"))\\n        return hashlib.sha256(content.encode(\"utf8\")).hexdigest()\\n\\n    def save_frozen(self, states_by_env):\\n        \"\"\"Implementation is not complete.\\n        \"\"\"\\n        data = self.pipfile_lock_content() or {}\\n        data.setdefault(\\'_meta\\', {\\n            \\'pipfile-spec\\': 5,\\n            \\'requires\\': {},\\n            \\'sources\\': self.DEFAULT_PIPFILE_SOURCES,\\n        })\\n        data.setdefault(\\'_meta\\', {}).setdefault(\\'hash\\', {})[\\'sha256\\'] = self.hash()\\n        for env, states in states_by_env.items():\\n            if env == \\'\\':\\n                env_key = \\'default\\'\\n            elif env == \\'dev\\':\\n                env_key = \\'develop\\'\\n            else:\\n                env_key = env\\n            reqs = data.setdefault(env_key, {})\\n            for state in states:\\n                if state.requirement.egg:\\n                    egg, url, version = parse_vcs_requirement(state.requirement.line)\\n                    reqs[state.key] = {\\n                        \\'vcs\\': url,\\n                    }\\n                else:\\n                    reqs[state.key] = {\\n                        \\'version\\': \\'==\\' + state.frozen,\\n                        \\'hashes\\': state.hashes or [],\\n                    }\\n        with open(self.pipfile + \\'.lock\\', \\'w\\') as f:\\n            f.write(json.dumps(data, sort_keys=True, indent=4))\\n\\n\\ndef create_parser(**parser_args):\\n    \"\"\"Utility function that tried to figure out what Parser to use\\n    in current directory.\\n    \"\"\"\\n    if parser_args.get(\\'requirements_files\\'):\\n        return Parser(**parser_args)\\n    elif parser_args.get(\\'package\\'):\\n        return SetupParser(**parser_args)\\n    elif parser_args.get(\\'pipfile\\'):\\n        return PipfileParser(**parser_args)\\n    return SingleParser(**parser_args)\\n\\n\\n# Utilities\\ndef get_info_from_setup(path):\\n    \"\"\"Mock setuptools.setup(**kargs) to get\\n    package information about requirements and extras\\n    \"\"\"\\n    preserve = {}\\n\\n    def _save_info(**setup_args):\\n        preserve[\\'args\\'] = setup_args\\n\\n    import setuptools\\n    original_setup = setuptools.setup\\n    setuptools.setup = _save_info\\n    import runpy\\n    runpy.run_path(os.path.join(path, \\'setup.py\\'), run_name=\\'__main__\\')\\n    setuptools.setup = original_setup\\n    return preserve.get(\\'args\\')\\n\\n\\ndef search_files_upward(start_path=None):\\n    \"Search for requirements.txt, setup.py or Pipfile upward\"\\n    if not start_path:\\n        start_path = op.abspath(op.curdir)\\n    if any(\\n            op.exists(op.join(start_path, filename))\\n            for filename in (\\'requirements.txt\\', \\'setup.py\\', \\'Pipfile\\')\\n    ):\\n        return start_path\\n    up_path = op.abspath(op.join(start_path, \\'..\\'))\\n    if op.samefile(start_path, up_path):\\n        return None\\n    return search_files_upward(start_path=up_path)\\n\\n\\ndef find_all_prefixed_files(directory, prefix):\\n    \"find all requirements_*.txt files\"\\n    envs = {}\\n    for entry in os.listdir(directory):\\n        if not entry.startswith(prefix):\\n            continue\\n        name, ext = op.splitext(entry)\\n        env = name[len(prefix):].lstrip(\\'_\\')\\n        envs[env] = op.join(directory, entry)\\n    return envs\\n\\n\\ndef create_parser_parameters():\\n    base_path = search_files_upward()\\n    if not base_path:\\n        raise PundleException(\\'Can not find requirements.txt nor setup.py nor Pipfile\\')\\n    py_version_path = python_version_string()\\n    pundledir_base = os.environ.get(\\'PUNDLEDIR\\') or op.join(op.expanduser(\\'~\\'), \\'.pundledir\\')\\n    if op.exists(op.join(base_path, \\'requirements.txt\\')):\\n        requirements_files = find_all_prefixed_files(base_path, \\'requirements\\')\\n    else:\\n        requirements_files = {}\\n    envs = list(requirements_files.keys()) or [\\'\\']\\n    params = {\\n        \\'base_path\\': base_path,\\n        \\'frozen_files\\': {\\n            env: op.join(base_path, \\'frozen_%s.txt\\' % env if env else \\'frozen.txt\\')\\n            for env in envs\\n        },\\n        \\'directory\\': op.join(pundledir_base, py_version_path),\\n    }\\n    if requirements_files:\\n        params[\\'requirements_files\\'] = requirements_files\\n    elif op.exists(op.join(base_path, \\'setup.py\\')):\\n        params[\\'package\\'] = base_path\\n    elif op.exists(op.join(base_path, \\'Pipfile\\')):\\n        params[\\'pipfile\\'] = op.join(base_path, \\'Pipfile\\')\\n    else:\\n        return\\n    return params\\n\\n\\ndef create_parser_or_exit():\\n    parser_kw = create_parser_parameters()\\n    if not parser_kw:\\n        print_message(\\'You have not requirements.txt. Create it and run again.\\')\\n        exit(1)\\n    return parser_kw\\n\\n\\n# Commands\\ndef upgrade_all(**kw):\\n    key = kw.pop(\\'key\\')\\n    prereleases = kw.pop(\\'prereleases\\')\\n    suite = create_parser(**kw).create_suite()\\n    suite.need_freeze()\\n    suite.upgrade(key=key, prereleases=prereleases)\\n    suite.install()\\n    suite.save_frozen()\\n\\n\\ndef install_all(**kw):\\n    suite = create_parser(**kw).create_suite()\\n    if suite.need_freeze() or suite.need_install():\\n        print_message(\\'Install some packages\\')\\n        suite.install()\\n    else:\\n        print_message(\\'Nothing to do, all packages installed\\')\\n    suite.save_frozen()\\n    return suite\\n\\n\\ndef activate():\\n    parser_kw = create_parser_parameters()\\n    if not parser_kw:\\n        raise PundleException(\\'Can`t create parser parameters\\')\\n    suite = create_parser(**parser_kw).create_suite()\\n    if suite.need_freeze(verbose=True):\\n        raise PundleException(\\'frozen file is outdated\\')\\n    if suite.need_install():\\n        raise PundleException(\\'Some dependencies not installed\\')\\n    envs = (os.environ.get(\\'PUNDLEENV\\') or \\'\\').split(\\',\\')\\n    suite.activate_all(envs=envs)\\n    return suite\\n\\n\\nFIXATE_TEMPLATE = \"\"\"\\n# pundle user customization start\\nimport pundle; pundle.activate()\\n# pundle user customization end\\n\"\"\"\\n\\n\\ndef fixate():\\n    \"puts activation code to usercustomize.py for user\"\\n    print_message(\\'Fixate\\')\\n    import site\\n    userdir = site.getusersitepackages()\\n    if not userdir:\\n        raise PundleException(\\'Can`t fixate due user have not site package directory\\')\\n    try:\\n        makedirs(userdir)\\n    except OSError:\\n        pass\\n    template = FIXATE_TEMPLATE.replace(\\'op.dirname(__file__)\\', \"\\'%s\\'\" % op.abspath(op.dirname(__file__)))\\n    usercustomize_file = op.join(userdir, \\'usercustomize.py\\')\\n    print_message(\\'Will edit %s file\\' % usercustomize_file)\\n    if op.exists(usercustomize_file):\\n        content = open(usercustomize_file).read()\\n        if \\'# pundle user customization start\\' in content:\\n            regex = re.compile(r\\'\\\\n# pundle user customization start.*# pundle user customization end\\\\n\\', re.DOTALL)\\n            content, res = regex.subn(template, content)\\n            open(usercustomize_file, \\'w\\').write(content)\\n        else:\\n            open(usercustomize_file, \\'a\\').write(content)\\n    else:\\n        open(usercustomize_file, \\'w\\').write(template)\\n    link_file = op.join(userdir, \\'pundle.py\\')\\n    if op.lexists(link_file):\\n        print_message(\\'Remove exist link to pundle\\')\\n        os.unlink(link_file)\\n    print_message(\\'Create link to pundle %s\\' % link_file)\\n    os.symlink(op.abspath(__file__), link_file)\\n    print_message(\\'Complete\\')\\n\\n\\ndef entry_points():\\n    suite = activate()\\n    entries = {}\\n    for r in suite.states.values():\\n        d = r.frozen_dist()\\n        if not d:\\n            continue\\n        if isinstance(d, VCSDist):\\n            continue\\n        scripts = d.get_entry_map().get(\\'console_scripts\\', {})\\n        for name in scripts:\\n            entries[name] = d\\n    return entries\\n\\n\\nclass CmdRegister:\\n    commands = {}\\n    ordered = []\\n\\n    @classmethod\\n    def cmdline(cls, *cmd_aliases):\\n        def wrap(func):\\n            for alias in cmd_aliases:\\n                cls.commands[alias] = func\\n                cls.ordered.append(alias)\\n        return wrap\\n\\n    @classmethod\\n    def help(cls):\\n        for alias in cls.ordered:\\n            if not alias:\\n                continue\\n            print(\"{:15s} {}\".format(alias, cls.commands[alias].__doc__))\\n\\n    @classmethod\\n    def main(cls):\\n        alias = \\'\\' if len(sys.argv) == 1 else sys.argv[1]\\n        if alias == \\'help\\':\\n            cls.help()\\n            return\\n        if alias not in cls.commands:\\n            print(\\'Unknown command\\\\nTry this:\\')\\n            cls.help()\\n            sys.exit(1)\\n        cls.commands[alias]()\\n\\n\\n@CmdRegister.cmdline(\\'\\', \\'install\\')\\ndef cmd_install():\\n    \"Install packages by frozen.txt and resolve ones that was not frozen\"\\n    install_all(**create_parser_or_exit())\\n\\n\\n@CmdRegister.cmdline(\\'upgrade\\')\\ndef cmd_upgrade():\\n    \"\"\"\\n    [package [pre]] if package provided will upgrade it and dependencies or all packages from PyPI.\\n    If `pre` provided will look for prereleases.\\n    \"\"\"\\n    key = sys.argv[2] if len(sys.argv) > 2 else None\\n    prereleases = sys.argv[3] == \\'pre\\' if len(sys.argv) > 3 else False\\n    upgrade_all(key=key, prereleases=prereleases, **create_parser_or_exit())\\n\\n\\nCmdRegister.cmdline(\\'fixate\\')(fixate)\\n\\n\\n@CmdRegister.cmdline(\\'exec\\')\\ndef cmd_exec():\\n    \"executes setuptools entry\"\\n    cmd = sys.argv[2]\\n    args = sys.argv[3:]\\n    entries = entry_points()\\n    if cmd not in entries:\\n        print_message(\\'Script is not found. Check if package is installed, or look at the `pundle entry_points`\\')\\n        sys.exit(1)\\n    exc = entries[cmd].get_entry_info(\\'console_scripts\\', cmd).load()\\n    sys.path.insert(0, \\'\\')\\n    sys.argv = [cmd] + args\\n    exc()\\n\\n\\n@CmdRegister.cmdline(\\'entry_points\\')\\ndef cmd_entry_points():\\n    \"prints available setuptools entries\"\\n    for entry, package in entry_points().items():\\n        print(\\'%s (%s)\\' % (entry, package))\\n\\n\\n@CmdRegister.cmdline(\\'edit\\')\\ndef cmd_edit():\\n    \"prints directory path to package\"\\n    parser_kw = create_parser_parameters()\\n    suite = create_parser(**parser_kw).create_suite()\\n    if suite.need_freeze():\\n        raise PundleException(\\'%s file is outdated\\' % suite.parser.frozen_file)\\n    print(suite.states[sys.argv[2]].frozen_dist().location)\\n\\n\\n@CmdRegister.cmdline(\\'info\\')\\ndef cmd_info():\\n    \"prints info about Pundle state\"\\n    parser_kw = create_parser_parameters()\\n    suite = create_parser(**parser_kw).create_suite()\\n    if suite.need_freeze():\\n        print(\\'frozen.txt is outdated\\')\\n    else:\\n        print(\\'frozen.txt is up to date\\')\\n    for state in suite.required_states():\\n        print(\\n            \\'Requirement \"{}\", frozen {}, {}\\'.format(\\n                state.key,\\n                state.frozen,\\n                state.requirement.line if state.requirement else \\'None\\'\\n            )\\n        )\\n        print(\\'Installed versions:\\')\\n        for dist in state.installed:\\n            print(\\'    \\', repr(dist))\\n        if not state.installed:\\n            print(\\'     None\\')\\n\\n\\ndef run_console(glob):\\n    import readline\\n    import rlcompleter\\n    import atexit\\n    import code\\n\\n    history_path = os.path.expanduser(\"~/.python_history\")\\n\\n    def save_history(history_path=history_path):\\n        readline.write_history_file(history_path)\\n    if os.path.exists(history_path):\\n        readline.read_history_file(history_path)\\n\\n    atexit.register(save_history)\\n\\n    readline.set_completer(rlcompleter.Completer(glob).complete)\\n    readline.parse_and_bind(\"tab: complete\")\\n    code.InteractiveConsole(locals=glob).interact()\\n\\n\\n@CmdRegister.cmdline(\\'console\\')\\ndef cmd_console():\\n    \"[ipython|bpython|ptpython] starts python console with activated pundle environment\"\\n    suite = activate()\\n    glob = {\\n        \\'pundle_suite\\': suite,\\n    }\\n    interpreter = sys.argv[2] if len(sys.argv) > 2 else None\\n    if not interpreter:\\n        run_console(glob)\\n    elif interpreter == \\'ipython\\':\\n        from IPython import embed\\n        embed()\\n    elif interpreter == \\'ptpython\\':\\n        from ptpython.repl import embed\\n        embed(glob, {})\\n    elif interpreter == \\'bpython\\':\\n        from bpython import embed\\n        embed(glob)\\n    else:\\n        raise PundleException(\\'Unknown interpreter: {}. Choose one of None, ipython, bpython, ptpython.\\')\\n\\n\\n@CmdRegister.cmdline(\\'run\\')\\ndef cmd_run():\\n    \"executes given script\"\\n    activate()\\n    import runpy\\n    sys.path.insert(0, \\'\\')\\n    script = sys.argv[2]\\n    sys.argv = [sys.argv[2]] + sys.argv[3:]\\n    runpy.run_path(script, run_name=\\'__main__\\')\\n\\n\\n@CmdRegister.cmdline(\\'module\\')\\ndef cmd_module():\\n    \"executes module like `python -m`\"\\n    activate()\\n    import runpy\\n    sys.path.insert(0, \\'\\')\\n    module = sys.argv[2]\\n    sys.argv = [sys.argv[2]] + sys.argv[3:]\\n    runpy.run_module(module, run_name=\\'__main__\\')\\n\\n\\n@CmdRegister.cmdline(\\'env\\')\\ndef cmd_env():\\n    \"populates PYTHONPATH with packages paths and executes command line in subprocess\"\\n    activate()\\n    aug_env = os.environ.copy()\\n    aug_env[\\'PYTHONPATH\\'] = \\':\\'.join(sys.path)\\n    subprocess.call(sys.argv[2:], env=aug_env)\\n\\n\\n@CmdRegister.cmdline(\\'print_env\\')\\ndef cmd_print_env():\\n    \"Prints PYTHONPATH. For usage with mypy and MYPYPATH\"\\n    suite = activate()\\n    path = \\':\\'.join(\\n        state.frozen_dist().location\\n        for state in suite.states.values()\\n        if state.frozen_dist()\\n    )\\n    print(path)\\n\\n\\nENTRY_POINT_TEMPLATE = \\'\\'\\'#! /usr/bin/env python\\nimport pundle; pundle.activate()\\npundle.entry_points()[\\'{entry_point}\\'].get_entry_info(\\'console_scripts\\', \\'{entry_point}\\').load(require=False)()\\n\\'\\'\\'\\n\\n\\n@CmdRegister.cmdline(\\'linkall\\')\\ndef link_all():\\n    \"links all packages to `.pundle_local` dir\"\\n    local_dir = \\'.pundle_local\\'\\n    suite = activate()\\n\\n    try:\\n        makedirs(local_dir)\\n    except OSError:\\n        pass\\n    local_dir_info = {de.name: de for de in os.scandir(local_dir)}\\n    for r in suite.states.values():\\n        d = r.frozen_dist()\\n        if not d:\\n            continue\\n        for dir_entry in os.scandir(d.location):\\n            if dir_entry.name.startswith(\\'__\\') or dir_entry.name.startswith(\\'.\\') or dir_entry.name == \\'bin\\':\\n                continue\\n            dest_path = os.path.join(local_dir, dir_entry.name)\\n            if dir_entry.name in local_dir_info:\\n                sym = local_dir_info.pop(dir_entry.name)\\n                existed = op.realpath(sym.path)\\n                if existed == dir_entry.path:\\n                    continue\\n                os.remove(sym.path)\\n            os.symlink(dir_entry.path, dest_path)\\n    # create entry_points binaries\\n    try:\\n        makedirs(os.path.join(local_dir, \\'bin\\'))\\n    except OSError:\\n        pass\\n    for bin_name, entry_point in entry_points().items():\\n        bin_filename = os.path.join(local_dir, \\'bin\\', bin_name)\\n        open(bin_filename, \\'w\\').write(ENTRY_POINT_TEMPLATE.format(entry_point=bin_name))\\n        file_stat = os.stat(bin_filename)\\n        os.chmod(bin_filename, file_stat.st_mode | stat.S_IEXEC)\\n    local_dir_info.pop(\\'bin\\')\\n\\n    # remove extra links\\n    for de in local_dir_info:\\n        os.remove(de.path)\\n\\n\\n@CmdRegister.cmdline(\\'show_requirements\\')\\ndef show_requirements():\\n    \"shows details requirements info\"\\n    suite = activate()\\n    for name, state in suite.states.items():\\n        if state.requirement:\\n            print(\\n                name,\\n                \\'frozen:\\',\\n                state.frozen,\\n                \\'required:\\',\\n                state.requirement.req if state.requirement.req else \\'VCS\\',\\n                state.requirement.envs,\\n            )\\n\\n\\n# Single mode that you can use in console\\n_single_mode_suite = {}  # cache variable to keep current suite for single_mode\\n\\n\\ndef single_mode():\\n    \"\"\" Create, cache and return Suite instance for single_mode.\\n    \"\"\"\\n    if not _single_mode_suite:\\n        py_version_path = python_version_string()\\n        pundledir_base = os.environ.get(\\'PUNDLEDIR\\') or op.join(op.expanduser(\\'~\\'), \\'.pundledir\\')\\n        directory = op.join(pundledir_base, py_version_path)\\n        _single_mode_suite[\\'cache\\'] = create_parser(directory=directory).create_suite()\\n    return _single_mode_suite[\\'cache\\']\\n\\n\\ndef use(key):\\n    \"\"\" Installs `key` requirement, like `django==1.11` or just `django`\\n    \"\"\"\\n    suite = single_mode()\\n    suite.use(key)\\n\\n\\nif __name__ == \\'__main__\\':\\n    CmdRegister.main()\\n'"}]}}