{"connections_support_transactions": {"line": 1103, "args": [{"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}, {"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}, {"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}, {"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}, {"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}, {"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}, {"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}, {"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}, {"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}, {"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}, {"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}, {"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}, {"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}, {"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}, {"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}, {"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}, {"func_args": {"aliases": "frozenset({'default'})"}, "return_value": "True"}], "text": "def connections_support_transactions(aliases=None):\n    \"\"\"\n    Return whether or not all (or specified) connections support\n    transactions.\n    \"\"\"\n    conns = connections.all() if aliases is None else (connections[alias] for alias in aliases)\n    return all(conn.features.supports_transactions for conn in conns)"}, "<lambda>": {"line": 254, "args": [{"func_args": {}, "return_value": "[]"}, {"func_args": {}, "return_value": "[]"}, {"func_args": {}, "return_value": "[]"}, {"func_args": {}, "return_value": "[]"}, {"func_args": {}, "return_value": "[]"}, {"func_args": {}, "return_value": "[]"}, {"func_args": {}, "return_value": "[]"}, {"func_args": {}, "return_value": "[]"}, {"func_args": {}, "return_value": "[]"}, {"func_args": {}, "return_value": "[]"}, {"func_args": {}, "return_value": "[]"}, {"func_args": {}, "return_value": "[]"}, {"func_args": {}, "return_value": "[]"}, {"func_args": {}, "return_value": "[]"}]}, "iterparentnodeids": {"line": 44, "args": [{"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests/test_wns.py'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests/test_wns.py'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests/test_wns.py'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests/test_wns.py'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests/test_wns.py'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests/test_wns.py'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests/test_wns.py'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests/test_wns.py'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, {"func_args": {"nodeid": "'tests/test_wns.py::WNSDictToXmlSchemaTestCase'"}, "return_value": "None"}], "text": "def iterparentnodeids(nodeid: str) -> Iterator[str]:\n    \"\"\"Return the parent node IDs of a given node ID, inclusive.\n\n    For the node ID\n\n        \"testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source\"\n\n    the result would be\n\n        \"\"\n        \"testing\"\n        \"testing/code\"\n        \"testing/code/test_excinfo.py\"\n        \"testing/code/test_excinfo.py::TestFormattedExcinfo\"\n        \"testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source\"\n\n    Note that :: parts are only considered at the last / component.\n    \"\"\"\n    pos = 0\n    sep = SEP\n    yield \"\"\n    while True:\n        at = nodeid.find(sep, pos)\n        if at == -1 and sep == SEP:\n            sep = \"::\"\n        elif at == -1:\n            if nodeid:\n                yield nodeid\n            break\n        else:\n            if at:\n                yield nodeid[:at]\n            pos = at + len(sep)"}, "pluralize": {"line": 1350, "args": [{"func_args": {"count": "81", "noun": "'passed'"}, "return_value": "(81, 'passed')"}, {"func_args": {"count": "4", "noun": "'warnings'"}, "return_value": "(4, 'warnings')"}], "text": "def pluralize(count: int, noun: str) -> Tuple[int, str]:\n    # No need to pluralize words such as `failed` or `passed`.\n    if noun not in [\"error\", \"warnings\", \"test\"]:\n        return count, noun\n\n    # The `warnings` key is plural. To avoid API breakage, we keep it that way but\n    # set it to singular here so we can determine plurality in the same way as we do\n    # for `error`.\n    noun = noun.replace(\"warnings\", \"warning\")\n\n    return count, noun + \"s\" if count != 1 else noun"}, "format_session_duration": {"line": 1377, "args": [{"func_args": {"seconds": "7.412570953369141"}, "return_value": "'7.41s'"}], "text": "def format_session_duration(seconds: float) -> str:\n    \"\"\"Format the given seconds in a human readable manner to show in the final summary.\"\"\"\n    if seconds < 60:\n        return f\"{seconds:.2f}s\"\n    else:\n        dt = datetime.timedelta(seconds=int(seconds))\n        return f\"{seconds:.2f}s ({dt})\""}, "get_terminal_width": {"line": 15, "args": [{"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}], "text": "def get_terminal_width() -> int:\n    width, _ = shutil.get_terminal_size(fallback=(80, 24))\n\n    # The Windows get_terminal_size may be bogus, let's sanify a bit.\n    if width < 40:\n        width = 80\n\n    return width"}, "scopemismatch": {"line": 799, "args": [{"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'class'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'class'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'class'"}, "return_value": "False"}, {"func_args": {"currentscope": "'class'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'class'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'session'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'session'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'session'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'session'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'session'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'session'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'session'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'class'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'class'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'class'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'session'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'class'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'class'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}, {"func_args": {"currentscope": "'function'", "newscope": "'function'"}, "return_value": "False"}], "text": "def scopemismatch(currentscope: \"_Scope\", newscope: \"_Scope\") -> bool:\n    return scopes.index(newscope) > scopes.index(currentscope)"}, "wcswidth": {"line": 43, "args": [{"func_args": {"s": "'tests/test_wns.py .....'"}, "return_value": "23"}, {"func_args": {"s": "'tests/test_wns.py ......'"}, "return_value": "24"}, {"func_args": {"s": "'tests/test_wns.py .......'"}, "return_value": "25"}, {"func_args": {"s": "'tests/test_wns.py ........'"}, "return_value": "26"}, {"func_args": {"s": "'tests/test_wns.py .........'"}, "return_value": "27"}], "text": "def wcswidth(s: str) -> int:\n    \"\"\"Determine how many columns are needed to display a string in a terminal.\n\n    Returns -1 if the string contains non-printable characters.\n    \"\"\"\n    width = 0\n    for c in unicodedata.normalize(\"NFC\", s):\n        wc = wcwidth(c)\n        if wc < 0:\n            return -1\n        width += wc\n    return width"}, "_get_stderr_fileno": {"line": 68, "args": [{"func_args": {}, "return_value": "2"}]}, "django_settings_is_configured": {"line": 16, "args": [{"func_args": {}, "return_value": "True"}, {"func_args": {}, "return_value": "True"}, {"func_args": {}, "return_value": "True"}, {"func_args": {}, "return_value": "True"}, {"func_args": {}, "return_value": "True"}, {"func_args": {}, "return_value": "True"}, {"func_args": {}, "return_value": "True"}, {"func_args": {}, "return_value": "True"}, {"func_args": {}, "return_value": "True"}], "text": "def django_settings_is_configured() -> bool:\n    \"\"\"Return whether the Django settings module has been configured.\n\n    This uses either the DJANGO_SETTINGS_MODULE environment variable, or the\n    configured flag in the Django settings object if django.conf has already\n    been imported.\n    \"\"\"\n    ret = bool(os.environ.get(\"DJANGO_SETTINGS_MODULE\"))\n\n    if not ret and \"django.conf\" in sys.modules:\n        django_conf = sys.modules[\"django.conf\"]  # type: Any\n        return django_conf.settings.configured\n\n    return ret"}, "is_in_memory_db": {"line": 10, "args": [{"func_args": {"database_name": "'file:memorydb_default?mode=memory&cache=shared'"}, "return_value": "True"}, {"func_args": {"database_name": "'file:memorydb_default?mode=memory&cache=shared'"}, "return_value": "True"}, {"func_args": {"database_name": "'file:memorydb_default?mode=memory&cache=shared'"}, "return_value": "True"}, {"func_args": {"database_name": "'file:memorydb_default?mode=memory&cache=shared'"}, "return_value": "True"}]}, "actual_path": {"line": 139, "args": [{"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}], "text": "def actual_path(path):\n        \"\"\"The actual path for non-Windows platforms.\"\"\"\n        return path"}, "abs_file": {"line": 144, "args": [{"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"path": "'.'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"path": "'./push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}]}, "find_python_files": {"line": 403, "args": [{"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "None"}], "text": "def find_python_files(dirname):\n    \"\"\"Yield all of the importable Python files in `dirname`, recursively.\n\n    To be importable, the files have to be in a directory with a __init__.py,\n    except for `dirname` itself, which isn't required to have one.  The\n    assumption is that `dirname` was specified directly, so the user knows\n    best, but sub-directories are checked for a __init__.py to be sure we only\n    find the importable files.\n\n    \"\"\"\n    for i, (dirpath, dirnames, filenames) in enumerate(os.walk(dirname)):\n        if i > 0 and '__init__.py' not in filenames:\n            # If a directory doesn't have __init__.py, then it isn't\n            # importable and neither are its files\n            del dirnames[:]\n            continue\n        for filename in filenames:\n            # We're only interested in files that look like reasonable Python\n            # files: Must end with .py or .pyw, and must not have certain funny\n            # characters that probably mean they are editor junk.\n            if re.match(r\"^[^.#~!$@%^&*()+=,]+\\.pyw?$\", filename):\n                yield os.path.join(dirpath, filename)"}, "canonical_filename": {"line": 53, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"filename": "'push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}]}, "relative_filename": {"line": 39, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'push_notifications/fields.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'push_notifications/conf/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'push_notifications/conf/appmodel.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'push_notifications/admin.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'push_notifications/api/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'push_notifications/exceptions.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'push_notifications/apns.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'push_notifications/migrations/0001_initial.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'push_notifications/migrations/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'push_notifications/settings.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'push_notifications/wns.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'push_notifications/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'push_notifications/conf/legacy.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'push_notifications/gcm.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'push_notifications/models.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'push_notifications/api/rest_framework.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'push_notifications/conf/base.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'push_notifications/compat.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'push_notifications/webpush.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'push_notifications/conf/app.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'push_notifications/fields.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'push_notifications/conf/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'push_notifications/conf/appmodel.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'push_notifications/admin.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'push_notifications/api/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'push_notifications/exceptions.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'push_notifications/apns.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'push_notifications/migrations/0001_initial.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'push_notifications/migrations/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'push_notifications/settings.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'push_notifications/wns.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'push_notifications/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'push_notifications/conf/legacy.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'push_notifications/gcm.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'push_notifications/models.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'push_notifications/api/rest_framework.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'push_notifications/conf/base.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'push_notifications/compat.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'push_notifications/webpush.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'push_notifications/conf/app.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'push_notifications/migrations/0004_fcm.py'"}]}, "join_regex": {"line": 182, "args": [{"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))'"}, {"func_args": {"regexes": "['while (True|1|False|0):', 'if (True|1|False|0):']"}, "return_value": "'(?:while (True|1|False|0):)|(?:if (True|1|False|0):)'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH))', '(?:while (True|1|False|0):)|(?:if (True|1|False|0):)')"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(branch|BRANCH)))|(?:(?:while (True|1|False|0):)|(?:if (True|1|False|0):))'"}], "text": "def join_regex(regexes):\n    \"\"\"Combine a list of regexes into one that matches any of them.\"\"\"\n    return \"|\".join(f\"(?:{r})\" for r in regexes)"}, "nice_pair": {"line": 140, "args": [{"func_args": {"pair": "(4, 6)"}, "return_value": "'4-6'"}, {"func_args": {"pair": "(23, 23)"}, "return_value": "'23'"}, {"func_args": {"pair": "(29, 106)"}, "return_value": "'29-106'"}, {"func_args": {"pair": "(109, 109)"}, "return_value": "'109'"}, {"func_args": {"pair": "(114, 114)"}, "return_value": "'114'"}, {"func_args": {"pair": "(119, 119)"}, "return_value": "'119'"}, {"func_args": {"pair": "(124, 124)"}, "return_value": "'124'"}, {"func_args": {"pair": "(143, 143)"}, "return_value": "'143'"}, {"func_args": {"pair": "(28, 28)"}, "return_value": "'28'"}, {"func_args": {"pair": "(71, 75)"}, "return_value": "'71-75'"}, {"func_args": {"pair": "(131, 131)"}, "return_value": "'131'"}, {"func_args": {"pair": "(139, 158)"}, "return_value": "'139-158'"}, {"func_args": {"pair": "(161, 163)"}, "return_value": "'161-163'"}, {"func_args": {"pair": "(166, 168)"}, "return_value": "'166-168'"}, {"func_args": {"pair": "(176, 176)"}, "return_value": "'176'"}, {"func_args": {"pair": "(25, 31)"}, "return_value": "'25-31'"}, {"func_args": {"pair": "(53, 53)"}, "return_value": "'53'"}, {"func_args": {"pair": "(120, 120)"}, "return_value": "'120'"}, {"func_args": {"pair": "(177, 178)"}, "return_value": "'177-178'"}, {"func_args": {"pair": "(223, 231)"}, "return_value": "'223-231'"}, {"func_args": {"pair": "(243, 243)"}, "return_value": "'243'"}, {"func_args": {"pair": "(264, 264)"}, "return_value": "'264'"}, {"func_args": {"pair": "(298, 298)"}, "return_value": "'298'"}, {"func_args": {"pair": "(307, 307)"}, "return_value": "'307'"}, {"func_args": {"pair": "(310, 310)"}, "return_value": "'310'"}, {"func_args": {"pair": "(313, 313)"}, "return_value": "'313'"}, {"func_args": {"pair": "(316, 316)"}, "return_value": "'316'"}, {"func_args": {"pair": "(319, 319)"}, "return_value": "'319'"}, {"func_args": {"pair": "(325, 337)"}, "return_value": "'325-337'"}, {"func_args": {"pair": "(340, 340)"}, "return_value": "'340'"}, {"func_args": {"pair": "(346, 346)"}, "return_value": "'346'"}, {"func_args": {"pair": "(349, 349)"}, "return_value": "'349'"}, {"func_args": {"pair": "(352, 352)"}, "return_value": "'352'"}, {"func_args": {"pair": "(355, 355)"}, "return_value": "'355'"}, {"func_args": {"pair": "(358, 358)"}, "return_value": "'358'"}, {"func_args": {"pair": "(361, 361)"}, "return_value": "'361'"}, {"func_args": {"pair": "(364, 364)"}, "return_value": "'364'"}, {"func_args": {"pair": "(367, 367)"}, "return_value": "'367'"}, {"func_args": {"pair": "(370, 370)"}, "return_value": "'370'"}, {"func_args": {"pair": "(373, 373)"}, "return_value": "'373'"}, {"func_args": {"pair": "(376, 376)"}, "return_value": "'376'"}, {"func_args": {"pair": "(6, 6)"}, "return_value": "'6'"}, {"func_args": {"pair": "(9, 9)"}, "return_value": "'9'"}, {"func_args": {"pair": "(12, 12)"}, "return_value": "'12'"}, {"func_args": {"pair": "(15, 15)"}, "return_value": "'15'"}, {"func_args": {"pair": "(18, 18)"}, "return_value": "'18'"}, {"func_args": {"pair": "(21, 21)"}, "return_value": "'21'"}, {"func_args": {"pair": "(24, 24)"}, "return_value": "'24'"}, {"func_args": {"pair": "(27, 27)"}, "return_value": "'27'"}, {"func_args": {"pair": "(30, 30)"}, "return_value": "'30'"}, {"func_args": {"pair": "(33, 33)"}, "return_value": "'33'"}, {"func_args": {"pair": "(36, 36)"}, "return_value": "'36'"}, {"func_args": {"pair": "(39, 39)"}, "return_value": "'39'"}, {"func_args": {"pair": "(44, 44)"}, "return_value": "'44'"}, {"func_args": {"pair": "(60, 60)"}, "return_value": "'60'"}, {"func_args": {"pair": "(63, 63)"}, "return_value": "'63'"}, {"func_args": {"pair": "(36, 39)"}, "return_value": "'36-39'"}, {"func_args": {"pair": "(42, 45)"}, "return_value": "'42-45'"}, {"func_args": {"pair": "(48, 54)"}, "return_value": "'48-54'"}, {"func_args": {"pair": "(77, 78)"}, "return_value": "'77-78'"}, {"func_args": {"pair": "(82, 82)"}, "return_value": "'82'"}, {"func_args": {"pair": "(91, 100)"}, "return_value": "'91-100'"}, {"func_args": {"pair": "(104, 104)"}, "return_value": "'104'"}, {"func_args": {"pair": "(113, 113)"}, "return_value": "'113'"}, {"func_args": {"pair": "(116, 116)"}, "return_value": "'116'"}, {"func_args": {"pair": "(123, 123)"}, "return_value": "'123'"}, {"func_args": {"pair": "(129, 129)"}, "return_value": "'129'"}, {"func_args": {"pair": "(132, 132)"}, "return_value": "'132'"}, {"func_args": {"pair": "(135, 135)"}, "return_value": "'135'"}, {"func_args": {"pair": "(138, 138)"}, "return_value": "'138'"}, {"func_args": {"pair": "(141, 141)"}, "return_value": "'141'"}, {"func_args": {"pair": "(144, 145)"}, "return_value": "'144-145'"}, {"func_args": {"pair": "(36, 36)"}, "return_value": "'36'"}, {"func_args": {"pair": "(40, 40)"}, "return_value": "'40'"}, {"func_args": {"pair": "(48, 51)"}, "return_value": "'48-51'"}, {"func_args": {"pair": "(55, 58)"}, "return_value": "'55-58'"}, {"func_args": {"pair": "(81, 81)"}, "return_value": "'81'"}, {"func_args": {"pair": "(85, 85)"}, "return_value": "'85'"}, {"func_args": {"pair": "(92, 92)"}, "return_value": "'92'"}, {"func_args": {"pair": "(107, 111)"}, "return_value": "'107-111'"}, {"func_args": {"pair": "(114, 117)"}, "return_value": "'114-117'"}, {"func_args": {"pair": "(121, 122)"}, "return_value": "'121-122'"}, {"func_args": {"pair": "(41, 49)"}, "return_value": "'41-49'"}, {"func_args": {"pair": "(55, 63)"}, "return_value": "'55-63'"}, {"func_args": {"pair": "(158, 158)"}, "return_value": "'158'"}, {"func_args": {"pair": "(168, 168)"}, "return_value": "'168'"}, {"func_args": {"pair": "(184, 184)"}, "return_value": "'184'"}, {"func_args": {"pair": "(188, 188)"}, "return_value": "'188'"}, {"func_args": {"pair": "(204, 204)"}, "return_value": "'204'"}, {"func_args": {"pair": "(46, 46)"}, "return_value": "'46'"}, {"func_args": {"pair": "(141, 142)"}, "return_value": "'141-142'"}, {"func_args": {"pair": "(178, 194)"}, "return_value": "'178-194'"}, {"func_args": {"pair": "(210, 212)"}, "return_value": "'210-212'"}, {"func_args": {"pair": "(225, 230)"}, "return_value": "'225-230'"}, {"func_args": {"pair": "(253, 253)"}, "return_value": "'253'"}, {"func_args": {"pair": "(256, 258)"}, "return_value": "'256-258'"}, {"func_args": {"pair": "(26, 26)"}, "return_value": "'26'"}, {"func_args": {"pair": "(31, 37)"}, "return_value": "'31-37'"}, {"func_args": {"pair": "(37, 82)"}, "return_value": "'37-82'"}, {"func_args": {"pair": "(93, 139)"}, "return_value": "'93-139'"}, {"func_args": {"pair": "(155, 169)"}, "return_value": "'155-169'"}, {"func_args": {"pair": "(224, 225)"}, "return_value": "'224-225'"}, {"func_args": {"pair": "(347, 347)"}, "return_value": "'347'"}], "text": "def nice_pair(pair):\n    \"\"\"Make a nice string representation of a pair of numbers.\n\n    If the numbers are equal, just return the number, otherwise return the pair\n    with a dash between them, indicating the range.\n\n    \"\"\"\n    start, end = pair\n    if start == end:\n        return \"%d\" % start\n    else:\n        return \"%d-%d\" % (start, end)"}, "tryint": {"line": 370, "args": [{"func_args": {"s": "'push_notifications/__init__.py                                         '"}, "return_value": "'push_notifications/__init__.py                                         '"}, {"func_args": {"s": "'5'"}, "return_value": "5"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'2'"}, "return_value": "2"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'60'"}, "return_value": "60"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'4'"}, "return_value": "4"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'6'"}, "return_value": "6"}, {"func_args": {"s": "''"}, "return_value": "''"}, {"func_args": {"s": "'push_notifications/admin.py                                           '"}, "return_value": "'push_notifications/admin.py                                           '"}, {"func_args": {"s": "'98'"}, "return_value": "98"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'62'"}, "return_value": "62"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'62'"}, "return_value": "62"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'2'"}, "return_value": "2"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'28'"}, "return_value": "28"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'23'"}, "return_value": "23"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'29'"}, "return_value": "29"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'106'"}, "return_value": "106"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'109'"}, "return_value": "109"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'114'"}, "return_value": "114"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'119'"}, "return_value": "119"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'124'"}, "return_value": "124"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'143'"}, "return_value": "143"}, {"func_args": {"s": "''"}, "return_value": "''"}, {"func_args": {"s": "'push_notifications/api/__init__.py                                     '"}, "return_value": "'push_notifications/api/__init__.py                                     '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'push_notifications/api/rest_framework.py                             '"}, "return_value": "'push_notifications/api/rest_framework.py                             '"}, {"func_args": {"s": "'124'"}, "return_value": "124"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'30'"}, "return_value": "30"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'76'"}, "return_value": "76"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'2'"}, "return_value": "2"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'76'"}, "return_value": "76"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'28'"}, "return_value": "28"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'71'"}, "return_value": "71"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'75'"}, "return_value": "75"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'82'"}, "return_value": "82"}, {"func_args": {"s": "'->'"}, "return_value": "'->'"}, {"func_args": {"s": "'85'"}, "return_value": "85"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'131'"}, "return_value": "131"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'139'"}, "return_value": "139"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'158'"}, "return_value": "158"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'161'"}, "return_value": "161"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'163'"}, "return_value": "163"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'166'"}, "return_value": "166"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'168'"}, "return_value": "168"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'176'"}, "return_value": "176"}, {"func_args": {"s": "''"}, "return_value": "''"}, {"func_args": {"s": "'push_notifications/apns.py                                            '"}, "return_value": "'push_notifications/apns.py                                            '"}, {"func_args": {"s": "'57'"}, "return_value": "57"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'3'"}, "return_value": "3"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'20'"}, "return_value": "20"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'3'"}, "return_value": "3"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'92'"}, "return_value": "92"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'20'"}, "return_value": "20"}, {"func_args": {"s": "'->'"}, "return_value": "'->'"}, {"func_args": {"s": "'32'"}, "return_value": "32"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'25'"}, "return_value": "25"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'31'"}, "return_value": "31"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'53'"}, "return_value": "53"}, {"func_args": {"s": "''"}, "return_value": "''"}, {"func_args": {"s": "'push_notifications/compat.py                                           '"}, "return_value": "'push_notifications/compat.py                                           '"}, {"func_args": {"s": "'3'"}, "return_value": "3"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'push_notifications/conf/__init__.py                                   '"}, "return_value": "'push_notifications/conf/__init__.py                                   '"}, {"func_args": {"s": "'11'"}, "return_value": "11"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'2'"}, "return_value": "2"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'push_notifications/conf/app.py                                       '"}, "return_value": "'push_notifications/conf/app.py                                       '"}, {"func_args": {"s": "'161'"}, "return_value": "161"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'35'"}, "return_value": "35"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'44'"}, "return_value": "44"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'5'"}, "return_value": "5"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'78'"}, "return_value": "78"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'120'"}, "return_value": "120"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'153'"}, "return_value": "153"}, {"func_args": {"s": "'->'"}, "return_value": "'->'"}, {"func_args": {"s": "'163'"}, "return_value": "163"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'177'"}, "return_value": "177"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'178'"}, "return_value": "178"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'223'"}, "return_value": "223"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'231'"}, "return_value": "231"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'243'"}, "return_value": "243"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'264'"}, "return_value": "264"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'298'"}, "return_value": "298"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'307'"}, "return_value": "307"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'310'"}, "return_value": "310"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'313'"}, "return_value": "313"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'316'"}, "return_value": "316"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'319'"}, "return_value": "319"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'325'"}, "return_value": "325"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'337'"}, "return_value": "337"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'340'"}, "return_value": "340"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'346'"}, "return_value": "346"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'349'"}, "return_value": "349"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'352'"}, "return_value": "352"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'355'"}, "return_value": "355"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'358'"}, "return_value": "358"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'361'"}, "return_value": "361"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'364'"}, "return_value": "364"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'367'"}, "return_value": "367"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'370'"}, "return_value": "370"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'373'"}, "return_value": "373"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'376'"}, "return_value": "376"}, {"func_args": {"s": "''"}, "return_value": "''"}, {"func_args": {"s": "'push_notifications/conf/appmodel.py                                    '"}, "return_value": "'push_notifications/conf/appmodel.py                                    '"}, {"func_args": {"s": "'3'"}, "return_value": "3"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'2'"}, "return_value": "2"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'push_notifications/conf/base.py                                       '"}, "return_value": "'push_notifications/conf/base.py                                       '"}, {"func_args": {"s": "'42'"}, "return_value": "42"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'15'"}, "return_value": "15"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'16'"}, "return_value": "16"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'4'"}, "return_value": "4"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'67'"}, "return_value": "67"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'6'"}, "return_value": "6"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'9'"}, "return_value": "9"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'12'"}, "return_value": "12"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'15'"}, "return_value": "15"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'18'"}, "return_value": "18"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'21'"}, "return_value": "21"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'24'"}, "return_value": "24"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'27'"}, "return_value": "27"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'30'"}, "return_value": "30"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'33'"}, "return_value": "33"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'36'"}, "return_value": "36"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'39'"}, "return_value": "39"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'44'"}, "return_value": "44"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'51'"}, "return_value": "51"}, {"func_args": {"s": "'->'"}, "return_value": "'->'"}, {"func_args": {"s": "'62'"}, "return_value": "62"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'55'"}, "return_value": "55"}, {"func_args": {"s": "'->'"}, "return_value": "'->'"}, {"func_args": {"s": "'51'"}, "return_value": "51"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'60'"}, "return_value": "60"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'63'"}, "return_value": "63"}, {"func_args": {"s": "''"}, "return_value": "''"}, {"func_args": {"s": "'push_notifications/conf/legacy.py                                     '"}, "return_value": "'push_notifications/conf/legacy.py                                     '"}, {"func_args": {"s": "'89'"}, "return_value": "89"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'27'"}, "return_value": "27"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'14'"}, "return_value": "14"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'1'"}, "return_value": "1"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'69'"}, "return_value": "69"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'36'"}, "return_value": "36"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'39'"}, "return_value": "39"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'42'"}, "return_value": "42"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'45'"}, "return_value": "45"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'48'"}, "return_value": "48"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'54'"}, "return_value": "54"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'77'"}, "return_value": "77"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'78'"}, "return_value": "78"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'82'"}, "return_value": "82"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'91'"}, "return_value": "91"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'104'"}, "return_value": "104"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'113'"}, "return_value": "113"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'116'"}, "return_value": "116"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'123'"}, "return_value": "123"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'129'"}, "return_value": "129"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'132'"}, "return_value": "132"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'135'"}, "return_value": "135"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'138'"}, "return_value": "138"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'141'"}, "return_value": "141"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'144'"}, "return_value": "144"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'145'"}, "return_value": "145"}, {"func_args": {"s": "''"}, "return_value": "''"}, {"func_args": {"s": "'push_notifications/exceptions.py                                      '"}, "return_value": "'push_notifications/exceptions.py                                      '"}, {"func_args": {"s": "'14'"}, "return_value": "14"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'12'"}, "return_value": "12"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'push_notifications/fields.py                                          '"}, "return_value": "'push_notifications/fields.py                                          '"}, {"func_args": {"s": "'64'"}, "return_value": "64"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'20'"}, "return_value": "20"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'24'"}, "return_value": "24"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'5'"}, "return_value": "5"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'65'"}, "return_value": "65"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'36'"}, "return_value": "36"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'40'"}, "return_value": "40"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'48'"}, "return_value": "48"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'51'"}, "return_value": "51"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'55'"}, "return_value": "55"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'58'"}, "return_value": "58"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'81'"}, "return_value": "81"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'85'"}, "return_value": "85"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'92'"}, "return_value": "92"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'93'"}, "return_value": "93"}, {"func_args": {"s": "'->'"}, "return_value": "'->'"}, {"func_args": {"s": "'95'"}, "return_value": "95"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'101'"}, "return_value": "101"}, {"func_args": {"s": "'->'"}, "return_value": "'->'"}, {"func_args": {"s": "'103'"}, "return_value": "103"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'107'"}, "return_value": "107"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'111'"}, "return_value": "111"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'114'"}, "return_value": "114"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'117'"}, "return_value": "117"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'121'"}, "return_value": "121"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'122'"}, "return_value": "122"}, {"func_args": {"s": "''"}, "return_value": "''"}, {"func_args": {"s": "'push_notifications/gcm.py                                             '"}, "return_value": "'push_notifications/gcm.py                                             '"}, {"func_args": {"s": "'91'"}, "return_value": "91"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'13'"}, "return_value": "13"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'50'"}, "return_value": "50"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'6'"}, "return_value": "6"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'87'"}, "return_value": "87"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'41'"}, "return_value": "41"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'49'"}, "return_value": "49"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'55'"}, "return_value": "55"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'63'"}, "return_value": "63"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'133'"}, "return_value": "133"}, {"func_args": {"s": "'->'"}, "return_value": "'->'"}, {"func_args": {"s": "'136'"}, "return_value": "136"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'158'"}, "return_value": "158"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'168'"}, "return_value": "168"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'184'"}, "return_value": "184"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'188'"}, "return_value": "188"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'204'"}, "return_value": "204"}, {"func_args": {"s": "''"}, "return_value": "''"}, {"func_args": {"s": "'push_notifications/migrations/'"}, "return_value": "'push_notifications/migrations/'"}, {"func_args": {"s": "'0001'"}, "return_value": "1"}, {"func_args": {"s": "'_initial.py                          '"}, "return_value": "'_initial.py                          '"}, {"func_args": {"s": "'6'"}, "return_value": "6"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'2'"}, "return_value": "2"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'push_notifications/migrations/'"}, "return_value": "'push_notifications/migrations/'"}, {"func_args": {"s": "'0002'"}, "return_value": "2"}, {"func_args": {"s": "'_auto_'"}, "return_value": "'_auto_'"}, {"func_args": {"s": "'20160106'"}, "return_value": "20160106"}, {"func_args": {"s": "'_'"}, "return_value": "'_'"}, {"func_args": {"s": "'0850'"}, "return_value": "850"}, {"func_args": {"s": "'.py               '"}, "return_value": "'.py               '"}, {"func_args": {"s": "'4'"}, "return_value": "4"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'2'"}, "return_value": "2"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'push_notifications/migrations/'"}, "return_value": "'push_notifications/migrations/'"}, {"func_args": {"s": "'0003'"}, "return_value": "3"}, {"func_args": {"s": "'_wnsdevice.py                        '"}, "return_value": "'_wnsdevice.py                        '"}, {"func_args": {"s": "'6'"}, "return_value": "6"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'2'"}, "return_value": "2"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'push_notifications/migrations/'"}, "return_value": "'push_notifications/migrations/'"}, {"func_args": {"s": "'0004'"}, "return_value": "4"}, {"func_args": {"s": "'_fcm.py                              '"}, "return_value": "'_fcm.py                              '"}, {"func_args": {"s": "'5'"}, "return_value": "5"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'2'"}, "return_value": "2"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'push_notifications/migrations/'"}, "return_value": "'push_notifications/migrations/'"}, {"func_args": {"s": "'0005'"}, "return_value": "5"}, {"func_args": {"s": "'_applicationid.py                    '"}, "return_value": "'_applicationid.py                    '"}, {"func_args": {"s": "'5'"}, "return_value": "5"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'2'"}, "return_value": "2"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'push_notifications/migrations/'"}, "return_value": "'push_notifications/migrations/'"}, {"func_args": {"s": "'0006'"}, "return_value": "6"}, {"func_args": {"s": "'_webpushdevice.py                    '"}, "return_value": "'_webpushdevice.py                    '"}, {"func_args": {"s": "'5'"}, "return_value": "5"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'2'"}, "return_value": "2"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'push_notifications/migrations/'"}, "return_value": "'push_notifications/migrations/'"}, {"func_args": {"s": "'0007'"}, "return_value": "7"}, {"func_args": {"s": "'_uniquesetting.py                    '"}, "return_value": "'_uniquesetting.py                    '"}, {"func_args": {"s": "'5'"}, "return_value": "5"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'2'"}, "return_value": "2"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'push_notifications/migrations/'"}, "return_value": "'push_notifications/migrations/'"}, {"func_args": {"s": "'0008'"}, "return_value": "8"}, {"func_args": {"s": "'_webpush_add_edge.py                 '"}, "return_value": "'_webpush_add_edge.py                 '"}, {"func_args": {"s": "'4'"}, "return_value": "4"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'2'"}, "return_value": "2"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'push_notifications/migrations/'"}, "return_value": "'push_notifications/migrations/'"}, {"func_args": {"s": "'0009'"}, "return_value": "9"}, {"func_args": {"s": "'_alter_apnsdevice_device_id.py       '"}, "return_value": "'_alter_apnsdevice_device_id.py       '"}, {"func_args": {"s": "'4'"}, "return_value": "4"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'2'"}, "return_value": "2"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'push_notifications/migrations/__init__.py                              '"}, "return_value": "'push_notifications/migrations/__init__.py                              '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'push_notifications/models.py                                         '"}, "return_value": "'push_notifications/models.py                                         '"}, {"func_args": {"s": "'123'"}, "return_value": "123"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'24'"}, "return_value": "24"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'64'"}, "return_value": "64"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'3'"}, "return_value": "3"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'80'"}, "return_value": "80"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'46'"}, "return_value": "46"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'109'"}, "return_value": "109"}, {"func_args": {"s": "'->'"}, "return_value": "'->'"}, {"func_args": {"s": "'112'"}, "return_value": "112"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'125'"}, "return_value": "125"}, {"func_args": {"s": "'->exit, '"}, "return_value": "'->exit, '"}, {"func_args": {"s": "'141'"}, "return_value": "141"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'142'"}, "return_value": "142"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'178'"}, "return_value": "178"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'194'"}, "return_value": "194"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'210'"}, "return_value": "210"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'212'"}, "return_value": "212"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'225'"}, "return_value": "225"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'230'"}, "return_value": "230"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'253'"}, "return_value": "253"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'256'"}, "return_value": "256"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'258'"}, "return_value": "258"}, {"func_args": {"s": "''"}, "return_value": "''"}, {"func_args": {"s": "'push_notifications/settings.py                                        '"}, "return_value": "'push_notifications/settings.py                                        '"}, {"func_args": {"s": "'24'"}, "return_value": "24"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'1'"}, "return_value": "1"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'2'"}, "return_value": "2"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'1'"}, "return_value": "1"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'92'"}, "return_value": "92"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'26'"}, "return_value": "26"}, {"func_args": {"s": "''"}, "return_value": "''"}, {"func_args": {"s": "'push_notifications/webpush.py                                         '"}, "return_value": "'push_notifications/webpush.py                                         '"}, {"func_args": {"s": "'18'"}, "return_value": "18"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'6'"}, "return_value": "6"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'2'"}, "return_value": "2"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'60'"}, "return_value": "60"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'31'"}, "return_value": "31"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'37'"}, "return_value": "37"}, {"func_args": {"s": "''"}, "return_value": "''"}, {"func_args": {"s": "'push_notifications/wns.py                                            '"}, "return_value": "'push_notifications/wns.py                                            '"}, {"func_args": {"s": "'141'"}, "return_value": "141"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'77'"}, "return_value": "77"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'78'"}, "return_value": "78"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'6'"}, "return_value": "6"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'44'"}, "return_value": "44"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'37'"}, "return_value": "37"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'82'"}, "return_value": "82"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'93'"}, "return_value": "93"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'139'"}, "return_value": "139"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'155'"}, "return_value": "155"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'169'"}, "return_value": "169"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'212'"}, "return_value": "212"}, {"func_args": {"s": "'->'"}, "return_value": "'->'"}, {"func_args": {"s": "'216'"}, "return_value": "216"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'224'"}, "return_value": "224"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'225'"}, "return_value": "225"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'317'"}, "return_value": "317"}, {"func_args": {"s": "'->exit, '"}, "return_value": "'->exit, '"}, {"func_args": {"s": "'320'"}, "return_value": "320"}, {"func_args": {"s": "'->'"}, "return_value": "'->'"}, {"func_args": {"s": "'322'"}, "return_value": "322"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'347'"}, "return_value": "347"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'356'"}, "return_value": "356"}, {"func_args": {"s": "'->'"}, "return_value": "'->'"}, {"func_args": {"s": "'340'"}, "return_value": "340"}, {"func_args": {"s": "''"}, "return_value": "''"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, {"func_args": {"s": "'.'"}, "return_value": "'.'"}, {"func_args": {"s": "'api'"}, "return_value": "'api'"}, {"func_args": {"s": "'conf'"}, "return_value": "'conf'"}, {"func_args": {"s": "'migrations'"}, "return_value": "'migrations'"}, {"func_args": {"s": "'__init__.py'"}, "return_value": "'__init__.py'"}, {"func_args": {"s": "'admin.py'"}, "return_value": "'admin.py'"}, {"func_args": {"s": "'apns.py'"}, "return_value": "'apns.py'"}, {"func_args": {"s": "'compat.py'"}, "return_value": "'compat.py'"}, {"func_args": {"s": "'exceptions.py'"}, "return_value": "'exceptions.py'"}, {"func_args": {"s": "'fields.py'"}, "return_value": "'fields.py'"}, {"func_args": {"s": "'gcm.py'"}, "return_value": "'gcm.py'"}, {"func_args": {"s": "'models.py'"}, "return_value": "'models.py'"}, {"func_args": {"s": "'settings.py'"}, "return_value": "'settings.py'"}, {"func_args": {"s": "'webpush.py'"}, "return_value": "'webpush.py'"}, {"func_args": {"s": "'wns.py'"}, "return_value": "'wns.py'"}, {"func_args": {"s": "'api/__init__.py'"}, "return_value": "'api/__init__.py'"}, {"func_args": {"s": "'api/rest_framework.py'"}, "return_value": "'api/rest_framework.py'"}, {"func_args": {"s": "'conf/__init__.py'"}, "return_value": "'conf/__init__.py'"}, {"func_args": {"s": "'conf/app.py'"}, "return_value": "'conf/app.py'"}, {"func_args": {"s": "'conf/appmodel.py'"}, "return_value": "'conf/appmodel.py'"}, {"func_args": {"s": "'conf/base.py'"}, "return_value": "'conf/base.py'"}, {"func_args": {"s": "'conf/legacy.py'"}, "return_value": "'conf/legacy.py'"}, {"func_args": {"s": "'migrations/'"}, "return_value": "'migrations/'"}, {"func_args": {"s": "'0001'"}, "return_value": "1"}, {"func_args": {"s": "'_initial.py'"}, "return_value": "'_initial.py'"}, {"func_args": {"s": "'migrations/'"}, "return_value": "'migrations/'"}, {"func_args": {"s": "'0002'"}, "return_value": "2"}, {"func_args": {"s": "'_auto_'"}, "return_value": "'_auto_'"}, {"func_args": {"s": "'20160106'"}, "return_value": "20160106"}, {"func_args": {"s": "'_'"}, "return_value": "'_'"}, {"func_args": {"s": "'0850'"}, "return_value": "850"}, {"func_args": {"s": "'.py'"}, "return_value": "'.py'"}, {"func_args": {"s": "'migrations/'"}, "return_value": "'migrations/'"}, {"func_args": {"s": "'0003'"}, "return_value": "3"}, {"func_args": {"s": "'_wnsdevice.py'"}, "return_value": "'_wnsdevice.py'"}, {"func_args": {"s": "'migrations/'"}, "return_value": "'migrations/'"}, {"func_args": {"s": "'0004'"}, "return_value": "4"}, {"func_args": {"s": "'_fcm.py'"}, "return_value": "'_fcm.py'"}, {"func_args": {"s": "'migrations/'"}, "return_value": "'migrations/'"}, {"func_args": {"s": "'0005'"}, "return_value": "5"}, {"func_args": {"s": "'_applicationid.py'"}, "return_value": "'_applicationid.py'"}, {"func_args": {"s": "'migrations/'"}, "return_value": "'migrations/'"}, {"func_args": {"s": "'0006'"}, "return_value": "6"}, {"func_args": {"s": "'_webpushdevice.py'"}, "return_value": "'_webpushdevice.py'"}, {"func_args": {"s": "'migrations/'"}, "return_value": "'migrations/'"}, {"func_args": {"s": "'0007'"}, "return_value": "7"}, {"func_args": {"s": "'_uniquesetting.py'"}, "return_value": "'_uniquesetting.py'"}, {"func_args": {"s": "'migrations/'"}, "return_value": "'migrations/'"}, {"func_args": {"s": "'0008'"}, "return_value": "8"}, {"func_args": {"s": "'_webpush_add_edge.py'"}, "return_value": "'_webpush_add_edge.py'"}, {"func_args": {"s": "'migrations/'"}, "return_value": "'migrations/'"}, {"func_args": {"s": "'0009'"}, "return_value": "9"}, {"func_args": {"s": "'_alter_apnsdevice_device_id.py'"}, "return_value": "'_alter_apnsdevice_device_id.py'"}, {"func_args": {"s": "'migrations/__init__.py'"}, "return_value": "'migrations/__init__.py'"}], "text": "def tryint(s):\n        \"\"\"If `s` is a number, return an int, else `s` unchanged.\"\"\"\n        try:\n            return int(s)\n        except ValueError:\n            return s"}, "human_key": {"line": 366, "args": [{"func_args": {"s": "'push_notifications/__init__.py                                         5      2      0      0    60%   4-6'"}, "return_value": "['push_notifications/__init__.py                                         ', 5, '      ', 2, '      ', 0, '      ', 0, '    ', 60, '%   ', 4, '-', 6, '']"}, {"func_args": {"s": "'push_notifications/admin.py                                           98     62     62      2    28%   23, 29-106, 109, 114, 119, 124, 143'"}, "return_value": "['push_notifications/admin.py                                           ', 98, '     ', 62, '     ', 62, '      ', 2, '    ', 28, '%   ', 23, ', ', 29, '-', 106, ', ', 109, ', ', 114, ', ', 119, ', ', 124, ', ', 143, '']"}, {"func_args": {"s": "'push_notifications/api/__init__.py                                     0      0      0      0   100%   '"}, "return_value": "['push_notifications/api/__init__.py                                     ', 0, '      ', 0, '      ', 0, '      ', 0, '   ', 100, '%   ']"}, {"func_args": {"s": "'push_notifications/api/rest_framework.py                             124     30     76      2    76%   28, 71-75, 82->85, 131, 139-158, 161-163, 166-168, 176'"}, "return_value": "['push_notifications/api/rest_framework.py                             ', 124, '     ', 30, '     ', 76, '      ', 2, '    ', 76, '%   ', 28, ', ', 71, '-', 75, ', ', 82, '->', 85, ', ', 131, ', ', 139, '-', 158, ', ', 161, '-', 163, ', ', 166, '-', 168, ', ', 176, '']"}, {"func_args": {"s": "'push_notifications/apns.py                                            57      3     20      3    92%   20->32, 25-31, 53'"}, "return_value": "['push_notifications/apns.py                                            ', 57, '      ', 3, '     ', 20, '      ', 3, '    ', 92, '%   ', 20, '->', 32, ', ', 25, '-', 31, ', ', 53, '']"}, {"func_args": {"s": "'push_notifications/compat.py                                           3      0      0      0   100%   '"}, "return_value": "['push_notifications/compat.py                                           ', 3, '      ', 0, '      ', 0, '      ', 0, '   ', 100, '%   ']"}, {"func_args": {"s": "'push_notifications/conf/__init__.py                                   11      0      2      0   100%   '"}, "return_value": "['push_notifications/conf/__init__.py                                   ', 11, '      ', 0, '      ', 2, '      ', 0, '   ', 100, '%   ']"}, {"func_args": {"s": "'push_notifications/conf/app.py                                       161     35     44      5    78%   120, 153->163, 177-178, 223-231, 243, 264, 298, 307, 310, 313, 316, 319, 325-337, 340, 346, 349, 352, 355, 358, 361, 364, 367, 370, 373, 376'"}, "return_value": "['push_notifications/conf/app.py                                       ', 161, '     ', 35, '     ', 44, '      ', 5, '    ', 78, '%   ', 120, ', ', 153, '->', 163, ', ', 177, '-', 178, ', ', 223, '-', 231, ', ', 243, ', ', 264, ', ', 298, ', ', 307, ', ', 310, ', ', 313, ', ', 316, ', ', 319, ', ', 325, '-', 337, ', ', 340, ', ', 346, ', ', 349, ', ', 352, ', ', 355, ', ', 358, ', ', 361, ', ', 364, ', ', 367, ', ', 370, ', ', 373, ', ', 376, '']"}, {"func_args": {"s": "'push_notifications/conf/appmodel.py                                    3      0      2      0   100%   '"}, "return_value": "['push_notifications/conf/appmodel.py                                    ', 3, '      ', 0, '      ', 2, '      ', 0, '   ', 100, '%   ']"}, {"func_args": {"s": "'push_notifications/conf/base.py                                       42     15     16      4    67%   6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 44, 51->62, 55->51, 60, 63'"}, "return_value": "['push_notifications/conf/base.py                                       ', 42, '     ', 15, '     ', 16, '      ', 4, '    ', 67, '%   ', 6, ', ', 9, ', ', 12, ', ', 15, ', ', 18, ', ', 21, ', ', 24, ', ', 27, ', ', 30, ', ', 33, ', ', 36, ', ', 39, ', ', 44, ', ', 51, '->', 62, ', ', 55, '->', 51, ', ', 60, ', ', 63, '']"}, {"func_args": {"s": "'push_notifications/conf/legacy.py                                     89     27     14      1    69%   36-39, 42-45, 48-54, 77-78, 82, 91-100, 104, 113, 116, 123, 129, 132, 135, 138, 141, 144-145'"}, "return_value": "['push_notifications/conf/legacy.py                                     ', 89, '     ', 27, '     ', 14, '      ', 1, '    ', 69, '%   ', 36, '-', 39, ', ', 42, '-', 45, ', ', 48, '-', 54, ', ', 77, '-', 78, ', ', 82, ', ', 91, '-', 100, ', ', 104, ', ', 113, ', ', 116, ', ', 123, ', ', 129, ', ', 132, ', ', 135, ', ', 138, ', ', 141, ', ', 144, '-', 145, '']"}, {"func_args": {"s": "'push_notifications/exceptions.py                                      14      0     12      0   100%   '"}, "return_value": "['push_notifications/exceptions.py                                      ', 14, '      ', 0, '     ', 12, '      ', 0, '   ', 100, '%   ']"}, {"func_args": {"s": "'push_notifications/fields.py                                          64     20     24      5    65%   36, 40, 48-51, 55-58, 81, 85, 92, 93->95, 101->103, 107-111, 114-117, 121-122'"}, "return_value": "['push_notifications/fields.py                                          ', 64, '     ', 20, '     ', 24, '      ', 5, '    ', 65, '%   ', 36, ', ', 40, ', ', 48, '-', 51, ', ', 55, '-', 58, ', ', 81, ', ', 85, ', ', 92, ', ', 93, '->', 95, ', ', 101, '->', 103, ', ', 107, '-', 111, ', ', 114, '-', 117, ', ', 121, '-', 122, '']"}, {"func_args": {"s": "'push_notifications/gcm.py                                             91     13     50      6    87%   41-49, 55-63, 133->136, 158, 168, 184, 188, 204'"}, "return_value": "['push_notifications/gcm.py                                             ', 91, '     ', 13, '     ', 50, '      ', 6, '    ', 87, '%   ', 41, '-', 49, ', ', 55, '-', 63, ', ', 133, '->', 136, ', ', 158, ', ', 168, ', ', 184, ', ', 188, ', ', 204, '']"}, {"func_args": {"s": "'push_notifications/migrations/0001_initial.py                          6      0      2      0   100%   '"}, "return_value": "['push_notifications/migrations/', 1, '_initial.py                          ', 6, '      ', 0, '      ', 2, '      ', 0, '   ', 100, '%   ']"}, {"func_args": {"s": "'push_notifications/migrations/0002_auto_20160106_0850.py               4      0      2      0   100%   '"}, "return_value": "['push_notifications/migrations/', 2, '_auto_', 20160106, '_', 850, '.py               ', 4, '      ', 0, '      ', 2, '      ', 0, '   ', 100, '%   ']"}, {"func_args": {"s": "'push_notifications/migrations/0003_wnsdevice.py                        6      0      2      0   100%   '"}, "return_value": "['push_notifications/migrations/', 3, '_wnsdevice.py                        ', 6, '      ', 0, '      ', 2, '      ', 0, '   ', 100, '%   ']"}, {"func_args": {"s": "'push_notifications/migrations/0004_fcm.py                              5      0      2      0   100%   '"}, "return_value": "['push_notifications/migrations/', 4, '_fcm.py                              ', 5, '      ', 0, '      ', 2, '      ', 0, '   ', 100, '%   ']"}, {"func_args": {"s": "'push_notifications/migrations/0005_applicationid.py                    5      0      2      0   100%   '"}, "return_value": "['push_notifications/migrations/', 5, '_applicationid.py                    ', 5, '      ', 0, '      ', 2, '      ', 0, '   ', 100, '%   ']"}, {"func_args": {"s": "'push_notifications/migrations/0006_webpushdevice.py                    5      0      2      0   100%   '"}, "return_value": "['push_notifications/migrations/', 6, '_webpushdevice.py                    ', 5, '      ', 0, '      ', 2, '      ', 0, '   ', 100, '%   ']"}, {"func_args": {"s": "'push_notifications/migrations/0007_uniquesetting.py                    5      0      2      0   100%   '"}, "return_value": "['push_notifications/migrations/', 7, '_uniquesetting.py                    ', 5, '      ', 0, '      ', 2, '      ', 0, '   ', 100, '%   ']"}, {"func_args": {"s": "'push_notifications/migrations/0008_webpush_add_edge.py                 4      0      2      0   100%   '"}, "return_value": "['push_notifications/migrations/', 8, '_webpush_add_edge.py                 ', 4, '      ', 0, '      ', 2, '      ', 0, '   ', 100, '%   ']"}, {"func_args": {"s": "'push_notifications/migrations/0009_alter_apnsdevice_device_id.py       4      0      2      0   100%   '"}, "return_value": "['push_notifications/migrations/', 9, '_alter_apnsdevice_device_id.py       ', 4, '      ', 0, '      ', 2, '      ', 0, '   ', 100, '%   ']"}, {"func_args": {"s": "'push_notifications/migrations/__init__.py                              0      0      0      0   100%   '"}, "return_value": "['push_notifications/migrations/__init__.py                              ', 0, '      ', 0, '      ', 0, '      ', 0, '   ', 100, '%   ']"}, {"func_args": {"s": "'push_notifications/models.py                                         123     24     64      3    80%   46, 109->112, 125->exit, 141-142, 178-194, 210-212, 225-230, 253, 256-258'"}, "return_value": "['push_notifications/models.py                                         ', 123, '     ', 24, '     ', 64, '      ', 3, '    ', 80, '%   ', 46, ', ', 109, '->', 112, ', ', 125, '->exit, ', 141, '-', 142, ', ', 178, '-', 194, ', ', 210, '-', 212, ', ', 225, '-', 230, ', ', 253, ', ', 256, '-', 258, '']"}, {"func_args": {"s": "'push_notifications/settings.py                                        24      1      2      1    92%   26'"}, "return_value": "['push_notifications/settings.py                                        ', 24, '      ', 1, '      ', 2, '      ', 1, '    ', 92, '%   ', 26, '']"}, {"func_args": {"s": "'push_notifications/webpush.py                                         18      6      2      0    60%   31-37'"}, "return_value": "['push_notifications/webpush.py                                         ', 18, '      ', 6, '      ', 2, '      ', 0, '    ', 60, '%   ', 31, '-', 37, '']"}, {"func_args": {"s": "'push_notifications/wns.py                                            141     77     78      6    44%   37-82, 93-139, 155-169, 212->216, 224-225, 317->exit, 320->322, 347, 356->340'"}, "return_value": "['push_notifications/wns.py                                            ', 141, '     ', 77, '     ', 78, '      ', 6, '    ', 44, '%   ', 37, '-', 82, ', ', 93, '-', 139, ', ', 155, '-', 169, ', ', 212, '->', 216, ', ', 224, '-', 225, ', ', 317, '->exit, ', 320, '->', 322, ', ', 347, ', ', 356, '->', 340, '']"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-push-notifications/push_notifications'"}, "return_value": "['/usr/app/src/test_repos/django-push-notifications/push_notifications']"}, {"func_args": {"s": "'.'"}, "return_value": "['.']"}, {"func_args": {"s": "'api'"}, "return_value": "['api']"}, {"func_args": {"s": "'conf'"}, "return_value": "['conf']"}, {"func_args": {"s": "'migrations'"}, "return_value": "['migrations']"}, {"func_args": {"s": "'__init__.py'"}, "return_value": "['__init__.py']"}, {"func_args": {"s": "'admin.py'"}, "return_value": "['admin.py']"}, {"func_args": {"s": "'apns.py'"}, "return_value": "['apns.py']"}, {"func_args": {"s": "'compat.py'"}, "return_value": "['compat.py']"}, {"func_args": {"s": "'exceptions.py'"}, "return_value": "['exceptions.py']"}, {"func_args": {"s": "'fields.py'"}, "return_value": "['fields.py']"}, {"func_args": {"s": "'gcm.py'"}, "return_value": "['gcm.py']"}, {"func_args": {"s": "'models.py'"}, "return_value": "['models.py']"}, {"func_args": {"s": "'settings.py'"}, "return_value": "['settings.py']"}, {"func_args": {"s": "'webpush.py'"}, "return_value": "['webpush.py']"}, {"func_args": {"s": "'wns.py'"}, "return_value": "['wns.py']"}, {"func_args": {"s": "'api/__init__.py'"}, "return_value": "['api/__init__.py']"}, {"func_args": {"s": "'api/rest_framework.py'"}, "return_value": "['api/rest_framework.py']"}, {"func_args": {"s": "'conf/__init__.py'"}, "return_value": "['conf/__init__.py']"}, {"func_args": {"s": "'conf/app.py'"}, "return_value": "['conf/app.py']"}, {"func_args": {"s": "'conf/appmodel.py'"}, "return_value": "['conf/appmodel.py']"}, {"func_args": {"s": "'conf/base.py'"}, "return_value": "['conf/base.py']"}, {"func_args": {"s": "'conf/legacy.py'"}, "return_value": "['conf/legacy.py']"}, {"func_args": {"s": "'migrations/0001_initial.py'"}, "return_value": "['migrations/', 1, '_initial.py']"}, {"func_args": {"s": "'migrations/0002_auto_20160106_0850.py'"}, "return_value": "['migrations/', 2, '_auto_', 20160106, '_', 850, '.py']"}, {"func_args": {"s": "'migrations/0003_wnsdevice.py'"}, "return_value": "['migrations/', 3, '_wnsdevice.py']"}, {"func_args": {"s": "'migrations/0004_fcm.py'"}, "return_value": "['migrations/', 4, '_fcm.py']"}, {"func_args": {"s": "'migrations/0005_applicationid.py'"}, "return_value": "['migrations/', 5, '_applicationid.py']"}, {"func_args": {"s": "'migrations/0006_webpushdevice.py'"}, "return_value": "['migrations/', 6, '_webpushdevice.py']"}, {"func_args": {"s": "'migrations/0007_uniquesetting.py'"}, "return_value": "['migrations/', 7, '_uniquesetting.py']"}, {"func_args": {"s": "'migrations/0008_webpush_add_edge.py'"}, "return_value": "['migrations/', 8, '_webpush_add_edge.py']"}, {"func_args": {"s": "'migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "['migrations/', 9, '_alter_apnsdevice_device_id.py']"}, {"func_args": {"s": "'migrations/__init__.py'"}, "return_value": "['migrations/__init__.py']"}], "text": "def human_key(s):\n    \"\"\"Turn a string into a list of string and number chunks.\n        \"z23a\" -> [\"z\", 23, \"a\"]\n    \"\"\"\n    def tryint(s):\n        \"\"\"If `s` is a number, return an int, else `s` unchanged.\"\"\"\n        try:\n            return int(s)\n        except ValueError:\n            return s\n\n    return [tryint(c) for c in re.split(r\"(\\d+)\", s)]"}, "human_sorted": {"line": 379, "args": [{"func_args": {"strings": "{'/usr/app/src/test_repos/django-push-notifications/push_notifications'}"}, "return_value": "['/usr/app/src/test_repos/django-push-notifications/push_notifications']"}], "text": "def human_sorted(strings):\n    \"\"\"Sort the given iterable of strings the way that humans expect.\n\n    Numeric components in the strings are sorted as numbers.\n\n    Returns the sorted list.\n\n    \"\"\"\n    return sorted(strings, key=human_key)"}, "combinable_files": {"line": 55, "args": [{"func_args": {"data_file": "'/usr/app/src/test_repos/django-push-notifications/.coverage'", "data_paths": "None"}, "return_value": "['/usr/app/src/test_repos/django-push-notifications/.coverage.cae2a1e14906.2077.683009']"}], "text": "def combinable_files(data_file, data_paths=None):\n    \"\"\"Make a list of data files to be combined.\n\n    `data_file` is a path to a data file.  `data_paths` is a list of files or\n    directories of files.\n\n    Returns a list of absolute file paths.\n    \"\"\"\n    data_dir, local = os.path.split(os.path.abspath(data_file))\n\n    data_paths = data_paths or [data_dir]\n    files_to_combine = []\n    for p in data_paths:\n        if os.path.isfile(p):\n            files_to_combine.append(os.path.abspath(p))\n        elif os.path.isdir(p):\n            pattern = os.path.join(os.path.abspath(p), f\"{local}.*\")\n            files_to_combine.extend(glob.glob(pattern))\n        else:\n            raise NoDataError(f\"Couldn't combine from non-existent path '{p}'\")\n    return files_to_combine"}, "_line_ranges": {"line": 270, "args": [{"func_args": {"statements": "{1, 3, 4, 6, 8}", "lines": "{4, 6}"}, "return_value": "[(4, 6)]"}, {"func_args": {"statements": "{1, 2, 3, 4, 6, 7, 8, 11, 14, 15, 16, 17, 18, 20, 21, 23, 25, 29, 30, 31, 33, 34, 35, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 60, 61, 62, 63, 64, 65, 70, 71, 72, 73, 74, 78, 79, 82, 83, 84, 85, 86, 87, 88, 89, 90, 95, 96, 97, 98, 100, 101, 102, 103, 105, 106, 108, 109, 111, 113, 114, 116, 118, 119, 121, 123, 124, 126, 129, 130, 133, 136, 137, 138, 140, 141, 143, 146, 147, 148, 149}", "lines": "{143, 23, 29, 30, 31, 33, 34, 35, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 60, 61, 62, 63, 64, 65, 70, 71, 72, 73, 74, 78, 79, 82, 83, 84, 85, 86, 87, 88, 89, 90, 95, 96, 97, 98, 100, 101, 102, 103, 105, 106, 109, 114, 119, 124}"}, "return_value": "[(23, 23), (29, 106), (109, 109), (114, 114), (119, 119), (124, 124), (143, 143)]"}, {"func_args": {"statements": "set()", "lines": "set()"}, "return_value": "[]"}, {"func_args": {"statements": "{1, 2, 3, 4, 5, 7, 8, 9, 13, 18, 21, 22, 23, 24, 25, 27, 28, 32, 33, 34, 38, 41, 44, 45, 46, 48, 52, 53, 55, 58, 59, 60, 61, 62, 64, 65, 66, 67, 69, 71, 72, 73, 74, 75, 77, 78, 79, 80, 82, 83, 85, 86, 87, 90, 91, 98, 99, 100, 104, 106, 108, 109, 110, 113, 114, 115, 118, 119, 120, 121, 128, 129, 131, 135, 136, 138, 139, 140, 141, 142, 145, 146, 147, 148, 149, 151, 152, 153, 154, 156, 157, 158, 160, 161, 162, 163, 165, 166, 167, 168, 171, 172, 174, 176, 180, 181, 182, 185, 186, 189, 190, 191, 194, 195, 198, 199, 200, 203, 204, 207, 208, 209, 212, 213}", "lines": "{131, 139, 140, 141, 142, 145, 146, 147, 148, 149, 151, 152, 153, 154, 28, 156, 157, 158, 161, 162, 163, 166, 167, 168, 176, 71, 72, 73, 74, 75}"}, "return_value": "[(28, 28), (71, 75), (131, 131), (139, 158), (161, 163), (166, 168), (176, 176)]"}, {"func_args": {"statements": "{7, 9, 10, 11, 12, 138, 14, 15, 16, 142, 143, 19, 20, 21, 22, 23, 144, 25, 31, 32, 37, 38, 41, 45, 46, 50, 52, 53, 55, 61, 64, 66, 69, 70, 71, 73, 74, 75, 76, 77, 78, 80, 82, 83, 87, 92, 93, 100, 112, 113, 117, 118, 119, 120, 121, 123, 126}", "lines": "{25, 53, 31}"}, "return_value": "[(25, 31), (53, 53)]"}, {"func_args": {"statements": "{2, 3, 4}", "lines": "set()"}, "return_value": "[]"}, {"func_args": {"statements": "{1, 3, 4, 5, 6, 9, 12, 15, 16, 18, 22}", "lines": "set()"}, "return_value": "[]"}, {"func_args": {"statements": "{1, 3, 4, 7, 12, 17, 21, 25, 34, 41, 48, 51, 52, 54, 58, 59, 63, 64, 66, 67, 70, 75, 77, 80, 83, 85, 87, 88, 90, 92, 93, 96, 97, 106, 107, 115, 117, 118, 120, 127, 128, 133, 137, 139, 140, 141, 142, 143, 145, 146, 150, 151, 152, 153, 154, 155, 159, 160, 163, 166, 167, 168, 170, 173, 174, 175, 176, 177, 178, 182, 183, 187, 188, 192, 193, 194, 196, 197, 201, 202, 206, 207, 208, 210, 211, 215, 216, 220, 222, 223, 227, 228, 231, 238, 241, 242, 243, 249, 255, 256, 257, 258, 264, 265, 267, 273, 274, 275, 280, 281, 282, 287, 288, 297, 298, 304, 306, 307, 309, 310, 312, 313, 315, 316, 318, 319, 321, 322, 324, 325, 326, 328, 329, 330, 331, 333, 337, 339, 340, 345, 346, 348, 349, 351, 352, 354, 355, 357, 358, 360, 361, 363, 364, 366, 367, 369, 370, 372, 373, 375, 376}", "lines": "{264, 298, 177, 178, 307, 310, 313, 316, 319, 325, 326, 328, 329, 330, 331, 333, 337, 340, 346, 349, 223, 352, 227, 228, 355, 358, 231, 376, 361, 364, 367, 370, 243, 373, 120}"}, "return_value": "[(120, 120), (177, 178), (223, 231), (243, 243), (264, 264), (298, 298), (307, 307), (310, 310), (313, 313), (316, 316), (319, 319), (325, 337), (340, 340), (346, 346), (349, 349), (352, 352), (355, 355), (358, 358), (361, 361), (364, 364), (367, 367), (370, 370), (373, 373), (376, 376)]"}, {"func_args": {"statements": "{1, 10, 4}", "lines": "set()"}, "return_value": "[]"}, {"func_args": {"statements": "{1, 4, 5, 6, 8, 9, 11, 12, 14, 15, 17, 18, 20, 21, 23, 24, 26, 27, 29, 30, 32, 33, 35, 36, 38, 39, 41, 44, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 62, 63}", "lines": "{33, 36, 6, 39, 9, 12, 44, 15, 18, 21, 24, 27, 60, 30, 63}"}, "return_value": "[(6, 6), (9, 9), (12, 12), (15, 15), (18, 18), (21, 21), (24, 24), (27, 27), (30, 30), (33, 33), (36, 36), (39, 39), (44, 44), (60, 60), (63, 63)]"}, {"func_args": {"statements": "{1, 3, 4, 7, 12, 13, 16, 18, 20, 23, 24, 25, 26, 27, 29, 33, 35, 36, 39, 41, 42, 45, 47, 48, 49, 54, 56, 57, 58, 63, 65, 66, 67, 72, 74, 75, 76, 77, 78, 79, 80, 82, 84, 85, 89, 91, 92, 93, 94, 96, 100, 101, 103, 104, 109, 110, 112, 113, 115, 116, 118, 119, 121, 122, 123, 125, 126, 128, 129, 131, 132, 134, 135, 137, 138, 140, 141, 143, 144, 145, 147, 148, 149, 151, 152, 153, 155, 156, 157}", "lines": "{129, 132, 135, 138, 141, 144, 145, 36, 39, 42, 45, 48, 49, 54, 77, 78, 82, 91, 92, 93, 94, 96, 100, 104, 113, 116, 123}"}, "return_value": "[(36, 39), (42, 45), (48, 54), (77, 78), (82, 82), (91, 100), (104, 104), (113, 113), (116, 116), (123, 123), (129, 129), (132, 132), (135, 135), (138, 138), (141, 141), (144, 145)]"}, {"func_args": {"statements": "{1, 2, 6, 7, 10, 11, 14, 15, 16, 17, 21, 22, 26, 27}", "lines": "set()"}, "return_value": "[]"}, {"func_args": {"statements": "{1, 2, 4, 5, 6, 7, 10, 12, 13, 16, 17, 23, 24, 27, 28, 31, 32, 35, 36, 39, 40, 43, 47, 48, 51, 53, 55, 57, 58, 61, 74, 79, 80, 81, 82, 83, 85, 87, 89, 90, 91, 92, 93, 94, 95, 97, 99, 100, 101, 102, 103, 105, 107, 108, 109, 110, 111, 113, 114, 115, 117, 119, 121, 122}", "lines": "{36, 40, 48, 51, 55, 57, 58, 81, 85, 92, 107, 108, 109, 110, 111, 114, 115, 117, 121, 122}"}, "return_value": "[(36, 36), (40, 40), (48, 51), (55, 58), (81, 81), (85, 85), (92, 92), (107, 111), (114, 117), (121, 122)]"}, {"func_args": {"statements": "{8, 10, 12, 13, 14, 15, 20, 23, 27, 32, 36, 37, 40, 41, 43, 48, 49, 54, 55, 57, 62, 63, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 83, 84, 88, 89, 90, 92, 93, 96, 98, 99, 101, 102, 103, 106, 115, 117, 121, 122, 123, 124, 126, 127, 128, 129, 130, 131, 132, 133, 134, 136, 137, 141, 146, 149, 150, 153, 154, 158, 159, 162, 166, 167, 168, 170, 173, 181, 182, 184, 187, 188, 191, 192, 196, 197, 198, 199, 202, 204, 207}", "lines": "{168, 41, 43, 204, 48, 49, 55, 184, 57, 158, 188, 62, 63}"}, "return_value": "[(41, 49), (55, 63), (158, 158), (168, 168), (184, 184), (188, 188), (204, 204)]"}, {"func_args": {"statements": "{2, 3, 5, 8, 10, 14}", "lines": "set()"}, "return_value": "[]"}, {"func_args": {"statements": "{8, 3, 12, 6}", "lines": "set()"}, "return_value": "[]"}, {"func_args": {"statements": "{3, 4, 5, 8, 10, 15}", "lines": "set()"}, "return_value": "[]"}, {"func_args": {"statements": "{3, 4, 7, 9, 14}", "lines": "set()"}, "return_value": "[]"}, {"func_args": {"statements": "{2, 3, 6, 8, 12}", "lines": "set()"}, "return_value": "[]"}, {"func_args": {"statements": "{2, 3, 6, 8, 13}", "lines": "set()"}, "return_value": "[]"}, {"func_args": {"statements": "{1, 3, 6, 8, 12}", "lines": "set()"}, "return_value": "[]"}, {"func_args": {"statements": "{8, 3, 12, 6}", "lines": "set()"}, "return_value": "[]"}, {"func_args": {"statements": "{8, 3, 12, 6}", "lines": "set()"}, "return_value": "[]"}, {"func_args": {"statements": "set()", "lines": "set()"}, "return_value": "[]"}, {"func_args": {"statements": "{256, 1, 2, 258, 4, 5, 8, 13, 21, 22, 23, 27, 30, 33, 42, 43, 45, 46, 53, 54, 55, 58, 59, 60, 61, 63, 64, 65, 67, 70, 71, 72, 73, 79, 80, 81, 83, 86, 90, 94, 95, 100, 102, 103, 105, 106, 108, 109, 110, 112, 118, 119, 120, 123, 124, 125, 126, 128, 130, 131, 132, 135, 139, 140, 141, 142, 143, 146, 147, 151, 155, 157, 158, 160, 161, 163, 171, 172, 173, 176, 177, 178, 180, 183, 184, 185, 188, 189, 190, 191, 192, 194, 197, 198, 202, 204, 206, 207, 209, 210, 212, 218, 219, 220, 223, 224, 225, 226, 227, 228, 230, 233, 234, 235, 238, 241, 246, 248, 249, 251, 252, 253, 255}", "lines": "{256, 258, 141, 142, 46, 178, 180, 183, 184, 185, 188, 189, 190, 191, 192, 194, 210, 212, 225, 226, 227, 228, 230, 253}"}, "return_value": "[(46, 46), (141, 142), (178, 194), (210, 212), (225, 230), (253, 253), (256, 258)]"}, {"func_args": {"statements": "{1, 4, 6, 11, 14, 15, 18, 21, 22, 25, 26, 28, 29, 30, 33, 34, 35, 40, 46, 47, 48, 51, 54, 57}", "lines": "{26}"}, "return_value": "[(26, 26)]"}, {"func_args": {"statements": "{1, 3, 4, 7, 8, 9, 18, 21, 23, 24, 31, 32, 33, 34, 36, 37, 38, 39}", "lines": "{32, 33, 34, 36, 37, 31}"}, "return_value": "[(31, 37)]"}, {"func_args": {"statements": "{8, 9, 11, 13, 14, 15, 16, 19, 20, 23, 24, 27, 28, 31, 37, 38, 39, 40, 44, 45, 49, 52, 58, 60, 61, 62, 63, 64, 67, 68, 70, 71, 72, 73, 75, 77, 78, 80, 82, 85, 93, 95, 96, 97, 99, 106, 107, 109, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 136, 137, 139, 142, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 172, 210, 211, 212, 213, 216, 218, 219, 220, 221, 223, 224, 225, 227, 232, 237, 248, 249, 250, 251, 255, 256, 259, 317, 318, 319, 320, 321, 322, 325, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 351, 352, 353, 354, 355, 356, 357, 360, 369, 370, 371}", "lines": "{37, 38, 39, 40, 44, 45, 49, 52, 58, 60, 61, 62, 63, 64, 67, 68, 70, 71, 72, 73, 75, 77, 78, 80, 82, 93, 95, 96, 97, 99, 106, 107, 109, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 136, 137, 139, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 224, 225, 347}"}, "return_value": "[(37, 82), (93, 139), (155, 169), (224, 225), (347, 347)]"}], "text": "def _line_ranges(statements, lines):\n    \"\"\"Produce a list of ranges for `format_lines`.\"\"\"\n    statements = sorted(statements)\n    lines = sorted(lines)\n\n    pairs = []\n    start = None\n    lidx = 0\n    for stmt in statements:\n        if lidx >= len(lines):\n            break\n        if stmt == lines[lidx]:\n            lidx += 1\n            if not start:\n                start = stmt\n            end = stmt\n        elif start:\n            pairs.append((start, end))\n            start = None\n    if start:\n        pairs.append((start, end))\n    return pairs"}, "source_for_file": {"line": 97, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}], "text": "def source_for_file(filename):\n    \"\"\"Return the source filename for `filename`.\n\n    Given a file name being traced, return the best guess as to the source\n    file to attribute it to.\n\n    \"\"\"\n    if filename.endswith(\".py\"):\n        # .py files are themselves source files.\n        return filename\n\n    elif filename.endswith((\".pyc\", \".pyo\")):\n        # Bytecode files probably have source files near them.\n        py_filename = filename[:-1]\n        if os.path.exists(py_filename):\n            # Found a .py file, use that.\n            return py_filename\n        if env.WINDOWS:\n            # On Windows, it could be a .pyw file.\n            pyw_filename = py_filename + \"w\"\n            if os.path.exists(pyw_filename):\n                return pyw_filename\n        # Didn't find source, but it's probably the .py file we want.\n        return py_filename\n\n    elif filename.endswith(\"$py.class\"):\n        # Jython is easy to guess.\n        return filename[:-9] + \".py\"\n\n    # No idea, just use the file name as-is.\n    return filename"}, "source_for_morf": {"line": 130, "args": [{"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}], "text": "def source_for_morf(morf):\n    \"\"\"Get the source filename for the module-or-file `morf`.\"\"\"\n    if hasattr(morf, '__file__') and morf.__file__:\n        filename = morf.__file__\n    elif isinstance(morf, types.ModuleType):\n        # A module should have had .__file__, otherwise we can't use it.\n        # This could be a PEP-420 namespace package.\n        raise CoverageException(f\"Module {morf} has no file\")\n    else:\n        filename = morf\n\n    filename = source_for_file(filename)\n    return filename"}, "read_python_source": {"line": 20, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "b'try:\\n    # Python 3.8+\\n    import importlib.metadata as importlib_metadata\\nexcept ImportError:\\n    # <Python 3.7 and lower\\n    import importlib_metadata\\n\\n__version__ = importlib_metadata.version(\"django-push-notifications\")\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "b'from django.apps import apps\\nfrom django.contrib import admin, messages\\nfrom django.utils.encoding import force_str\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .exceptions import APNSServerError, GCMError, WebPushError\\nfrom .models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nUser = apps.get_model(*SETTINGS[\"USER_MODEL\"].split(\".\"))\\n\\n\\nclass DeviceAdmin(admin.ModelAdmin):\\n\\tlist_display = (\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\",)\\n\\tactions = (\"send_message\", \"send_bulk_message\", \"enable\", \"disable\")\\n\\traw_id_fields = (\"user\",)\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"device_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"device_id\")\\n\\n\\tdef send_messages(self, request, queryset, bulk=False):\\n\\t\\t\"\"\"\\n\\t\\tProvides error handling for DeviceAdmin send_message and send_bulk_message methods.\\n\\t\\t\"\"\"\\n\\t\\tret = []\\n\\t\\terrors = []\\n\\t\\tr = \"\"\\n\\n\\t\\tfor device in queryset:\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tif bulk:\\n\\t\\t\\t\\t\\tr = queryset.send_message(\"Test bulk notification\")\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = device.send_message(\"Test single notification\")\\n\\t\\t\\t\\tif r:\\n\\t\\t\\t\\t\\tret.append(r)\\n\\t\\t\\texcept GCMError as e:\\n\\t\\t\\t\\terrors.append(str(e))\\n\\t\\t\\texcept APNSServerError as e:\\n\\t\\t\\t\\terrors.append(e.status)\\n\\t\\t\\texcept WebPushError as e:\\n\\t\\t\\t\\terrors.append(force_str(e))\\n\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\t# Because NotRegistered and InvalidRegistration do not throw GCMError\\n\\t\\t# catch them here to display error msg.\\n\\t\\tif not bulk:\\n\\t\\t\\tfor r in ret:\\n\\t\\t\\t\\tif \"error\" in r[\"results\"][0]:\\n\\t\\t\\t\\t\\terrors.append(r[\"results\"][0][\"error\"])\\n\\t\\telse:\\n\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\terrors = [r[\"error\"] for r in ret[0][0][\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\terrors = errors + [r[\"error\"] for r in entry[\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept IndexError:\\n\\t\\t\\t\\t\\tpass\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\tif value.lower() != \"success\":\\n\\t\\t\\t\\t\\t\\terrors.append(value)\\n\\t\\tif errors:\\n\\t\\t\\tself.message_user(\\n\\t\\t\\t\\trequest, _(\"Some messages could not be processed: %r\" % (\", \".join(errors))),\\n\\t\\t\\t\\tlevel=messages.ERROR\\n\\t\\t\\t)\\n\\t\\tif ret:\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\t# When the queryset exceeds the max_recipients value, the\\n\\t\\t\\t\\t# send_message method returns a list of dicts, one per chunk\\n\\t\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\t\\tsuccess = ret[0][0][\"success\"]\\n\\t\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\t\\tsuccess = 0\\n\\t\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\t\\tsuccess = success + entry[\"success\"]\\n\\t\\t\\t\\t\\tif success == 0:\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\t\\tsuccess = []\\n\\t\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\t\\tif value.lower() == \"success\":\\n\\t\\t\\t\\t\\t\\t\\tsuccess.append(key)\\n\\n\\t\\t\\telif len(errors) == len(ret):\\n\\t\\t\\t\\treturn\\n\\t\\t\\tif errors:\\n\\t\\t\\t\\tmsg = _(\"Some messages were sent: %s\" % (ret))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = _(\"All messages were sent: %s\" % (ret))\\n\\t\\t\\tself.message_user(request, msg)\\n\\n\\tdef send_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset)\\n\\n\\tsend_message.short_description = _(\"Send test message\")\\n\\n\\tdef send_bulk_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset, True)\\n\\n\\tsend_bulk_message.short_description = _(\"Send test message in bulk\")\\n\\n\\tdef enable(self, request, queryset):\\n\\t\\tqueryset.update(active=True)\\n\\n\\tenable.short_description = _(\"Enable selected devices\")\\n\\n\\tdef disable(self, request, queryset):\\n\\t\\tqueryset.update(active=False)\\n\\n\\tdisable.short_description = _(\"Disable selected devices\")\\n\\n\\nclass GCMDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\\n\\t\\t\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\", \"cloud_message_type\"\\n\\t)\\n\\tlist_filter = (\"active\", \"cloud_message_type\")\\n\\n\\nclass WebPushDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\"__str__\", \"browser\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\", \"browser\")\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"registration_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"registration_id\")\\n\\n\\nadmin.site.register(APNSDevice, DeviceAdmin)\\nadmin.site.register(GCMDevice, GCMDeviceAdmin)\\nadmin.site.register(WNSDevice, DeviceAdmin)\\nadmin.site.register(WebPushDevice, WebPushDeviceAdmin)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "b''"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "b'from rest_framework import permissions, status\\nfrom rest_framework.fields import IntegerField\\nfrom rest_framework.response import Response\\nfrom rest_framework.serializers import ModelSerializer, Serializer, ValidationError\\nfrom rest_framework.viewsets import ModelViewSet\\n\\nfrom ..fields import UNSIGNED_64BIT_INT_MAX_VALUE, hex_re\\nfrom ..models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\n# Fields\\nclass HexIntegerField(IntegerField):\\n\\t\"\"\"\\n\\tStore an integer represented as a hex string of form \"0x01\".\\n\\t\"\"\"\\n\\n\\tdef to_internal_value(self, data):\\n\\t\\t# validate hex string and convert it to the unsigned\\n\\t\\t# integer representation for internal use\\n\\t\\ttry:\\n\\t\\t\\tdata = int(data, 16) if type(data) != int else data\\n\\t\\texcept ValueError:\\n\\t\\t\\traise ValidationError(\"Device ID is not a valid hex number\")\\n\\t\\treturn super(HexIntegerField, self).to_internal_value(data)\\n\\n\\tdef to_representation(self, value):\\n\\t\\treturn value\\n\\n\\n# Serializers\\nclass DeviceSerializerMixin(ModelSerializer):\\n\\tclass Meta:\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"application_id\", \"registration_id\", \"device_id\",\\n\\t\\t\\t\"active\", \"date_created\"\\n\\t\\t)\\n\\t\\tread_only_fields = (\"date_created\",)\\n\\n\\t\\t# See https://github.com/tomchristie/django-rest-framework/issues/1101\\n\\t\\textra_kwargs = {\"active\": {\"default\": True}}\\n\\n\\nclass APNSDeviceSerializer(ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = APNSDevice\\n\\n\\tdef validate_registration_id(self, value):\\n\\t\\t# iOS device tokens are 256-bit hexadecimal (64 characters). In 2016 Apple is increasing\\n\\t\\t# iOS device tokens to 100 bytes hexadecimal (200 characters).\\n\\n\\t\\tif hex_re.match(value) is None or len(value) not in (64, 200):\\n\\t\\t\\traise ValidationError(\"Registration ID (device token) is invalid\")\\n\\n\\t\\treturn value\\n\\n\\nclass UniqueRegistrationSerializerMixin(Serializer):\\n\\tdef validate(self, attrs):\\n\\t\\tdevices = None\\n\\t\\tprimary_key = None\\n\\t\\trequest_method = None\\n\\n\\t\\tif self.initial_data.get(\"registration_id\", None):\\n\\t\\t\\tif self.instance:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telse:\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\t\\telse:\\n\\t\\t\\tif self.context[\"request\"].method in [\"PUT\", \"PATCH\"]:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telif self.context[\"request\"].method == \"POST\":\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\n\\t\\tDevice = self.Meta.model\\n\\t\\tif request_method == \"update\":\\n\\t\\t\\treg_id = attrs.get(\"registration_id\", self.instance.registration_id)\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=reg_id) \\\\\\n\\t\\t\\t\\t.exclude(id=primary_key)\\n\\t\\telif request_method == \"create\":\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=attrs[\"registration_id\"])\\n\\n\\t\\tif devices:\\n\\t\\t\\traise ValidationError({\"registration_id\": \"This field must be unique.\"})\\n\\t\\treturn attrs\\n\\n\\nclass GCMDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tdevice_id = HexIntegerField(\\n\\t\\thelp_text=\"ANDROID_ID / TelephonyManager.getDeviceId() (e.g: 0x01)\",\\n\\t\\tstyle={\"input_type\": \"text\"},\\n\\t\\trequired=False,\\n\\t\\tallow_null=True\\n\\t)\\n\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = GCMDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"device_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"cloud_message_type\", \"application_id\",\\n\\t\\t)\\n\\t\\textra_kwargs = {\"id\": {\"read_only\": False, \"required\": False}}\\n\\n\\tdef validate_device_id(self, value):\\n\\t\\t# device ids are 64 bit unsigned values\\n\\t\\tif value > UNSIGNED_64BIT_INT_MAX_VALUE:\\n\\t\\t\\traise ValidationError(\"Device ID is out of range\")\\n\\t\\treturn value\\n\\n\\nclass WNSDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WNSDevice\\n\\n\\nclass WebPushDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WebPushDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"p256dh\", \"auth\", \"browser\", \"application_id\",\\n\\t\\t)\\n\\n\\n# Permissions\\nclass IsOwner(permissions.BasePermission):\\n\\tdef has_object_permission(self, request, view, obj):\\n\\t\\t# must be the owner to view the object\\n\\t\\treturn obj.user == request.user\\n\\n\\n# Mixins\\nclass DeviceViewSetMixin:\\n\\tlookup_field = \"registration_id\"\\n\\n\\tdef create(self, request, *args, **kwargs):\\n\\t\\tserializer = None\\n\\t\\tis_update = False\\n\\t\\tif SETTINGS.get(\"UPDATE_ON_DUPLICATE_REG_ID\") and self.lookup_field in request.data:\\n\\t\\t\\tinstance = self.queryset.model.objects.filter(\\n\\t\\t\\t\\tregistration_id=request.data[self.lookup_field]\\n\\t\\t\\t).first()\\n\\t\\t\\tif instance:\\n\\t\\t\\t\\tserializer = self.get_serializer(instance, data=request.data)\\n\\t\\t\\t\\tis_update = True\\n\\t\\tif not serializer:\\n\\t\\t\\tserializer = self.get_serializer(data=request.data)\\n\\n\\t\\tserializer.is_valid(raise_exception=True)\\n\\t\\tif is_update:\\n\\t\\t\\tself.perform_update(serializer)\\n\\t\\t\\treturn Response(serializer.data)\\n\\t\\telse:\\n\\t\\t\\tself.perform_create(serializer)\\n\\t\\t\\theaders = self.get_success_headers(serializer.data)\\n\\t\\t\\treturn Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\\n\\n\\tdef perform_create(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_create(serializer)\\n\\n\\tdef perform_update(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_update(serializer)\\n\\n\\nclass AuthorizedMixin:\\n\\tpermission_classes = (permissions.IsAuthenticated, IsOwner)\\n\\n\\tdef get_queryset(self):\\n\\t\\t# filter all devices to only those belonging to the current user\\n\\t\\treturn self.queryset.filter(user=self.request.user)\\n\\n\\n# ViewSets\\nclass APNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = APNSDevice.objects.all()\\n\\tserializer_class = APNSDeviceSerializer\\n\\n\\nclass APNSDeviceAuthorizedViewSet(AuthorizedMixin, APNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass GCMDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = GCMDevice.objects.all()\\n\\tserializer_class = GCMDeviceSerializer\\n\\n\\nclass GCMDeviceAuthorizedViewSet(AuthorizedMixin, GCMDeviceViewSet):\\n\\tpass\\n\\n\\nclass WNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WNSDevice.objects.all()\\n\\tserializer_class = WNSDeviceSerializer\\n\\n\\nclass WNSDeviceAuthorizedViewSet(AuthorizedMixin, WNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass WebPushDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WebPushDevice.objects.all()\\n\\tserializer_class = WebPushDeviceSerializer\\n\\n\\nclass WebPushDeviceAuthorizedViewSet(AuthorizedMixin, WebPushDeviceViewSet):\\n\\tpass\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "b'\"\"\"\\nApple Push Notification Service\\nDocumentation is available on the iOS Developer Library:\\nhttps://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html\\n\"\"\"\\n\\nimport time\\n\\nfrom apns2 import client as apns2_client\\nfrom apns2 import credentials as apns2_credentials\\nfrom apns2 import errors as apns2_errors\\nfrom apns2 import payload as apns2_payload\\n\\nfrom . import models\\nfrom .conf import get_manager\\nfrom .exceptions import APNSError, APNSUnsupportedPriority, APNSServerError\\n\\n\\ndef _apns_create_socket(creds=None, application_id=None):\\n\\tif creds is None:\\n\\t\\tif not get_manager().has_auth_token_creds(application_id):\\n\\t\\t\\tcert = get_manager().get_apns_certificate(application_id)\\n\\t\\t\\tcreds = apns2_credentials.CertificateCredentials(cert)\\n\\t\\telse:\\n\\t\\t\\tkeyPath, keyId, teamId = get_manager().get_apns_auth_creds(application_id)\\n\\t\\t\\t# No use getting a lifetime because this credential is\\n\\t\\t\\t# ephemeral, but if you\\'re looking at this to see how to\\n\\t\\t\\t# create a credential, you could also pass the lifetime and\\n\\t\\t\\t# algorithm. Neither of those settings are exposed in the\\n\\t\\t\\t# settings API at the moment.\\n\\t\\t\\tcreds = creds or apns2_credentials.TokenCredentials(keyPath, keyId, teamId)\\n\\tclient = apns2_client.APNsClient(\\n\\t\\tcreds,\\n\\t\\tuse_sandbox=get_manager().get_apns_use_sandbox(application_id),\\n\\t\\tuse_alternative_port=get_manager().get_apns_use_alternative_port(application_id)\\n\\t)\\n\\tclient.connect()\\n\\treturn client\\n\\n\\ndef _apns_prepare(\\n\\ttoken, alert, application_id=None, badge=None, sound=None, category=None,\\n\\tcontent_available=False, action_loc_key=None, loc_key=None, loc_args=[],\\n\\textra={}, mutable_content=False, thread_id=None, url_args=None):\\n\\t\\tif action_loc_key or loc_key or loc_args:\\n\\t\\t\\tapns2_alert = apns2_payload.PayloadAlert(\\n\\t\\t\\t\\tbody=alert if alert else {}, body_localized_key=loc_key,\\n\\t\\t\\t\\tbody_localized_args=loc_args, action_localized_key=action_loc_key)\\n\\t\\telse:\\n\\t\\t\\tapns2_alert = alert\\n\\n\\t\\tif callable(badge):\\n\\t\\t\\tbadge = badge(token)\\n\\n\\t\\treturn apns2_payload.Payload(\\n\\t\\t\\talert=apns2_alert, badge=badge, sound=sound, category=category,\\n\\t\\t\\turl_args=url_args, custom=extra, thread_id=thread_id,\\n\\t\\t\\tcontent_available=content_available, mutable_content=mutable_content)\\n\\n\\ndef _apns_send(\\n\\tregistration_id, alert, batch=False, application_id=None, creds=None, **kwargs\\n):\\n\\tclient = _apns_create_socket(creds=creds, application_id=application_id)\\n\\n\\tnotification_kwargs = {}\\n\\n\\t# if expiration isn\"t specified use 1 month from now\\n\\tnotification_kwargs[\"expiration\"] = kwargs.pop(\"expiration\", None)\\n\\tif not notification_kwargs[\"expiration\"]:\\n\\t\\tnotification_kwargs[\"expiration\"] = int(time.time()) + 2592000\\n\\n\\tpriority = kwargs.pop(\"priority\", None)\\n\\tif priority:\\n\\t\\ttry:\\n\\t\\t\\tnotification_kwargs[\"priority\"] = apns2_client.NotificationPriority(str(priority))\\n\\t\\texcept ValueError:\\n\\t\\t\\traise APNSUnsupportedPriority(\"Unsupported priority %d\" % (priority))\\n\\n\\tnotification_kwargs[\"collapse_id\"] = kwargs.pop(\"collapse_id\", None)\\n\\n\\tif batch:\\n\\t\\tdata = [apns2_client.Notification(\\n\\t\\t\\ttoken=rid, payload=_apns_prepare(rid, alert, **kwargs)) for rid in registration_id]\\n\\t\\t# returns a dictionary mapping each token to its result. That\\n\\t\\t# result is either \"Success\" or the reason for the failure.\\n\\t\\treturn client.send_notification_batch(\\n\\t\\t\\tdata, get_manager().get_apns_topic(application_id=application_id),\\n\\t\\t\\t**notification_kwargs\\n\\t\\t)\\n\\n\\tdata = _apns_prepare(registration_id, alert, **kwargs)\\n\\tclient.send_notification(\\n\\t\\tregistration_id, data,\\n\\t\\tget_manager().get_apns_topic(application_id=application_id),\\n\\t\\t**notification_kwargs\\n\\t)\\n\\n\\ndef apns_send_message(registration_id, alert, application_id=None, creds=None, **kwargs):\\n\\t\"\"\"\\n\\tSends an APNS notification to a single registration_id.\\n\\tThis will send the notification as form data.\\n\\tIf sending multiple notifications, it is more efficient to use\\n\\tapns_send_bulk_message()\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\ttry:\\n\\t\\t_apns_send(\\n\\t\\t\\tregistration_id, alert, application_id=application_id,\\n\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t)\\n\\texcept apns2_errors.APNsException as apns2_exception:\\n\\t\\tif isinstance(apns2_exception, apns2_errors.Unregistered):\\n\\t\\t\\tdevice = models.APNSDevice.objects.get(registration_id=registration_id)\\n\\t\\t\\tdevice.active = False\\n\\t\\t\\tdevice.save()\\n\\n\\t\\traise APNSServerError(status=apns2_exception.__class__.__name__)\\n\\n\\ndef apns_send_bulk_message(\\n\\tregistration_ids, alert, application_id=None, creds=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends an APNS notification to one or more registration_ids.\\n\\tThe registration_ids argument needs to be a list.\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\tresults = _apns_send(\\n\\t\\tregistration_ids, alert, batch=True, application_id=application_id,\\n\\t\\tcreds=creds, **kwargs\\n\\t)\\n\\tinactive_tokens = [token for token, result in results.items() if result == \"Unregistered\"]\\n\\tmodels.APNSDevice.objects.filter(registration_id__in=inactive_tokens).update(active=False)\\n\\treturn results\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "b'# flake8:noqa\\nfrom urllib.error import HTTPError\\nfrom urllib.parse import urlencode\\nfrom urllib.request import Request, urlopen\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "b'from django.utils.module_loading import import_string\\n\\nfrom .app import AppConfig  # noqa: F401\\nfrom .appmodel import AppModelConfig  # noqa: F401\\nfrom .legacy import LegacyConfig  # noqa: F401\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS  # noqa: I001\\n\\n\\nmanager = None\\n\\n\\ndef get_manager(reload=False):\\n\\tglobal manager\\n\\n\\tif not manager or reload is True:\\n\\t\\tmanager = import_string(SETTINGS[\"CONFIG\"])()\\n\\n\\treturn manager\\n\\n\\n# implementing get_manager as a function allows tests to reload settings\\nget_manager()\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "b'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig, check_apns_certificate\\n\\n\\nSETTING_MISMATCH = (\\n\\t\"Application \\'{application_id}\\' ({platform}) does not support the setting \\'{setting}\\'.\"\\n)\\n\\n# code can be \"missing\" or \"invalid\"\\nBAD_PLATFORM = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"PLATFORM\"] is {code}. \\'\\n\\t\"Must be one of: {platforms}.\"\\n)\\n\\nUNKNOWN_PLATFORM = (\\n\\t\"Unknown Platform: {platform}. Must be one of: {platforms}.\"\\n)\\n\\nMISSING_SETTING = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"{setting}\"] is missing.\\'\\n)\\n\\nPLATFORMS = [\\n\\t\"APNS\",\\n\\t\"FCM\",\\n\\t\"GCM\",\\n\\t\"WNS\",\\n\\t\"WP\",\\n]\\n\\n# Settings that all applications must have\\nREQUIRED_SETTINGS = [\\n\\t\"PLATFORM\",\\n]\\n\\n# Settings that an application may have to enable optional features\\n# these settings are stubs for registry support and have no effect on the operation\\n# of the application at this time.\\nOPTIONAL_SETTINGS = [\\n\\t\"APPLICATION_GROUP\", \"APPLICATION_SECRET\"\\n]\\n\\n# Since we can have an auth key, combined with a auth key id and team id *or*\\n# a certificate, we make these all optional, and then make sure we have one or\\n# the other (group) of settings.\\nAPNS_SETTINGS_CERT_CREDS = \"CERTIFICATE\"\\n\\n# Subkeys for APNS_SETTINGS_AUTH_CREDS\\nAPNS_AUTH_CREDS_REQUIRED = [\"AUTH_KEY_PATH\", \"AUTH_KEY_ID\", \"TEAM_ID\"]\\nAPNS_AUTH_CREDS_OPTIONAL = [\"CERTIFICATE\", \"ENCRYPTION_ALGORITHM\", \"TOKEN_LIFETIME\"]\\n\\nAPNS_OPTIONAL_SETTINGS = [\\n\\t\"USE_SANDBOX\", \"USE_ALTERNATIVE_PORT\", \"TOPIC\"\\n]\\n\\nFCM_REQUIRED_SETTINGS = GCM_REQUIRED_SETTINGS = [\"API_KEY\"]\\nFCM_OPTIONAL_SETTINGS = GCM_OPTIONAL_SETTINGS = [\\n\\t\"POST_URL\", \"MAX_RECIPIENTS\", \"ERROR_TIMEOUT\"\\n]\\n\\nWNS_REQUIRED_SETTINGS = [\"PACKAGE_SECURITY_ID\", \"SECRET_KEY\"]\\nWNS_OPTIONAL_SETTINGS = [\"WNS_ACCESS_URL\"]\\n\\nWP_REQUIRED_SETTINGS = [\"PRIVATE_KEY\", \"CLAIMS\"]\\nWP_OPTIONAL_SETTINGS = [\"ERROR_TIMEOUT\", \"POST_URL\"]\\n\\n\\nclass AppConfig(BaseConfig):\\n\\t\"\"\"\\n\\tSupports any number of push notification enabled applications.\\n\\t\"\"\"\\n\\n\\tdef __init__(self, settings=None):\\n\\t\\t# supports overriding the settings to be loaded. Will load from ..settings by default.\\n\\t\\tself._settings = settings or SETTINGS\\n\\n\\t\\t# initialize APPLICATIONS to an empty collection\\n\\t\\tself._settings.setdefault(\"APPLICATIONS\", {})\\n\\n\\t\\t# validate application configurations\\n\\t\\tself._validate_applications(self._settings[\"APPLICATIONS\"])\\n\\n\\tdef _validate_applications(self, apps):\\n\\t\\t\"\"\"Validate the application collection\"\"\"\\n\\t\\tfor application_id, application_config in apps.items():\\n\\t\\t\\tself._validate_config(application_id, application_config)\\n\\n\\t\\t\\tapplication_config[\"APPLICATION_ID\"] = application_id\\n\\n\\tdef _validate_config(self, application_id, application_config):\\n\\t\\tplatform = application_config.get(\"PLATFORM\", None)\\n\\n\\t\\t# platform is not present\\n\\t\\tif platform is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"required\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# platform is not a valid choice from PLATFORMS\\n\\t\\tif platform not in PLATFORMS:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"invalid\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\tvalidate_fn = \"_validate_{platform}_config\".format(platform=platform).lower()\\n\\n\\t\\tif hasattr(self, validate_fn):\\n\\t\\t\\tgetattr(self, validate_fn)(application_id, application_config)\\n\\t\\telse:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tUNKNOWN_PLATFORM.format(\\n\\t\\t\\t\\t\\tplatform=platform,\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\tdef _validate_apns_config(self, application_id, application_config):\\n\\t\\tallowed = REQUIRED_SETTINGS + OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\tAPNS_OPTIONAL_SETTINGS\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\t# We have two sets of settings, certificate and JWT auth key.\\n\\t\\t# Auth Key requires 3 values, so if that is set, that will take\\n\\t\\t# precedence. If None are set, we will throw an error.\\n\\t\\thas_cert_creds = APNS_SETTINGS_CERT_CREDS in \\\\\\n\\t\\t\\tapplication_config.keys()\\n\\t\\tself.has_token_creds = True\\n\\t\\tfor token_setting in APNS_AUTH_CREDS_REQUIRED:\\n\\t\\t\\tif token_setting not in application_config.keys():\\n\\t\\t\\t\\tself.has_token_creds = False\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif not has_cert_creds and not self.has_token_creds:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tsetting=(APNS_SETTINGS_CERT_CREDS, APNS_AUTH_CREDS_REQUIRED)))\\n\\t\\tcert_path = None\\n\\t\\tif has_cert_creds:\\n\\t\\t\\tcert_path = \"CERTIFICATE\"\\n\\t\\telif self.has_token_creds:\\n\\t\\t\\tcert_path = \"AUTH_KEY_PATH\"\\n\\t\\t\\tallowed_tokens = APNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\t\\tAPNS_OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\t\\tREQUIRED_SETTINGS\\n\\t\\t\\tself._validate_allowed_settings(application_id, application_config, allowed_tokens)\\n\\t\\t\\tself._validate_required_settings(\\n\\t\\t\\t\\tapplication_id, application_config, APNS_AUTH_CREDS_REQUIRED\\n\\t\\t\\t)\\n\\t\\tself._validate_apns_certificate(application_config[cert_path])\\n\\n\\t\\t# determine/set optional values\\n\\t\\tapplication_config.setdefault(\"USE_SANDBOX\", False)\\n\\t\\tapplication_config.setdefault(\"USE_ALTERNATIVE_PORT\", False)\\n\\t\\tapplication_config.setdefault(\"TOPIC\", None)\\n\\n\\tdef _validate_apns_certificate(self, certfile):\\n\\t\\t\"\"\"Validate the APNS certificate at startup.\"\"\"\\n\\n\\t\\ttry:\\n\\t\\t\\twith open(certfile, \"r\") as f:\\n\\t\\t\\t\\tcontent = f.read()\\n\\t\\t\\t\\tcheck_apns_certificate(content)\\n\\t\\texcept Exception as e:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"The APNS certificate file at {!r} is not readable: {}\".format(certfile, e)\\n\\t\\t\\t)\\n\\n\\tdef _validate_fcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + FCM_REQUIRED_SETTINGS + FCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, FCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://fcm.googleapis.com/fcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_gcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + GCM_REQUIRED_SETTINGS + GCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, GCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://android.googleapis.com/gcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_wns_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WNS_REQUIRED_SETTINGS + WNS_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WNS_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\")\\n\\n\\tdef _validate_wp_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WP_REQUIRED_SETTINGS + WP_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WP_REQUIRED_SETTINGS\\n\\t\\t)\\n\\t\\tapplication_config.setdefault(\"POST_URL\", {\\n\\t\\t\\t\"CHROME\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"OPERA\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n\\t\\t\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\\t})\\n\\n\\tdef _validate_allowed_settings(self, application_id, application_config, allowed_settings):\\n\\t\\t\"\"\"Confirm only allowed settings are present.\"\"\"\\n\\n\\t\\tfor setting_key in application_config.keys():\\n\\t\\t\\tif setting_key not in allowed_settings:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"Platform {}, app {} does not support the setting: {}.\".format(\\n\\t\\t\\t\\t\\t\\tapplication_config[\"PLATFORM\"], application_id, setting_key\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\n\\tdef _validate_required_settings(\\n\\t\\tself, application_id, application_config, required_settings,\\n\\t\\tshould_throw=True\\n\\t):\\n\\t\\t\"\"\"All required keys must be present\"\"\"\\n\\n\\t\\tfor setting_key in required_settings:\\n\\t\\t\\tif setting_key not in application_config.keys():\\n\\t\\t\\t\\tif should_throw:\\n\\t\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\t\\t\\tapplication_id=application_id, setting=setting_key\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tdef _get_application_settings(self, application_id, platform, settings_key):\\n\\t\\t\"\"\"\\n\\t\\tWalks through PUSH_NOTIFICATIONS_SETTINGS to find the correct setting value\\n\\t\\tor raises ImproperlyConfigured.\\n\\t\\t\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tconf_cls = \"push_notifications.conf.AppConfig\"\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"{} requires the application_id be specified at all times.\".format(conf_cls)\\n\\t\\t\\t)\\n\\n\\t\\t# verify that the application config exists\\n\\t\\tapp_config = self._settings.get(\"APPLICATIONS\").get(application_id, None)\\n\\t\\tif app_config is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"No application configured with application_id: {}.\".format(application_id)\\n\\t\\t\\t)\\n\\n\\t\\t# fetch a setting for the incorrect type of platform\\n\\t\\tif app_config.get(\"PLATFORM\") != platform:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tSETTING_MISMATCH.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tplatform=app_config.get(\"PLATFORM\"),\\n\\t\\t\\t\\t\\tsetting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# finally, try to fetch the setting\\n\\t\\tif settings_key not in app_config:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id, setting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\treturn app_config.get(settings_key)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\treturn self.has_token_creds\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"GCM\", \"API_KEY\")\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"FCM\", \"API_KEY\")\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"POST_URL\")\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"ERROR_TIMEOUT\")\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"MAX_RECIPIENTS\")\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(application_id, \"APNS\", \"CERTIFICATE\")\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn \\\\\\n\\t\\t(self._get_apns_auth_key_path(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key_path(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_PATH\")\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_ID\")\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TEAM_ID\")\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_SANDBOX\")\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_ALTERNATIVE_PORT\")\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TOPIC\")\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"PACKAGE_SECURITY_ID\")\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"SECRET_KEY\")\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"POST_URL\")[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"PRIVATE_KEY\")\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"CLAIMS\")\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "b'from .base import BaseConfig\\n\\n\\nclass AppModelConfig(BaseConfig):\\n\\t\"\"\"Future home of the Application Model conf adapter\\n\\n\\tSupports multiple applications in the database.\\n\\t\"\"\"\\n\\n\\tpass\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "b'from django.core.exceptions import ImproperlyConfigured\\n\\n\\nclass BaseConfig:\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_applications(self):\\n\\t\\t\"\"\"Returns a collection containing the configured applications.\"\"\"\\n\\n\\t\\traise NotImplementedError\\n\\n\\n# This works for both the certificate and the auth key (since that\\'s just\\n# a certificate).\\ndef check_apns_certificate(ss):\\n\\tmode = \"start\"\\n\\tfor s in ss.split(\"\\\\n\"):\\n\\t\\tif mode == \"start\":\\n\\t\\t\\tif \"BEGIN RSA PRIVATE KEY\" in s or \"BEGIN PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"key\"\\n\\t\\telif mode == \"key\":\\n\\t\\t\\tif \"END RSA PRIVATE KEY\" in s or \"END PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"end\"\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif s.startswith(\"Proc-Type\") and \"ENCRYPTED\" in s:\\n\\t\\t\\t\\traise ImproperlyConfigured(\"Encrypted APNS private keys are not supported\")\\n\\n\\tif mode != \"end\":\\n\\t\\traise ImproperlyConfigured(\"The APNS certificate doesn\\'t contain a private key\")\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "b'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig\\n\\n\\n__all__ = [\\n\\t\"LegacyConfig\"\\n]\\n\\n\\nclass empty:\\n\\tpass\\n\\n\\nclass LegacyConfig(BaseConfig):\\n\\n\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\n\\tdef _get_application_settings(self, application_id, settings_key, error_message):\\n\\t\\t\"\"\"Legacy behaviour\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tvalue = SETTINGS.get(settings_key, empty)\\n\\t\\t\\tif value is empty:\\n\\t\\t\\t\\traise ImproperlyConfigured(error_message)\\n\\t\\t\\treturn value\\n\\t\\telse:\\n\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\"LegacySettings does not support application_id. To enable \"\\n\\t\\t\\t\\t\"multiple application support, use push_notifications.conf.AppSettings.\"\\n\\t\\t\\t)\\n\\t\\t\\traise ImproperlyConfigured(msg)\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"GCM_API_KEY\"] to send messages through GCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"GCM_API_KEY\", msg)\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"FCM_API_KEY\"] to send messages through FCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"FCM_API_KEY\", msg)\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_POST_URL\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_ERROR_TIMEOUT\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_MAX_RECIPIENTS\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\ttry:\\n\\t\\t\\tself._get_apns_auth_key(application_id)\\n\\t\\t\\tself._get_apns_auth_key_id(application_id)\\n\\t\\t\\tself._get_apns_team_id(application_id)\\n\\t\\texcept ImproperlyConfigured:\\n\\t\\t\\treturn False\\n\\n\\t\\treturn True\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(\\n\\t\\t\\tapplication_id, \"APNS_CERTIFICATE\",\\n\\t\\t\\t\"You need to setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\t)\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\traise ImproperlyConfigured(msg)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn (\\n\\t\\t\\tself._get_apns_auth_key(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_PATH\", self.msg)\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TEAM_ID\", self.msg)\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_ID\", self.msg)\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_USE_SANDBOX\", self.msg)\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn\\n\\t\\tself._get_application_settings(application_id, \"APNS_USE_ALTERNATIVE_PORT\", self.msg)\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TOPIC\", self.msg)\\n\\n\\tdef get_apns_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_HOST\", self.msg)\\n\\n\\tdef get_apns_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_PORT\", self.msg)\\n\\n\\tdef get_apns_feedback_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_HOST\", self.msg)\\n\\n\\tdef get_apns_feedback_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_PORT\", self.msg)\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_PACKAGE_SECURITY_ID\", self.msg)\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_SECRET_KEY\", msg)\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_POST_URL\", msg)[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_PRIVATE_KEY\", msg)\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_CLAIMS\", msg)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "b'class NotificationError(Exception):\\n\\tpass\\n\\n\\n# APNS\\nclass APNSError(NotificationError):\\n\\tpass\\n\\n\\nclass APNSUnsupportedPriority(APNSError):\\n\\tpass\\n\\n\\nclass APNSServerError(APNSError):\\n\\tdef __init__(self, status):\\n\\t\\tsuper().__init__(status)\\n\\t\\tself.status = status\\n\\n\\n# GCM\\nclass GCMError(NotificationError):\\n\\tpass\\n\\n\\n# Web Push\\nclass WebPushError(NotificationError):\\n\\tpass\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "b'import re\\nimport struct\\n\\nfrom django import forms\\nfrom django.core.validators import MaxValueValidator, MinValueValidator, RegexValidator\\nfrom django.db import connection, models\\nfrom django.utils.translation import gettext_lazy as _\\n\\n\\n__all__ = [\"HexadecimalField\", \"HexIntegerField\"]\\n\\nUNSIGNED_64BIT_INT_MIN_VALUE = 0\\nUNSIGNED_64BIT_INT_MAX_VALUE = 2 ** 64 - 1\\n\\n\\nhex_re = re.compile(r\"^(([0-9A-f])|(0x[0-9A-f]))+$\")\\nsigned_integer_vendors = [\\n\\t\"postgresql\",\\n\\t\"sqlite\",\\n]\\n\\n\\ndef _using_signed_storage():\\n\\treturn connection.vendor in signed_integer_vendors\\n\\n\\ndef _signed_to_unsigned_integer(value):\\n\\treturn struct.unpack(\"Q\", struct.pack(\"q\", value))[0]\\n\\n\\ndef _unsigned_to_signed_integer(value):\\n\\treturn struct.unpack(\"q\", struct.pack(\"Q\", value))[0]\\n\\n\\ndef _hex_string_to_unsigned_integer(value):\\n\\treturn int(value, 16)\\n\\n\\ndef _unsigned_integer_to_hex_string(value):\\n\\treturn hex(value).rstrip(\"L\")\\n\\n\\nclass HexadecimalField(forms.CharField):\\n\\t\"\"\"\\n\\tA form field that accepts only hexadecimal numbers\\n\\t\"\"\"\\n\\tdef __init__(self, *args, **kwargs):\\n\\t\\tself.default_validators = [\\n\\t\\t\\tRegexValidator(hex_re, _(\"Enter a valid hexadecimal number\"), \"invalid\")\\n\\t\\t]\\n\\t\\tsuper(HexadecimalField, self).__init__(*args, **kwargs)\\n\\n\\tdef prepare_value(self, value):\\n\\t\\t# converts bigint from db to hex before it is displayed in admin\\n\\t\\tif value and not isinstance(value, str) \\\\\\n\\t\\t\\tand connection.vendor in (\"mysql\", \"sqlite\"):\\n\\t\\t\\tvalue = _unsigned_integer_to_hex_string(value)\\n\\t\\treturn super(forms.CharField, self).prepare_value(value)\\n\\n\\nclass HexIntegerField(models.BigIntegerField):\\n\\t\"\"\"\\n\\tThis field stores a hexadecimal *string* of up to 64 bits as an unsigned integer\\n\\ton *all* backends including postgres.\\n\\n\\tReasoning: Postgres only supports signed bigints. Since we don\\'t care about\\n\\tsignedness, we store it as signed, and cast it to unsigned when we deal with\\n\\tthe actual value (with struct)\\n\\n\\tOn sqlite and mysql, native unsigned bigint types are used. In all cases, the\\n\\tvalue we deal with in python is always in hex.\\n\\t\"\"\"\\n\\n\\tvalidators = [\\n\\t\\tMinValueValidator(UNSIGNED_64BIT_INT_MIN_VALUE),\\n\\t\\tMaxValueValidator(UNSIGNED_64BIT_INT_MAX_VALUE)\\n\\t]\\n\\n\\tdef db_type(self, connection):\\n\\t\\tif \"mysql\" == connection.vendor:\\n\\t\\t\\treturn \"bigint unsigned\"\\n\\t\\telif \"sqlite\" == connection.vendor:\\n\\t\\t\\treturn \"UNSIGNED BIG INT\"\\n\\t\\telse:\\n\\t\\t\\treturn super(HexIntegerField, self).db_type(connection=connection)\\n\\n\\tdef get_prep_value(self, value):\\n\\t\\t\"\"\" Return the integer value to be stored from the hex string \"\"\"\\n\\t\\tif value is None or value == \"\":\\n\\t\\t\\treturn None\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _unsigned_to_signed_integer(value)\\n\\t\\treturn value\\n\\n\\tdef from_db_value(self, value, *args):\\n\\t\\t\"\"\" Return an unsigned int representation from all db backends \"\"\"\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _signed_to_unsigned_integer(value)\\n\\t\\treturn value\\n\\n\\tdef to_python(self, value):\\n\\t\\t\"\"\" Return a str representation of the hexadecimal \"\"\"\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\treturn value\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\treturn _unsigned_integer_to_hex_string(value)\\n\\n\\tdef formfield(self, **kwargs):\\n\\t\\tdefaults = {\"form_class\": HexadecimalField}\\n\\t\\tdefaults.update(kwargs)\\n\\t\\t# yes, that super call is right\\n\\t\\treturn super(models.IntegerField, self).formfield(**defaults)\\n\\n\\tdef run_validators(self, value):\\n\\t\\t# make sure validation is performed on integer value not string value\\n\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\treturn super(models.BigIntegerField, self).run_validators(value)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "b'\"\"\"\\nFirebase Cloud Messaging\\nPreviously known as GCM / C2DM\\nDocumentation is available on the Firebase Developer website:\\nhttps://firebase.google.com/docs/cloud-messaging/\\n\"\"\"\\n\\nimport json\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import Request, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import GCMError\\nfrom .models import GCMDevice\\n\\n\\n# Valid keys for FCM messages. Reference:\\n# https://firebase.google.com/docs/cloud-messaging/http-server-ref\\nFCM_TARGETS_KEYS = [\\n\\t\"to\", \"condition\", \"notification_key\"\\n]\\nFCM_OPTIONS_KEYS = [\\n\\t\"collapse_key\", \"priority\", \"content_available\", \"delay_while_idle\", \"time_to_live\",\\n\\t\"restricted_package_name\", \"dry_run\", \"mutable_content\"\\n]\\nFCM_NOTIFICATIONS_PAYLOAD_KEYS = [\\n\\t\"title\", \"body\", \"icon\", \"image\", \"sound\", \"badge\", \"color\", \"tag\", \"click_action\",\\n\\t\"body_loc_key\", \"body_loc_args\", \"title_loc_key\", \"title_loc_args\", \"android_channel_id\"\\n]\\n\\ndef _chunks(l, n):\\n\\t\"\"\"\\n\\tYield successive chunks from list \\\\a l with a minimum size \\\\a n\\n\\t\"\"\"\\n\\tfor i in range(0, len(l), n):\\n\\t\\tyield l[i:i + n]\\n\\n\\ndef _gcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_gcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"GCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"GCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _fcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_fcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"FCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"FCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _cm_handle_response(registration_ids, response_data, cloud_type, application_id=None):\\n\\tresponse = response_data\\n\\tif response.get(\"failure\") or response.get(\"canonical_ids\"):\\n\\t\\tids_to_remove, old_new_ids = [], []\\n\\t\\tthrow_error = False\\n\\t\\tfor index, result in enumerate(response[\"results\"]):\\n\\t\\t\\terror = result.get(\"error\")\\n\\t\\t\\tif error:\\n\\t\\t\\t\\t# https://firebase.google.com/docs/cloud-messaging/http-server-ref#error-codes\\n\\t\\t\\t\\t# If error is NotRegistered or InvalidRegistration, then we will deactivate devices\\n\\t\\t\\t\\t# because this registration ID is no more valid and can\\'t be used to send messages,\\n\\t\\t\\t\\t# otherwise raise error\\n\\t\\t\\t\\tif error in (\"NotRegistered\", \"InvalidRegistration\"):\\n\\t\\t\\t\\t\\tids_to_remove.append(registration_ids[index])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tthrow_error = True\\n\\t\\t\\tresult[\"original_registration_id\"] = registration_ids[index]\\n\\t\\t\\t# If registration_id is set, replace the original ID with the new value (canonical ID)\\n\\t\\t\\t# in your server database. Note that the original ID is not part of the result, you need\\n\\t\\t\\t# to obtain it from the list of registration_ids in the request (using the same index).\\n\\t\\t\\tnew_id = result.get(\"registration_id\")\\n\\t\\t\\tif new_id:\\n\\t\\t\\t\\told_new_ids.append((registration_ids[index], new_id))\\n\\n\\t\\tif ids_to_remove:\\n\\t\\t\\tremoved = GCMDevice.objects.filter(\\n\\t\\t\\t\\tregistration_id__in=ids_to_remove, cloud_message_type=cloud_type\\n\\t\\t\\t)\\n\\t\\t\\tremoved.update(active=False)\\n\\n\\t\\tfor old_id, new_id in old_new_ids:\\n\\t\\t\\t_cm_handle_canonical_id(new_id, old_id, cloud_type)\\n\\n\\t\\tif throw_error:\\n\\t\\t\\traise GCMError(response)\\n\\treturn response\\n\\n\\ndef _cm_send_request(\\n\\tregistration_ids, data, cloud_type=\"GCM\", application_id=None,\\n\\tuse_fcm_notifications=True, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a FCM or GCM notification to one or more registration_ids as json data.\\n\\tThe registration_ids needs to be a list.\\n\\t\"\"\"\\n\\n\\tpayload = {\"registration_ids\": registration_ids} if registration_ids else {}\\n\\n\\tdata = data.copy()\\n\\n\\t# If using FCM, optionally autodiscovers notification related keys\\n\\t# https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages\\n\\tif cloud_type == \"FCM\" and use_fcm_notifications:\\n\\t\\tnotification_payload = {}\\n\\t\\tif \"message\" in data:\\n\\t\\t\\tnotification_payload[\"body\"] = data.pop(\"message\", None)\\n\\n\\t\\tfor key in FCM_NOTIFICATIONS_PAYLOAD_KEYS:\\n\\t\\t\\tvalue_from_extra = data.pop(key, None)\\n\\t\\t\\tif value_from_extra:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_extra\\n\\t\\t\\tvalue_from_kwargs = kwargs.pop(key, None)\\n\\t\\t\\tif value_from_kwargs:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_kwargs\\n\\t\\tif notification_payload:\\n\\t\\t\\tpayload[\"notification\"] = notification_payload\\n\\n\\tif data:\\n\\t\\tpayload[\"data\"] = data\\n\\n\\t# Attach any additional non falsy keyword args (targets, options)\\n\\t# See ref : https://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\tpayload.update({\\n\\t\\tk: v for k, v in kwargs.items() if v and (k in FCM_TARGETS_KEYS or k in FCM_OPTIONS_KEYS)\\n\\t})\\n\\n\\t# Sort the keys for deterministic output (useful for tests)\\n\\tjson_payload = json.dumps(payload, separators=(\",\", \":\"), sort_keys=True).encode(\"utf-8\")\\n\\n\\t# Sends requests and handles the response\\n\\tif cloud_type == \"GCM\":\\n\\t\\tresponse = json.loads(_gcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telif cloud_type == \"FCM\":\\n\\t\\tresponse = json.loads(_fcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\treturn _cm_handle_response(registration_ids, response, cloud_type, application_id)\\n\\n\\ndef _cm_handle_canonical_id(canonical_id, current_id, cloud_type):\\n\\t\"\"\"\\n\\tHandle situation when FCM server response contains canonical ID\\n\\t\"\"\"\\n\\tdevices = GCMDevice.objects.filter(cloud_message_type=cloud_type)\\n\\tif devices.filter(registration_id=canonical_id, active=True).exists():\\n\\t\\tdevices.filter(registration_id=current_id).update(active=False)\\n\\telse:\\n\\t\\tdevices.filter(registration_id=current_id).update(registration_id=canonical_id)\\n\\n\\ndef send_message(registration_ids, data, cloud_type, application_id=None, **kwargs):\\n\\t\"\"\"\\n\\tSends a FCM (or GCM) notification to one or more registration_ids. The registration_ids\\n\\tcan be a list or a single string. This will send the notification as json data.\\n\\n\\tA reference of extra keyword arguments sent to the server is available here:\\n\\thttps://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\t\"\"\"\\n\\tif cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\tmax_recipients = get_manager().get_max_recipients(cloud_type, application_id)\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\n\\t# Checks for valid recipient\\n\\tif registration_ids is None and \"/topics/\" not in kwargs.get(\"to\", \"\"):\\n\\t\\treturn\\n\\n\\t# Bundles the registration_ids in an list if only one is sent\\n\\tif not isinstance(registration_ids, list):\\n\\t\\tregistration_ids = [registration_ids] if registration_ids else None\\n\\n\\t# FCM only allows up to 1000 reg ids per bulk message\\n\\t# https://firebase.google.com/docs/cloud-messaging/server#http-request\\n\\tif registration_ids:\\n\\t\\tret = []\\n\\t\\tfor chunk in _chunks(registration_ids, max_recipients):\\n\\t\\t\\tret.append(_cm_send_request(\\n\\t\\t\\t\\tchunk, data, cloud_type=cloud_type, application_id=application_id, **kwargs\\n\\t\\t\\t))\\n\\t\\treturn ret[0] if len(ret) == 1 else ret\\n\\telse:\\n\\t\\treturn _cm_send_request(None, data, cloud_type=cloud_type, **kwargs)\\n\\n\\nsend_bulk_message = send_message\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "b\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\nimport push_notifications.fields\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='APNSDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', models.UUIDField(help_text='UDID / UIDevice.identifierForVendor()', max_length=32, null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.CharField(unique=True, max_length=64, verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'APNS device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n        migrations.CreateModel(\\n            name='GCMDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', push_notifications.fields.HexIntegerField(help_text='ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)', null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'GCM device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "b\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.1 on 2016-01-06 08:50\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0001_initial'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=True, verbose_name='Registration ID'),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "b\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nimport django.db.models.deletion\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0002_auto_20160106_0850'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WNSDevice',\\n            fields=[\\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\\n                ('name', models.CharField(blank=True, max_length=255, null=True, verbose_name='Name')),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, null=True, verbose_name='Creation date')),\\n                ('device_id', models.UUIDField(blank=True, db_index=True, help_text='GUID()', null=True, verbose_name='Device ID')),\\n                ('registration_id', models.TextField(verbose_name='Notification URI')),\\n                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\\n            ],\\n            options={\\n                'verbose_name': 'WNS device',\\n            },\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "b\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n\\tdependencies = [\\n\\t\\tmigrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n\\t\\t('push_notifications', '0003_wnsdevice'),\\n\\t]\\n\\n\\toperations = [\\n\\t\\tmigrations.AddField(\\n\\t\\t\\tmodel_name='gcmdevice',\\n\\t\\t\\tname='cloud_message_type',\\n\\t\\t\\tfield=models.CharField(choices=[('FCM', 'Firebase Cloud Message'), ('GCM', 'Google Cloud Message')], default='GCM', help_text='You should choose FCM or GCM', max_length=3, verbose_name='Cloud Message Type')\\n\\t\\t),\\n\\t]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "b\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0004_fcm'),\\n    ]\\n\\n    operations = [\\n        migrations.AddField(\\n            model_name='apnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='gcmdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='wnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "b\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0005_applicationid'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WebPushDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('application_id', models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('p256dh', models.CharField(max_length=88, verbose_name='User public encryption key')),\\n                ('auth', models.CharField(max_length=24, verbose_name='User auth secret')),\\n                ('browser', models.CharField(default='CHROME', help_text='Currently only support to Chrome, Firefox and Opera browsers', max_length=10, verbose_name='Browser', choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera')])),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'WebPush device',\\n            },\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "b\"from django.db import migrations, models\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0006_webpushdevice'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='gcmdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='wnsdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Notification URI'),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "b\"# Generated by Django 3.2.8 on 2021-11-12 09:49\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0007_uniquesetting'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='browser',\\n            field=models.CharField(choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera'), ('EDGE', 'Edge')], default='CHROME', help_text='Currently only support to Chrome, Firefox, Edge and Opera browsers', max_length=10, verbose_name='Browser'),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "b\"# Generated by Django 3.2.9 on 2022-01-10 09:03\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0008_webpush_add_edge'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='device_id',\\n            field=models.UUIDField(blank=True, db_index=True, help_text='UUID / UIDevice.identifierForVendor()', null=True, verbose_name='Device ID'),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "b''"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "b'from django.db import models\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .fields import HexIntegerField\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nCLOUD_MESSAGE_TYPES = (\\n\\t(\"FCM\", \"Firebase Cloud Message\"),\\n\\t(\"GCM\", \"Google Cloud Message\"),\\n)\\n\\nBROWSER_TYPES = (\\n\\t(\"CHROME\", \"Chrome\"),\\n\\t(\"FIREFOX\", \"Firefox\"),\\n\\t(\"OPERA\", \"Opera\"),\\n\\t(\"EDGE\", \"Edge\")\\n)\\n\\n\\nclass Device(models.Model):\\n\\tname = models.CharField(max_length=255, verbose_name=_(\"Name\"), blank=True, null=True)\\n\\tactive = models.BooleanField(\\n\\t\\tverbose_name=_(\"Is active\"), default=True,\\n\\t\\thelp_text=_(\"Inactive devices will not be sent notifications\")\\n\\t)\\n\\tuser = models.ForeignKey(\\n\\t\\tSETTINGS[\"USER_MODEL\"], blank=True, null=True, on_delete=models.CASCADE\\n\\t)\\n\\tdate_created = models.DateTimeField(\\n\\t\\tverbose_name=_(\"Creation date\"), auto_now_add=True, null=True\\n\\t)\\n\\tapplication_id = models.CharField(\\n\\t\\tmax_length=64, verbose_name=_(\"Application ID\"),\\n\\t\\thelp_text=_(\\n\\t\\t\\t\"Opaque application identity, should be filled in for multiple\"\\n\\t\\t\\t\" key/certificate access\"\\n\\t\\t),\\n\\t\\tblank=True, null=True\\n\\t)\\n\\n\\tclass Meta:\\n\\t\\tabstract = True\\n\\n\\tdef __str__(self):\\n\\t\\treturn (\\n\\t\\t\\tself.name or\\n\\t\\t\\tstr(self.device_id or \"\") or\\n\\t\\t\\t\"{} for {}\".format(self.__class__.__name__, self.user or \"unknown user\")\\n\\t\\t)\\n\\n\\nclass GCMDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn GCMDeviceQuerySet(self.model)\\n\\n\\nclass GCMDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\t\\tif message is not None:\\n\\t\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\\n\\t\\t\\t\\t\"application_id\"\\n\\t\\t\\t).values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tresponse = []\\n\\t\\t\\tfor cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\t\\treg_ids = list(\\n\\t\\t\\t\\t\\t\\tself.filter(\\n\\t\\t\\t\\t\\t\\t\\tactive=True, cloud_message_type=cloud_type, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\tif reg_ids:\\n\\t\\t\\t\\t\\t\\tr = gcm_send_message(reg_ids, data, cloud_type, application_id=app_id, **kwargs)\\n\\t\\t\\t\\t\\t\\tresponse.append(r)\\n\\n\\t\\t\\treturn response\\n\\n\\nclass GCMDevice(Device):\\n\\t# device_id cannot be a reliable primary key as fragmentation between different devices\\n\\t# can make it turn out to be null and such:\\n\\t# http://android-developers.blogspot.co.uk/2011/03/identifying-app-installations.html\\n\\tdevice_id = HexIntegerField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tcloud_message_type = models.CharField(\\n\\t\\tverbose_name=_(\"Cloud Message Type\"), max_length=3,\\n\\t\\tchoices=CLOUD_MESSAGE_TYPES, default=\"GCM\",\\n\\t\\thelp_text=_(\"You should choose FCM or GCM\")\\n\\t)\\n\\tobjects = GCMDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"GCM device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\tif message is not None:\\n\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\treturn gcm_send_message(\\n\\t\\t\\tself.registration_id, data, self.cloud_message_type,\\n\\t\\t\\tapplication_id=self.application_id, **kwargs\\n\\t\\t)\\n\\n\\nclass APNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn APNSDeviceQuerySet(self.model)\\n\\n\\nclass APNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .apns import apns_send_bulk_message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\")\\\\\\n\\t\\t\\t\\t.values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tres = []\\n\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\treg_ids = list(self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\"registration_id\", flat=True)\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tr = apns_send_bulk_message(\\n\\t\\t\\t\\t\\tregistration_ids=reg_ids, alert=message, application_id=app_id,\\n\\t\\t\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\t\\tres += [r]\\n\\t\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\t\\tres += r\\n\\t\\t\\treturn res\\n\\n\\nclass APNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"UUID / UIDevice.identifierForVendor()\")\\n\\t)\\n\\tregistration_id = models.CharField(\\n\\t\\tverbose_name=_(\"Registration ID\"), max_length=200, unique=SETTINGS[\"UNIQUE_REG_ID\"]\\n\\t)\\n\\n\\tobjects = APNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"APNS device\")\\n\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tfrom .apns import apns_send_message\\n\\n\\t\\treturn apns_send_message(\\n\\t\\t\\tregistration_id=self.registration_id,\\n\\t\\t\\talert=message,\\n\\t\\t\\tapplication_id=self.application_id, creds=creds,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WNSDeviceQuerySet(self.model)\\n\\n\\nclass WNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_bulk_message\\n\\n\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\").values_list(\\n\\t\\t\\t\"application_id\", flat=True\\n\\t\\t).distinct()\\n\\t\\tres = []\\n\\t\\tfor app_id in app_ids:\\n\\t\\t\\treg_ids = self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t)\\n\\t\\t\\tr = wns_send_bulk_message(uri_list=list(reg_ids), message=message, **kwargs)\\n\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\tres += [r]\\n\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\tres += r\\n\\n\\t\\treturn res\\n\\n\\nclass WNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"GUID()\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Notification URI\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\n\\tobjects = WNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WNS device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_message\\n\\n\\t\\treturn wns_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, application_id=self.application_id,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WebPushDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WebPushDeviceQuerySet(self.model)\\n\\n\\nclass WebPushDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tdevices = self.filter(active=True).order_by(\"application_id\").distinct()\\n\\t\\tres = []\\n\\t\\tfor device in devices:\\n\\t\\t\\tres.append(device.send_message(message))\\n\\n\\t\\treturn res\\n\\n\\nclass WebPushDevice(Device):\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tp256dh = models.CharField(\\n\\t\\tverbose_name=_(\"User public encryption key\"),\\n\\t\\tmax_length=88)\\n\\tauth = models.CharField(\\n\\t\\tverbose_name=_(\"User auth secret\"),\\n\\t\\tmax_length=24)\\n\\tbrowser = models.CharField(\\n\\t\\tverbose_name=_(\"Browser\"), max_length=10,\\n\\t\\tchoices=BROWSER_TYPES, default=BROWSER_TYPES[0][0],\\n\\t\\thelp_text=_(\"Currently only support to Chrome, Firefox, Edge and Opera browsers\")\\n\\t)\\n\\tobjects = WebPushDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WebPush device\")\\n\\n\\t@property\\n\\tdef device_id(self):\\n\\t\\treturn None\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .webpush import webpush_send_message\\n\\n\\t\\treturn webpush_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, browser=self.browser,\\n\\t\\t\\tauth=self.auth, p256dh=self.p256dh, application_id=self.application_id, **kwargs)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "b'from django.conf import settings\\n\\n\\nPUSH_NOTIFICATIONS_SETTINGS = getattr(settings, \"PUSH_NOTIFICATIONS_SETTINGS\", {})\\n\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"CONFIG\", \"push_notifications.conf.LegacyConfig\"\\n)\\n\\n# GCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"GCM_POST_URL\", \"https://android.googleapis.com/gcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_ERROR_TIMEOUT\", None)\\n\\n# FCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"FCM_POST_URL\", \"https://fcm.googleapis.com/fcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_ERROR_TIMEOUT\", None)\\n\\n# APNS\\nif settings.DEBUG:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", True)\\nelse:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_ALTERNATIVE_PORT\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_TOPIC\", None)\\n\\n# WNS\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_PACKAGE_SECURITY_ID\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_SECRET_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\"\\n)\\n\\n# WP (WebPush)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_POST_URL\", {\\n\\t\"CHROME\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"OPERA\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n})\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_PRIVATE_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_CLAIMS\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_ERROR_TIMEOUT\", None)\\n\\n# User model\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"USER_MODEL\", settings.AUTH_USER_MODEL)\\n\\n# Unique registration ID for all devices\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UNIQUE_REG_ID\", False)\\n\\n# API endpoint settings\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UPDATE_ON_DUPLICATE_REG_ID\", False)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "b'from pywebpush import WebPushException, webpush\\n\\nfrom .conf import get_manager\\nfrom .exceptions import WebPushError\\n\\n\\ndef get_subscription_info(application_id, uri, browser, auth, p256dh):\\n\\turl = get_manager().get_wp_post_url(application_id, browser)\\n\\treturn {\\n\\t\\t\"endpoint\": \"{}/{}\".format(url, uri),\\n\\t\\t\"keys\": {\\n\\t\\t\\t\"auth\": auth,\\n\\t\\t\\t\"p256dh\": p256dh,\\n\\t\\t}\\n\\t}\\n\\n\\ndef webpush_send_message(\\n\\turi, message, browser, auth, p256dh, application_id=None, **kwargs\\n):\\n\\tsubscription_info = get_subscription_info(application_id, uri, browser, auth, p256dh)\\n\\n\\ttry:\\n\\t\\tresponse = webpush(\\n\\t\\t\\tsubscription_info=subscription_info,\\n\\t\\t\\tdata=message,\\n\\t\\t\\tvapid_private_key=get_manager().get_wp_private_key(application_id),\\n\\t\\t\\tvapid_claims=get_manager().get_wp_claims(application_id).copy(),\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\t\\tresults = {\"results\": [{}]}\\n\\t\\tif not response.ok:\\n\\t\\t\\tresults[\"results\"][0][\"error\"] = response.content\\n\\t\\t\\tresults[\"results\"][0][\"original_registration_id\"] = response.content\\n\\t\\telse:\\n\\t\\t\\tresults[\"success\"] = 1\\n\\t\\treturn results\\n\\texcept WebPushException as e:\\n\\t\\traise WebPushError(e.message)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "b'\"\"\"\\nWindows Notification Service\\n\\nDocumentation is available on the Windows Dev Center:\\nhttps://msdn.microsoft.com/en-us/windows/uwp/controls-and-patterns/tiles-and-notifications-windows-push-notification-services--wns--overview\\n\"\"\"\\n\\nimport json\\nimport xml.etree.ElementTree as ET\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import HTTPError, Request, urlencode, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import NotificationError\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass WNSError(NotificationError):\\n\\tpass\\n\\n\\nclass WNSAuthenticationError(WNSError):\\n\\tpass\\n\\n\\nclass WNSNotificationResponseError(WNSError):\\n\\tpass\\n\\n\\ndef _wns_authenticate(scope=\"notify.windows.com\", application_id=None):\\n\\t\"\"\"\\n\\tRequests an Access token for WNS communication.\\n\\n\\t:return: dict: {\\'access_token\\': <str>, \\'expires_in\\': <int>, \\'token_type\\': \\'bearer\\'}\\n\\t\"\"\"\\n\\tclient_id = get_manager().get_wns_package_security_id(application_id)\\n\\tclient_secret = get_manager().get_wns_secret_key(application_id)\\n\\tif not client_id:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_PACKAGE_SECURITY_ID\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\tif not client_secret:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_SECRET_KEY\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": \"application/x-www-form-urlencoded\",\\n\\t}\\n\\tparams = {\\n\\t\\t\"grant_type\": \"client_credentials\",\\n\\t\\t\"client_id\": client_id,\\n\\t\\t\"client_secret\": client_secret,\\n\\t\\t\"scope\": scope,\\n\\t}\\n\\tdata = urlencode(params).encode(\"utf-8\")\\n\\n\\trequest = Request(SETTINGS[\"WNS_ACCESS_URL\"], data=data, headers=headers)\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\t# One of your settings is probably jacked up.\\n\\t\\t\\t# https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh868245\\n\\t\\t\\traise WNSAuthenticationError(\"Authentication failed, check your WNS settings.\")\\n\\t\\traise err\\n\\n\\toauth_data = response.read().decode(\"utf-8\")\\n\\ttry:\\n\\t\\toauth_data = json.loads(oauth_data)\\n\\texcept Exception:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Received invalid JSON data from WNS.\")\\n\\n\\taccess_token = oauth_data.get(\"access_token\")\\n\\tif not access_token:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Access token missing from WNS response.\")\\n\\n\\treturn access_token\\n\\n\\ndef _wns_send(uri, data, wns_type=\"wns/toast\", application_id=None):\\n\\t\"\"\"\\n\\tSends a notification data and authentication to WNS.\\n\\n\\t:param uri: str: The device\\'s unique notification URI\\n\\t:param data: dict: The notification data to be sent.\\n\\t:return:\\n\\t\"\"\"\\n\\taccess_token = _wns_authenticate(application_id=application_id)\\n\\n\\tcontent_type = \"text/xml\"\\n\\tif wns_type == \"wns/raw\":\\n\\t\\tcontent_type = \"application/octet-stream\"\\n\\n\\theaders = {\\n\\t\\t# content_type is \"text/xml\" (toast/badge/tile) | \"application/octet-stream\" (raw)\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"Bearer %s\" % (access_token),\\n\\t\\t\"X-WNS-Type\": wns_type,  # wns/toast | wns/badge | wns/tile | wns/raw\\n\\t}\\n\\n\\tif type(data) is str:\\n\\t\\tdata = data.encode(\"utf-8\")\\n\\n\\trequest = Request(uri, data, headers)\\n\\n\\t# A lot of things can happen, let them know which one.\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\tmsg = \"One or more headers were specified incorrectly or conflict with another header.\"\\n\\t\\telif err.code == 401:\\n\\t\\t\\tmsg = \"The cloud service did not present a valid authentication ticket.\"\\n\\t\\telif err.code == 403:\\n\\t\\t\\tmsg = \"The cloud service is not authorized to send a notification to this URI.\"\\n\\t\\telif err.code == 404:\\n\\t\\t\\tmsg = \"The channel URI is not valid or is not recognized by WNS.\"\\n\\t\\telif err.code == 405:\\n\\t\\t\\tmsg = \"Invalid method. Only POST or DELETE is allowed.\"\\n\\t\\telif err.code == 406:\\n\\t\\t\\tmsg = \"The cloud service exceeded its throttle limit\"\\n\\t\\telif err.code == 410:\\n\\t\\t\\tmsg = \"The channel expired.\"\\n\\t\\telif err.code == 413:\\n\\t\\t\\tmsg = \"The notification payload exceeds the 500 byte limit.\"\\n\\t\\telif err.code == 500:\\n\\t\\t\\tmsg = \"An internal failure caused notification delivery to fail.\"\\n\\t\\telif err.code == 503:\\n\\t\\t\\tmsg = \"The server is currently unavailable.\"\\n\\t\\telse:\\n\\t\\t\\traise err\\n\\t\\traise WNSNotificationResponseError(\"HTTP %i: %s\" % (err.code, msg))\\n\\n\\treturn response.read().decode(\"utf-8\")\\n\\n\\ndef _wns_prepare_toast(data, **kwargs):\\n\\t\"\"\"\\n\\tCreates the xml tree for a `toast` notification\\n\\n\\t:param data: dict: The notification data to be converted to an xml tree.\\n\\n\\t{\\n\\t\\t\"text\": [\"Title text\", \"Message Text\", \"Another message!\"],\\n\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t}\\n\\n\\t:return: str\\n\\t\"\"\"\\n\\troot = ET.Element(\"toast\")\\n\\tvisual = ET.SubElement(root, \"visual\")\\n\\tbinding = ET.SubElement(visual, \"binding\")\\n\\tbinding.attrib[\"template\"] = kwargs.pop(\"template\", \"ToastText01\")\\n\\tif \"text\" in data:\\n\\t\\tfor count, item in enumerate(data[\"text\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"text\")\\n\\t\\t\\telem.text = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\tif \"image\" in data:\\n\\t\\tfor count, item in enumerate(data[\"image\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"img\")\\n\\t\\t\\telem.attrib[\"src\"] = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\treturn ET.tostring(root)\\n\\n\\ndef wns_send_message(\\n\\turi, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a notification request to WNS.\\n\\tThere are four notification types that WNS can send: toast, tile, badge and raw.\\n\\tToast, tile, and badge can all be customized to use different\\n\\ttemplates/icons/sounds/launch params/etc.\\n\\tSee docs for more information:\\n\\thttps://msdn.microsoft.com/en-us/library/windows/apps/br212853.aspx\\n\\n\\tThere are multiple ways to input notification data:\\n\\n\\t1. The simplest and least custom notification to send is to just pass a string\\n\\tto `message`. This will create a toast notification with one text element. e.g.:\\n\\t\\t\"This is my notification title\"\\n\\n\\t2. You can also pass a dictionary to `message`: it can only contain one or both\\n\\tkeys: [\"text\", \"image\"]. The value of each key must be a list with the text and\\n\\tsrc respectively. e.g.:\\n\\t\\t{\\n\\t\\t\\t\"text\": [\"text1\", \"text2\"],\\n\\t\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t\\t}\\n\\n\\t3. Passing a dictionary to `xml_data` will create one of three types of\\n\\tnotifications depending on the dictionary data (toast, tile, badge).\\n\\tSee `dict_to_xml_schema` docs for more information on dictionary formatting.\\n\\n\\t4. Passing a value to `raw_data` will create a `raw` notification and send the\\n\\tinput data as is.\\n\\n\\t:param uri: str: The device\\'s unique notification uri.\\n\\t:param message: str|dict: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\t# Create a simple toast notification\\n\\tif message:\\n\\t\\twns_type = \"wns/toast\"\\n\\t\\tif isinstance(message, str):\\n\\t\\t\\tmessage = {\\n\\t\\t\\t\\t\"text\": [message, ],\\n\\t\\t\\t}\\n\\t\\tprepared_data = _wns_prepare_toast(data=message, **kwargs)\\n\\t# Create a toast/tile/badge notification from a dictionary\\n\\telif xml_data:\\n\\t\\txml = dict_to_xml_schema(xml_data)\\n\\t\\twns_type = \"wns/%s\" % xml.tag\\n\\t\\tprepared_data = ET.tostring(xml)\\n\\t# Create a raw notification\\n\\telif raw_data:\\n\\t\\twns_type = \"wns/raw\"\\n\\t\\tprepared_data = raw_data\\n\\telse:\\n\\t\\traise TypeError(\\n\\t\\t\\t\"At least one of the following parameters must be set:\"\\n\\t\\t\\t\"`message`, `xml_data`, `raw_data`\"\\n\\t\\t)\\n\\n\\treturn _wns_send(\\n\\t\\turi=uri, data=prepared_data, wns_type=wns_type, application_id=application_id\\n\\t)\\n\\n\\ndef wns_send_bulk_message(\\n\\turi_list, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tWNS doesn\\'t support bulk notification, so we loop through each uri.\\n\\n\\t:param uri_list: list: A list of uris the notification will be sent to.\\n\\t:param message: str: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\tres = []\\n\\tif uri_list:\\n\\t\\tfor uri in uri_list:\\n\\t\\t\\tr = wns_send_message(\\n\\t\\t\\t\\turi=uri, message=message, xml_data=xml_data,\\n\\t\\t\\t\\traw_data=raw_data, application_id=application_id, **kwargs\\n\\t\\t\\t)\\n\\t\\t\\tres.append(r)\\n\\treturn res\\n\\n\\ndef dict_to_xml_schema(data):\\n\\t\"\"\"\\n\\tInput a dictionary to be converted to xml. There should be only one key at\\n\\tthe top level. The value must be a dict with (required) `children` key and\\n\\t(optional) `attrs` key. This will be called the `sub-element dictionary`.\\n\\n\\tThe `attrs` value must be a dictionary; each value will be added to the\\n\\telement\\'s xml tag as attributes. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\n\\twould result in:\\n\\t\\t<example key1=\"value1\" key2=\"value2\"></example>\\n\\n\\tIf the value is a dict it must contain one or more keys which will be used\\n\\tas the sub-element names. Each sub-element must have a value of a sub-element\\n\\tdictionary(see above) or a list of sub-element dictionaries.\\n\\tIf the value is not a dict, it will be the value of the element.\\n\\tIf the value is a list, multiple elements of the same tag will be created\\n\\tfrom each sub-element dict in the list.\\n\\n\\t:param data: dict: Used to create an XML tree. e.g.:\\n\\t\\texample_data = {\\n\\t\\t\\t\"toast\": {\\n\\t\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\\t\"launch\": \"param\",\\n\\t\\t\\t\\t\\t\"duration\": \"short\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\"visual\": {\\n\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\"binding\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"template\": \"ToastText01\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"text\": [\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"1\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text1\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"2\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text2\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor key, value in data.items():\\n\\t\\troot = _add_element_attrs(ET.Element(key), value.get(\"attrs\", {}))\\n\\t\\tchildren = value.get(\"children\", None)\\n\\t\\tif isinstance(children, dict):\\n\\t\\t\\t_add_sub_elements_from_dict(root, children)\\n\\t\\treturn root\\n\\n\\ndef _add_sub_elements_from_dict(parent, sub_dict):\\n\\t\"\"\"\\n\\tAdd SubElements to the parent element.\\n\\n\\t:param parent: ElementTree.Element: The parent element for the newly created SubElement.\\n\\t:param sub_dict: dict: Used to create a new SubElement. See `dict_to_xml_schema`\\n\\tmethod docstring for more information. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\t\"\"\"\\n\\tfor key, value in sub_dict.items():\\n\\t\\tif isinstance(value, list):\\n\\t\\t\\tfor repeated_element in value:\\n\\t\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t\\t_add_element_attrs(sub_element, repeated_element.get(\"attrs\", {}))\\n\\t\\t\\t\\tchildren = repeated_element.get(\"children\", None)\\n\\t\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\t\\tsub_element.text = children\\n\\t\\telse:\\n\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t_add_element_attrs(sub_element, value.get(\"attrs\", {}))\\n\\t\\t\\tchildren = value.get(\"children\", None)\\n\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\tsub_element.text = children\\n\\n\\ndef _add_element_attrs(elem, attrs):\\n\\t\"\"\"\\n\\tAdd attributes to the given element.\\n\\n\\t:param elem: ElementTree.Element: The element the attributes are being added to.\\n\\t:param attrs: dict: A dictionary of attributes. e.g.:\\n\\t\\t{\"attribute1\": \"value\", \"attribute2\": \"another\"}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor attr, value in attrs.items():\\n\\t\\telem.attrib[attr] = value\\n\\treturn elem\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "b'try:\\n    # Python 3.8+\\n    import importlib.metadata as importlib_metadata\\nexcept ImportError:\\n    # <Python 3.7 and lower\\n    import importlib_metadata\\n\\n__version__ = importlib_metadata.version(\"django-push-notifications\")\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "b'from django.apps import apps\\nfrom django.contrib import admin, messages\\nfrom django.utils.encoding import force_str\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .exceptions import APNSServerError, GCMError, WebPushError\\nfrom .models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nUser = apps.get_model(*SETTINGS[\"USER_MODEL\"].split(\".\"))\\n\\n\\nclass DeviceAdmin(admin.ModelAdmin):\\n\\tlist_display = (\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\",)\\n\\tactions = (\"send_message\", \"send_bulk_message\", \"enable\", \"disable\")\\n\\traw_id_fields = (\"user\",)\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"device_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"device_id\")\\n\\n\\tdef send_messages(self, request, queryset, bulk=False):\\n\\t\\t\"\"\"\\n\\t\\tProvides error handling for DeviceAdmin send_message and send_bulk_message methods.\\n\\t\\t\"\"\"\\n\\t\\tret = []\\n\\t\\terrors = []\\n\\t\\tr = \"\"\\n\\n\\t\\tfor device in queryset:\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tif bulk:\\n\\t\\t\\t\\t\\tr = queryset.send_message(\"Test bulk notification\")\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = device.send_message(\"Test single notification\")\\n\\t\\t\\t\\tif r:\\n\\t\\t\\t\\t\\tret.append(r)\\n\\t\\t\\texcept GCMError as e:\\n\\t\\t\\t\\terrors.append(str(e))\\n\\t\\t\\texcept APNSServerError as e:\\n\\t\\t\\t\\terrors.append(e.status)\\n\\t\\t\\texcept WebPushError as e:\\n\\t\\t\\t\\terrors.append(force_str(e))\\n\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\t# Because NotRegistered and InvalidRegistration do not throw GCMError\\n\\t\\t# catch them here to display error msg.\\n\\t\\tif not bulk:\\n\\t\\t\\tfor r in ret:\\n\\t\\t\\t\\tif \"error\" in r[\"results\"][0]:\\n\\t\\t\\t\\t\\terrors.append(r[\"results\"][0][\"error\"])\\n\\t\\telse:\\n\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\terrors = [r[\"error\"] for r in ret[0][0][\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\terrors = errors + [r[\"error\"] for r in entry[\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept IndexError:\\n\\t\\t\\t\\t\\tpass\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\tif value.lower() != \"success\":\\n\\t\\t\\t\\t\\t\\terrors.append(value)\\n\\t\\tif errors:\\n\\t\\t\\tself.message_user(\\n\\t\\t\\t\\trequest, _(\"Some messages could not be processed: %r\" % (\", \".join(errors))),\\n\\t\\t\\t\\tlevel=messages.ERROR\\n\\t\\t\\t)\\n\\t\\tif ret:\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\t# When the queryset exceeds the max_recipients value, the\\n\\t\\t\\t\\t# send_message method returns a list of dicts, one per chunk\\n\\t\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\t\\tsuccess = ret[0][0][\"success\"]\\n\\t\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\t\\tsuccess = 0\\n\\t\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\t\\tsuccess = success + entry[\"success\"]\\n\\t\\t\\t\\t\\tif success == 0:\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\t\\tsuccess = []\\n\\t\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\t\\tif value.lower() == \"success\":\\n\\t\\t\\t\\t\\t\\t\\tsuccess.append(key)\\n\\n\\t\\t\\telif len(errors) == len(ret):\\n\\t\\t\\t\\treturn\\n\\t\\t\\tif errors:\\n\\t\\t\\t\\tmsg = _(\"Some messages were sent: %s\" % (ret))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = _(\"All messages were sent: %s\" % (ret))\\n\\t\\t\\tself.message_user(request, msg)\\n\\n\\tdef send_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset)\\n\\n\\tsend_message.short_description = _(\"Send test message\")\\n\\n\\tdef send_bulk_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset, True)\\n\\n\\tsend_bulk_message.short_description = _(\"Send test message in bulk\")\\n\\n\\tdef enable(self, request, queryset):\\n\\t\\tqueryset.update(active=True)\\n\\n\\tenable.short_description = _(\"Enable selected devices\")\\n\\n\\tdef disable(self, request, queryset):\\n\\t\\tqueryset.update(active=False)\\n\\n\\tdisable.short_description = _(\"Disable selected devices\")\\n\\n\\nclass GCMDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\\n\\t\\t\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\", \"cloud_message_type\"\\n\\t)\\n\\tlist_filter = (\"active\", \"cloud_message_type\")\\n\\n\\nclass WebPushDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\"__str__\", \"browser\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\", \"browser\")\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"registration_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"registration_id\")\\n\\n\\nadmin.site.register(APNSDevice, DeviceAdmin)\\nadmin.site.register(GCMDevice, GCMDeviceAdmin)\\nadmin.site.register(WNSDevice, DeviceAdmin)\\nadmin.site.register(WebPushDevice, WebPushDeviceAdmin)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "b''"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "b'from rest_framework import permissions, status\\nfrom rest_framework.fields import IntegerField\\nfrom rest_framework.response import Response\\nfrom rest_framework.serializers import ModelSerializer, Serializer, ValidationError\\nfrom rest_framework.viewsets import ModelViewSet\\n\\nfrom ..fields import UNSIGNED_64BIT_INT_MAX_VALUE, hex_re\\nfrom ..models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\n# Fields\\nclass HexIntegerField(IntegerField):\\n\\t\"\"\"\\n\\tStore an integer represented as a hex string of form \"0x01\".\\n\\t\"\"\"\\n\\n\\tdef to_internal_value(self, data):\\n\\t\\t# validate hex string and convert it to the unsigned\\n\\t\\t# integer representation for internal use\\n\\t\\ttry:\\n\\t\\t\\tdata = int(data, 16) if type(data) != int else data\\n\\t\\texcept ValueError:\\n\\t\\t\\traise ValidationError(\"Device ID is not a valid hex number\")\\n\\t\\treturn super(HexIntegerField, self).to_internal_value(data)\\n\\n\\tdef to_representation(self, value):\\n\\t\\treturn value\\n\\n\\n# Serializers\\nclass DeviceSerializerMixin(ModelSerializer):\\n\\tclass Meta:\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"application_id\", \"registration_id\", \"device_id\",\\n\\t\\t\\t\"active\", \"date_created\"\\n\\t\\t)\\n\\t\\tread_only_fields = (\"date_created\",)\\n\\n\\t\\t# See https://github.com/tomchristie/django-rest-framework/issues/1101\\n\\t\\textra_kwargs = {\"active\": {\"default\": True}}\\n\\n\\nclass APNSDeviceSerializer(ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = APNSDevice\\n\\n\\tdef validate_registration_id(self, value):\\n\\t\\t# iOS device tokens are 256-bit hexadecimal (64 characters). In 2016 Apple is increasing\\n\\t\\t# iOS device tokens to 100 bytes hexadecimal (200 characters).\\n\\n\\t\\tif hex_re.match(value) is None or len(value) not in (64, 200):\\n\\t\\t\\traise ValidationError(\"Registration ID (device token) is invalid\")\\n\\n\\t\\treturn value\\n\\n\\nclass UniqueRegistrationSerializerMixin(Serializer):\\n\\tdef validate(self, attrs):\\n\\t\\tdevices = None\\n\\t\\tprimary_key = None\\n\\t\\trequest_method = None\\n\\n\\t\\tif self.initial_data.get(\"registration_id\", None):\\n\\t\\t\\tif self.instance:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telse:\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\t\\telse:\\n\\t\\t\\tif self.context[\"request\"].method in [\"PUT\", \"PATCH\"]:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telif self.context[\"request\"].method == \"POST\":\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\n\\t\\tDevice = self.Meta.model\\n\\t\\tif request_method == \"update\":\\n\\t\\t\\treg_id = attrs.get(\"registration_id\", self.instance.registration_id)\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=reg_id) \\\\\\n\\t\\t\\t\\t.exclude(id=primary_key)\\n\\t\\telif request_method == \"create\":\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=attrs[\"registration_id\"])\\n\\n\\t\\tif devices:\\n\\t\\t\\traise ValidationError({\"registration_id\": \"This field must be unique.\"})\\n\\t\\treturn attrs\\n\\n\\nclass GCMDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tdevice_id = HexIntegerField(\\n\\t\\thelp_text=\"ANDROID_ID / TelephonyManager.getDeviceId() (e.g: 0x01)\",\\n\\t\\tstyle={\"input_type\": \"text\"},\\n\\t\\trequired=False,\\n\\t\\tallow_null=True\\n\\t)\\n\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = GCMDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"device_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"cloud_message_type\", \"application_id\",\\n\\t\\t)\\n\\t\\textra_kwargs = {\"id\": {\"read_only\": False, \"required\": False}}\\n\\n\\tdef validate_device_id(self, value):\\n\\t\\t# device ids are 64 bit unsigned values\\n\\t\\tif value > UNSIGNED_64BIT_INT_MAX_VALUE:\\n\\t\\t\\traise ValidationError(\"Device ID is out of range\")\\n\\t\\treturn value\\n\\n\\nclass WNSDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WNSDevice\\n\\n\\nclass WebPushDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WebPushDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"p256dh\", \"auth\", \"browser\", \"application_id\",\\n\\t\\t)\\n\\n\\n# Permissions\\nclass IsOwner(permissions.BasePermission):\\n\\tdef has_object_permission(self, request, view, obj):\\n\\t\\t# must be the owner to view the object\\n\\t\\treturn obj.user == request.user\\n\\n\\n# Mixins\\nclass DeviceViewSetMixin:\\n\\tlookup_field = \"registration_id\"\\n\\n\\tdef create(self, request, *args, **kwargs):\\n\\t\\tserializer = None\\n\\t\\tis_update = False\\n\\t\\tif SETTINGS.get(\"UPDATE_ON_DUPLICATE_REG_ID\") and self.lookup_field in request.data:\\n\\t\\t\\tinstance = self.queryset.model.objects.filter(\\n\\t\\t\\t\\tregistration_id=request.data[self.lookup_field]\\n\\t\\t\\t).first()\\n\\t\\t\\tif instance:\\n\\t\\t\\t\\tserializer = self.get_serializer(instance, data=request.data)\\n\\t\\t\\t\\tis_update = True\\n\\t\\tif not serializer:\\n\\t\\t\\tserializer = self.get_serializer(data=request.data)\\n\\n\\t\\tserializer.is_valid(raise_exception=True)\\n\\t\\tif is_update:\\n\\t\\t\\tself.perform_update(serializer)\\n\\t\\t\\treturn Response(serializer.data)\\n\\t\\telse:\\n\\t\\t\\tself.perform_create(serializer)\\n\\t\\t\\theaders = self.get_success_headers(serializer.data)\\n\\t\\t\\treturn Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\\n\\n\\tdef perform_create(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_create(serializer)\\n\\n\\tdef perform_update(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_update(serializer)\\n\\n\\nclass AuthorizedMixin:\\n\\tpermission_classes = (permissions.IsAuthenticated, IsOwner)\\n\\n\\tdef get_queryset(self):\\n\\t\\t# filter all devices to only those belonging to the current user\\n\\t\\treturn self.queryset.filter(user=self.request.user)\\n\\n\\n# ViewSets\\nclass APNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = APNSDevice.objects.all()\\n\\tserializer_class = APNSDeviceSerializer\\n\\n\\nclass APNSDeviceAuthorizedViewSet(AuthorizedMixin, APNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass GCMDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = GCMDevice.objects.all()\\n\\tserializer_class = GCMDeviceSerializer\\n\\n\\nclass GCMDeviceAuthorizedViewSet(AuthorizedMixin, GCMDeviceViewSet):\\n\\tpass\\n\\n\\nclass WNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WNSDevice.objects.all()\\n\\tserializer_class = WNSDeviceSerializer\\n\\n\\nclass WNSDeviceAuthorizedViewSet(AuthorizedMixin, WNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass WebPushDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WebPushDevice.objects.all()\\n\\tserializer_class = WebPushDeviceSerializer\\n\\n\\nclass WebPushDeviceAuthorizedViewSet(AuthorizedMixin, WebPushDeviceViewSet):\\n\\tpass\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "b'\"\"\"\\nApple Push Notification Service\\nDocumentation is available on the iOS Developer Library:\\nhttps://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html\\n\"\"\"\\n\\nimport time\\n\\nfrom apns2 import client as apns2_client\\nfrom apns2 import credentials as apns2_credentials\\nfrom apns2 import errors as apns2_errors\\nfrom apns2 import payload as apns2_payload\\n\\nfrom . import models\\nfrom .conf import get_manager\\nfrom .exceptions import APNSError, APNSUnsupportedPriority, APNSServerError\\n\\n\\ndef _apns_create_socket(creds=None, application_id=None):\\n\\tif creds is None:\\n\\t\\tif not get_manager().has_auth_token_creds(application_id):\\n\\t\\t\\tcert = get_manager().get_apns_certificate(application_id)\\n\\t\\t\\tcreds = apns2_credentials.CertificateCredentials(cert)\\n\\t\\telse:\\n\\t\\t\\tkeyPath, keyId, teamId = get_manager().get_apns_auth_creds(application_id)\\n\\t\\t\\t# No use getting a lifetime because this credential is\\n\\t\\t\\t# ephemeral, but if you\\'re looking at this to see how to\\n\\t\\t\\t# create a credential, you could also pass the lifetime and\\n\\t\\t\\t# algorithm. Neither of those settings are exposed in the\\n\\t\\t\\t# settings API at the moment.\\n\\t\\t\\tcreds = creds or apns2_credentials.TokenCredentials(keyPath, keyId, teamId)\\n\\tclient = apns2_client.APNsClient(\\n\\t\\tcreds,\\n\\t\\tuse_sandbox=get_manager().get_apns_use_sandbox(application_id),\\n\\t\\tuse_alternative_port=get_manager().get_apns_use_alternative_port(application_id)\\n\\t)\\n\\tclient.connect()\\n\\treturn client\\n\\n\\ndef _apns_prepare(\\n\\ttoken, alert, application_id=None, badge=None, sound=None, category=None,\\n\\tcontent_available=False, action_loc_key=None, loc_key=None, loc_args=[],\\n\\textra={}, mutable_content=False, thread_id=None, url_args=None):\\n\\t\\tif action_loc_key or loc_key or loc_args:\\n\\t\\t\\tapns2_alert = apns2_payload.PayloadAlert(\\n\\t\\t\\t\\tbody=alert if alert else {}, body_localized_key=loc_key,\\n\\t\\t\\t\\tbody_localized_args=loc_args, action_localized_key=action_loc_key)\\n\\t\\telse:\\n\\t\\t\\tapns2_alert = alert\\n\\n\\t\\tif callable(badge):\\n\\t\\t\\tbadge = badge(token)\\n\\n\\t\\treturn apns2_payload.Payload(\\n\\t\\t\\talert=apns2_alert, badge=badge, sound=sound, category=category,\\n\\t\\t\\turl_args=url_args, custom=extra, thread_id=thread_id,\\n\\t\\t\\tcontent_available=content_available, mutable_content=mutable_content)\\n\\n\\ndef _apns_send(\\n\\tregistration_id, alert, batch=False, application_id=None, creds=None, **kwargs\\n):\\n\\tclient = _apns_create_socket(creds=creds, application_id=application_id)\\n\\n\\tnotification_kwargs = {}\\n\\n\\t# if expiration isn\"t specified use 1 month from now\\n\\tnotification_kwargs[\"expiration\"] = kwargs.pop(\"expiration\", None)\\n\\tif not notification_kwargs[\"expiration\"]:\\n\\t\\tnotification_kwargs[\"expiration\"] = int(time.time()) + 2592000\\n\\n\\tpriority = kwargs.pop(\"priority\", None)\\n\\tif priority:\\n\\t\\ttry:\\n\\t\\t\\tnotification_kwargs[\"priority\"] = apns2_client.NotificationPriority(str(priority))\\n\\t\\texcept ValueError:\\n\\t\\t\\traise APNSUnsupportedPriority(\"Unsupported priority %d\" % (priority))\\n\\n\\tnotification_kwargs[\"collapse_id\"] = kwargs.pop(\"collapse_id\", None)\\n\\n\\tif batch:\\n\\t\\tdata = [apns2_client.Notification(\\n\\t\\t\\ttoken=rid, payload=_apns_prepare(rid, alert, **kwargs)) for rid in registration_id]\\n\\t\\t# returns a dictionary mapping each token to its result. That\\n\\t\\t# result is either \"Success\" or the reason for the failure.\\n\\t\\treturn client.send_notification_batch(\\n\\t\\t\\tdata, get_manager().get_apns_topic(application_id=application_id),\\n\\t\\t\\t**notification_kwargs\\n\\t\\t)\\n\\n\\tdata = _apns_prepare(registration_id, alert, **kwargs)\\n\\tclient.send_notification(\\n\\t\\tregistration_id, data,\\n\\t\\tget_manager().get_apns_topic(application_id=application_id),\\n\\t\\t**notification_kwargs\\n\\t)\\n\\n\\ndef apns_send_message(registration_id, alert, application_id=None, creds=None, **kwargs):\\n\\t\"\"\"\\n\\tSends an APNS notification to a single registration_id.\\n\\tThis will send the notification as form data.\\n\\tIf sending multiple notifications, it is more efficient to use\\n\\tapns_send_bulk_message()\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\ttry:\\n\\t\\t_apns_send(\\n\\t\\t\\tregistration_id, alert, application_id=application_id,\\n\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t)\\n\\texcept apns2_errors.APNsException as apns2_exception:\\n\\t\\tif isinstance(apns2_exception, apns2_errors.Unregistered):\\n\\t\\t\\tdevice = models.APNSDevice.objects.get(registration_id=registration_id)\\n\\t\\t\\tdevice.active = False\\n\\t\\t\\tdevice.save()\\n\\n\\t\\traise APNSServerError(status=apns2_exception.__class__.__name__)\\n\\n\\ndef apns_send_bulk_message(\\n\\tregistration_ids, alert, application_id=None, creds=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends an APNS notification to one or more registration_ids.\\n\\tThe registration_ids argument needs to be a list.\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\tresults = _apns_send(\\n\\t\\tregistration_ids, alert, batch=True, application_id=application_id,\\n\\t\\tcreds=creds, **kwargs\\n\\t)\\n\\tinactive_tokens = [token for token, result in results.items() if result == \"Unregistered\"]\\n\\tmodels.APNSDevice.objects.filter(registration_id__in=inactive_tokens).update(active=False)\\n\\treturn results\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "b'# flake8:noqa\\nfrom urllib.error import HTTPError\\nfrom urllib.parse import urlencode\\nfrom urllib.request import Request, urlopen\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "b'from django.utils.module_loading import import_string\\n\\nfrom .app import AppConfig  # noqa: F401\\nfrom .appmodel import AppModelConfig  # noqa: F401\\nfrom .legacy import LegacyConfig  # noqa: F401\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS  # noqa: I001\\n\\n\\nmanager = None\\n\\n\\ndef get_manager(reload=False):\\n\\tglobal manager\\n\\n\\tif not manager or reload is True:\\n\\t\\tmanager = import_string(SETTINGS[\"CONFIG\"])()\\n\\n\\treturn manager\\n\\n\\n# implementing get_manager as a function allows tests to reload settings\\nget_manager()\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "b'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig, check_apns_certificate\\n\\n\\nSETTING_MISMATCH = (\\n\\t\"Application \\'{application_id}\\' ({platform}) does not support the setting \\'{setting}\\'.\"\\n)\\n\\n# code can be \"missing\" or \"invalid\"\\nBAD_PLATFORM = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"PLATFORM\"] is {code}. \\'\\n\\t\"Must be one of: {platforms}.\"\\n)\\n\\nUNKNOWN_PLATFORM = (\\n\\t\"Unknown Platform: {platform}. Must be one of: {platforms}.\"\\n)\\n\\nMISSING_SETTING = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"{setting}\"] is missing.\\'\\n)\\n\\nPLATFORMS = [\\n\\t\"APNS\",\\n\\t\"FCM\",\\n\\t\"GCM\",\\n\\t\"WNS\",\\n\\t\"WP\",\\n]\\n\\n# Settings that all applications must have\\nREQUIRED_SETTINGS = [\\n\\t\"PLATFORM\",\\n]\\n\\n# Settings that an application may have to enable optional features\\n# these settings are stubs for registry support and have no effect on the operation\\n# of the application at this time.\\nOPTIONAL_SETTINGS = [\\n\\t\"APPLICATION_GROUP\", \"APPLICATION_SECRET\"\\n]\\n\\n# Since we can have an auth key, combined with a auth key id and team id *or*\\n# a certificate, we make these all optional, and then make sure we have one or\\n# the other (group) of settings.\\nAPNS_SETTINGS_CERT_CREDS = \"CERTIFICATE\"\\n\\n# Subkeys for APNS_SETTINGS_AUTH_CREDS\\nAPNS_AUTH_CREDS_REQUIRED = [\"AUTH_KEY_PATH\", \"AUTH_KEY_ID\", \"TEAM_ID\"]\\nAPNS_AUTH_CREDS_OPTIONAL = [\"CERTIFICATE\", \"ENCRYPTION_ALGORITHM\", \"TOKEN_LIFETIME\"]\\n\\nAPNS_OPTIONAL_SETTINGS = [\\n\\t\"USE_SANDBOX\", \"USE_ALTERNATIVE_PORT\", \"TOPIC\"\\n]\\n\\nFCM_REQUIRED_SETTINGS = GCM_REQUIRED_SETTINGS = [\"API_KEY\"]\\nFCM_OPTIONAL_SETTINGS = GCM_OPTIONAL_SETTINGS = [\\n\\t\"POST_URL\", \"MAX_RECIPIENTS\", \"ERROR_TIMEOUT\"\\n]\\n\\nWNS_REQUIRED_SETTINGS = [\"PACKAGE_SECURITY_ID\", \"SECRET_KEY\"]\\nWNS_OPTIONAL_SETTINGS = [\"WNS_ACCESS_URL\"]\\n\\nWP_REQUIRED_SETTINGS = [\"PRIVATE_KEY\", \"CLAIMS\"]\\nWP_OPTIONAL_SETTINGS = [\"ERROR_TIMEOUT\", \"POST_URL\"]\\n\\n\\nclass AppConfig(BaseConfig):\\n\\t\"\"\"\\n\\tSupports any number of push notification enabled applications.\\n\\t\"\"\"\\n\\n\\tdef __init__(self, settings=None):\\n\\t\\t# supports overriding the settings to be loaded. Will load from ..settings by default.\\n\\t\\tself._settings = settings or SETTINGS\\n\\n\\t\\t# initialize APPLICATIONS to an empty collection\\n\\t\\tself._settings.setdefault(\"APPLICATIONS\", {})\\n\\n\\t\\t# validate application configurations\\n\\t\\tself._validate_applications(self._settings[\"APPLICATIONS\"])\\n\\n\\tdef _validate_applications(self, apps):\\n\\t\\t\"\"\"Validate the application collection\"\"\"\\n\\t\\tfor application_id, application_config in apps.items():\\n\\t\\t\\tself._validate_config(application_id, application_config)\\n\\n\\t\\t\\tapplication_config[\"APPLICATION_ID\"] = application_id\\n\\n\\tdef _validate_config(self, application_id, application_config):\\n\\t\\tplatform = application_config.get(\"PLATFORM\", None)\\n\\n\\t\\t# platform is not present\\n\\t\\tif platform is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"required\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# platform is not a valid choice from PLATFORMS\\n\\t\\tif platform not in PLATFORMS:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"invalid\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\tvalidate_fn = \"_validate_{platform}_config\".format(platform=platform).lower()\\n\\n\\t\\tif hasattr(self, validate_fn):\\n\\t\\t\\tgetattr(self, validate_fn)(application_id, application_config)\\n\\t\\telse:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tUNKNOWN_PLATFORM.format(\\n\\t\\t\\t\\t\\tplatform=platform,\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\tdef _validate_apns_config(self, application_id, application_config):\\n\\t\\tallowed = REQUIRED_SETTINGS + OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\tAPNS_OPTIONAL_SETTINGS\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\t# We have two sets of settings, certificate and JWT auth key.\\n\\t\\t# Auth Key requires 3 values, so if that is set, that will take\\n\\t\\t# precedence. If None are set, we will throw an error.\\n\\t\\thas_cert_creds = APNS_SETTINGS_CERT_CREDS in \\\\\\n\\t\\t\\tapplication_config.keys()\\n\\t\\tself.has_token_creds = True\\n\\t\\tfor token_setting in APNS_AUTH_CREDS_REQUIRED:\\n\\t\\t\\tif token_setting not in application_config.keys():\\n\\t\\t\\t\\tself.has_token_creds = False\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif not has_cert_creds and not self.has_token_creds:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tsetting=(APNS_SETTINGS_CERT_CREDS, APNS_AUTH_CREDS_REQUIRED)))\\n\\t\\tcert_path = None\\n\\t\\tif has_cert_creds:\\n\\t\\t\\tcert_path = \"CERTIFICATE\"\\n\\t\\telif self.has_token_creds:\\n\\t\\t\\tcert_path = \"AUTH_KEY_PATH\"\\n\\t\\t\\tallowed_tokens = APNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\t\\tAPNS_OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\t\\tREQUIRED_SETTINGS\\n\\t\\t\\tself._validate_allowed_settings(application_id, application_config, allowed_tokens)\\n\\t\\t\\tself._validate_required_settings(\\n\\t\\t\\t\\tapplication_id, application_config, APNS_AUTH_CREDS_REQUIRED\\n\\t\\t\\t)\\n\\t\\tself._validate_apns_certificate(application_config[cert_path])\\n\\n\\t\\t# determine/set optional values\\n\\t\\tapplication_config.setdefault(\"USE_SANDBOX\", False)\\n\\t\\tapplication_config.setdefault(\"USE_ALTERNATIVE_PORT\", False)\\n\\t\\tapplication_config.setdefault(\"TOPIC\", None)\\n\\n\\tdef _validate_apns_certificate(self, certfile):\\n\\t\\t\"\"\"Validate the APNS certificate at startup.\"\"\"\\n\\n\\t\\ttry:\\n\\t\\t\\twith open(certfile, \"r\") as f:\\n\\t\\t\\t\\tcontent = f.read()\\n\\t\\t\\t\\tcheck_apns_certificate(content)\\n\\t\\texcept Exception as e:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"The APNS certificate file at {!r} is not readable: {}\".format(certfile, e)\\n\\t\\t\\t)\\n\\n\\tdef _validate_fcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + FCM_REQUIRED_SETTINGS + FCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, FCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://fcm.googleapis.com/fcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_gcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + GCM_REQUIRED_SETTINGS + GCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, GCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://android.googleapis.com/gcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_wns_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WNS_REQUIRED_SETTINGS + WNS_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WNS_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\")\\n\\n\\tdef _validate_wp_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WP_REQUIRED_SETTINGS + WP_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WP_REQUIRED_SETTINGS\\n\\t\\t)\\n\\t\\tapplication_config.setdefault(\"POST_URL\", {\\n\\t\\t\\t\"CHROME\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"OPERA\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n\\t\\t\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\\t})\\n\\n\\tdef _validate_allowed_settings(self, application_id, application_config, allowed_settings):\\n\\t\\t\"\"\"Confirm only allowed settings are present.\"\"\"\\n\\n\\t\\tfor setting_key in application_config.keys():\\n\\t\\t\\tif setting_key not in allowed_settings:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"Platform {}, app {} does not support the setting: {}.\".format(\\n\\t\\t\\t\\t\\t\\tapplication_config[\"PLATFORM\"], application_id, setting_key\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\n\\tdef _validate_required_settings(\\n\\t\\tself, application_id, application_config, required_settings,\\n\\t\\tshould_throw=True\\n\\t):\\n\\t\\t\"\"\"All required keys must be present\"\"\"\\n\\n\\t\\tfor setting_key in required_settings:\\n\\t\\t\\tif setting_key not in application_config.keys():\\n\\t\\t\\t\\tif should_throw:\\n\\t\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\t\\t\\tapplication_id=application_id, setting=setting_key\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tdef _get_application_settings(self, application_id, platform, settings_key):\\n\\t\\t\"\"\"\\n\\t\\tWalks through PUSH_NOTIFICATIONS_SETTINGS to find the correct setting value\\n\\t\\tor raises ImproperlyConfigured.\\n\\t\\t\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tconf_cls = \"push_notifications.conf.AppConfig\"\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"{} requires the application_id be specified at all times.\".format(conf_cls)\\n\\t\\t\\t)\\n\\n\\t\\t# verify that the application config exists\\n\\t\\tapp_config = self._settings.get(\"APPLICATIONS\").get(application_id, None)\\n\\t\\tif app_config is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"No application configured with application_id: {}.\".format(application_id)\\n\\t\\t\\t)\\n\\n\\t\\t# fetch a setting for the incorrect type of platform\\n\\t\\tif app_config.get(\"PLATFORM\") != platform:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tSETTING_MISMATCH.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tplatform=app_config.get(\"PLATFORM\"),\\n\\t\\t\\t\\t\\tsetting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# finally, try to fetch the setting\\n\\t\\tif settings_key not in app_config:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id, setting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\treturn app_config.get(settings_key)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\treturn self.has_token_creds\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"GCM\", \"API_KEY\")\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"FCM\", \"API_KEY\")\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"POST_URL\")\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"ERROR_TIMEOUT\")\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"MAX_RECIPIENTS\")\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(application_id, \"APNS\", \"CERTIFICATE\")\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn \\\\\\n\\t\\t(self._get_apns_auth_key_path(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key_path(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_PATH\")\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_ID\")\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TEAM_ID\")\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_SANDBOX\")\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_ALTERNATIVE_PORT\")\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TOPIC\")\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"PACKAGE_SECURITY_ID\")\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"SECRET_KEY\")\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"POST_URL\")[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"PRIVATE_KEY\")\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"CLAIMS\")\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "b'from .base import BaseConfig\\n\\n\\nclass AppModelConfig(BaseConfig):\\n\\t\"\"\"Future home of the Application Model conf adapter\\n\\n\\tSupports multiple applications in the database.\\n\\t\"\"\"\\n\\n\\tpass\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "b'from django.core.exceptions import ImproperlyConfigured\\n\\n\\nclass BaseConfig:\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_applications(self):\\n\\t\\t\"\"\"Returns a collection containing the configured applications.\"\"\"\\n\\n\\t\\traise NotImplementedError\\n\\n\\n# This works for both the certificate and the auth key (since that\\'s just\\n# a certificate).\\ndef check_apns_certificate(ss):\\n\\tmode = \"start\"\\n\\tfor s in ss.split(\"\\\\n\"):\\n\\t\\tif mode == \"start\":\\n\\t\\t\\tif \"BEGIN RSA PRIVATE KEY\" in s or \"BEGIN PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"key\"\\n\\t\\telif mode == \"key\":\\n\\t\\t\\tif \"END RSA PRIVATE KEY\" in s or \"END PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"end\"\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif s.startswith(\"Proc-Type\") and \"ENCRYPTED\" in s:\\n\\t\\t\\t\\traise ImproperlyConfigured(\"Encrypted APNS private keys are not supported\")\\n\\n\\tif mode != \"end\":\\n\\t\\traise ImproperlyConfigured(\"The APNS certificate doesn\\'t contain a private key\")\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "b'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig\\n\\n\\n__all__ = [\\n\\t\"LegacyConfig\"\\n]\\n\\n\\nclass empty:\\n\\tpass\\n\\n\\nclass LegacyConfig(BaseConfig):\\n\\n\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\n\\tdef _get_application_settings(self, application_id, settings_key, error_message):\\n\\t\\t\"\"\"Legacy behaviour\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tvalue = SETTINGS.get(settings_key, empty)\\n\\t\\t\\tif value is empty:\\n\\t\\t\\t\\traise ImproperlyConfigured(error_message)\\n\\t\\t\\treturn value\\n\\t\\telse:\\n\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\"LegacySettings does not support application_id. To enable \"\\n\\t\\t\\t\\t\"multiple application support, use push_notifications.conf.AppSettings.\"\\n\\t\\t\\t)\\n\\t\\t\\traise ImproperlyConfigured(msg)\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"GCM_API_KEY\"] to send messages through GCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"GCM_API_KEY\", msg)\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"FCM_API_KEY\"] to send messages through FCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"FCM_API_KEY\", msg)\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_POST_URL\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_ERROR_TIMEOUT\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_MAX_RECIPIENTS\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\ttry:\\n\\t\\t\\tself._get_apns_auth_key(application_id)\\n\\t\\t\\tself._get_apns_auth_key_id(application_id)\\n\\t\\t\\tself._get_apns_team_id(application_id)\\n\\t\\texcept ImproperlyConfigured:\\n\\t\\t\\treturn False\\n\\n\\t\\treturn True\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(\\n\\t\\t\\tapplication_id, \"APNS_CERTIFICATE\",\\n\\t\\t\\t\"You need to setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\t)\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\traise ImproperlyConfigured(msg)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn (\\n\\t\\t\\tself._get_apns_auth_key(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_PATH\", self.msg)\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TEAM_ID\", self.msg)\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_ID\", self.msg)\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_USE_SANDBOX\", self.msg)\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn\\n\\t\\tself._get_application_settings(application_id, \"APNS_USE_ALTERNATIVE_PORT\", self.msg)\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TOPIC\", self.msg)\\n\\n\\tdef get_apns_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_HOST\", self.msg)\\n\\n\\tdef get_apns_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_PORT\", self.msg)\\n\\n\\tdef get_apns_feedback_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_HOST\", self.msg)\\n\\n\\tdef get_apns_feedback_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_PORT\", self.msg)\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_PACKAGE_SECURITY_ID\", self.msg)\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_SECRET_KEY\", msg)\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_POST_URL\", msg)[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_PRIVATE_KEY\", msg)\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_CLAIMS\", msg)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "b'class NotificationError(Exception):\\n\\tpass\\n\\n\\n# APNS\\nclass APNSError(NotificationError):\\n\\tpass\\n\\n\\nclass APNSUnsupportedPriority(APNSError):\\n\\tpass\\n\\n\\nclass APNSServerError(APNSError):\\n\\tdef __init__(self, status):\\n\\t\\tsuper().__init__(status)\\n\\t\\tself.status = status\\n\\n\\n# GCM\\nclass GCMError(NotificationError):\\n\\tpass\\n\\n\\n# Web Push\\nclass WebPushError(NotificationError):\\n\\tpass\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "b'import re\\nimport struct\\n\\nfrom django import forms\\nfrom django.core.validators import MaxValueValidator, MinValueValidator, RegexValidator\\nfrom django.db import connection, models\\nfrom django.utils.translation import gettext_lazy as _\\n\\n\\n__all__ = [\"HexadecimalField\", \"HexIntegerField\"]\\n\\nUNSIGNED_64BIT_INT_MIN_VALUE = 0\\nUNSIGNED_64BIT_INT_MAX_VALUE = 2 ** 64 - 1\\n\\n\\nhex_re = re.compile(r\"^(([0-9A-f])|(0x[0-9A-f]))+$\")\\nsigned_integer_vendors = [\\n\\t\"postgresql\",\\n\\t\"sqlite\",\\n]\\n\\n\\ndef _using_signed_storage():\\n\\treturn connection.vendor in signed_integer_vendors\\n\\n\\ndef _signed_to_unsigned_integer(value):\\n\\treturn struct.unpack(\"Q\", struct.pack(\"q\", value))[0]\\n\\n\\ndef _unsigned_to_signed_integer(value):\\n\\treturn struct.unpack(\"q\", struct.pack(\"Q\", value))[0]\\n\\n\\ndef _hex_string_to_unsigned_integer(value):\\n\\treturn int(value, 16)\\n\\n\\ndef _unsigned_integer_to_hex_string(value):\\n\\treturn hex(value).rstrip(\"L\")\\n\\n\\nclass HexadecimalField(forms.CharField):\\n\\t\"\"\"\\n\\tA form field that accepts only hexadecimal numbers\\n\\t\"\"\"\\n\\tdef __init__(self, *args, **kwargs):\\n\\t\\tself.default_validators = [\\n\\t\\t\\tRegexValidator(hex_re, _(\"Enter a valid hexadecimal number\"), \"invalid\")\\n\\t\\t]\\n\\t\\tsuper(HexadecimalField, self).__init__(*args, **kwargs)\\n\\n\\tdef prepare_value(self, value):\\n\\t\\t# converts bigint from db to hex before it is displayed in admin\\n\\t\\tif value and not isinstance(value, str) \\\\\\n\\t\\t\\tand connection.vendor in (\"mysql\", \"sqlite\"):\\n\\t\\t\\tvalue = _unsigned_integer_to_hex_string(value)\\n\\t\\treturn super(forms.CharField, self).prepare_value(value)\\n\\n\\nclass HexIntegerField(models.BigIntegerField):\\n\\t\"\"\"\\n\\tThis field stores a hexadecimal *string* of up to 64 bits as an unsigned integer\\n\\ton *all* backends including postgres.\\n\\n\\tReasoning: Postgres only supports signed bigints. Since we don\\'t care about\\n\\tsignedness, we store it as signed, and cast it to unsigned when we deal with\\n\\tthe actual value (with struct)\\n\\n\\tOn sqlite and mysql, native unsigned bigint types are used. In all cases, the\\n\\tvalue we deal with in python is always in hex.\\n\\t\"\"\"\\n\\n\\tvalidators = [\\n\\t\\tMinValueValidator(UNSIGNED_64BIT_INT_MIN_VALUE),\\n\\t\\tMaxValueValidator(UNSIGNED_64BIT_INT_MAX_VALUE)\\n\\t]\\n\\n\\tdef db_type(self, connection):\\n\\t\\tif \"mysql\" == connection.vendor:\\n\\t\\t\\treturn \"bigint unsigned\"\\n\\t\\telif \"sqlite\" == connection.vendor:\\n\\t\\t\\treturn \"UNSIGNED BIG INT\"\\n\\t\\telse:\\n\\t\\t\\treturn super(HexIntegerField, self).db_type(connection=connection)\\n\\n\\tdef get_prep_value(self, value):\\n\\t\\t\"\"\" Return the integer value to be stored from the hex string \"\"\"\\n\\t\\tif value is None or value == \"\":\\n\\t\\t\\treturn None\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _unsigned_to_signed_integer(value)\\n\\t\\treturn value\\n\\n\\tdef from_db_value(self, value, *args):\\n\\t\\t\"\"\" Return an unsigned int representation from all db backends \"\"\"\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _signed_to_unsigned_integer(value)\\n\\t\\treturn value\\n\\n\\tdef to_python(self, value):\\n\\t\\t\"\"\" Return a str representation of the hexadecimal \"\"\"\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\treturn value\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\treturn _unsigned_integer_to_hex_string(value)\\n\\n\\tdef formfield(self, **kwargs):\\n\\t\\tdefaults = {\"form_class\": HexadecimalField}\\n\\t\\tdefaults.update(kwargs)\\n\\t\\t# yes, that super call is right\\n\\t\\treturn super(models.IntegerField, self).formfield(**defaults)\\n\\n\\tdef run_validators(self, value):\\n\\t\\t# make sure validation is performed on integer value not string value\\n\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\treturn super(models.BigIntegerField, self).run_validators(value)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "b'\"\"\"\\nFirebase Cloud Messaging\\nPreviously known as GCM / C2DM\\nDocumentation is available on the Firebase Developer website:\\nhttps://firebase.google.com/docs/cloud-messaging/\\n\"\"\"\\n\\nimport json\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import Request, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import GCMError\\nfrom .models import GCMDevice\\n\\n\\n# Valid keys for FCM messages. Reference:\\n# https://firebase.google.com/docs/cloud-messaging/http-server-ref\\nFCM_TARGETS_KEYS = [\\n\\t\"to\", \"condition\", \"notification_key\"\\n]\\nFCM_OPTIONS_KEYS = [\\n\\t\"collapse_key\", \"priority\", \"content_available\", \"delay_while_idle\", \"time_to_live\",\\n\\t\"restricted_package_name\", \"dry_run\", \"mutable_content\"\\n]\\nFCM_NOTIFICATIONS_PAYLOAD_KEYS = [\\n\\t\"title\", \"body\", \"icon\", \"image\", \"sound\", \"badge\", \"color\", \"tag\", \"click_action\",\\n\\t\"body_loc_key\", \"body_loc_args\", \"title_loc_key\", \"title_loc_args\", \"android_channel_id\"\\n]\\n\\ndef _chunks(l, n):\\n\\t\"\"\"\\n\\tYield successive chunks from list \\\\a l with a minimum size \\\\a n\\n\\t\"\"\"\\n\\tfor i in range(0, len(l), n):\\n\\t\\tyield l[i:i + n]\\n\\n\\ndef _gcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_gcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"GCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"GCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _fcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_fcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"FCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"FCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _cm_handle_response(registration_ids, response_data, cloud_type, application_id=None):\\n\\tresponse = response_data\\n\\tif response.get(\"failure\") or response.get(\"canonical_ids\"):\\n\\t\\tids_to_remove, old_new_ids = [], []\\n\\t\\tthrow_error = False\\n\\t\\tfor index, result in enumerate(response[\"results\"]):\\n\\t\\t\\terror = result.get(\"error\")\\n\\t\\t\\tif error:\\n\\t\\t\\t\\t# https://firebase.google.com/docs/cloud-messaging/http-server-ref#error-codes\\n\\t\\t\\t\\t# If error is NotRegistered or InvalidRegistration, then we will deactivate devices\\n\\t\\t\\t\\t# because this registration ID is no more valid and can\\'t be used to send messages,\\n\\t\\t\\t\\t# otherwise raise error\\n\\t\\t\\t\\tif error in (\"NotRegistered\", \"InvalidRegistration\"):\\n\\t\\t\\t\\t\\tids_to_remove.append(registration_ids[index])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tthrow_error = True\\n\\t\\t\\tresult[\"original_registration_id\"] = registration_ids[index]\\n\\t\\t\\t# If registration_id is set, replace the original ID with the new value (canonical ID)\\n\\t\\t\\t# in your server database. Note that the original ID is not part of the result, you need\\n\\t\\t\\t# to obtain it from the list of registration_ids in the request (using the same index).\\n\\t\\t\\tnew_id = result.get(\"registration_id\")\\n\\t\\t\\tif new_id:\\n\\t\\t\\t\\told_new_ids.append((registration_ids[index], new_id))\\n\\n\\t\\tif ids_to_remove:\\n\\t\\t\\tremoved = GCMDevice.objects.filter(\\n\\t\\t\\t\\tregistration_id__in=ids_to_remove, cloud_message_type=cloud_type\\n\\t\\t\\t)\\n\\t\\t\\tremoved.update(active=False)\\n\\n\\t\\tfor old_id, new_id in old_new_ids:\\n\\t\\t\\t_cm_handle_canonical_id(new_id, old_id, cloud_type)\\n\\n\\t\\tif throw_error:\\n\\t\\t\\traise GCMError(response)\\n\\treturn response\\n\\n\\ndef _cm_send_request(\\n\\tregistration_ids, data, cloud_type=\"GCM\", application_id=None,\\n\\tuse_fcm_notifications=True, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a FCM or GCM notification to one or more registration_ids as json data.\\n\\tThe registration_ids needs to be a list.\\n\\t\"\"\"\\n\\n\\tpayload = {\"registration_ids\": registration_ids} if registration_ids else {}\\n\\n\\tdata = data.copy()\\n\\n\\t# If using FCM, optionally autodiscovers notification related keys\\n\\t# https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages\\n\\tif cloud_type == \"FCM\" and use_fcm_notifications:\\n\\t\\tnotification_payload = {}\\n\\t\\tif \"message\" in data:\\n\\t\\t\\tnotification_payload[\"body\"] = data.pop(\"message\", None)\\n\\n\\t\\tfor key in FCM_NOTIFICATIONS_PAYLOAD_KEYS:\\n\\t\\t\\tvalue_from_extra = data.pop(key, None)\\n\\t\\t\\tif value_from_extra:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_extra\\n\\t\\t\\tvalue_from_kwargs = kwargs.pop(key, None)\\n\\t\\t\\tif value_from_kwargs:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_kwargs\\n\\t\\tif notification_payload:\\n\\t\\t\\tpayload[\"notification\"] = notification_payload\\n\\n\\tif data:\\n\\t\\tpayload[\"data\"] = data\\n\\n\\t# Attach any additional non falsy keyword args (targets, options)\\n\\t# See ref : https://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\tpayload.update({\\n\\t\\tk: v for k, v in kwargs.items() if v and (k in FCM_TARGETS_KEYS or k in FCM_OPTIONS_KEYS)\\n\\t})\\n\\n\\t# Sort the keys for deterministic output (useful for tests)\\n\\tjson_payload = json.dumps(payload, separators=(\",\", \":\"), sort_keys=True).encode(\"utf-8\")\\n\\n\\t# Sends requests and handles the response\\n\\tif cloud_type == \"GCM\":\\n\\t\\tresponse = json.loads(_gcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telif cloud_type == \"FCM\":\\n\\t\\tresponse = json.loads(_fcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\treturn _cm_handle_response(registration_ids, response, cloud_type, application_id)\\n\\n\\ndef _cm_handle_canonical_id(canonical_id, current_id, cloud_type):\\n\\t\"\"\"\\n\\tHandle situation when FCM server response contains canonical ID\\n\\t\"\"\"\\n\\tdevices = GCMDevice.objects.filter(cloud_message_type=cloud_type)\\n\\tif devices.filter(registration_id=canonical_id, active=True).exists():\\n\\t\\tdevices.filter(registration_id=current_id).update(active=False)\\n\\telse:\\n\\t\\tdevices.filter(registration_id=current_id).update(registration_id=canonical_id)\\n\\n\\ndef send_message(registration_ids, data, cloud_type, application_id=None, **kwargs):\\n\\t\"\"\"\\n\\tSends a FCM (or GCM) notification to one or more registration_ids. The registration_ids\\n\\tcan be a list or a single string. This will send the notification as json data.\\n\\n\\tA reference of extra keyword arguments sent to the server is available here:\\n\\thttps://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\t\"\"\"\\n\\tif cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\tmax_recipients = get_manager().get_max_recipients(cloud_type, application_id)\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\n\\t# Checks for valid recipient\\n\\tif registration_ids is None and \"/topics/\" not in kwargs.get(\"to\", \"\"):\\n\\t\\treturn\\n\\n\\t# Bundles the registration_ids in an list if only one is sent\\n\\tif not isinstance(registration_ids, list):\\n\\t\\tregistration_ids = [registration_ids] if registration_ids else None\\n\\n\\t# FCM only allows up to 1000 reg ids per bulk message\\n\\t# https://firebase.google.com/docs/cloud-messaging/server#http-request\\n\\tif registration_ids:\\n\\t\\tret = []\\n\\t\\tfor chunk in _chunks(registration_ids, max_recipients):\\n\\t\\t\\tret.append(_cm_send_request(\\n\\t\\t\\t\\tchunk, data, cloud_type=cloud_type, application_id=application_id, **kwargs\\n\\t\\t\\t))\\n\\t\\treturn ret[0] if len(ret) == 1 else ret\\n\\telse:\\n\\t\\treturn _cm_send_request(None, data, cloud_type=cloud_type, **kwargs)\\n\\n\\nsend_bulk_message = send_message\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "b\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\nimport push_notifications.fields\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='APNSDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', models.UUIDField(help_text='UDID / UIDevice.identifierForVendor()', max_length=32, null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.CharField(unique=True, max_length=64, verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'APNS device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n        migrations.CreateModel(\\n            name='GCMDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', push_notifications.fields.HexIntegerField(help_text='ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)', null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'GCM device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "b\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.1 on 2016-01-06 08:50\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0001_initial'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=True, verbose_name='Registration ID'),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "b\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nimport django.db.models.deletion\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0002_auto_20160106_0850'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WNSDevice',\\n            fields=[\\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\\n                ('name', models.CharField(blank=True, max_length=255, null=True, verbose_name='Name')),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, null=True, verbose_name='Creation date')),\\n                ('device_id', models.UUIDField(blank=True, db_index=True, help_text='GUID()', null=True, verbose_name='Device ID')),\\n                ('registration_id', models.TextField(verbose_name='Notification URI')),\\n                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\\n            ],\\n            options={\\n                'verbose_name': 'WNS device',\\n            },\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "b\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n\\tdependencies = [\\n\\t\\tmigrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n\\t\\t('push_notifications', '0003_wnsdevice'),\\n\\t]\\n\\n\\toperations = [\\n\\t\\tmigrations.AddField(\\n\\t\\t\\tmodel_name='gcmdevice',\\n\\t\\t\\tname='cloud_message_type',\\n\\t\\t\\tfield=models.CharField(choices=[('FCM', 'Firebase Cloud Message'), ('GCM', 'Google Cloud Message')], default='GCM', help_text='You should choose FCM or GCM', max_length=3, verbose_name='Cloud Message Type')\\n\\t\\t),\\n\\t]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "b\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0004_fcm'),\\n    ]\\n\\n    operations = [\\n        migrations.AddField(\\n            model_name='apnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='gcmdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='wnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "b\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0005_applicationid'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WebPushDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('application_id', models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('p256dh', models.CharField(max_length=88, verbose_name='User public encryption key')),\\n                ('auth', models.CharField(max_length=24, verbose_name='User auth secret')),\\n                ('browser', models.CharField(default='CHROME', help_text='Currently only support to Chrome, Firefox and Opera browsers', max_length=10, verbose_name='Browser', choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera')])),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'WebPush device',\\n            },\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "b\"from django.db import migrations, models\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0006_webpushdevice'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='gcmdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='wnsdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Notification URI'),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "b\"# Generated by Django 3.2.8 on 2021-11-12 09:49\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0007_uniquesetting'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='browser',\\n            field=models.CharField(choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera'), ('EDGE', 'Edge')], default='CHROME', help_text='Currently only support to Chrome, Firefox, Edge and Opera browsers', max_length=10, verbose_name='Browser'),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "b\"# Generated by Django 3.2.9 on 2022-01-10 09:03\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0008_webpush_add_edge'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='device_id',\\n            field=models.UUIDField(blank=True, db_index=True, help_text='UUID / UIDevice.identifierForVendor()', null=True, verbose_name='Device ID'),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "b''"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "b'from django.db import models\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .fields import HexIntegerField\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nCLOUD_MESSAGE_TYPES = (\\n\\t(\"FCM\", \"Firebase Cloud Message\"),\\n\\t(\"GCM\", \"Google Cloud Message\"),\\n)\\n\\nBROWSER_TYPES = (\\n\\t(\"CHROME\", \"Chrome\"),\\n\\t(\"FIREFOX\", \"Firefox\"),\\n\\t(\"OPERA\", \"Opera\"),\\n\\t(\"EDGE\", \"Edge\")\\n)\\n\\n\\nclass Device(models.Model):\\n\\tname = models.CharField(max_length=255, verbose_name=_(\"Name\"), blank=True, null=True)\\n\\tactive = models.BooleanField(\\n\\t\\tverbose_name=_(\"Is active\"), default=True,\\n\\t\\thelp_text=_(\"Inactive devices will not be sent notifications\")\\n\\t)\\n\\tuser = models.ForeignKey(\\n\\t\\tSETTINGS[\"USER_MODEL\"], blank=True, null=True, on_delete=models.CASCADE\\n\\t)\\n\\tdate_created = models.DateTimeField(\\n\\t\\tverbose_name=_(\"Creation date\"), auto_now_add=True, null=True\\n\\t)\\n\\tapplication_id = models.CharField(\\n\\t\\tmax_length=64, verbose_name=_(\"Application ID\"),\\n\\t\\thelp_text=_(\\n\\t\\t\\t\"Opaque application identity, should be filled in for multiple\"\\n\\t\\t\\t\" key/certificate access\"\\n\\t\\t),\\n\\t\\tblank=True, null=True\\n\\t)\\n\\n\\tclass Meta:\\n\\t\\tabstract = True\\n\\n\\tdef __str__(self):\\n\\t\\treturn (\\n\\t\\t\\tself.name or\\n\\t\\t\\tstr(self.device_id or \"\") or\\n\\t\\t\\t\"{} for {}\".format(self.__class__.__name__, self.user or \"unknown user\")\\n\\t\\t)\\n\\n\\nclass GCMDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn GCMDeviceQuerySet(self.model)\\n\\n\\nclass GCMDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\t\\tif message is not None:\\n\\t\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\\n\\t\\t\\t\\t\"application_id\"\\n\\t\\t\\t).values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tresponse = []\\n\\t\\t\\tfor cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\t\\treg_ids = list(\\n\\t\\t\\t\\t\\t\\tself.filter(\\n\\t\\t\\t\\t\\t\\t\\tactive=True, cloud_message_type=cloud_type, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\tif reg_ids:\\n\\t\\t\\t\\t\\t\\tr = gcm_send_message(reg_ids, data, cloud_type, application_id=app_id, **kwargs)\\n\\t\\t\\t\\t\\t\\tresponse.append(r)\\n\\n\\t\\t\\treturn response\\n\\n\\nclass GCMDevice(Device):\\n\\t# device_id cannot be a reliable primary key as fragmentation between different devices\\n\\t# can make it turn out to be null and such:\\n\\t# http://android-developers.blogspot.co.uk/2011/03/identifying-app-installations.html\\n\\tdevice_id = HexIntegerField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tcloud_message_type = models.CharField(\\n\\t\\tverbose_name=_(\"Cloud Message Type\"), max_length=3,\\n\\t\\tchoices=CLOUD_MESSAGE_TYPES, default=\"GCM\",\\n\\t\\thelp_text=_(\"You should choose FCM or GCM\")\\n\\t)\\n\\tobjects = GCMDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"GCM device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\tif message is not None:\\n\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\treturn gcm_send_message(\\n\\t\\t\\tself.registration_id, data, self.cloud_message_type,\\n\\t\\t\\tapplication_id=self.application_id, **kwargs\\n\\t\\t)\\n\\n\\nclass APNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn APNSDeviceQuerySet(self.model)\\n\\n\\nclass APNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .apns import apns_send_bulk_message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\")\\\\\\n\\t\\t\\t\\t.values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tres = []\\n\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\treg_ids = list(self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\"registration_id\", flat=True)\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tr = apns_send_bulk_message(\\n\\t\\t\\t\\t\\tregistration_ids=reg_ids, alert=message, application_id=app_id,\\n\\t\\t\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\t\\tres += [r]\\n\\t\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\t\\tres += r\\n\\t\\t\\treturn res\\n\\n\\nclass APNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"UUID / UIDevice.identifierForVendor()\")\\n\\t)\\n\\tregistration_id = models.CharField(\\n\\t\\tverbose_name=_(\"Registration ID\"), max_length=200, unique=SETTINGS[\"UNIQUE_REG_ID\"]\\n\\t)\\n\\n\\tobjects = APNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"APNS device\")\\n\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tfrom .apns import apns_send_message\\n\\n\\t\\treturn apns_send_message(\\n\\t\\t\\tregistration_id=self.registration_id,\\n\\t\\t\\talert=message,\\n\\t\\t\\tapplication_id=self.application_id, creds=creds,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WNSDeviceQuerySet(self.model)\\n\\n\\nclass WNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_bulk_message\\n\\n\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\").values_list(\\n\\t\\t\\t\"application_id\", flat=True\\n\\t\\t).distinct()\\n\\t\\tres = []\\n\\t\\tfor app_id in app_ids:\\n\\t\\t\\treg_ids = self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t)\\n\\t\\t\\tr = wns_send_bulk_message(uri_list=list(reg_ids), message=message, **kwargs)\\n\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\tres += [r]\\n\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\tres += r\\n\\n\\t\\treturn res\\n\\n\\nclass WNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"GUID()\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Notification URI\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\n\\tobjects = WNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WNS device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_message\\n\\n\\t\\treturn wns_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, application_id=self.application_id,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WebPushDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WebPushDeviceQuerySet(self.model)\\n\\n\\nclass WebPushDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tdevices = self.filter(active=True).order_by(\"application_id\").distinct()\\n\\t\\tres = []\\n\\t\\tfor device in devices:\\n\\t\\t\\tres.append(device.send_message(message))\\n\\n\\t\\treturn res\\n\\n\\nclass WebPushDevice(Device):\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tp256dh = models.CharField(\\n\\t\\tverbose_name=_(\"User public encryption key\"),\\n\\t\\tmax_length=88)\\n\\tauth = models.CharField(\\n\\t\\tverbose_name=_(\"User auth secret\"),\\n\\t\\tmax_length=24)\\n\\tbrowser = models.CharField(\\n\\t\\tverbose_name=_(\"Browser\"), max_length=10,\\n\\t\\tchoices=BROWSER_TYPES, default=BROWSER_TYPES[0][0],\\n\\t\\thelp_text=_(\"Currently only support to Chrome, Firefox, Edge and Opera browsers\")\\n\\t)\\n\\tobjects = WebPushDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WebPush device\")\\n\\n\\t@property\\n\\tdef device_id(self):\\n\\t\\treturn None\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .webpush import webpush_send_message\\n\\n\\t\\treturn webpush_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, browser=self.browser,\\n\\t\\t\\tauth=self.auth, p256dh=self.p256dh, application_id=self.application_id, **kwargs)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "b'from django.conf import settings\\n\\n\\nPUSH_NOTIFICATIONS_SETTINGS = getattr(settings, \"PUSH_NOTIFICATIONS_SETTINGS\", {})\\n\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"CONFIG\", \"push_notifications.conf.LegacyConfig\"\\n)\\n\\n# GCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"GCM_POST_URL\", \"https://android.googleapis.com/gcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_ERROR_TIMEOUT\", None)\\n\\n# FCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"FCM_POST_URL\", \"https://fcm.googleapis.com/fcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_ERROR_TIMEOUT\", None)\\n\\n# APNS\\nif settings.DEBUG:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", True)\\nelse:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_ALTERNATIVE_PORT\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_TOPIC\", None)\\n\\n# WNS\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_PACKAGE_SECURITY_ID\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_SECRET_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\"\\n)\\n\\n# WP (WebPush)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_POST_URL\", {\\n\\t\"CHROME\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"OPERA\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n})\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_PRIVATE_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_CLAIMS\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_ERROR_TIMEOUT\", None)\\n\\n# User model\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"USER_MODEL\", settings.AUTH_USER_MODEL)\\n\\n# Unique registration ID for all devices\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UNIQUE_REG_ID\", False)\\n\\n# API endpoint settings\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UPDATE_ON_DUPLICATE_REG_ID\", False)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "b'from pywebpush import WebPushException, webpush\\n\\nfrom .conf import get_manager\\nfrom .exceptions import WebPushError\\n\\n\\ndef get_subscription_info(application_id, uri, browser, auth, p256dh):\\n\\turl = get_manager().get_wp_post_url(application_id, browser)\\n\\treturn {\\n\\t\\t\"endpoint\": \"{}/{}\".format(url, uri),\\n\\t\\t\"keys\": {\\n\\t\\t\\t\"auth\": auth,\\n\\t\\t\\t\"p256dh\": p256dh,\\n\\t\\t}\\n\\t}\\n\\n\\ndef webpush_send_message(\\n\\turi, message, browser, auth, p256dh, application_id=None, **kwargs\\n):\\n\\tsubscription_info = get_subscription_info(application_id, uri, browser, auth, p256dh)\\n\\n\\ttry:\\n\\t\\tresponse = webpush(\\n\\t\\t\\tsubscription_info=subscription_info,\\n\\t\\t\\tdata=message,\\n\\t\\t\\tvapid_private_key=get_manager().get_wp_private_key(application_id),\\n\\t\\t\\tvapid_claims=get_manager().get_wp_claims(application_id).copy(),\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\t\\tresults = {\"results\": [{}]}\\n\\t\\tif not response.ok:\\n\\t\\t\\tresults[\"results\"][0][\"error\"] = response.content\\n\\t\\t\\tresults[\"results\"][0][\"original_registration_id\"] = response.content\\n\\t\\telse:\\n\\t\\t\\tresults[\"success\"] = 1\\n\\t\\treturn results\\n\\texcept WebPushException as e:\\n\\t\\traise WebPushError(e.message)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "b'\"\"\"\\nWindows Notification Service\\n\\nDocumentation is available on the Windows Dev Center:\\nhttps://msdn.microsoft.com/en-us/windows/uwp/controls-and-patterns/tiles-and-notifications-windows-push-notification-services--wns--overview\\n\"\"\"\\n\\nimport json\\nimport xml.etree.ElementTree as ET\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import HTTPError, Request, urlencode, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import NotificationError\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass WNSError(NotificationError):\\n\\tpass\\n\\n\\nclass WNSAuthenticationError(WNSError):\\n\\tpass\\n\\n\\nclass WNSNotificationResponseError(WNSError):\\n\\tpass\\n\\n\\ndef _wns_authenticate(scope=\"notify.windows.com\", application_id=None):\\n\\t\"\"\"\\n\\tRequests an Access token for WNS communication.\\n\\n\\t:return: dict: {\\'access_token\\': <str>, \\'expires_in\\': <int>, \\'token_type\\': \\'bearer\\'}\\n\\t\"\"\"\\n\\tclient_id = get_manager().get_wns_package_security_id(application_id)\\n\\tclient_secret = get_manager().get_wns_secret_key(application_id)\\n\\tif not client_id:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_PACKAGE_SECURITY_ID\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\tif not client_secret:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_SECRET_KEY\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": \"application/x-www-form-urlencoded\",\\n\\t}\\n\\tparams = {\\n\\t\\t\"grant_type\": \"client_credentials\",\\n\\t\\t\"client_id\": client_id,\\n\\t\\t\"client_secret\": client_secret,\\n\\t\\t\"scope\": scope,\\n\\t}\\n\\tdata = urlencode(params).encode(\"utf-8\")\\n\\n\\trequest = Request(SETTINGS[\"WNS_ACCESS_URL\"], data=data, headers=headers)\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\t# One of your settings is probably jacked up.\\n\\t\\t\\t# https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh868245\\n\\t\\t\\traise WNSAuthenticationError(\"Authentication failed, check your WNS settings.\")\\n\\t\\traise err\\n\\n\\toauth_data = response.read().decode(\"utf-8\")\\n\\ttry:\\n\\t\\toauth_data = json.loads(oauth_data)\\n\\texcept Exception:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Received invalid JSON data from WNS.\")\\n\\n\\taccess_token = oauth_data.get(\"access_token\")\\n\\tif not access_token:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Access token missing from WNS response.\")\\n\\n\\treturn access_token\\n\\n\\ndef _wns_send(uri, data, wns_type=\"wns/toast\", application_id=None):\\n\\t\"\"\"\\n\\tSends a notification data and authentication to WNS.\\n\\n\\t:param uri: str: The device\\'s unique notification URI\\n\\t:param data: dict: The notification data to be sent.\\n\\t:return:\\n\\t\"\"\"\\n\\taccess_token = _wns_authenticate(application_id=application_id)\\n\\n\\tcontent_type = \"text/xml\"\\n\\tif wns_type == \"wns/raw\":\\n\\t\\tcontent_type = \"application/octet-stream\"\\n\\n\\theaders = {\\n\\t\\t# content_type is \"text/xml\" (toast/badge/tile) | \"application/octet-stream\" (raw)\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"Bearer %s\" % (access_token),\\n\\t\\t\"X-WNS-Type\": wns_type,  # wns/toast | wns/badge | wns/tile | wns/raw\\n\\t}\\n\\n\\tif type(data) is str:\\n\\t\\tdata = data.encode(\"utf-8\")\\n\\n\\trequest = Request(uri, data, headers)\\n\\n\\t# A lot of things can happen, let them know which one.\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\tmsg = \"One or more headers were specified incorrectly or conflict with another header.\"\\n\\t\\telif err.code == 401:\\n\\t\\t\\tmsg = \"The cloud service did not present a valid authentication ticket.\"\\n\\t\\telif err.code == 403:\\n\\t\\t\\tmsg = \"The cloud service is not authorized to send a notification to this URI.\"\\n\\t\\telif err.code == 404:\\n\\t\\t\\tmsg = \"The channel URI is not valid or is not recognized by WNS.\"\\n\\t\\telif err.code == 405:\\n\\t\\t\\tmsg = \"Invalid method. Only POST or DELETE is allowed.\"\\n\\t\\telif err.code == 406:\\n\\t\\t\\tmsg = \"The cloud service exceeded its throttle limit\"\\n\\t\\telif err.code == 410:\\n\\t\\t\\tmsg = \"The channel expired.\"\\n\\t\\telif err.code == 413:\\n\\t\\t\\tmsg = \"The notification payload exceeds the 500 byte limit.\"\\n\\t\\telif err.code == 500:\\n\\t\\t\\tmsg = \"An internal failure caused notification delivery to fail.\"\\n\\t\\telif err.code == 503:\\n\\t\\t\\tmsg = \"The server is currently unavailable.\"\\n\\t\\telse:\\n\\t\\t\\traise err\\n\\t\\traise WNSNotificationResponseError(\"HTTP %i: %s\" % (err.code, msg))\\n\\n\\treturn response.read().decode(\"utf-8\")\\n\\n\\ndef _wns_prepare_toast(data, **kwargs):\\n\\t\"\"\"\\n\\tCreates the xml tree for a `toast` notification\\n\\n\\t:param data: dict: The notification data to be converted to an xml tree.\\n\\n\\t{\\n\\t\\t\"text\": [\"Title text\", \"Message Text\", \"Another message!\"],\\n\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t}\\n\\n\\t:return: str\\n\\t\"\"\"\\n\\troot = ET.Element(\"toast\")\\n\\tvisual = ET.SubElement(root, \"visual\")\\n\\tbinding = ET.SubElement(visual, \"binding\")\\n\\tbinding.attrib[\"template\"] = kwargs.pop(\"template\", \"ToastText01\")\\n\\tif \"text\" in data:\\n\\t\\tfor count, item in enumerate(data[\"text\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"text\")\\n\\t\\t\\telem.text = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\tif \"image\" in data:\\n\\t\\tfor count, item in enumerate(data[\"image\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"img\")\\n\\t\\t\\telem.attrib[\"src\"] = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\treturn ET.tostring(root)\\n\\n\\ndef wns_send_message(\\n\\turi, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a notification request to WNS.\\n\\tThere are four notification types that WNS can send: toast, tile, badge and raw.\\n\\tToast, tile, and badge can all be customized to use different\\n\\ttemplates/icons/sounds/launch params/etc.\\n\\tSee docs for more information:\\n\\thttps://msdn.microsoft.com/en-us/library/windows/apps/br212853.aspx\\n\\n\\tThere are multiple ways to input notification data:\\n\\n\\t1. The simplest and least custom notification to send is to just pass a string\\n\\tto `message`. This will create a toast notification with one text element. e.g.:\\n\\t\\t\"This is my notification title\"\\n\\n\\t2. You can also pass a dictionary to `message`: it can only contain one or both\\n\\tkeys: [\"text\", \"image\"]. The value of each key must be a list with the text and\\n\\tsrc respectively. e.g.:\\n\\t\\t{\\n\\t\\t\\t\"text\": [\"text1\", \"text2\"],\\n\\t\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t\\t}\\n\\n\\t3. Passing a dictionary to `xml_data` will create one of three types of\\n\\tnotifications depending on the dictionary data (toast, tile, badge).\\n\\tSee `dict_to_xml_schema` docs for more information on dictionary formatting.\\n\\n\\t4. Passing a value to `raw_data` will create a `raw` notification and send the\\n\\tinput data as is.\\n\\n\\t:param uri: str: The device\\'s unique notification uri.\\n\\t:param message: str|dict: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\t# Create a simple toast notification\\n\\tif message:\\n\\t\\twns_type = \"wns/toast\"\\n\\t\\tif isinstance(message, str):\\n\\t\\t\\tmessage = {\\n\\t\\t\\t\\t\"text\": [message, ],\\n\\t\\t\\t}\\n\\t\\tprepared_data = _wns_prepare_toast(data=message, **kwargs)\\n\\t# Create a toast/tile/badge notification from a dictionary\\n\\telif xml_data:\\n\\t\\txml = dict_to_xml_schema(xml_data)\\n\\t\\twns_type = \"wns/%s\" % xml.tag\\n\\t\\tprepared_data = ET.tostring(xml)\\n\\t# Create a raw notification\\n\\telif raw_data:\\n\\t\\twns_type = \"wns/raw\"\\n\\t\\tprepared_data = raw_data\\n\\telse:\\n\\t\\traise TypeError(\\n\\t\\t\\t\"At least one of the following parameters must be set:\"\\n\\t\\t\\t\"`message`, `xml_data`, `raw_data`\"\\n\\t\\t)\\n\\n\\treturn _wns_send(\\n\\t\\turi=uri, data=prepared_data, wns_type=wns_type, application_id=application_id\\n\\t)\\n\\n\\ndef wns_send_bulk_message(\\n\\turi_list, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tWNS doesn\\'t support bulk notification, so we loop through each uri.\\n\\n\\t:param uri_list: list: A list of uris the notification will be sent to.\\n\\t:param message: str: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\tres = []\\n\\tif uri_list:\\n\\t\\tfor uri in uri_list:\\n\\t\\t\\tr = wns_send_message(\\n\\t\\t\\t\\turi=uri, message=message, xml_data=xml_data,\\n\\t\\t\\t\\traw_data=raw_data, application_id=application_id, **kwargs\\n\\t\\t\\t)\\n\\t\\t\\tres.append(r)\\n\\treturn res\\n\\n\\ndef dict_to_xml_schema(data):\\n\\t\"\"\"\\n\\tInput a dictionary to be converted to xml. There should be only one key at\\n\\tthe top level. The value must be a dict with (required) `children` key and\\n\\t(optional) `attrs` key. This will be called the `sub-element dictionary`.\\n\\n\\tThe `attrs` value must be a dictionary; each value will be added to the\\n\\telement\\'s xml tag as attributes. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\n\\twould result in:\\n\\t\\t<example key1=\"value1\" key2=\"value2\"></example>\\n\\n\\tIf the value is a dict it must contain one or more keys which will be used\\n\\tas the sub-element names. Each sub-element must have a value of a sub-element\\n\\tdictionary(see above) or a list of sub-element dictionaries.\\n\\tIf the value is not a dict, it will be the value of the element.\\n\\tIf the value is a list, multiple elements of the same tag will be created\\n\\tfrom each sub-element dict in the list.\\n\\n\\t:param data: dict: Used to create an XML tree. e.g.:\\n\\t\\texample_data = {\\n\\t\\t\\t\"toast\": {\\n\\t\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\\t\"launch\": \"param\",\\n\\t\\t\\t\\t\\t\"duration\": \"short\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\"visual\": {\\n\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\"binding\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"template\": \"ToastText01\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"text\": [\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"1\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text1\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"2\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text2\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor key, value in data.items():\\n\\t\\troot = _add_element_attrs(ET.Element(key), value.get(\"attrs\", {}))\\n\\t\\tchildren = value.get(\"children\", None)\\n\\t\\tif isinstance(children, dict):\\n\\t\\t\\t_add_sub_elements_from_dict(root, children)\\n\\t\\treturn root\\n\\n\\ndef _add_sub_elements_from_dict(parent, sub_dict):\\n\\t\"\"\"\\n\\tAdd SubElements to the parent element.\\n\\n\\t:param parent: ElementTree.Element: The parent element for the newly created SubElement.\\n\\t:param sub_dict: dict: Used to create a new SubElement. See `dict_to_xml_schema`\\n\\tmethod docstring for more information. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\t\"\"\"\\n\\tfor key, value in sub_dict.items():\\n\\t\\tif isinstance(value, list):\\n\\t\\t\\tfor repeated_element in value:\\n\\t\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t\\t_add_element_attrs(sub_element, repeated_element.get(\"attrs\", {}))\\n\\t\\t\\t\\tchildren = repeated_element.get(\"children\", None)\\n\\t\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\t\\tsub_element.text = children\\n\\t\\telse:\\n\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t_add_element_attrs(sub_element, value.get(\"attrs\", {}))\\n\\t\\t\\tchildren = value.get(\"children\", None)\\n\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\tsub_element.text = children\\n\\n\\ndef _add_element_attrs(elem, attrs):\\n\\t\"\"\"\\n\\tAdd attributes to the given element.\\n\\n\\t:param elem: ElementTree.Element: The element the attributes are being added to.\\n\\t:param attrs: dict: A dictionary of attributes. e.g.:\\n\\t\\t{\"attribute1\": \"value\", \"attribute2\": \"another\"}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor attr, value in attrs.items():\\n\\t\\telem.attrib[attr] = value\\n\\treturn elem\\n'"}]}, "get_python_source": {"line": 37, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'try:\\n    # Python 3.8+\\n    import importlib.metadata as importlib_metadata\\nexcept ImportError:\\n    # <Python 3.7 and lower\\n    import importlib_metadata\\n\\n__version__ = importlib_metadata.version(\"django-push-notifications\")\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'from django.apps import apps\\nfrom django.contrib import admin, messages\\nfrom django.utils.encoding import force_str\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .exceptions import APNSServerError, GCMError, WebPushError\\nfrom .models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nUser = apps.get_model(*SETTINGS[\"USER_MODEL\"].split(\".\"))\\n\\n\\nclass DeviceAdmin(admin.ModelAdmin):\\n\\tlist_display = (\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\",)\\n\\tactions = (\"send_message\", \"send_bulk_message\", \"enable\", \"disable\")\\n\\traw_id_fields = (\"user\",)\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"device_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"device_id\")\\n\\n\\tdef send_messages(self, request, queryset, bulk=False):\\n\\t\\t\"\"\"\\n\\t\\tProvides error handling for DeviceAdmin send_message and send_bulk_message methods.\\n\\t\\t\"\"\"\\n\\t\\tret = []\\n\\t\\terrors = []\\n\\t\\tr = \"\"\\n\\n\\t\\tfor device in queryset:\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tif bulk:\\n\\t\\t\\t\\t\\tr = queryset.send_message(\"Test bulk notification\")\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = device.send_message(\"Test single notification\")\\n\\t\\t\\t\\tif r:\\n\\t\\t\\t\\t\\tret.append(r)\\n\\t\\t\\texcept GCMError as e:\\n\\t\\t\\t\\terrors.append(str(e))\\n\\t\\t\\texcept APNSServerError as e:\\n\\t\\t\\t\\terrors.append(e.status)\\n\\t\\t\\texcept WebPushError as e:\\n\\t\\t\\t\\terrors.append(force_str(e))\\n\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\t# Because NotRegistered and InvalidRegistration do not throw GCMError\\n\\t\\t# catch them here to display error msg.\\n\\t\\tif not bulk:\\n\\t\\t\\tfor r in ret:\\n\\t\\t\\t\\tif \"error\" in r[\"results\"][0]:\\n\\t\\t\\t\\t\\terrors.append(r[\"results\"][0][\"error\"])\\n\\t\\telse:\\n\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\terrors = [r[\"error\"] for r in ret[0][0][\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\terrors = errors + [r[\"error\"] for r in entry[\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept IndexError:\\n\\t\\t\\t\\t\\tpass\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\tif value.lower() != \"success\":\\n\\t\\t\\t\\t\\t\\terrors.append(value)\\n\\t\\tif errors:\\n\\t\\t\\tself.message_user(\\n\\t\\t\\t\\trequest, _(\"Some messages could not be processed: %r\" % (\", \".join(errors))),\\n\\t\\t\\t\\tlevel=messages.ERROR\\n\\t\\t\\t)\\n\\t\\tif ret:\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\t# When the queryset exceeds the max_recipients value, the\\n\\t\\t\\t\\t# send_message method returns a list of dicts, one per chunk\\n\\t\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\t\\tsuccess = ret[0][0][\"success\"]\\n\\t\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\t\\tsuccess = 0\\n\\t\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\t\\tsuccess = success + entry[\"success\"]\\n\\t\\t\\t\\t\\tif success == 0:\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\t\\tsuccess = []\\n\\t\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\t\\tif value.lower() == \"success\":\\n\\t\\t\\t\\t\\t\\t\\tsuccess.append(key)\\n\\n\\t\\t\\telif len(errors) == len(ret):\\n\\t\\t\\t\\treturn\\n\\t\\t\\tif errors:\\n\\t\\t\\t\\tmsg = _(\"Some messages were sent: %s\" % (ret))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = _(\"All messages were sent: %s\" % (ret))\\n\\t\\t\\tself.message_user(request, msg)\\n\\n\\tdef send_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset)\\n\\n\\tsend_message.short_description = _(\"Send test message\")\\n\\n\\tdef send_bulk_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset, True)\\n\\n\\tsend_bulk_message.short_description = _(\"Send test message in bulk\")\\n\\n\\tdef enable(self, request, queryset):\\n\\t\\tqueryset.update(active=True)\\n\\n\\tenable.short_description = _(\"Enable selected devices\")\\n\\n\\tdef disable(self, request, queryset):\\n\\t\\tqueryset.update(active=False)\\n\\n\\tdisable.short_description = _(\"Disable selected devices\")\\n\\n\\nclass GCMDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\\n\\t\\t\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\", \"cloud_message_type\"\\n\\t)\\n\\tlist_filter = (\"active\", \"cloud_message_type\")\\n\\n\\nclass WebPushDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\"__str__\", \"browser\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\", \"browser\")\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"registration_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"registration_id\")\\n\\n\\nadmin.site.register(APNSDevice, DeviceAdmin)\\nadmin.site.register(GCMDevice, GCMDeviceAdmin)\\nadmin.site.register(WNSDevice, DeviceAdmin)\\nadmin.site.register(WebPushDevice, WebPushDeviceAdmin)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "''"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'from rest_framework import permissions, status\\nfrom rest_framework.fields import IntegerField\\nfrom rest_framework.response import Response\\nfrom rest_framework.serializers import ModelSerializer, Serializer, ValidationError\\nfrom rest_framework.viewsets import ModelViewSet\\n\\nfrom ..fields import UNSIGNED_64BIT_INT_MAX_VALUE, hex_re\\nfrom ..models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\n# Fields\\nclass HexIntegerField(IntegerField):\\n\\t\"\"\"\\n\\tStore an integer represented as a hex string of form \"0x01\".\\n\\t\"\"\"\\n\\n\\tdef to_internal_value(self, data):\\n\\t\\t# validate hex string and convert it to the unsigned\\n\\t\\t# integer representation for internal use\\n\\t\\ttry:\\n\\t\\t\\tdata = int(data, 16) if type(data) != int else data\\n\\t\\texcept ValueError:\\n\\t\\t\\traise ValidationError(\"Device ID is not a valid hex number\")\\n\\t\\treturn super(HexIntegerField, self).to_internal_value(data)\\n\\n\\tdef to_representation(self, value):\\n\\t\\treturn value\\n\\n\\n# Serializers\\nclass DeviceSerializerMixin(ModelSerializer):\\n\\tclass Meta:\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"application_id\", \"registration_id\", \"device_id\",\\n\\t\\t\\t\"active\", \"date_created\"\\n\\t\\t)\\n\\t\\tread_only_fields = (\"date_created\",)\\n\\n\\t\\t# See https://github.com/tomchristie/django-rest-framework/issues/1101\\n\\t\\textra_kwargs = {\"active\": {\"default\": True}}\\n\\n\\nclass APNSDeviceSerializer(ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = APNSDevice\\n\\n\\tdef validate_registration_id(self, value):\\n\\t\\t# iOS device tokens are 256-bit hexadecimal (64 characters). In 2016 Apple is increasing\\n\\t\\t# iOS device tokens to 100 bytes hexadecimal (200 characters).\\n\\n\\t\\tif hex_re.match(value) is None or len(value) not in (64, 200):\\n\\t\\t\\traise ValidationError(\"Registration ID (device token) is invalid\")\\n\\n\\t\\treturn value\\n\\n\\nclass UniqueRegistrationSerializerMixin(Serializer):\\n\\tdef validate(self, attrs):\\n\\t\\tdevices = None\\n\\t\\tprimary_key = None\\n\\t\\trequest_method = None\\n\\n\\t\\tif self.initial_data.get(\"registration_id\", None):\\n\\t\\t\\tif self.instance:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telse:\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\t\\telse:\\n\\t\\t\\tif self.context[\"request\"].method in [\"PUT\", \"PATCH\"]:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telif self.context[\"request\"].method == \"POST\":\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\n\\t\\tDevice = self.Meta.model\\n\\t\\tif request_method == \"update\":\\n\\t\\t\\treg_id = attrs.get(\"registration_id\", self.instance.registration_id)\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=reg_id) \\\\\\n\\t\\t\\t\\t.exclude(id=primary_key)\\n\\t\\telif request_method == \"create\":\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=attrs[\"registration_id\"])\\n\\n\\t\\tif devices:\\n\\t\\t\\traise ValidationError({\"registration_id\": \"This field must be unique.\"})\\n\\t\\treturn attrs\\n\\n\\nclass GCMDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tdevice_id = HexIntegerField(\\n\\t\\thelp_text=\"ANDROID_ID / TelephonyManager.getDeviceId() (e.g: 0x01)\",\\n\\t\\tstyle={\"input_type\": \"text\"},\\n\\t\\trequired=False,\\n\\t\\tallow_null=True\\n\\t)\\n\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = GCMDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"device_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"cloud_message_type\", \"application_id\",\\n\\t\\t)\\n\\t\\textra_kwargs = {\"id\": {\"read_only\": False, \"required\": False}}\\n\\n\\tdef validate_device_id(self, value):\\n\\t\\t# device ids are 64 bit unsigned values\\n\\t\\tif value > UNSIGNED_64BIT_INT_MAX_VALUE:\\n\\t\\t\\traise ValidationError(\"Device ID is out of range\")\\n\\t\\treturn value\\n\\n\\nclass WNSDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WNSDevice\\n\\n\\nclass WebPushDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WebPushDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"p256dh\", \"auth\", \"browser\", \"application_id\",\\n\\t\\t)\\n\\n\\n# Permissions\\nclass IsOwner(permissions.BasePermission):\\n\\tdef has_object_permission(self, request, view, obj):\\n\\t\\t# must be the owner to view the object\\n\\t\\treturn obj.user == request.user\\n\\n\\n# Mixins\\nclass DeviceViewSetMixin:\\n\\tlookup_field = \"registration_id\"\\n\\n\\tdef create(self, request, *args, **kwargs):\\n\\t\\tserializer = None\\n\\t\\tis_update = False\\n\\t\\tif SETTINGS.get(\"UPDATE_ON_DUPLICATE_REG_ID\") and self.lookup_field in request.data:\\n\\t\\t\\tinstance = self.queryset.model.objects.filter(\\n\\t\\t\\t\\tregistration_id=request.data[self.lookup_field]\\n\\t\\t\\t).first()\\n\\t\\t\\tif instance:\\n\\t\\t\\t\\tserializer = self.get_serializer(instance, data=request.data)\\n\\t\\t\\t\\tis_update = True\\n\\t\\tif not serializer:\\n\\t\\t\\tserializer = self.get_serializer(data=request.data)\\n\\n\\t\\tserializer.is_valid(raise_exception=True)\\n\\t\\tif is_update:\\n\\t\\t\\tself.perform_update(serializer)\\n\\t\\t\\treturn Response(serializer.data)\\n\\t\\telse:\\n\\t\\t\\tself.perform_create(serializer)\\n\\t\\t\\theaders = self.get_success_headers(serializer.data)\\n\\t\\t\\treturn Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\\n\\n\\tdef perform_create(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_create(serializer)\\n\\n\\tdef perform_update(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_update(serializer)\\n\\n\\nclass AuthorizedMixin:\\n\\tpermission_classes = (permissions.IsAuthenticated, IsOwner)\\n\\n\\tdef get_queryset(self):\\n\\t\\t# filter all devices to only those belonging to the current user\\n\\t\\treturn self.queryset.filter(user=self.request.user)\\n\\n\\n# ViewSets\\nclass APNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = APNSDevice.objects.all()\\n\\tserializer_class = APNSDeviceSerializer\\n\\n\\nclass APNSDeviceAuthorizedViewSet(AuthorizedMixin, APNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass GCMDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = GCMDevice.objects.all()\\n\\tserializer_class = GCMDeviceSerializer\\n\\n\\nclass GCMDeviceAuthorizedViewSet(AuthorizedMixin, GCMDeviceViewSet):\\n\\tpass\\n\\n\\nclass WNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WNSDevice.objects.all()\\n\\tserializer_class = WNSDeviceSerializer\\n\\n\\nclass WNSDeviceAuthorizedViewSet(AuthorizedMixin, WNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass WebPushDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WebPushDevice.objects.all()\\n\\tserializer_class = WebPushDeviceSerializer\\n\\n\\nclass WebPushDeviceAuthorizedViewSet(AuthorizedMixin, WebPushDeviceViewSet):\\n\\tpass\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'\"\"\"\\nApple Push Notification Service\\nDocumentation is available on the iOS Developer Library:\\nhttps://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html\\n\"\"\"\\n\\nimport time\\n\\nfrom apns2 import client as apns2_client\\nfrom apns2 import credentials as apns2_credentials\\nfrom apns2 import errors as apns2_errors\\nfrom apns2 import payload as apns2_payload\\n\\nfrom . import models\\nfrom .conf import get_manager\\nfrom .exceptions import APNSError, APNSUnsupportedPriority, APNSServerError\\n\\n\\ndef _apns_create_socket(creds=None, application_id=None):\\n\\tif creds is None:\\n\\t\\tif not get_manager().has_auth_token_creds(application_id):\\n\\t\\t\\tcert = get_manager().get_apns_certificate(application_id)\\n\\t\\t\\tcreds = apns2_credentials.CertificateCredentials(cert)\\n\\t\\telse:\\n\\t\\t\\tkeyPath, keyId, teamId = get_manager().get_apns_auth_creds(application_id)\\n\\t\\t\\t# No use getting a lifetime because this credential is\\n\\t\\t\\t# ephemeral, but if you\\'re looking at this to see how to\\n\\t\\t\\t# create a credential, you could also pass the lifetime and\\n\\t\\t\\t# algorithm. Neither of those settings are exposed in the\\n\\t\\t\\t# settings API at the moment.\\n\\t\\t\\tcreds = creds or apns2_credentials.TokenCredentials(keyPath, keyId, teamId)\\n\\tclient = apns2_client.APNsClient(\\n\\t\\tcreds,\\n\\t\\tuse_sandbox=get_manager().get_apns_use_sandbox(application_id),\\n\\t\\tuse_alternative_port=get_manager().get_apns_use_alternative_port(application_id)\\n\\t)\\n\\tclient.connect()\\n\\treturn client\\n\\n\\ndef _apns_prepare(\\n\\ttoken, alert, application_id=None, badge=None, sound=None, category=None,\\n\\tcontent_available=False, action_loc_key=None, loc_key=None, loc_args=[],\\n\\textra={}, mutable_content=False, thread_id=None, url_args=None):\\n\\t\\tif action_loc_key or loc_key or loc_args:\\n\\t\\t\\tapns2_alert = apns2_payload.PayloadAlert(\\n\\t\\t\\t\\tbody=alert if alert else {}, body_localized_key=loc_key,\\n\\t\\t\\t\\tbody_localized_args=loc_args, action_localized_key=action_loc_key)\\n\\t\\telse:\\n\\t\\t\\tapns2_alert = alert\\n\\n\\t\\tif callable(badge):\\n\\t\\t\\tbadge = badge(token)\\n\\n\\t\\treturn apns2_payload.Payload(\\n\\t\\t\\talert=apns2_alert, badge=badge, sound=sound, category=category,\\n\\t\\t\\turl_args=url_args, custom=extra, thread_id=thread_id,\\n\\t\\t\\tcontent_available=content_available, mutable_content=mutable_content)\\n\\n\\ndef _apns_send(\\n\\tregistration_id, alert, batch=False, application_id=None, creds=None, **kwargs\\n):\\n\\tclient = _apns_create_socket(creds=creds, application_id=application_id)\\n\\n\\tnotification_kwargs = {}\\n\\n\\t# if expiration isn\"t specified use 1 month from now\\n\\tnotification_kwargs[\"expiration\"] = kwargs.pop(\"expiration\", None)\\n\\tif not notification_kwargs[\"expiration\"]:\\n\\t\\tnotification_kwargs[\"expiration\"] = int(time.time()) + 2592000\\n\\n\\tpriority = kwargs.pop(\"priority\", None)\\n\\tif priority:\\n\\t\\ttry:\\n\\t\\t\\tnotification_kwargs[\"priority\"] = apns2_client.NotificationPriority(str(priority))\\n\\t\\texcept ValueError:\\n\\t\\t\\traise APNSUnsupportedPriority(\"Unsupported priority %d\" % (priority))\\n\\n\\tnotification_kwargs[\"collapse_id\"] = kwargs.pop(\"collapse_id\", None)\\n\\n\\tif batch:\\n\\t\\tdata = [apns2_client.Notification(\\n\\t\\t\\ttoken=rid, payload=_apns_prepare(rid, alert, **kwargs)) for rid in registration_id]\\n\\t\\t# returns a dictionary mapping each token to its result. That\\n\\t\\t# result is either \"Success\" or the reason for the failure.\\n\\t\\treturn client.send_notification_batch(\\n\\t\\t\\tdata, get_manager().get_apns_topic(application_id=application_id),\\n\\t\\t\\t**notification_kwargs\\n\\t\\t)\\n\\n\\tdata = _apns_prepare(registration_id, alert, **kwargs)\\n\\tclient.send_notification(\\n\\t\\tregistration_id, data,\\n\\t\\tget_manager().get_apns_topic(application_id=application_id),\\n\\t\\t**notification_kwargs\\n\\t)\\n\\n\\ndef apns_send_message(registration_id, alert, application_id=None, creds=None, **kwargs):\\n\\t\"\"\"\\n\\tSends an APNS notification to a single registration_id.\\n\\tThis will send the notification as form data.\\n\\tIf sending multiple notifications, it is more efficient to use\\n\\tapns_send_bulk_message()\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\ttry:\\n\\t\\t_apns_send(\\n\\t\\t\\tregistration_id, alert, application_id=application_id,\\n\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t)\\n\\texcept apns2_errors.APNsException as apns2_exception:\\n\\t\\tif isinstance(apns2_exception, apns2_errors.Unregistered):\\n\\t\\t\\tdevice = models.APNSDevice.objects.get(registration_id=registration_id)\\n\\t\\t\\tdevice.active = False\\n\\t\\t\\tdevice.save()\\n\\n\\t\\traise APNSServerError(status=apns2_exception.__class__.__name__)\\n\\n\\ndef apns_send_bulk_message(\\n\\tregistration_ids, alert, application_id=None, creds=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends an APNS notification to one or more registration_ids.\\n\\tThe registration_ids argument needs to be a list.\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\tresults = _apns_send(\\n\\t\\tregistration_ids, alert, batch=True, application_id=application_id,\\n\\t\\tcreds=creds, **kwargs\\n\\t)\\n\\tinactive_tokens = [token for token, result in results.items() if result == \"Unregistered\"]\\n\\tmodels.APNSDevice.objects.filter(registration_id__in=inactive_tokens).update(active=False)\\n\\treturn results\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'# flake8:noqa\\nfrom urllib.error import HTTPError\\nfrom urllib.parse import urlencode\\nfrom urllib.request import Request, urlopen\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'from django.utils.module_loading import import_string\\n\\nfrom .app import AppConfig  # noqa: F401\\nfrom .appmodel import AppModelConfig  # noqa: F401\\nfrom .legacy import LegacyConfig  # noqa: F401\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS  # noqa: I001\\n\\n\\nmanager = None\\n\\n\\ndef get_manager(reload=False):\\n\\tglobal manager\\n\\n\\tif not manager or reload is True:\\n\\t\\tmanager = import_string(SETTINGS[\"CONFIG\"])()\\n\\n\\treturn manager\\n\\n\\n# implementing get_manager as a function allows tests to reload settings\\nget_manager()\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig, check_apns_certificate\\n\\n\\nSETTING_MISMATCH = (\\n\\t\"Application \\'{application_id}\\' ({platform}) does not support the setting \\'{setting}\\'.\"\\n)\\n\\n# code can be \"missing\" or \"invalid\"\\nBAD_PLATFORM = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"PLATFORM\"] is {code}. \\'\\n\\t\"Must be one of: {platforms}.\"\\n)\\n\\nUNKNOWN_PLATFORM = (\\n\\t\"Unknown Platform: {platform}. Must be one of: {platforms}.\"\\n)\\n\\nMISSING_SETTING = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"{setting}\"] is missing.\\'\\n)\\n\\nPLATFORMS = [\\n\\t\"APNS\",\\n\\t\"FCM\",\\n\\t\"GCM\",\\n\\t\"WNS\",\\n\\t\"WP\",\\n]\\n\\n# Settings that all applications must have\\nREQUIRED_SETTINGS = [\\n\\t\"PLATFORM\",\\n]\\n\\n# Settings that an application may have to enable optional features\\n# these settings are stubs for registry support and have no effect on the operation\\n# of the application at this time.\\nOPTIONAL_SETTINGS = [\\n\\t\"APPLICATION_GROUP\", \"APPLICATION_SECRET\"\\n]\\n\\n# Since we can have an auth key, combined with a auth key id and team id *or*\\n# a certificate, we make these all optional, and then make sure we have one or\\n# the other (group) of settings.\\nAPNS_SETTINGS_CERT_CREDS = \"CERTIFICATE\"\\n\\n# Subkeys for APNS_SETTINGS_AUTH_CREDS\\nAPNS_AUTH_CREDS_REQUIRED = [\"AUTH_KEY_PATH\", \"AUTH_KEY_ID\", \"TEAM_ID\"]\\nAPNS_AUTH_CREDS_OPTIONAL = [\"CERTIFICATE\", \"ENCRYPTION_ALGORITHM\", \"TOKEN_LIFETIME\"]\\n\\nAPNS_OPTIONAL_SETTINGS = [\\n\\t\"USE_SANDBOX\", \"USE_ALTERNATIVE_PORT\", \"TOPIC\"\\n]\\n\\nFCM_REQUIRED_SETTINGS = GCM_REQUIRED_SETTINGS = [\"API_KEY\"]\\nFCM_OPTIONAL_SETTINGS = GCM_OPTIONAL_SETTINGS = [\\n\\t\"POST_URL\", \"MAX_RECIPIENTS\", \"ERROR_TIMEOUT\"\\n]\\n\\nWNS_REQUIRED_SETTINGS = [\"PACKAGE_SECURITY_ID\", \"SECRET_KEY\"]\\nWNS_OPTIONAL_SETTINGS = [\"WNS_ACCESS_URL\"]\\n\\nWP_REQUIRED_SETTINGS = [\"PRIVATE_KEY\", \"CLAIMS\"]\\nWP_OPTIONAL_SETTINGS = [\"ERROR_TIMEOUT\", \"POST_URL\"]\\n\\n\\nclass AppConfig(BaseConfig):\\n\\t\"\"\"\\n\\tSupports any number of push notification enabled applications.\\n\\t\"\"\"\\n\\n\\tdef __init__(self, settings=None):\\n\\t\\t# supports overriding the settings to be loaded. Will load from ..settings by default.\\n\\t\\tself._settings = settings or SETTINGS\\n\\n\\t\\t# initialize APPLICATIONS to an empty collection\\n\\t\\tself._settings.setdefault(\"APPLICATIONS\", {})\\n\\n\\t\\t# validate application configurations\\n\\t\\tself._validate_applications(self._settings[\"APPLICATIONS\"])\\n\\n\\tdef _validate_applications(self, apps):\\n\\t\\t\"\"\"Validate the application collection\"\"\"\\n\\t\\tfor application_id, application_config in apps.items():\\n\\t\\t\\tself._validate_config(application_id, application_config)\\n\\n\\t\\t\\tapplication_config[\"APPLICATION_ID\"] = application_id\\n\\n\\tdef _validate_config(self, application_id, application_config):\\n\\t\\tplatform = application_config.get(\"PLATFORM\", None)\\n\\n\\t\\t# platform is not present\\n\\t\\tif platform is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"required\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# platform is not a valid choice from PLATFORMS\\n\\t\\tif platform not in PLATFORMS:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"invalid\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\tvalidate_fn = \"_validate_{platform}_config\".format(platform=platform).lower()\\n\\n\\t\\tif hasattr(self, validate_fn):\\n\\t\\t\\tgetattr(self, validate_fn)(application_id, application_config)\\n\\t\\telse:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tUNKNOWN_PLATFORM.format(\\n\\t\\t\\t\\t\\tplatform=platform,\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\tdef _validate_apns_config(self, application_id, application_config):\\n\\t\\tallowed = REQUIRED_SETTINGS + OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\tAPNS_OPTIONAL_SETTINGS\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\t# We have two sets of settings, certificate and JWT auth key.\\n\\t\\t# Auth Key requires 3 values, so if that is set, that will take\\n\\t\\t# precedence. If None are set, we will throw an error.\\n\\t\\thas_cert_creds = APNS_SETTINGS_CERT_CREDS in \\\\\\n\\t\\t\\tapplication_config.keys()\\n\\t\\tself.has_token_creds = True\\n\\t\\tfor token_setting in APNS_AUTH_CREDS_REQUIRED:\\n\\t\\t\\tif token_setting not in application_config.keys():\\n\\t\\t\\t\\tself.has_token_creds = False\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif not has_cert_creds and not self.has_token_creds:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tsetting=(APNS_SETTINGS_CERT_CREDS, APNS_AUTH_CREDS_REQUIRED)))\\n\\t\\tcert_path = None\\n\\t\\tif has_cert_creds:\\n\\t\\t\\tcert_path = \"CERTIFICATE\"\\n\\t\\telif self.has_token_creds:\\n\\t\\t\\tcert_path = \"AUTH_KEY_PATH\"\\n\\t\\t\\tallowed_tokens = APNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\t\\tAPNS_OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\t\\tREQUIRED_SETTINGS\\n\\t\\t\\tself._validate_allowed_settings(application_id, application_config, allowed_tokens)\\n\\t\\t\\tself._validate_required_settings(\\n\\t\\t\\t\\tapplication_id, application_config, APNS_AUTH_CREDS_REQUIRED\\n\\t\\t\\t)\\n\\t\\tself._validate_apns_certificate(application_config[cert_path])\\n\\n\\t\\t# determine/set optional values\\n\\t\\tapplication_config.setdefault(\"USE_SANDBOX\", False)\\n\\t\\tapplication_config.setdefault(\"USE_ALTERNATIVE_PORT\", False)\\n\\t\\tapplication_config.setdefault(\"TOPIC\", None)\\n\\n\\tdef _validate_apns_certificate(self, certfile):\\n\\t\\t\"\"\"Validate the APNS certificate at startup.\"\"\"\\n\\n\\t\\ttry:\\n\\t\\t\\twith open(certfile, \"r\") as f:\\n\\t\\t\\t\\tcontent = f.read()\\n\\t\\t\\t\\tcheck_apns_certificate(content)\\n\\t\\texcept Exception as e:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"The APNS certificate file at {!r} is not readable: {}\".format(certfile, e)\\n\\t\\t\\t)\\n\\n\\tdef _validate_fcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + FCM_REQUIRED_SETTINGS + FCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, FCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://fcm.googleapis.com/fcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_gcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + GCM_REQUIRED_SETTINGS + GCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, GCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://android.googleapis.com/gcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_wns_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WNS_REQUIRED_SETTINGS + WNS_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WNS_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\")\\n\\n\\tdef _validate_wp_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WP_REQUIRED_SETTINGS + WP_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WP_REQUIRED_SETTINGS\\n\\t\\t)\\n\\t\\tapplication_config.setdefault(\"POST_URL\", {\\n\\t\\t\\t\"CHROME\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"OPERA\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n\\t\\t\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\\t})\\n\\n\\tdef _validate_allowed_settings(self, application_id, application_config, allowed_settings):\\n\\t\\t\"\"\"Confirm only allowed settings are present.\"\"\"\\n\\n\\t\\tfor setting_key in application_config.keys():\\n\\t\\t\\tif setting_key not in allowed_settings:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"Platform {}, app {} does not support the setting: {}.\".format(\\n\\t\\t\\t\\t\\t\\tapplication_config[\"PLATFORM\"], application_id, setting_key\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\n\\tdef _validate_required_settings(\\n\\t\\tself, application_id, application_config, required_settings,\\n\\t\\tshould_throw=True\\n\\t):\\n\\t\\t\"\"\"All required keys must be present\"\"\"\\n\\n\\t\\tfor setting_key in required_settings:\\n\\t\\t\\tif setting_key not in application_config.keys():\\n\\t\\t\\t\\tif should_throw:\\n\\t\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\t\\t\\tapplication_id=application_id, setting=setting_key\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tdef _get_application_settings(self, application_id, platform, settings_key):\\n\\t\\t\"\"\"\\n\\t\\tWalks through PUSH_NOTIFICATIONS_SETTINGS to find the correct setting value\\n\\t\\tor raises ImproperlyConfigured.\\n\\t\\t\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tconf_cls = \"push_notifications.conf.AppConfig\"\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"{} requires the application_id be specified at all times.\".format(conf_cls)\\n\\t\\t\\t)\\n\\n\\t\\t# verify that the application config exists\\n\\t\\tapp_config = self._settings.get(\"APPLICATIONS\").get(application_id, None)\\n\\t\\tif app_config is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"No application configured with application_id: {}.\".format(application_id)\\n\\t\\t\\t)\\n\\n\\t\\t# fetch a setting for the incorrect type of platform\\n\\t\\tif app_config.get(\"PLATFORM\") != platform:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tSETTING_MISMATCH.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tplatform=app_config.get(\"PLATFORM\"),\\n\\t\\t\\t\\t\\tsetting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# finally, try to fetch the setting\\n\\t\\tif settings_key not in app_config:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id, setting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\treturn app_config.get(settings_key)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\treturn self.has_token_creds\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"GCM\", \"API_KEY\")\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"FCM\", \"API_KEY\")\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"POST_URL\")\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"ERROR_TIMEOUT\")\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"MAX_RECIPIENTS\")\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(application_id, \"APNS\", \"CERTIFICATE\")\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn \\\\\\n\\t\\t(self._get_apns_auth_key_path(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key_path(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_PATH\")\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_ID\")\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TEAM_ID\")\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_SANDBOX\")\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_ALTERNATIVE_PORT\")\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TOPIC\")\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"PACKAGE_SECURITY_ID\")\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"SECRET_KEY\")\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"POST_URL\")[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"PRIVATE_KEY\")\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"CLAIMS\")\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'from .base import BaseConfig\\n\\n\\nclass AppModelConfig(BaseConfig):\\n\\t\"\"\"Future home of the Application Model conf adapter\\n\\n\\tSupports multiple applications in the database.\\n\\t\"\"\"\\n\\n\\tpass\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\n\\nclass BaseConfig:\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_applications(self):\\n\\t\\t\"\"\"Returns a collection containing the configured applications.\"\"\"\\n\\n\\t\\traise NotImplementedError\\n\\n\\n# This works for both the certificate and the auth key (since that\\'s just\\n# a certificate).\\ndef check_apns_certificate(ss):\\n\\tmode = \"start\"\\n\\tfor s in ss.split(\"\\\\n\"):\\n\\t\\tif mode == \"start\":\\n\\t\\t\\tif \"BEGIN RSA PRIVATE KEY\" in s or \"BEGIN PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"key\"\\n\\t\\telif mode == \"key\":\\n\\t\\t\\tif \"END RSA PRIVATE KEY\" in s or \"END PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"end\"\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif s.startswith(\"Proc-Type\") and \"ENCRYPTED\" in s:\\n\\t\\t\\t\\traise ImproperlyConfigured(\"Encrypted APNS private keys are not supported\")\\n\\n\\tif mode != \"end\":\\n\\t\\traise ImproperlyConfigured(\"The APNS certificate doesn\\'t contain a private key\")\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig\\n\\n\\n__all__ = [\\n\\t\"LegacyConfig\"\\n]\\n\\n\\nclass empty:\\n\\tpass\\n\\n\\nclass LegacyConfig(BaseConfig):\\n\\n\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\n\\tdef _get_application_settings(self, application_id, settings_key, error_message):\\n\\t\\t\"\"\"Legacy behaviour\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tvalue = SETTINGS.get(settings_key, empty)\\n\\t\\t\\tif value is empty:\\n\\t\\t\\t\\traise ImproperlyConfigured(error_message)\\n\\t\\t\\treturn value\\n\\t\\telse:\\n\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\"LegacySettings does not support application_id. To enable \"\\n\\t\\t\\t\\t\"multiple application support, use push_notifications.conf.AppSettings.\"\\n\\t\\t\\t)\\n\\t\\t\\traise ImproperlyConfigured(msg)\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"GCM_API_KEY\"] to send messages through GCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"GCM_API_KEY\", msg)\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"FCM_API_KEY\"] to send messages through FCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"FCM_API_KEY\", msg)\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_POST_URL\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_ERROR_TIMEOUT\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_MAX_RECIPIENTS\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\ttry:\\n\\t\\t\\tself._get_apns_auth_key(application_id)\\n\\t\\t\\tself._get_apns_auth_key_id(application_id)\\n\\t\\t\\tself._get_apns_team_id(application_id)\\n\\t\\texcept ImproperlyConfigured:\\n\\t\\t\\treturn False\\n\\n\\t\\treturn True\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(\\n\\t\\t\\tapplication_id, \"APNS_CERTIFICATE\",\\n\\t\\t\\t\"You need to setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\t)\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\traise ImproperlyConfigured(msg)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn (\\n\\t\\t\\tself._get_apns_auth_key(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_PATH\", self.msg)\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TEAM_ID\", self.msg)\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_ID\", self.msg)\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_USE_SANDBOX\", self.msg)\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn\\n\\t\\tself._get_application_settings(application_id, \"APNS_USE_ALTERNATIVE_PORT\", self.msg)\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TOPIC\", self.msg)\\n\\n\\tdef get_apns_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_HOST\", self.msg)\\n\\n\\tdef get_apns_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_PORT\", self.msg)\\n\\n\\tdef get_apns_feedback_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_HOST\", self.msg)\\n\\n\\tdef get_apns_feedback_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_PORT\", self.msg)\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_PACKAGE_SECURITY_ID\", self.msg)\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_SECRET_KEY\", msg)\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_POST_URL\", msg)[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_PRIVATE_KEY\", msg)\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_CLAIMS\", msg)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'class NotificationError(Exception):\\n\\tpass\\n\\n\\n# APNS\\nclass APNSError(NotificationError):\\n\\tpass\\n\\n\\nclass APNSUnsupportedPriority(APNSError):\\n\\tpass\\n\\n\\nclass APNSServerError(APNSError):\\n\\tdef __init__(self, status):\\n\\t\\tsuper().__init__(status)\\n\\t\\tself.status = status\\n\\n\\n# GCM\\nclass GCMError(NotificationError):\\n\\tpass\\n\\n\\n# Web Push\\nclass WebPushError(NotificationError):\\n\\tpass\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'import re\\nimport struct\\n\\nfrom django import forms\\nfrom django.core.validators import MaxValueValidator, MinValueValidator, RegexValidator\\nfrom django.db import connection, models\\nfrom django.utils.translation import gettext_lazy as _\\n\\n\\n__all__ = [\"HexadecimalField\", \"HexIntegerField\"]\\n\\nUNSIGNED_64BIT_INT_MIN_VALUE = 0\\nUNSIGNED_64BIT_INT_MAX_VALUE = 2 ** 64 - 1\\n\\n\\nhex_re = re.compile(r\"^(([0-9A-f])|(0x[0-9A-f]))+$\")\\nsigned_integer_vendors = [\\n\\t\"postgresql\",\\n\\t\"sqlite\",\\n]\\n\\n\\ndef _using_signed_storage():\\n\\treturn connection.vendor in signed_integer_vendors\\n\\n\\ndef _signed_to_unsigned_integer(value):\\n\\treturn struct.unpack(\"Q\", struct.pack(\"q\", value))[0]\\n\\n\\ndef _unsigned_to_signed_integer(value):\\n\\treturn struct.unpack(\"q\", struct.pack(\"Q\", value))[0]\\n\\n\\ndef _hex_string_to_unsigned_integer(value):\\n\\treturn int(value, 16)\\n\\n\\ndef _unsigned_integer_to_hex_string(value):\\n\\treturn hex(value).rstrip(\"L\")\\n\\n\\nclass HexadecimalField(forms.CharField):\\n\\t\"\"\"\\n\\tA form field that accepts only hexadecimal numbers\\n\\t\"\"\"\\n\\tdef __init__(self, *args, **kwargs):\\n\\t\\tself.default_validators = [\\n\\t\\t\\tRegexValidator(hex_re, _(\"Enter a valid hexadecimal number\"), \"invalid\")\\n\\t\\t]\\n\\t\\tsuper(HexadecimalField, self).__init__(*args, **kwargs)\\n\\n\\tdef prepare_value(self, value):\\n\\t\\t# converts bigint from db to hex before it is displayed in admin\\n\\t\\tif value and not isinstance(value, str) \\\\\\n\\t\\t\\tand connection.vendor in (\"mysql\", \"sqlite\"):\\n\\t\\t\\tvalue = _unsigned_integer_to_hex_string(value)\\n\\t\\treturn super(forms.CharField, self).prepare_value(value)\\n\\n\\nclass HexIntegerField(models.BigIntegerField):\\n\\t\"\"\"\\n\\tThis field stores a hexadecimal *string* of up to 64 bits as an unsigned integer\\n\\ton *all* backends including postgres.\\n\\n\\tReasoning: Postgres only supports signed bigints. Since we don\\'t care about\\n\\tsignedness, we store it as signed, and cast it to unsigned when we deal with\\n\\tthe actual value (with struct)\\n\\n\\tOn sqlite and mysql, native unsigned bigint types are used. In all cases, the\\n\\tvalue we deal with in python is always in hex.\\n\\t\"\"\"\\n\\n\\tvalidators = [\\n\\t\\tMinValueValidator(UNSIGNED_64BIT_INT_MIN_VALUE),\\n\\t\\tMaxValueValidator(UNSIGNED_64BIT_INT_MAX_VALUE)\\n\\t]\\n\\n\\tdef db_type(self, connection):\\n\\t\\tif \"mysql\" == connection.vendor:\\n\\t\\t\\treturn \"bigint unsigned\"\\n\\t\\telif \"sqlite\" == connection.vendor:\\n\\t\\t\\treturn \"UNSIGNED BIG INT\"\\n\\t\\telse:\\n\\t\\t\\treturn super(HexIntegerField, self).db_type(connection=connection)\\n\\n\\tdef get_prep_value(self, value):\\n\\t\\t\"\"\" Return the integer value to be stored from the hex string \"\"\"\\n\\t\\tif value is None or value == \"\":\\n\\t\\t\\treturn None\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _unsigned_to_signed_integer(value)\\n\\t\\treturn value\\n\\n\\tdef from_db_value(self, value, *args):\\n\\t\\t\"\"\" Return an unsigned int representation from all db backends \"\"\"\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _signed_to_unsigned_integer(value)\\n\\t\\treturn value\\n\\n\\tdef to_python(self, value):\\n\\t\\t\"\"\" Return a str representation of the hexadecimal \"\"\"\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\treturn value\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\treturn _unsigned_integer_to_hex_string(value)\\n\\n\\tdef formfield(self, **kwargs):\\n\\t\\tdefaults = {\"form_class\": HexadecimalField}\\n\\t\\tdefaults.update(kwargs)\\n\\t\\t# yes, that super call is right\\n\\t\\treturn super(models.IntegerField, self).formfield(**defaults)\\n\\n\\tdef run_validators(self, value):\\n\\t\\t# make sure validation is performed on integer value not string value\\n\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\treturn super(models.BigIntegerField, self).run_validators(value)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'\"\"\"\\nFirebase Cloud Messaging\\nPreviously known as GCM / C2DM\\nDocumentation is available on the Firebase Developer website:\\nhttps://firebase.google.com/docs/cloud-messaging/\\n\"\"\"\\n\\nimport json\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import Request, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import GCMError\\nfrom .models import GCMDevice\\n\\n\\n# Valid keys for FCM messages. Reference:\\n# https://firebase.google.com/docs/cloud-messaging/http-server-ref\\nFCM_TARGETS_KEYS = [\\n\\t\"to\", \"condition\", \"notification_key\"\\n]\\nFCM_OPTIONS_KEYS = [\\n\\t\"collapse_key\", \"priority\", \"content_available\", \"delay_while_idle\", \"time_to_live\",\\n\\t\"restricted_package_name\", \"dry_run\", \"mutable_content\"\\n]\\nFCM_NOTIFICATIONS_PAYLOAD_KEYS = [\\n\\t\"title\", \"body\", \"icon\", \"image\", \"sound\", \"badge\", \"color\", \"tag\", \"click_action\",\\n\\t\"body_loc_key\", \"body_loc_args\", \"title_loc_key\", \"title_loc_args\", \"android_channel_id\"\\n]\\n\\ndef _chunks(l, n):\\n\\t\"\"\"\\n\\tYield successive chunks from list \\\\a l with a minimum size \\\\a n\\n\\t\"\"\"\\n\\tfor i in range(0, len(l), n):\\n\\t\\tyield l[i:i + n]\\n\\n\\ndef _gcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_gcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"GCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"GCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _fcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_fcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"FCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"FCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _cm_handle_response(registration_ids, response_data, cloud_type, application_id=None):\\n\\tresponse = response_data\\n\\tif response.get(\"failure\") or response.get(\"canonical_ids\"):\\n\\t\\tids_to_remove, old_new_ids = [], []\\n\\t\\tthrow_error = False\\n\\t\\tfor index, result in enumerate(response[\"results\"]):\\n\\t\\t\\terror = result.get(\"error\")\\n\\t\\t\\tif error:\\n\\t\\t\\t\\t# https://firebase.google.com/docs/cloud-messaging/http-server-ref#error-codes\\n\\t\\t\\t\\t# If error is NotRegistered or InvalidRegistration, then we will deactivate devices\\n\\t\\t\\t\\t# because this registration ID is no more valid and can\\'t be used to send messages,\\n\\t\\t\\t\\t# otherwise raise error\\n\\t\\t\\t\\tif error in (\"NotRegistered\", \"InvalidRegistration\"):\\n\\t\\t\\t\\t\\tids_to_remove.append(registration_ids[index])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tthrow_error = True\\n\\t\\t\\tresult[\"original_registration_id\"] = registration_ids[index]\\n\\t\\t\\t# If registration_id is set, replace the original ID with the new value (canonical ID)\\n\\t\\t\\t# in your server database. Note that the original ID is not part of the result, you need\\n\\t\\t\\t# to obtain it from the list of registration_ids in the request (using the same index).\\n\\t\\t\\tnew_id = result.get(\"registration_id\")\\n\\t\\t\\tif new_id:\\n\\t\\t\\t\\told_new_ids.append((registration_ids[index], new_id))\\n\\n\\t\\tif ids_to_remove:\\n\\t\\t\\tremoved = GCMDevice.objects.filter(\\n\\t\\t\\t\\tregistration_id__in=ids_to_remove, cloud_message_type=cloud_type\\n\\t\\t\\t)\\n\\t\\t\\tremoved.update(active=False)\\n\\n\\t\\tfor old_id, new_id in old_new_ids:\\n\\t\\t\\t_cm_handle_canonical_id(new_id, old_id, cloud_type)\\n\\n\\t\\tif throw_error:\\n\\t\\t\\traise GCMError(response)\\n\\treturn response\\n\\n\\ndef _cm_send_request(\\n\\tregistration_ids, data, cloud_type=\"GCM\", application_id=None,\\n\\tuse_fcm_notifications=True, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a FCM or GCM notification to one or more registration_ids as json data.\\n\\tThe registration_ids needs to be a list.\\n\\t\"\"\"\\n\\n\\tpayload = {\"registration_ids\": registration_ids} if registration_ids else {}\\n\\n\\tdata = data.copy()\\n\\n\\t# If using FCM, optionally autodiscovers notification related keys\\n\\t# https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages\\n\\tif cloud_type == \"FCM\" and use_fcm_notifications:\\n\\t\\tnotification_payload = {}\\n\\t\\tif \"message\" in data:\\n\\t\\t\\tnotification_payload[\"body\"] = data.pop(\"message\", None)\\n\\n\\t\\tfor key in FCM_NOTIFICATIONS_PAYLOAD_KEYS:\\n\\t\\t\\tvalue_from_extra = data.pop(key, None)\\n\\t\\t\\tif value_from_extra:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_extra\\n\\t\\t\\tvalue_from_kwargs = kwargs.pop(key, None)\\n\\t\\t\\tif value_from_kwargs:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_kwargs\\n\\t\\tif notification_payload:\\n\\t\\t\\tpayload[\"notification\"] = notification_payload\\n\\n\\tif data:\\n\\t\\tpayload[\"data\"] = data\\n\\n\\t# Attach any additional non falsy keyword args (targets, options)\\n\\t# See ref : https://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\tpayload.update({\\n\\t\\tk: v for k, v in kwargs.items() if v and (k in FCM_TARGETS_KEYS or k in FCM_OPTIONS_KEYS)\\n\\t})\\n\\n\\t# Sort the keys for deterministic output (useful for tests)\\n\\tjson_payload = json.dumps(payload, separators=(\",\", \":\"), sort_keys=True).encode(\"utf-8\")\\n\\n\\t# Sends requests and handles the response\\n\\tif cloud_type == \"GCM\":\\n\\t\\tresponse = json.loads(_gcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telif cloud_type == \"FCM\":\\n\\t\\tresponse = json.loads(_fcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\treturn _cm_handle_response(registration_ids, response, cloud_type, application_id)\\n\\n\\ndef _cm_handle_canonical_id(canonical_id, current_id, cloud_type):\\n\\t\"\"\"\\n\\tHandle situation when FCM server response contains canonical ID\\n\\t\"\"\"\\n\\tdevices = GCMDevice.objects.filter(cloud_message_type=cloud_type)\\n\\tif devices.filter(registration_id=canonical_id, active=True).exists():\\n\\t\\tdevices.filter(registration_id=current_id).update(active=False)\\n\\telse:\\n\\t\\tdevices.filter(registration_id=current_id).update(registration_id=canonical_id)\\n\\n\\ndef send_message(registration_ids, data, cloud_type, application_id=None, **kwargs):\\n\\t\"\"\"\\n\\tSends a FCM (or GCM) notification to one or more registration_ids. The registration_ids\\n\\tcan be a list or a single string. This will send the notification as json data.\\n\\n\\tA reference of extra keyword arguments sent to the server is available here:\\n\\thttps://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\t\"\"\"\\n\\tif cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\tmax_recipients = get_manager().get_max_recipients(cloud_type, application_id)\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\n\\t# Checks for valid recipient\\n\\tif registration_ids is None and \"/topics/\" not in kwargs.get(\"to\", \"\"):\\n\\t\\treturn\\n\\n\\t# Bundles the registration_ids in an list if only one is sent\\n\\tif not isinstance(registration_ids, list):\\n\\t\\tregistration_ids = [registration_ids] if registration_ids else None\\n\\n\\t# FCM only allows up to 1000 reg ids per bulk message\\n\\t# https://firebase.google.com/docs/cloud-messaging/server#http-request\\n\\tif registration_ids:\\n\\t\\tret = []\\n\\t\\tfor chunk in _chunks(registration_ids, max_recipients):\\n\\t\\t\\tret.append(_cm_send_request(\\n\\t\\t\\t\\tchunk, data, cloud_type=cloud_type, application_id=application_id, **kwargs\\n\\t\\t\\t))\\n\\t\\treturn ret[0] if len(ret) == 1 else ret\\n\\telse:\\n\\t\\treturn _cm_send_request(None, data, cloud_type=cloud_type, **kwargs)\\n\\n\\nsend_bulk_message = send_message\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\nimport push_notifications.fields\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='APNSDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', models.UUIDField(help_text='UDID / UIDevice.identifierForVendor()', max_length=32, null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.CharField(unique=True, max_length=64, verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'APNS device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n        migrations.CreateModel(\\n            name='GCMDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', push_notifications.fields.HexIntegerField(help_text='ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)', null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'GCM device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.1 on 2016-01-06 08:50\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0001_initial'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=True, verbose_name='Registration ID'),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nimport django.db.models.deletion\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0002_auto_20160106_0850'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WNSDevice',\\n            fields=[\\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\\n                ('name', models.CharField(blank=True, max_length=255, null=True, verbose_name='Name')),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, null=True, verbose_name='Creation date')),\\n                ('device_id', models.UUIDField(blank=True, db_index=True, help_text='GUID()', null=True, verbose_name='Device ID')),\\n                ('registration_id', models.TextField(verbose_name='Notification URI')),\\n                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\\n            ],\\n            options={\\n                'verbose_name': 'WNS device',\\n            },\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n\\tdependencies = [\\n\\t\\tmigrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n\\t\\t('push_notifications', '0003_wnsdevice'),\\n\\t]\\n\\n\\toperations = [\\n\\t\\tmigrations.AddField(\\n\\t\\t\\tmodel_name='gcmdevice',\\n\\t\\t\\tname='cloud_message_type',\\n\\t\\t\\tfield=models.CharField(choices=[('FCM', 'Firebase Cloud Message'), ('GCM', 'Google Cloud Message')], default='GCM', help_text='You should choose FCM or GCM', max_length=3, verbose_name='Cloud Message Type')\\n\\t\\t),\\n\\t]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0004_fcm'),\\n    ]\\n\\n    operations = [\\n        migrations.AddField(\\n            model_name='apnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='gcmdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='wnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0005_applicationid'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WebPushDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('application_id', models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('p256dh', models.CharField(max_length=88, verbose_name='User public encryption key')),\\n                ('auth', models.CharField(max_length=24, verbose_name='User auth secret')),\\n                ('browser', models.CharField(default='CHROME', help_text='Currently only support to Chrome, Firefox and Opera browsers', max_length=10, verbose_name='Browser', choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera')])),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'WebPush device',\\n            },\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "\"from django.db import migrations, models\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0006_webpushdevice'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='gcmdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='wnsdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Notification URI'),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "\"# Generated by Django 3.2.8 on 2021-11-12 09:49\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0007_uniquesetting'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='browser',\\n            field=models.CharField(choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera'), ('EDGE', 'Edge')], default='CHROME', help_text='Currently only support to Chrome, Firefox, Edge and Opera browsers', max_length=10, verbose_name='Browser'),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "\"# Generated by Django 3.2.9 on 2022-01-10 09:03\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0008_webpush_add_edge'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='device_id',\\n            field=models.UUIDField(blank=True, db_index=True, help_text='UUID / UIDevice.identifierForVendor()', null=True, verbose_name='Device ID'),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "''"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'from django.db import models\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .fields import HexIntegerField\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nCLOUD_MESSAGE_TYPES = (\\n\\t(\"FCM\", \"Firebase Cloud Message\"),\\n\\t(\"GCM\", \"Google Cloud Message\"),\\n)\\n\\nBROWSER_TYPES = (\\n\\t(\"CHROME\", \"Chrome\"),\\n\\t(\"FIREFOX\", \"Firefox\"),\\n\\t(\"OPERA\", \"Opera\"),\\n\\t(\"EDGE\", \"Edge\")\\n)\\n\\n\\nclass Device(models.Model):\\n\\tname = models.CharField(max_length=255, verbose_name=_(\"Name\"), blank=True, null=True)\\n\\tactive = models.BooleanField(\\n\\t\\tverbose_name=_(\"Is active\"), default=True,\\n\\t\\thelp_text=_(\"Inactive devices will not be sent notifications\")\\n\\t)\\n\\tuser = models.ForeignKey(\\n\\t\\tSETTINGS[\"USER_MODEL\"], blank=True, null=True, on_delete=models.CASCADE\\n\\t)\\n\\tdate_created = models.DateTimeField(\\n\\t\\tverbose_name=_(\"Creation date\"), auto_now_add=True, null=True\\n\\t)\\n\\tapplication_id = models.CharField(\\n\\t\\tmax_length=64, verbose_name=_(\"Application ID\"),\\n\\t\\thelp_text=_(\\n\\t\\t\\t\"Opaque application identity, should be filled in for multiple\"\\n\\t\\t\\t\" key/certificate access\"\\n\\t\\t),\\n\\t\\tblank=True, null=True\\n\\t)\\n\\n\\tclass Meta:\\n\\t\\tabstract = True\\n\\n\\tdef __str__(self):\\n\\t\\treturn (\\n\\t\\t\\tself.name or\\n\\t\\t\\tstr(self.device_id or \"\") or\\n\\t\\t\\t\"{} for {}\".format(self.__class__.__name__, self.user or \"unknown user\")\\n\\t\\t)\\n\\n\\nclass GCMDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn GCMDeviceQuerySet(self.model)\\n\\n\\nclass GCMDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\t\\tif message is not None:\\n\\t\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\\n\\t\\t\\t\\t\"application_id\"\\n\\t\\t\\t).values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tresponse = []\\n\\t\\t\\tfor cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\t\\treg_ids = list(\\n\\t\\t\\t\\t\\t\\tself.filter(\\n\\t\\t\\t\\t\\t\\t\\tactive=True, cloud_message_type=cloud_type, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\tif reg_ids:\\n\\t\\t\\t\\t\\t\\tr = gcm_send_message(reg_ids, data, cloud_type, application_id=app_id, **kwargs)\\n\\t\\t\\t\\t\\t\\tresponse.append(r)\\n\\n\\t\\t\\treturn response\\n\\n\\nclass GCMDevice(Device):\\n\\t# device_id cannot be a reliable primary key as fragmentation between different devices\\n\\t# can make it turn out to be null and such:\\n\\t# http://android-developers.blogspot.co.uk/2011/03/identifying-app-installations.html\\n\\tdevice_id = HexIntegerField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tcloud_message_type = models.CharField(\\n\\t\\tverbose_name=_(\"Cloud Message Type\"), max_length=3,\\n\\t\\tchoices=CLOUD_MESSAGE_TYPES, default=\"GCM\",\\n\\t\\thelp_text=_(\"You should choose FCM or GCM\")\\n\\t)\\n\\tobjects = GCMDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"GCM device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\tif message is not None:\\n\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\treturn gcm_send_message(\\n\\t\\t\\tself.registration_id, data, self.cloud_message_type,\\n\\t\\t\\tapplication_id=self.application_id, **kwargs\\n\\t\\t)\\n\\n\\nclass APNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn APNSDeviceQuerySet(self.model)\\n\\n\\nclass APNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .apns import apns_send_bulk_message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\")\\\\\\n\\t\\t\\t\\t.values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tres = []\\n\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\treg_ids = list(self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\"registration_id\", flat=True)\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tr = apns_send_bulk_message(\\n\\t\\t\\t\\t\\tregistration_ids=reg_ids, alert=message, application_id=app_id,\\n\\t\\t\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\t\\tres += [r]\\n\\t\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\t\\tres += r\\n\\t\\t\\treturn res\\n\\n\\nclass APNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"UUID / UIDevice.identifierForVendor()\")\\n\\t)\\n\\tregistration_id = models.CharField(\\n\\t\\tverbose_name=_(\"Registration ID\"), max_length=200, unique=SETTINGS[\"UNIQUE_REG_ID\"]\\n\\t)\\n\\n\\tobjects = APNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"APNS device\")\\n\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tfrom .apns import apns_send_message\\n\\n\\t\\treturn apns_send_message(\\n\\t\\t\\tregistration_id=self.registration_id,\\n\\t\\t\\talert=message,\\n\\t\\t\\tapplication_id=self.application_id, creds=creds,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WNSDeviceQuerySet(self.model)\\n\\n\\nclass WNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_bulk_message\\n\\n\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\").values_list(\\n\\t\\t\\t\"application_id\", flat=True\\n\\t\\t).distinct()\\n\\t\\tres = []\\n\\t\\tfor app_id in app_ids:\\n\\t\\t\\treg_ids = self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t)\\n\\t\\t\\tr = wns_send_bulk_message(uri_list=list(reg_ids), message=message, **kwargs)\\n\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\tres += [r]\\n\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\tres += r\\n\\n\\t\\treturn res\\n\\n\\nclass WNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"GUID()\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Notification URI\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\n\\tobjects = WNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WNS device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_message\\n\\n\\t\\treturn wns_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, application_id=self.application_id,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WebPushDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WebPushDeviceQuerySet(self.model)\\n\\n\\nclass WebPushDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tdevices = self.filter(active=True).order_by(\"application_id\").distinct()\\n\\t\\tres = []\\n\\t\\tfor device in devices:\\n\\t\\t\\tres.append(device.send_message(message))\\n\\n\\t\\treturn res\\n\\n\\nclass WebPushDevice(Device):\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tp256dh = models.CharField(\\n\\t\\tverbose_name=_(\"User public encryption key\"),\\n\\t\\tmax_length=88)\\n\\tauth = models.CharField(\\n\\t\\tverbose_name=_(\"User auth secret\"),\\n\\t\\tmax_length=24)\\n\\tbrowser = models.CharField(\\n\\t\\tverbose_name=_(\"Browser\"), max_length=10,\\n\\t\\tchoices=BROWSER_TYPES, default=BROWSER_TYPES[0][0],\\n\\t\\thelp_text=_(\"Currently only support to Chrome, Firefox, Edge and Opera browsers\")\\n\\t)\\n\\tobjects = WebPushDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WebPush device\")\\n\\n\\t@property\\n\\tdef device_id(self):\\n\\t\\treturn None\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .webpush import webpush_send_message\\n\\n\\t\\treturn webpush_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, browser=self.browser,\\n\\t\\t\\tauth=self.auth, p256dh=self.p256dh, application_id=self.application_id, **kwargs)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'from django.conf import settings\\n\\n\\nPUSH_NOTIFICATIONS_SETTINGS = getattr(settings, \"PUSH_NOTIFICATIONS_SETTINGS\", {})\\n\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"CONFIG\", \"push_notifications.conf.LegacyConfig\"\\n)\\n\\n# GCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"GCM_POST_URL\", \"https://android.googleapis.com/gcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_ERROR_TIMEOUT\", None)\\n\\n# FCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"FCM_POST_URL\", \"https://fcm.googleapis.com/fcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_ERROR_TIMEOUT\", None)\\n\\n# APNS\\nif settings.DEBUG:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", True)\\nelse:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_ALTERNATIVE_PORT\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_TOPIC\", None)\\n\\n# WNS\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_PACKAGE_SECURITY_ID\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_SECRET_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\"\\n)\\n\\n# WP (WebPush)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_POST_URL\", {\\n\\t\"CHROME\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"OPERA\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n})\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_PRIVATE_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_CLAIMS\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_ERROR_TIMEOUT\", None)\\n\\n# User model\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"USER_MODEL\", settings.AUTH_USER_MODEL)\\n\\n# Unique registration ID for all devices\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UNIQUE_REG_ID\", False)\\n\\n# API endpoint settings\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UPDATE_ON_DUPLICATE_REG_ID\", False)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'from pywebpush import WebPushException, webpush\\n\\nfrom .conf import get_manager\\nfrom .exceptions import WebPushError\\n\\n\\ndef get_subscription_info(application_id, uri, browser, auth, p256dh):\\n\\turl = get_manager().get_wp_post_url(application_id, browser)\\n\\treturn {\\n\\t\\t\"endpoint\": \"{}/{}\".format(url, uri),\\n\\t\\t\"keys\": {\\n\\t\\t\\t\"auth\": auth,\\n\\t\\t\\t\"p256dh\": p256dh,\\n\\t\\t}\\n\\t}\\n\\n\\ndef webpush_send_message(\\n\\turi, message, browser, auth, p256dh, application_id=None, **kwargs\\n):\\n\\tsubscription_info = get_subscription_info(application_id, uri, browser, auth, p256dh)\\n\\n\\ttry:\\n\\t\\tresponse = webpush(\\n\\t\\t\\tsubscription_info=subscription_info,\\n\\t\\t\\tdata=message,\\n\\t\\t\\tvapid_private_key=get_manager().get_wp_private_key(application_id),\\n\\t\\t\\tvapid_claims=get_manager().get_wp_claims(application_id).copy(),\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\t\\tresults = {\"results\": [{}]}\\n\\t\\tif not response.ok:\\n\\t\\t\\tresults[\"results\"][0][\"error\"] = response.content\\n\\t\\t\\tresults[\"results\"][0][\"original_registration_id\"] = response.content\\n\\t\\telse:\\n\\t\\t\\tresults[\"success\"] = 1\\n\\t\\treturn results\\n\\texcept WebPushException as e:\\n\\t\\traise WebPushError(e.message)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'\"\"\"\\nWindows Notification Service\\n\\nDocumentation is available on the Windows Dev Center:\\nhttps://msdn.microsoft.com/en-us/windows/uwp/controls-and-patterns/tiles-and-notifications-windows-push-notification-services--wns--overview\\n\"\"\"\\n\\nimport json\\nimport xml.etree.ElementTree as ET\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import HTTPError, Request, urlencode, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import NotificationError\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass WNSError(NotificationError):\\n\\tpass\\n\\n\\nclass WNSAuthenticationError(WNSError):\\n\\tpass\\n\\n\\nclass WNSNotificationResponseError(WNSError):\\n\\tpass\\n\\n\\ndef _wns_authenticate(scope=\"notify.windows.com\", application_id=None):\\n\\t\"\"\"\\n\\tRequests an Access token for WNS communication.\\n\\n\\t:return: dict: {\\'access_token\\': <str>, \\'expires_in\\': <int>, \\'token_type\\': \\'bearer\\'}\\n\\t\"\"\"\\n\\tclient_id = get_manager().get_wns_package_security_id(application_id)\\n\\tclient_secret = get_manager().get_wns_secret_key(application_id)\\n\\tif not client_id:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_PACKAGE_SECURITY_ID\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\tif not client_secret:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_SECRET_KEY\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": \"application/x-www-form-urlencoded\",\\n\\t}\\n\\tparams = {\\n\\t\\t\"grant_type\": \"client_credentials\",\\n\\t\\t\"client_id\": client_id,\\n\\t\\t\"client_secret\": client_secret,\\n\\t\\t\"scope\": scope,\\n\\t}\\n\\tdata = urlencode(params).encode(\"utf-8\")\\n\\n\\trequest = Request(SETTINGS[\"WNS_ACCESS_URL\"], data=data, headers=headers)\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\t# One of your settings is probably jacked up.\\n\\t\\t\\t# https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh868245\\n\\t\\t\\traise WNSAuthenticationError(\"Authentication failed, check your WNS settings.\")\\n\\t\\traise err\\n\\n\\toauth_data = response.read().decode(\"utf-8\")\\n\\ttry:\\n\\t\\toauth_data = json.loads(oauth_data)\\n\\texcept Exception:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Received invalid JSON data from WNS.\")\\n\\n\\taccess_token = oauth_data.get(\"access_token\")\\n\\tif not access_token:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Access token missing from WNS response.\")\\n\\n\\treturn access_token\\n\\n\\ndef _wns_send(uri, data, wns_type=\"wns/toast\", application_id=None):\\n\\t\"\"\"\\n\\tSends a notification data and authentication to WNS.\\n\\n\\t:param uri: str: The device\\'s unique notification URI\\n\\t:param data: dict: The notification data to be sent.\\n\\t:return:\\n\\t\"\"\"\\n\\taccess_token = _wns_authenticate(application_id=application_id)\\n\\n\\tcontent_type = \"text/xml\"\\n\\tif wns_type == \"wns/raw\":\\n\\t\\tcontent_type = \"application/octet-stream\"\\n\\n\\theaders = {\\n\\t\\t# content_type is \"text/xml\" (toast/badge/tile) | \"application/octet-stream\" (raw)\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"Bearer %s\" % (access_token),\\n\\t\\t\"X-WNS-Type\": wns_type,  # wns/toast | wns/badge | wns/tile | wns/raw\\n\\t}\\n\\n\\tif type(data) is str:\\n\\t\\tdata = data.encode(\"utf-8\")\\n\\n\\trequest = Request(uri, data, headers)\\n\\n\\t# A lot of things can happen, let them know which one.\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\tmsg = \"One or more headers were specified incorrectly or conflict with another header.\"\\n\\t\\telif err.code == 401:\\n\\t\\t\\tmsg = \"The cloud service did not present a valid authentication ticket.\"\\n\\t\\telif err.code == 403:\\n\\t\\t\\tmsg = \"The cloud service is not authorized to send a notification to this URI.\"\\n\\t\\telif err.code == 404:\\n\\t\\t\\tmsg = \"The channel URI is not valid or is not recognized by WNS.\"\\n\\t\\telif err.code == 405:\\n\\t\\t\\tmsg = \"Invalid method. Only POST or DELETE is allowed.\"\\n\\t\\telif err.code == 406:\\n\\t\\t\\tmsg = \"The cloud service exceeded its throttle limit\"\\n\\t\\telif err.code == 410:\\n\\t\\t\\tmsg = \"The channel expired.\"\\n\\t\\telif err.code == 413:\\n\\t\\t\\tmsg = \"The notification payload exceeds the 500 byte limit.\"\\n\\t\\telif err.code == 500:\\n\\t\\t\\tmsg = \"An internal failure caused notification delivery to fail.\"\\n\\t\\telif err.code == 503:\\n\\t\\t\\tmsg = \"The server is currently unavailable.\"\\n\\t\\telse:\\n\\t\\t\\traise err\\n\\t\\traise WNSNotificationResponseError(\"HTTP %i: %s\" % (err.code, msg))\\n\\n\\treturn response.read().decode(\"utf-8\")\\n\\n\\ndef _wns_prepare_toast(data, **kwargs):\\n\\t\"\"\"\\n\\tCreates the xml tree for a `toast` notification\\n\\n\\t:param data: dict: The notification data to be converted to an xml tree.\\n\\n\\t{\\n\\t\\t\"text\": [\"Title text\", \"Message Text\", \"Another message!\"],\\n\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t}\\n\\n\\t:return: str\\n\\t\"\"\"\\n\\troot = ET.Element(\"toast\")\\n\\tvisual = ET.SubElement(root, \"visual\")\\n\\tbinding = ET.SubElement(visual, \"binding\")\\n\\tbinding.attrib[\"template\"] = kwargs.pop(\"template\", \"ToastText01\")\\n\\tif \"text\" in data:\\n\\t\\tfor count, item in enumerate(data[\"text\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"text\")\\n\\t\\t\\telem.text = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\tif \"image\" in data:\\n\\t\\tfor count, item in enumerate(data[\"image\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"img\")\\n\\t\\t\\telem.attrib[\"src\"] = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\treturn ET.tostring(root)\\n\\n\\ndef wns_send_message(\\n\\turi, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a notification request to WNS.\\n\\tThere are four notification types that WNS can send: toast, tile, badge and raw.\\n\\tToast, tile, and badge can all be customized to use different\\n\\ttemplates/icons/sounds/launch params/etc.\\n\\tSee docs for more information:\\n\\thttps://msdn.microsoft.com/en-us/library/windows/apps/br212853.aspx\\n\\n\\tThere are multiple ways to input notification data:\\n\\n\\t1. The simplest and least custom notification to send is to just pass a string\\n\\tto `message`. This will create a toast notification with one text element. e.g.:\\n\\t\\t\"This is my notification title\"\\n\\n\\t2. You can also pass a dictionary to `message`: it can only contain one or both\\n\\tkeys: [\"text\", \"image\"]. The value of each key must be a list with the text and\\n\\tsrc respectively. e.g.:\\n\\t\\t{\\n\\t\\t\\t\"text\": [\"text1\", \"text2\"],\\n\\t\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t\\t}\\n\\n\\t3. Passing a dictionary to `xml_data` will create one of three types of\\n\\tnotifications depending on the dictionary data (toast, tile, badge).\\n\\tSee `dict_to_xml_schema` docs for more information on dictionary formatting.\\n\\n\\t4. Passing a value to `raw_data` will create a `raw` notification and send the\\n\\tinput data as is.\\n\\n\\t:param uri: str: The device\\'s unique notification uri.\\n\\t:param message: str|dict: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\t# Create a simple toast notification\\n\\tif message:\\n\\t\\twns_type = \"wns/toast\"\\n\\t\\tif isinstance(message, str):\\n\\t\\t\\tmessage = {\\n\\t\\t\\t\\t\"text\": [message, ],\\n\\t\\t\\t}\\n\\t\\tprepared_data = _wns_prepare_toast(data=message, **kwargs)\\n\\t# Create a toast/tile/badge notification from a dictionary\\n\\telif xml_data:\\n\\t\\txml = dict_to_xml_schema(xml_data)\\n\\t\\twns_type = \"wns/%s\" % xml.tag\\n\\t\\tprepared_data = ET.tostring(xml)\\n\\t# Create a raw notification\\n\\telif raw_data:\\n\\t\\twns_type = \"wns/raw\"\\n\\t\\tprepared_data = raw_data\\n\\telse:\\n\\t\\traise TypeError(\\n\\t\\t\\t\"At least one of the following parameters must be set:\"\\n\\t\\t\\t\"`message`, `xml_data`, `raw_data`\"\\n\\t\\t)\\n\\n\\treturn _wns_send(\\n\\t\\turi=uri, data=prepared_data, wns_type=wns_type, application_id=application_id\\n\\t)\\n\\n\\ndef wns_send_bulk_message(\\n\\turi_list, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tWNS doesn\\'t support bulk notification, so we loop through each uri.\\n\\n\\t:param uri_list: list: A list of uris the notification will be sent to.\\n\\t:param message: str: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\tres = []\\n\\tif uri_list:\\n\\t\\tfor uri in uri_list:\\n\\t\\t\\tr = wns_send_message(\\n\\t\\t\\t\\turi=uri, message=message, xml_data=xml_data,\\n\\t\\t\\t\\traw_data=raw_data, application_id=application_id, **kwargs\\n\\t\\t\\t)\\n\\t\\t\\tres.append(r)\\n\\treturn res\\n\\n\\ndef dict_to_xml_schema(data):\\n\\t\"\"\"\\n\\tInput a dictionary to be converted to xml. There should be only one key at\\n\\tthe top level. The value must be a dict with (required) `children` key and\\n\\t(optional) `attrs` key. This will be called the `sub-element dictionary`.\\n\\n\\tThe `attrs` value must be a dictionary; each value will be added to the\\n\\telement\\'s xml tag as attributes. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\n\\twould result in:\\n\\t\\t<example key1=\"value1\" key2=\"value2\"></example>\\n\\n\\tIf the value is a dict it must contain one or more keys which will be used\\n\\tas the sub-element names. Each sub-element must have a value of a sub-element\\n\\tdictionary(see above) or a list of sub-element dictionaries.\\n\\tIf the value is not a dict, it will be the value of the element.\\n\\tIf the value is a list, multiple elements of the same tag will be created\\n\\tfrom each sub-element dict in the list.\\n\\n\\t:param data: dict: Used to create an XML tree. e.g.:\\n\\t\\texample_data = {\\n\\t\\t\\t\"toast\": {\\n\\t\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\\t\"launch\": \"param\",\\n\\t\\t\\t\\t\\t\"duration\": \"short\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\"visual\": {\\n\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\"binding\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"template\": \"ToastText01\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"text\": [\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"1\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text1\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"2\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text2\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor key, value in data.items():\\n\\t\\troot = _add_element_attrs(ET.Element(key), value.get(\"attrs\", {}))\\n\\t\\tchildren = value.get(\"children\", None)\\n\\t\\tif isinstance(children, dict):\\n\\t\\t\\t_add_sub_elements_from_dict(root, children)\\n\\t\\treturn root\\n\\n\\ndef _add_sub_elements_from_dict(parent, sub_dict):\\n\\t\"\"\"\\n\\tAdd SubElements to the parent element.\\n\\n\\t:param parent: ElementTree.Element: The parent element for the newly created SubElement.\\n\\t:param sub_dict: dict: Used to create a new SubElement. See `dict_to_xml_schema`\\n\\tmethod docstring for more information. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\t\"\"\"\\n\\tfor key, value in sub_dict.items():\\n\\t\\tif isinstance(value, list):\\n\\t\\t\\tfor repeated_element in value:\\n\\t\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t\\t_add_element_attrs(sub_element, repeated_element.get(\"attrs\", {}))\\n\\t\\t\\t\\tchildren = repeated_element.get(\"children\", None)\\n\\t\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\t\\tsub_element.text = children\\n\\t\\telse:\\n\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t_add_element_attrs(sub_element, value.get(\"attrs\", {}))\\n\\t\\t\\tchildren = value.get(\"children\", None)\\n\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\tsub_element.text = children\\n\\n\\ndef _add_element_attrs(elem, attrs):\\n\\t\"\"\"\\n\\tAdd attributes to the given element.\\n\\n\\t:param elem: ElementTree.Element: The element the attributes are being added to.\\n\\t:param attrs: dict: A dictionary of attributes. e.g.:\\n\\t\\t{\"attribute1\": \"value\", \"attribute2\": \"another\"}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor attr, value in attrs.items():\\n\\t\\telem.attrib[attr] = value\\n\\treturn elem\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/__init__.py'"}, "return_value": "'try:\\n    # Python 3.8+\\n    import importlib.metadata as importlib_metadata\\nexcept ImportError:\\n    # <Python 3.7 and lower\\n    import importlib_metadata\\n\\n__version__ = importlib_metadata.version(\"django-push-notifications\")\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/admin.py'"}, "return_value": "'from django.apps import apps\\nfrom django.contrib import admin, messages\\nfrom django.utils.encoding import force_str\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .exceptions import APNSServerError, GCMError, WebPushError\\nfrom .models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nUser = apps.get_model(*SETTINGS[\"USER_MODEL\"].split(\".\"))\\n\\n\\nclass DeviceAdmin(admin.ModelAdmin):\\n\\tlist_display = (\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\",)\\n\\tactions = (\"send_message\", \"send_bulk_message\", \"enable\", \"disable\")\\n\\traw_id_fields = (\"user\",)\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"device_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"device_id\")\\n\\n\\tdef send_messages(self, request, queryset, bulk=False):\\n\\t\\t\"\"\"\\n\\t\\tProvides error handling for DeviceAdmin send_message and send_bulk_message methods.\\n\\t\\t\"\"\"\\n\\t\\tret = []\\n\\t\\terrors = []\\n\\t\\tr = \"\"\\n\\n\\t\\tfor device in queryset:\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tif bulk:\\n\\t\\t\\t\\t\\tr = queryset.send_message(\"Test bulk notification\")\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = device.send_message(\"Test single notification\")\\n\\t\\t\\t\\tif r:\\n\\t\\t\\t\\t\\tret.append(r)\\n\\t\\t\\texcept GCMError as e:\\n\\t\\t\\t\\terrors.append(str(e))\\n\\t\\t\\texcept APNSServerError as e:\\n\\t\\t\\t\\terrors.append(e.status)\\n\\t\\t\\texcept WebPushError as e:\\n\\t\\t\\t\\terrors.append(force_str(e))\\n\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\t# Because NotRegistered and InvalidRegistration do not throw GCMError\\n\\t\\t# catch them here to display error msg.\\n\\t\\tif not bulk:\\n\\t\\t\\tfor r in ret:\\n\\t\\t\\t\\tif \"error\" in r[\"results\"][0]:\\n\\t\\t\\t\\t\\terrors.append(r[\"results\"][0][\"error\"])\\n\\t\\telse:\\n\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\terrors = [r[\"error\"] for r in ret[0][0][\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\terrors = errors + [r[\"error\"] for r in entry[\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept IndexError:\\n\\t\\t\\t\\t\\tpass\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\tif value.lower() != \"success\":\\n\\t\\t\\t\\t\\t\\terrors.append(value)\\n\\t\\tif errors:\\n\\t\\t\\tself.message_user(\\n\\t\\t\\t\\trequest, _(\"Some messages could not be processed: %r\" % (\", \".join(errors))),\\n\\t\\t\\t\\tlevel=messages.ERROR\\n\\t\\t\\t)\\n\\t\\tif ret:\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\t# When the queryset exceeds the max_recipients value, the\\n\\t\\t\\t\\t# send_message method returns a list of dicts, one per chunk\\n\\t\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\t\\tsuccess = ret[0][0][\"success\"]\\n\\t\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\t\\tsuccess = 0\\n\\t\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\t\\tsuccess = success + entry[\"success\"]\\n\\t\\t\\t\\t\\tif success == 0:\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\t\\tsuccess = []\\n\\t\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\t\\tif value.lower() == \"success\":\\n\\t\\t\\t\\t\\t\\t\\tsuccess.append(key)\\n\\n\\t\\t\\telif len(errors) == len(ret):\\n\\t\\t\\t\\treturn\\n\\t\\t\\tif errors:\\n\\t\\t\\t\\tmsg = _(\"Some messages were sent: %s\" % (ret))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = _(\"All messages were sent: %s\" % (ret))\\n\\t\\t\\tself.message_user(request, msg)\\n\\n\\tdef send_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset)\\n\\n\\tsend_message.short_description = _(\"Send test message\")\\n\\n\\tdef send_bulk_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset, True)\\n\\n\\tsend_bulk_message.short_description = _(\"Send test message in bulk\")\\n\\n\\tdef enable(self, request, queryset):\\n\\t\\tqueryset.update(active=True)\\n\\n\\tenable.short_description = _(\"Enable selected devices\")\\n\\n\\tdef disable(self, request, queryset):\\n\\t\\tqueryset.update(active=False)\\n\\n\\tdisable.short_description = _(\"Disable selected devices\")\\n\\n\\nclass GCMDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\\n\\t\\t\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\", \"cloud_message_type\"\\n\\t)\\n\\tlist_filter = (\"active\", \"cloud_message_type\")\\n\\n\\nclass WebPushDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\"__str__\", \"browser\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\", \"browser\")\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"registration_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"registration_id\")\\n\\n\\nadmin.site.register(APNSDevice, DeviceAdmin)\\nadmin.site.register(GCMDevice, GCMDeviceAdmin)\\nadmin.site.register(WNSDevice, DeviceAdmin)\\nadmin.site.register(WebPushDevice, WebPushDeviceAdmin)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/__init__.py'"}, "return_value": "''"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/api/rest_framework.py'"}, "return_value": "'from rest_framework import permissions, status\\nfrom rest_framework.fields import IntegerField\\nfrom rest_framework.response import Response\\nfrom rest_framework.serializers import ModelSerializer, Serializer, ValidationError\\nfrom rest_framework.viewsets import ModelViewSet\\n\\nfrom ..fields import UNSIGNED_64BIT_INT_MAX_VALUE, hex_re\\nfrom ..models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\n# Fields\\nclass HexIntegerField(IntegerField):\\n\\t\"\"\"\\n\\tStore an integer represented as a hex string of form \"0x01\".\\n\\t\"\"\"\\n\\n\\tdef to_internal_value(self, data):\\n\\t\\t# validate hex string and convert it to the unsigned\\n\\t\\t# integer representation for internal use\\n\\t\\ttry:\\n\\t\\t\\tdata = int(data, 16) if type(data) != int else data\\n\\t\\texcept ValueError:\\n\\t\\t\\traise ValidationError(\"Device ID is not a valid hex number\")\\n\\t\\treturn super(HexIntegerField, self).to_internal_value(data)\\n\\n\\tdef to_representation(self, value):\\n\\t\\treturn value\\n\\n\\n# Serializers\\nclass DeviceSerializerMixin(ModelSerializer):\\n\\tclass Meta:\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"application_id\", \"registration_id\", \"device_id\",\\n\\t\\t\\t\"active\", \"date_created\"\\n\\t\\t)\\n\\t\\tread_only_fields = (\"date_created\",)\\n\\n\\t\\t# See https://github.com/tomchristie/django-rest-framework/issues/1101\\n\\t\\textra_kwargs = {\"active\": {\"default\": True}}\\n\\n\\nclass APNSDeviceSerializer(ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = APNSDevice\\n\\n\\tdef validate_registration_id(self, value):\\n\\t\\t# iOS device tokens are 256-bit hexadecimal (64 characters). In 2016 Apple is increasing\\n\\t\\t# iOS device tokens to 100 bytes hexadecimal (200 characters).\\n\\n\\t\\tif hex_re.match(value) is None or len(value) not in (64, 200):\\n\\t\\t\\traise ValidationError(\"Registration ID (device token) is invalid\")\\n\\n\\t\\treturn value\\n\\n\\nclass UniqueRegistrationSerializerMixin(Serializer):\\n\\tdef validate(self, attrs):\\n\\t\\tdevices = None\\n\\t\\tprimary_key = None\\n\\t\\trequest_method = None\\n\\n\\t\\tif self.initial_data.get(\"registration_id\", None):\\n\\t\\t\\tif self.instance:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telse:\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\t\\telse:\\n\\t\\t\\tif self.context[\"request\"].method in [\"PUT\", \"PATCH\"]:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telif self.context[\"request\"].method == \"POST\":\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\n\\t\\tDevice = self.Meta.model\\n\\t\\tif request_method == \"update\":\\n\\t\\t\\treg_id = attrs.get(\"registration_id\", self.instance.registration_id)\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=reg_id) \\\\\\n\\t\\t\\t\\t.exclude(id=primary_key)\\n\\t\\telif request_method == \"create\":\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=attrs[\"registration_id\"])\\n\\n\\t\\tif devices:\\n\\t\\t\\traise ValidationError({\"registration_id\": \"This field must be unique.\"})\\n\\t\\treturn attrs\\n\\n\\nclass GCMDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tdevice_id = HexIntegerField(\\n\\t\\thelp_text=\"ANDROID_ID / TelephonyManager.getDeviceId() (e.g: 0x01)\",\\n\\t\\tstyle={\"input_type\": \"text\"},\\n\\t\\trequired=False,\\n\\t\\tallow_null=True\\n\\t)\\n\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = GCMDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"device_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"cloud_message_type\", \"application_id\",\\n\\t\\t)\\n\\t\\textra_kwargs = {\"id\": {\"read_only\": False, \"required\": False}}\\n\\n\\tdef validate_device_id(self, value):\\n\\t\\t# device ids are 64 bit unsigned values\\n\\t\\tif value > UNSIGNED_64BIT_INT_MAX_VALUE:\\n\\t\\t\\traise ValidationError(\"Device ID is out of range\")\\n\\t\\treturn value\\n\\n\\nclass WNSDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WNSDevice\\n\\n\\nclass WebPushDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WebPushDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"p256dh\", \"auth\", \"browser\", \"application_id\",\\n\\t\\t)\\n\\n\\n# Permissions\\nclass IsOwner(permissions.BasePermission):\\n\\tdef has_object_permission(self, request, view, obj):\\n\\t\\t# must be the owner to view the object\\n\\t\\treturn obj.user == request.user\\n\\n\\n# Mixins\\nclass DeviceViewSetMixin:\\n\\tlookup_field = \"registration_id\"\\n\\n\\tdef create(self, request, *args, **kwargs):\\n\\t\\tserializer = None\\n\\t\\tis_update = False\\n\\t\\tif SETTINGS.get(\"UPDATE_ON_DUPLICATE_REG_ID\") and self.lookup_field in request.data:\\n\\t\\t\\tinstance = self.queryset.model.objects.filter(\\n\\t\\t\\t\\tregistration_id=request.data[self.lookup_field]\\n\\t\\t\\t).first()\\n\\t\\t\\tif instance:\\n\\t\\t\\t\\tserializer = self.get_serializer(instance, data=request.data)\\n\\t\\t\\t\\tis_update = True\\n\\t\\tif not serializer:\\n\\t\\t\\tserializer = self.get_serializer(data=request.data)\\n\\n\\t\\tserializer.is_valid(raise_exception=True)\\n\\t\\tif is_update:\\n\\t\\t\\tself.perform_update(serializer)\\n\\t\\t\\treturn Response(serializer.data)\\n\\t\\telse:\\n\\t\\t\\tself.perform_create(serializer)\\n\\t\\t\\theaders = self.get_success_headers(serializer.data)\\n\\t\\t\\treturn Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\\n\\n\\tdef perform_create(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_create(serializer)\\n\\n\\tdef perform_update(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_update(serializer)\\n\\n\\nclass AuthorizedMixin:\\n\\tpermission_classes = (permissions.IsAuthenticated, IsOwner)\\n\\n\\tdef get_queryset(self):\\n\\t\\t# filter all devices to only those belonging to the current user\\n\\t\\treturn self.queryset.filter(user=self.request.user)\\n\\n\\n# ViewSets\\nclass APNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = APNSDevice.objects.all()\\n\\tserializer_class = APNSDeviceSerializer\\n\\n\\nclass APNSDeviceAuthorizedViewSet(AuthorizedMixin, APNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass GCMDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = GCMDevice.objects.all()\\n\\tserializer_class = GCMDeviceSerializer\\n\\n\\nclass GCMDeviceAuthorizedViewSet(AuthorizedMixin, GCMDeviceViewSet):\\n\\tpass\\n\\n\\nclass WNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WNSDevice.objects.all()\\n\\tserializer_class = WNSDeviceSerializer\\n\\n\\nclass WNSDeviceAuthorizedViewSet(AuthorizedMixin, WNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass WebPushDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WebPushDevice.objects.all()\\n\\tserializer_class = WebPushDeviceSerializer\\n\\n\\nclass WebPushDeviceAuthorizedViewSet(AuthorizedMixin, WebPushDeviceViewSet):\\n\\tpass\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/apns.py'"}, "return_value": "'\"\"\"\\nApple Push Notification Service\\nDocumentation is available on the iOS Developer Library:\\nhttps://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html\\n\"\"\"\\n\\nimport time\\n\\nfrom apns2 import client as apns2_client\\nfrom apns2 import credentials as apns2_credentials\\nfrom apns2 import errors as apns2_errors\\nfrom apns2 import payload as apns2_payload\\n\\nfrom . import models\\nfrom .conf import get_manager\\nfrom .exceptions import APNSError, APNSUnsupportedPriority, APNSServerError\\n\\n\\ndef _apns_create_socket(creds=None, application_id=None):\\n\\tif creds is None:\\n\\t\\tif not get_manager().has_auth_token_creds(application_id):\\n\\t\\t\\tcert = get_manager().get_apns_certificate(application_id)\\n\\t\\t\\tcreds = apns2_credentials.CertificateCredentials(cert)\\n\\t\\telse:\\n\\t\\t\\tkeyPath, keyId, teamId = get_manager().get_apns_auth_creds(application_id)\\n\\t\\t\\t# No use getting a lifetime because this credential is\\n\\t\\t\\t# ephemeral, but if you\\'re looking at this to see how to\\n\\t\\t\\t# create a credential, you could also pass the lifetime and\\n\\t\\t\\t# algorithm. Neither of those settings are exposed in the\\n\\t\\t\\t# settings API at the moment.\\n\\t\\t\\tcreds = creds or apns2_credentials.TokenCredentials(keyPath, keyId, teamId)\\n\\tclient = apns2_client.APNsClient(\\n\\t\\tcreds,\\n\\t\\tuse_sandbox=get_manager().get_apns_use_sandbox(application_id),\\n\\t\\tuse_alternative_port=get_manager().get_apns_use_alternative_port(application_id)\\n\\t)\\n\\tclient.connect()\\n\\treturn client\\n\\n\\ndef _apns_prepare(\\n\\ttoken, alert, application_id=None, badge=None, sound=None, category=None,\\n\\tcontent_available=False, action_loc_key=None, loc_key=None, loc_args=[],\\n\\textra={}, mutable_content=False, thread_id=None, url_args=None):\\n\\t\\tif action_loc_key or loc_key or loc_args:\\n\\t\\t\\tapns2_alert = apns2_payload.PayloadAlert(\\n\\t\\t\\t\\tbody=alert if alert else {}, body_localized_key=loc_key,\\n\\t\\t\\t\\tbody_localized_args=loc_args, action_localized_key=action_loc_key)\\n\\t\\telse:\\n\\t\\t\\tapns2_alert = alert\\n\\n\\t\\tif callable(badge):\\n\\t\\t\\tbadge = badge(token)\\n\\n\\t\\treturn apns2_payload.Payload(\\n\\t\\t\\talert=apns2_alert, badge=badge, sound=sound, category=category,\\n\\t\\t\\turl_args=url_args, custom=extra, thread_id=thread_id,\\n\\t\\t\\tcontent_available=content_available, mutable_content=mutable_content)\\n\\n\\ndef _apns_send(\\n\\tregistration_id, alert, batch=False, application_id=None, creds=None, **kwargs\\n):\\n\\tclient = _apns_create_socket(creds=creds, application_id=application_id)\\n\\n\\tnotification_kwargs = {}\\n\\n\\t# if expiration isn\"t specified use 1 month from now\\n\\tnotification_kwargs[\"expiration\"] = kwargs.pop(\"expiration\", None)\\n\\tif not notification_kwargs[\"expiration\"]:\\n\\t\\tnotification_kwargs[\"expiration\"] = int(time.time()) + 2592000\\n\\n\\tpriority = kwargs.pop(\"priority\", None)\\n\\tif priority:\\n\\t\\ttry:\\n\\t\\t\\tnotification_kwargs[\"priority\"] = apns2_client.NotificationPriority(str(priority))\\n\\t\\texcept ValueError:\\n\\t\\t\\traise APNSUnsupportedPriority(\"Unsupported priority %d\" % (priority))\\n\\n\\tnotification_kwargs[\"collapse_id\"] = kwargs.pop(\"collapse_id\", None)\\n\\n\\tif batch:\\n\\t\\tdata = [apns2_client.Notification(\\n\\t\\t\\ttoken=rid, payload=_apns_prepare(rid, alert, **kwargs)) for rid in registration_id]\\n\\t\\t# returns a dictionary mapping each token to its result. That\\n\\t\\t# result is either \"Success\" or the reason for the failure.\\n\\t\\treturn client.send_notification_batch(\\n\\t\\t\\tdata, get_manager().get_apns_topic(application_id=application_id),\\n\\t\\t\\t**notification_kwargs\\n\\t\\t)\\n\\n\\tdata = _apns_prepare(registration_id, alert, **kwargs)\\n\\tclient.send_notification(\\n\\t\\tregistration_id, data,\\n\\t\\tget_manager().get_apns_topic(application_id=application_id),\\n\\t\\t**notification_kwargs\\n\\t)\\n\\n\\ndef apns_send_message(registration_id, alert, application_id=None, creds=None, **kwargs):\\n\\t\"\"\"\\n\\tSends an APNS notification to a single registration_id.\\n\\tThis will send the notification as form data.\\n\\tIf sending multiple notifications, it is more efficient to use\\n\\tapns_send_bulk_message()\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\ttry:\\n\\t\\t_apns_send(\\n\\t\\t\\tregistration_id, alert, application_id=application_id,\\n\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t)\\n\\texcept apns2_errors.APNsException as apns2_exception:\\n\\t\\tif isinstance(apns2_exception, apns2_errors.Unregistered):\\n\\t\\t\\tdevice = models.APNSDevice.objects.get(registration_id=registration_id)\\n\\t\\t\\tdevice.active = False\\n\\t\\t\\tdevice.save()\\n\\n\\t\\traise APNSServerError(status=apns2_exception.__class__.__name__)\\n\\n\\ndef apns_send_bulk_message(\\n\\tregistration_ids, alert, application_id=None, creds=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends an APNS notification to one or more registration_ids.\\n\\tThe registration_ids argument needs to be a list.\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\tresults = _apns_send(\\n\\t\\tregistration_ids, alert, batch=True, application_id=application_id,\\n\\t\\tcreds=creds, **kwargs\\n\\t)\\n\\tinactive_tokens = [token for token, result in results.items() if result == \"Unregistered\"]\\n\\tmodels.APNSDevice.objects.filter(registration_id__in=inactive_tokens).update(active=False)\\n\\treturn results\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/compat.py'"}, "return_value": "'# flake8:noqa\\nfrom urllib.error import HTTPError\\nfrom urllib.parse import urlencode\\nfrom urllib.request import Request, urlopen\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/__init__.py'"}, "return_value": "'from django.utils.module_loading import import_string\\n\\nfrom .app import AppConfig  # noqa: F401\\nfrom .appmodel import AppModelConfig  # noqa: F401\\nfrom .legacy import LegacyConfig  # noqa: F401\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS  # noqa: I001\\n\\n\\nmanager = None\\n\\n\\ndef get_manager(reload=False):\\n\\tglobal manager\\n\\n\\tif not manager or reload is True:\\n\\t\\tmanager = import_string(SETTINGS[\"CONFIG\"])()\\n\\n\\treturn manager\\n\\n\\n# implementing get_manager as a function allows tests to reload settings\\nget_manager()\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/app.py'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig, check_apns_certificate\\n\\n\\nSETTING_MISMATCH = (\\n\\t\"Application \\'{application_id}\\' ({platform}) does not support the setting \\'{setting}\\'.\"\\n)\\n\\n# code can be \"missing\" or \"invalid\"\\nBAD_PLATFORM = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"PLATFORM\"] is {code}. \\'\\n\\t\"Must be one of: {platforms}.\"\\n)\\n\\nUNKNOWN_PLATFORM = (\\n\\t\"Unknown Platform: {platform}. Must be one of: {platforms}.\"\\n)\\n\\nMISSING_SETTING = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"{setting}\"] is missing.\\'\\n)\\n\\nPLATFORMS = [\\n\\t\"APNS\",\\n\\t\"FCM\",\\n\\t\"GCM\",\\n\\t\"WNS\",\\n\\t\"WP\",\\n]\\n\\n# Settings that all applications must have\\nREQUIRED_SETTINGS = [\\n\\t\"PLATFORM\",\\n]\\n\\n# Settings that an application may have to enable optional features\\n# these settings are stubs for registry support and have no effect on the operation\\n# of the application at this time.\\nOPTIONAL_SETTINGS = [\\n\\t\"APPLICATION_GROUP\", \"APPLICATION_SECRET\"\\n]\\n\\n# Since we can have an auth key, combined with a auth key id and team id *or*\\n# a certificate, we make these all optional, and then make sure we have one or\\n# the other (group) of settings.\\nAPNS_SETTINGS_CERT_CREDS = \"CERTIFICATE\"\\n\\n# Subkeys for APNS_SETTINGS_AUTH_CREDS\\nAPNS_AUTH_CREDS_REQUIRED = [\"AUTH_KEY_PATH\", \"AUTH_KEY_ID\", \"TEAM_ID\"]\\nAPNS_AUTH_CREDS_OPTIONAL = [\"CERTIFICATE\", \"ENCRYPTION_ALGORITHM\", \"TOKEN_LIFETIME\"]\\n\\nAPNS_OPTIONAL_SETTINGS = [\\n\\t\"USE_SANDBOX\", \"USE_ALTERNATIVE_PORT\", \"TOPIC\"\\n]\\n\\nFCM_REQUIRED_SETTINGS = GCM_REQUIRED_SETTINGS = [\"API_KEY\"]\\nFCM_OPTIONAL_SETTINGS = GCM_OPTIONAL_SETTINGS = [\\n\\t\"POST_URL\", \"MAX_RECIPIENTS\", \"ERROR_TIMEOUT\"\\n]\\n\\nWNS_REQUIRED_SETTINGS = [\"PACKAGE_SECURITY_ID\", \"SECRET_KEY\"]\\nWNS_OPTIONAL_SETTINGS = [\"WNS_ACCESS_URL\"]\\n\\nWP_REQUIRED_SETTINGS = [\"PRIVATE_KEY\", \"CLAIMS\"]\\nWP_OPTIONAL_SETTINGS = [\"ERROR_TIMEOUT\", \"POST_URL\"]\\n\\n\\nclass AppConfig(BaseConfig):\\n\\t\"\"\"\\n\\tSupports any number of push notification enabled applications.\\n\\t\"\"\"\\n\\n\\tdef __init__(self, settings=None):\\n\\t\\t# supports overriding the settings to be loaded. Will load from ..settings by default.\\n\\t\\tself._settings = settings or SETTINGS\\n\\n\\t\\t# initialize APPLICATIONS to an empty collection\\n\\t\\tself._settings.setdefault(\"APPLICATIONS\", {})\\n\\n\\t\\t# validate application configurations\\n\\t\\tself._validate_applications(self._settings[\"APPLICATIONS\"])\\n\\n\\tdef _validate_applications(self, apps):\\n\\t\\t\"\"\"Validate the application collection\"\"\"\\n\\t\\tfor application_id, application_config in apps.items():\\n\\t\\t\\tself._validate_config(application_id, application_config)\\n\\n\\t\\t\\tapplication_config[\"APPLICATION_ID\"] = application_id\\n\\n\\tdef _validate_config(self, application_id, application_config):\\n\\t\\tplatform = application_config.get(\"PLATFORM\", None)\\n\\n\\t\\t# platform is not present\\n\\t\\tif platform is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"required\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# platform is not a valid choice from PLATFORMS\\n\\t\\tif platform not in PLATFORMS:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"invalid\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\tvalidate_fn = \"_validate_{platform}_config\".format(platform=platform).lower()\\n\\n\\t\\tif hasattr(self, validate_fn):\\n\\t\\t\\tgetattr(self, validate_fn)(application_id, application_config)\\n\\t\\telse:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tUNKNOWN_PLATFORM.format(\\n\\t\\t\\t\\t\\tplatform=platform,\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\tdef _validate_apns_config(self, application_id, application_config):\\n\\t\\tallowed = REQUIRED_SETTINGS + OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\tAPNS_OPTIONAL_SETTINGS\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\t# We have two sets of settings, certificate and JWT auth key.\\n\\t\\t# Auth Key requires 3 values, so if that is set, that will take\\n\\t\\t# precedence. If None are set, we will throw an error.\\n\\t\\thas_cert_creds = APNS_SETTINGS_CERT_CREDS in \\\\\\n\\t\\t\\tapplication_config.keys()\\n\\t\\tself.has_token_creds = True\\n\\t\\tfor token_setting in APNS_AUTH_CREDS_REQUIRED:\\n\\t\\t\\tif token_setting not in application_config.keys():\\n\\t\\t\\t\\tself.has_token_creds = False\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif not has_cert_creds and not self.has_token_creds:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tsetting=(APNS_SETTINGS_CERT_CREDS, APNS_AUTH_CREDS_REQUIRED)))\\n\\t\\tcert_path = None\\n\\t\\tif has_cert_creds:\\n\\t\\t\\tcert_path = \"CERTIFICATE\"\\n\\t\\telif self.has_token_creds:\\n\\t\\t\\tcert_path = \"AUTH_KEY_PATH\"\\n\\t\\t\\tallowed_tokens = APNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\t\\tAPNS_OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\t\\tREQUIRED_SETTINGS\\n\\t\\t\\tself._validate_allowed_settings(application_id, application_config, allowed_tokens)\\n\\t\\t\\tself._validate_required_settings(\\n\\t\\t\\t\\tapplication_id, application_config, APNS_AUTH_CREDS_REQUIRED\\n\\t\\t\\t)\\n\\t\\tself._validate_apns_certificate(application_config[cert_path])\\n\\n\\t\\t# determine/set optional values\\n\\t\\tapplication_config.setdefault(\"USE_SANDBOX\", False)\\n\\t\\tapplication_config.setdefault(\"USE_ALTERNATIVE_PORT\", False)\\n\\t\\tapplication_config.setdefault(\"TOPIC\", None)\\n\\n\\tdef _validate_apns_certificate(self, certfile):\\n\\t\\t\"\"\"Validate the APNS certificate at startup.\"\"\"\\n\\n\\t\\ttry:\\n\\t\\t\\twith open(certfile, \"r\") as f:\\n\\t\\t\\t\\tcontent = f.read()\\n\\t\\t\\t\\tcheck_apns_certificate(content)\\n\\t\\texcept Exception as e:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"The APNS certificate file at {!r} is not readable: {}\".format(certfile, e)\\n\\t\\t\\t)\\n\\n\\tdef _validate_fcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + FCM_REQUIRED_SETTINGS + FCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, FCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://fcm.googleapis.com/fcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_gcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + GCM_REQUIRED_SETTINGS + GCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, GCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://android.googleapis.com/gcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_wns_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WNS_REQUIRED_SETTINGS + WNS_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WNS_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\")\\n\\n\\tdef _validate_wp_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WP_REQUIRED_SETTINGS + WP_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WP_REQUIRED_SETTINGS\\n\\t\\t)\\n\\t\\tapplication_config.setdefault(\"POST_URL\", {\\n\\t\\t\\t\"CHROME\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"OPERA\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n\\t\\t\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\\t})\\n\\n\\tdef _validate_allowed_settings(self, application_id, application_config, allowed_settings):\\n\\t\\t\"\"\"Confirm only allowed settings are present.\"\"\"\\n\\n\\t\\tfor setting_key in application_config.keys():\\n\\t\\t\\tif setting_key not in allowed_settings:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"Platform {}, app {} does not support the setting: {}.\".format(\\n\\t\\t\\t\\t\\t\\tapplication_config[\"PLATFORM\"], application_id, setting_key\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\n\\tdef _validate_required_settings(\\n\\t\\tself, application_id, application_config, required_settings,\\n\\t\\tshould_throw=True\\n\\t):\\n\\t\\t\"\"\"All required keys must be present\"\"\"\\n\\n\\t\\tfor setting_key in required_settings:\\n\\t\\t\\tif setting_key not in application_config.keys():\\n\\t\\t\\t\\tif should_throw:\\n\\t\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\t\\t\\tapplication_id=application_id, setting=setting_key\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tdef _get_application_settings(self, application_id, platform, settings_key):\\n\\t\\t\"\"\"\\n\\t\\tWalks through PUSH_NOTIFICATIONS_SETTINGS to find the correct setting value\\n\\t\\tor raises ImproperlyConfigured.\\n\\t\\t\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tconf_cls = \"push_notifications.conf.AppConfig\"\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"{} requires the application_id be specified at all times.\".format(conf_cls)\\n\\t\\t\\t)\\n\\n\\t\\t# verify that the application config exists\\n\\t\\tapp_config = self._settings.get(\"APPLICATIONS\").get(application_id, None)\\n\\t\\tif app_config is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"No application configured with application_id: {}.\".format(application_id)\\n\\t\\t\\t)\\n\\n\\t\\t# fetch a setting for the incorrect type of platform\\n\\t\\tif app_config.get(\"PLATFORM\") != platform:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tSETTING_MISMATCH.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tplatform=app_config.get(\"PLATFORM\"),\\n\\t\\t\\t\\t\\tsetting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# finally, try to fetch the setting\\n\\t\\tif settings_key not in app_config:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id, setting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\treturn app_config.get(settings_key)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\treturn self.has_token_creds\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"GCM\", \"API_KEY\")\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"FCM\", \"API_KEY\")\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"POST_URL\")\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"ERROR_TIMEOUT\")\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"MAX_RECIPIENTS\")\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(application_id, \"APNS\", \"CERTIFICATE\")\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn \\\\\\n\\t\\t(self._get_apns_auth_key_path(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key_path(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_PATH\")\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_ID\")\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TEAM_ID\")\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_SANDBOX\")\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_ALTERNATIVE_PORT\")\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TOPIC\")\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"PACKAGE_SECURITY_ID\")\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"SECRET_KEY\")\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"POST_URL\")[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"PRIVATE_KEY\")\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"CLAIMS\")\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/appmodel.py'"}, "return_value": "'from .base import BaseConfig\\n\\n\\nclass AppModelConfig(BaseConfig):\\n\\t\"\"\"Future home of the Application Model conf adapter\\n\\n\\tSupports multiple applications in the database.\\n\\t\"\"\"\\n\\n\\tpass\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/base.py'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\n\\nclass BaseConfig:\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_applications(self):\\n\\t\\t\"\"\"Returns a collection containing the configured applications.\"\"\"\\n\\n\\t\\traise NotImplementedError\\n\\n\\n# This works for both the certificate and the auth key (since that\\'s just\\n# a certificate).\\ndef check_apns_certificate(ss):\\n\\tmode = \"start\"\\n\\tfor s in ss.split(\"\\\\n\"):\\n\\t\\tif mode == \"start\":\\n\\t\\t\\tif \"BEGIN RSA PRIVATE KEY\" in s or \"BEGIN PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"key\"\\n\\t\\telif mode == \"key\":\\n\\t\\t\\tif \"END RSA PRIVATE KEY\" in s or \"END PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"end\"\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif s.startswith(\"Proc-Type\") and \"ENCRYPTED\" in s:\\n\\t\\t\\t\\traise ImproperlyConfigured(\"Encrypted APNS private keys are not supported\")\\n\\n\\tif mode != \"end\":\\n\\t\\traise ImproperlyConfigured(\"The APNS certificate doesn\\'t contain a private key\")\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/conf/legacy.py'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig\\n\\n\\n__all__ = [\\n\\t\"LegacyConfig\"\\n]\\n\\n\\nclass empty:\\n\\tpass\\n\\n\\nclass LegacyConfig(BaseConfig):\\n\\n\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\n\\tdef _get_application_settings(self, application_id, settings_key, error_message):\\n\\t\\t\"\"\"Legacy behaviour\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tvalue = SETTINGS.get(settings_key, empty)\\n\\t\\t\\tif value is empty:\\n\\t\\t\\t\\traise ImproperlyConfigured(error_message)\\n\\t\\t\\treturn value\\n\\t\\telse:\\n\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\"LegacySettings does not support application_id. To enable \"\\n\\t\\t\\t\\t\"multiple application support, use push_notifications.conf.AppSettings.\"\\n\\t\\t\\t)\\n\\t\\t\\traise ImproperlyConfigured(msg)\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"GCM_API_KEY\"] to send messages through GCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"GCM_API_KEY\", msg)\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"FCM_API_KEY\"] to send messages through FCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"FCM_API_KEY\", msg)\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_POST_URL\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_ERROR_TIMEOUT\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_MAX_RECIPIENTS\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\ttry:\\n\\t\\t\\tself._get_apns_auth_key(application_id)\\n\\t\\t\\tself._get_apns_auth_key_id(application_id)\\n\\t\\t\\tself._get_apns_team_id(application_id)\\n\\t\\texcept ImproperlyConfigured:\\n\\t\\t\\treturn False\\n\\n\\t\\treturn True\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(\\n\\t\\t\\tapplication_id, \"APNS_CERTIFICATE\",\\n\\t\\t\\t\"You need to setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\t)\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\traise ImproperlyConfigured(msg)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn (\\n\\t\\t\\tself._get_apns_auth_key(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_PATH\", self.msg)\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TEAM_ID\", self.msg)\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_ID\", self.msg)\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_USE_SANDBOX\", self.msg)\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn\\n\\t\\tself._get_application_settings(application_id, \"APNS_USE_ALTERNATIVE_PORT\", self.msg)\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TOPIC\", self.msg)\\n\\n\\tdef get_apns_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_HOST\", self.msg)\\n\\n\\tdef get_apns_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_PORT\", self.msg)\\n\\n\\tdef get_apns_feedback_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_HOST\", self.msg)\\n\\n\\tdef get_apns_feedback_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_PORT\", self.msg)\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_PACKAGE_SECURITY_ID\", self.msg)\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_SECRET_KEY\", msg)\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_POST_URL\", msg)[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_PRIVATE_KEY\", msg)\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_CLAIMS\", msg)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/exceptions.py'"}, "return_value": "'class NotificationError(Exception):\\n\\tpass\\n\\n\\n# APNS\\nclass APNSError(NotificationError):\\n\\tpass\\n\\n\\nclass APNSUnsupportedPriority(APNSError):\\n\\tpass\\n\\n\\nclass APNSServerError(APNSError):\\n\\tdef __init__(self, status):\\n\\t\\tsuper().__init__(status)\\n\\t\\tself.status = status\\n\\n\\n# GCM\\nclass GCMError(NotificationError):\\n\\tpass\\n\\n\\n# Web Push\\nclass WebPushError(NotificationError):\\n\\tpass\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/fields.py'"}, "return_value": "'import re\\nimport struct\\n\\nfrom django import forms\\nfrom django.core.validators import MaxValueValidator, MinValueValidator, RegexValidator\\nfrom django.db import connection, models\\nfrom django.utils.translation import gettext_lazy as _\\n\\n\\n__all__ = [\"HexadecimalField\", \"HexIntegerField\"]\\n\\nUNSIGNED_64BIT_INT_MIN_VALUE = 0\\nUNSIGNED_64BIT_INT_MAX_VALUE = 2 ** 64 - 1\\n\\n\\nhex_re = re.compile(r\"^(([0-9A-f])|(0x[0-9A-f]))+$\")\\nsigned_integer_vendors = [\\n\\t\"postgresql\",\\n\\t\"sqlite\",\\n]\\n\\n\\ndef _using_signed_storage():\\n\\treturn connection.vendor in signed_integer_vendors\\n\\n\\ndef _signed_to_unsigned_integer(value):\\n\\treturn struct.unpack(\"Q\", struct.pack(\"q\", value))[0]\\n\\n\\ndef _unsigned_to_signed_integer(value):\\n\\treturn struct.unpack(\"q\", struct.pack(\"Q\", value))[0]\\n\\n\\ndef _hex_string_to_unsigned_integer(value):\\n\\treturn int(value, 16)\\n\\n\\ndef _unsigned_integer_to_hex_string(value):\\n\\treturn hex(value).rstrip(\"L\")\\n\\n\\nclass HexadecimalField(forms.CharField):\\n\\t\"\"\"\\n\\tA form field that accepts only hexadecimal numbers\\n\\t\"\"\"\\n\\tdef __init__(self, *args, **kwargs):\\n\\t\\tself.default_validators = [\\n\\t\\t\\tRegexValidator(hex_re, _(\"Enter a valid hexadecimal number\"), \"invalid\")\\n\\t\\t]\\n\\t\\tsuper(HexadecimalField, self).__init__(*args, **kwargs)\\n\\n\\tdef prepare_value(self, value):\\n\\t\\t# converts bigint from db to hex before it is displayed in admin\\n\\t\\tif value and not isinstance(value, str) \\\\\\n\\t\\t\\tand connection.vendor in (\"mysql\", \"sqlite\"):\\n\\t\\t\\tvalue = _unsigned_integer_to_hex_string(value)\\n\\t\\treturn super(forms.CharField, self).prepare_value(value)\\n\\n\\nclass HexIntegerField(models.BigIntegerField):\\n\\t\"\"\"\\n\\tThis field stores a hexadecimal *string* of up to 64 bits as an unsigned integer\\n\\ton *all* backends including postgres.\\n\\n\\tReasoning: Postgres only supports signed bigints. Since we don\\'t care about\\n\\tsignedness, we store it as signed, and cast it to unsigned when we deal with\\n\\tthe actual value (with struct)\\n\\n\\tOn sqlite and mysql, native unsigned bigint types are used. In all cases, the\\n\\tvalue we deal with in python is always in hex.\\n\\t\"\"\"\\n\\n\\tvalidators = [\\n\\t\\tMinValueValidator(UNSIGNED_64BIT_INT_MIN_VALUE),\\n\\t\\tMaxValueValidator(UNSIGNED_64BIT_INT_MAX_VALUE)\\n\\t]\\n\\n\\tdef db_type(self, connection):\\n\\t\\tif \"mysql\" == connection.vendor:\\n\\t\\t\\treturn \"bigint unsigned\"\\n\\t\\telif \"sqlite\" == connection.vendor:\\n\\t\\t\\treturn \"UNSIGNED BIG INT\"\\n\\t\\telse:\\n\\t\\t\\treturn super(HexIntegerField, self).db_type(connection=connection)\\n\\n\\tdef get_prep_value(self, value):\\n\\t\\t\"\"\" Return the integer value to be stored from the hex string \"\"\"\\n\\t\\tif value is None or value == \"\":\\n\\t\\t\\treturn None\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _unsigned_to_signed_integer(value)\\n\\t\\treturn value\\n\\n\\tdef from_db_value(self, value, *args):\\n\\t\\t\"\"\" Return an unsigned int representation from all db backends \"\"\"\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _signed_to_unsigned_integer(value)\\n\\t\\treturn value\\n\\n\\tdef to_python(self, value):\\n\\t\\t\"\"\" Return a str representation of the hexadecimal \"\"\"\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\treturn value\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\treturn _unsigned_integer_to_hex_string(value)\\n\\n\\tdef formfield(self, **kwargs):\\n\\t\\tdefaults = {\"form_class\": HexadecimalField}\\n\\t\\tdefaults.update(kwargs)\\n\\t\\t# yes, that super call is right\\n\\t\\treturn super(models.IntegerField, self).formfield(**defaults)\\n\\n\\tdef run_validators(self, value):\\n\\t\\t# make sure validation is performed on integer value not string value\\n\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\treturn super(models.BigIntegerField, self).run_validators(value)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/gcm.py'"}, "return_value": "'\"\"\"\\nFirebase Cloud Messaging\\nPreviously known as GCM / C2DM\\nDocumentation is available on the Firebase Developer website:\\nhttps://firebase.google.com/docs/cloud-messaging/\\n\"\"\"\\n\\nimport json\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import Request, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import GCMError\\nfrom .models import GCMDevice\\n\\n\\n# Valid keys for FCM messages. Reference:\\n# https://firebase.google.com/docs/cloud-messaging/http-server-ref\\nFCM_TARGETS_KEYS = [\\n\\t\"to\", \"condition\", \"notification_key\"\\n]\\nFCM_OPTIONS_KEYS = [\\n\\t\"collapse_key\", \"priority\", \"content_available\", \"delay_while_idle\", \"time_to_live\",\\n\\t\"restricted_package_name\", \"dry_run\", \"mutable_content\"\\n]\\nFCM_NOTIFICATIONS_PAYLOAD_KEYS = [\\n\\t\"title\", \"body\", \"icon\", \"image\", \"sound\", \"badge\", \"color\", \"tag\", \"click_action\",\\n\\t\"body_loc_key\", \"body_loc_args\", \"title_loc_key\", \"title_loc_args\", \"android_channel_id\"\\n]\\n\\ndef _chunks(l, n):\\n\\t\"\"\"\\n\\tYield successive chunks from list \\\\a l with a minimum size \\\\a n\\n\\t\"\"\"\\n\\tfor i in range(0, len(l), n):\\n\\t\\tyield l[i:i + n]\\n\\n\\ndef _gcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_gcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"GCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"GCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _fcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_fcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"FCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"FCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _cm_handle_response(registration_ids, response_data, cloud_type, application_id=None):\\n\\tresponse = response_data\\n\\tif response.get(\"failure\") or response.get(\"canonical_ids\"):\\n\\t\\tids_to_remove, old_new_ids = [], []\\n\\t\\tthrow_error = False\\n\\t\\tfor index, result in enumerate(response[\"results\"]):\\n\\t\\t\\terror = result.get(\"error\")\\n\\t\\t\\tif error:\\n\\t\\t\\t\\t# https://firebase.google.com/docs/cloud-messaging/http-server-ref#error-codes\\n\\t\\t\\t\\t# If error is NotRegistered or InvalidRegistration, then we will deactivate devices\\n\\t\\t\\t\\t# because this registration ID is no more valid and can\\'t be used to send messages,\\n\\t\\t\\t\\t# otherwise raise error\\n\\t\\t\\t\\tif error in (\"NotRegistered\", \"InvalidRegistration\"):\\n\\t\\t\\t\\t\\tids_to_remove.append(registration_ids[index])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tthrow_error = True\\n\\t\\t\\tresult[\"original_registration_id\"] = registration_ids[index]\\n\\t\\t\\t# If registration_id is set, replace the original ID with the new value (canonical ID)\\n\\t\\t\\t# in your server database. Note that the original ID is not part of the result, you need\\n\\t\\t\\t# to obtain it from the list of registration_ids in the request (using the same index).\\n\\t\\t\\tnew_id = result.get(\"registration_id\")\\n\\t\\t\\tif new_id:\\n\\t\\t\\t\\told_new_ids.append((registration_ids[index], new_id))\\n\\n\\t\\tif ids_to_remove:\\n\\t\\t\\tremoved = GCMDevice.objects.filter(\\n\\t\\t\\t\\tregistration_id__in=ids_to_remove, cloud_message_type=cloud_type\\n\\t\\t\\t)\\n\\t\\t\\tremoved.update(active=False)\\n\\n\\t\\tfor old_id, new_id in old_new_ids:\\n\\t\\t\\t_cm_handle_canonical_id(new_id, old_id, cloud_type)\\n\\n\\t\\tif throw_error:\\n\\t\\t\\traise GCMError(response)\\n\\treturn response\\n\\n\\ndef _cm_send_request(\\n\\tregistration_ids, data, cloud_type=\"GCM\", application_id=None,\\n\\tuse_fcm_notifications=True, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a FCM or GCM notification to one or more registration_ids as json data.\\n\\tThe registration_ids needs to be a list.\\n\\t\"\"\"\\n\\n\\tpayload = {\"registration_ids\": registration_ids} if registration_ids else {}\\n\\n\\tdata = data.copy()\\n\\n\\t# If using FCM, optionally autodiscovers notification related keys\\n\\t# https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages\\n\\tif cloud_type == \"FCM\" and use_fcm_notifications:\\n\\t\\tnotification_payload = {}\\n\\t\\tif \"message\" in data:\\n\\t\\t\\tnotification_payload[\"body\"] = data.pop(\"message\", None)\\n\\n\\t\\tfor key in FCM_NOTIFICATIONS_PAYLOAD_KEYS:\\n\\t\\t\\tvalue_from_extra = data.pop(key, None)\\n\\t\\t\\tif value_from_extra:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_extra\\n\\t\\t\\tvalue_from_kwargs = kwargs.pop(key, None)\\n\\t\\t\\tif value_from_kwargs:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_kwargs\\n\\t\\tif notification_payload:\\n\\t\\t\\tpayload[\"notification\"] = notification_payload\\n\\n\\tif data:\\n\\t\\tpayload[\"data\"] = data\\n\\n\\t# Attach any additional non falsy keyword args (targets, options)\\n\\t# See ref : https://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\tpayload.update({\\n\\t\\tk: v for k, v in kwargs.items() if v and (k in FCM_TARGETS_KEYS or k in FCM_OPTIONS_KEYS)\\n\\t})\\n\\n\\t# Sort the keys for deterministic output (useful for tests)\\n\\tjson_payload = json.dumps(payload, separators=(\",\", \":\"), sort_keys=True).encode(\"utf-8\")\\n\\n\\t# Sends requests and handles the response\\n\\tif cloud_type == \"GCM\":\\n\\t\\tresponse = json.loads(_gcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telif cloud_type == \"FCM\":\\n\\t\\tresponse = json.loads(_fcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\treturn _cm_handle_response(registration_ids, response, cloud_type, application_id)\\n\\n\\ndef _cm_handle_canonical_id(canonical_id, current_id, cloud_type):\\n\\t\"\"\"\\n\\tHandle situation when FCM server response contains canonical ID\\n\\t\"\"\"\\n\\tdevices = GCMDevice.objects.filter(cloud_message_type=cloud_type)\\n\\tif devices.filter(registration_id=canonical_id, active=True).exists():\\n\\t\\tdevices.filter(registration_id=current_id).update(active=False)\\n\\telse:\\n\\t\\tdevices.filter(registration_id=current_id).update(registration_id=canonical_id)\\n\\n\\ndef send_message(registration_ids, data, cloud_type, application_id=None, **kwargs):\\n\\t\"\"\"\\n\\tSends a FCM (or GCM) notification to one or more registration_ids. The registration_ids\\n\\tcan be a list or a single string. This will send the notification as json data.\\n\\n\\tA reference of extra keyword arguments sent to the server is available here:\\n\\thttps://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\t\"\"\"\\n\\tif cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\tmax_recipients = get_manager().get_max_recipients(cloud_type, application_id)\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\n\\t# Checks for valid recipient\\n\\tif registration_ids is None and \"/topics/\" not in kwargs.get(\"to\", \"\"):\\n\\t\\treturn\\n\\n\\t# Bundles the registration_ids in an list if only one is sent\\n\\tif not isinstance(registration_ids, list):\\n\\t\\tregistration_ids = [registration_ids] if registration_ids else None\\n\\n\\t# FCM only allows up to 1000 reg ids per bulk message\\n\\t# https://firebase.google.com/docs/cloud-messaging/server#http-request\\n\\tif registration_ids:\\n\\t\\tret = []\\n\\t\\tfor chunk in _chunks(registration_ids, max_recipients):\\n\\t\\t\\tret.append(_cm_send_request(\\n\\t\\t\\t\\tchunk, data, cloud_type=cloud_type, application_id=application_id, **kwargs\\n\\t\\t\\t))\\n\\t\\treturn ret[0] if len(ret) == 1 else ret\\n\\telse:\\n\\t\\treturn _cm_send_request(None, data, cloud_type=cloud_type, **kwargs)\\n\\n\\nsend_bulk_message = send_message\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0001_initial.py'"}, "return_value": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\nimport push_notifications.fields\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='APNSDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', models.UUIDField(help_text='UDID / UIDevice.identifierForVendor()', max_length=32, null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.CharField(unique=True, max_length=64, verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'APNS device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n        migrations.CreateModel(\\n            name='GCMDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', push_notifications.fields.HexIntegerField(help_text='ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)', null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'GCM device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0002_auto_20160106_0850.py'"}, "return_value": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.1 on 2016-01-06 08:50\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0001_initial'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=True, verbose_name='Registration ID'),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0003_wnsdevice.py'"}, "return_value": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nimport django.db.models.deletion\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0002_auto_20160106_0850'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WNSDevice',\\n            fields=[\\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\\n                ('name', models.CharField(blank=True, max_length=255, null=True, verbose_name='Name')),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, null=True, verbose_name='Creation date')),\\n                ('device_id', models.UUIDField(blank=True, db_index=True, help_text='GUID()', null=True, verbose_name='Device ID')),\\n                ('registration_id', models.TextField(verbose_name='Notification URI')),\\n                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\\n            ],\\n            options={\\n                'verbose_name': 'WNS device',\\n            },\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0004_fcm.py'"}, "return_value": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n\\tdependencies = [\\n\\t\\tmigrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n\\t\\t('push_notifications', '0003_wnsdevice'),\\n\\t]\\n\\n\\toperations = [\\n\\t\\tmigrations.AddField(\\n\\t\\t\\tmodel_name='gcmdevice',\\n\\t\\t\\tname='cloud_message_type',\\n\\t\\t\\tfield=models.CharField(choices=[('FCM', 'Firebase Cloud Message'), ('GCM', 'Google Cloud Message')], default='GCM', help_text='You should choose FCM or GCM', max_length=3, verbose_name='Cloud Message Type')\\n\\t\\t),\\n\\t]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0005_applicationid.py'"}, "return_value": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0004_fcm'),\\n    ]\\n\\n    operations = [\\n        migrations.AddField(\\n            model_name='apnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='gcmdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='wnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0006_webpushdevice.py'"}, "return_value": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0005_applicationid'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WebPushDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('application_id', models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('p256dh', models.CharField(max_length=88, verbose_name='User public encryption key')),\\n                ('auth', models.CharField(max_length=24, verbose_name='User auth secret')),\\n                ('browser', models.CharField(default='CHROME', help_text='Currently only support to Chrome, Firefox and Opera browsers', max_length=10, verbose_name='Browser', choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera')])),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'WebPush device',\\n            },\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0007_uniquesetting.py'"}, "return_value": "\"from django.db import migrations, models\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0006_webpushdevice'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='gcmdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='wnsdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Notification URI'),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0008_webpush_add_edge.py'"}, "return_value": "\"# Generated by Django 3.2.8 on 2021-11-12 09:49\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0007_uniquesetting'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='browser',\\n            field=models.CharField(choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera'), ('EDGE', 'Edge')], default='CHROME', help_text='Currently only support to Chrome, Firefox, Edge and Opera browsers', max_length=10, verbose_name='Browser'),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/0009_alter_apnsdevice_device_id.py'"}, "return_value": "\"# Generated by Django 3.2.9 on 2022-01-10 09:03\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0008_webpush_add_edge'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='device_id',\\n            field=models.UUIDField(blank=True, db_index=True, help_text='UUID / UIDevice.identifierForVendor()', null=True, verbose_name='Device ID'),\\n        ),\\n    ]\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/migrations/__init__.py'"}, "return_value": "''"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/models.py'"}, "return_value": "'from django.db import models\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .fields import HexIntegerField\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nCLOUD_MESSAGE_TYPES = (\\n\\t(\"FCM\", \"Firebase Cloud Message\"),\\n\\t(\"GCM\", \"Google Cloud Message\"),\\n)\\n\\nBROWSER_TYPES = (\\n\\t(\"CHROME\", \"Chrome\"),\\n\\t(\"FIREFOX\", \"Firefox\"),\\n\\t(\"OPERA\", \"Opera\"),\\n\\t(\"EDGE\", \"Edge\")\\n)\\n\\n\\nclass Device(models.Model):\\n\\tname = models.CharField(max_length=255, verbose_name=_(\"Name\"), blank=True, null=True)\\n\\tactive = models.BooleanField(\\n\\t\\tverbose_name=_(\"Is active\"), default=True,\\n\\t\\thelp_text=_(\"Inactive devices will not be sent notifications\")\\n\\t)\\n\\tuser = models.ForeignKey(\\n\\t\\tSETTINGS[\"USER_MODEL\"], blank=True, null=True, on_delete=models.CASCADE\\n\\t)\\n\\tdate_created = models.DateTimeField(\\n\\t\\tverbose_name=_(\"Creation date\"), auto_now_add=True, null=True\\n\\t)\\n\\tapplication_id = models.CharField(\\n\\t\\tmax_length=64, verbose_name=_(\"Application ID\"),\\n\\t\\thelp_text=_(\\n\\t\\t\\t\"Opaque application identity, should be filled in for multiple\"\\n\\t\\t\\t\" key/certificate access\"\\n\\t\\t),\\n\\t\\tblank=True, null=True\\n\\t)\\n\\n\\tclass Meta:\\n\\t\\tabstract = True\\n\\n\\tdef __str__(self):\\n\\t\\treturn (\\n\\t\\t\\tself.name or\\n\\t\\t\\tstr(self.device_id or \"\") or\\n\\t\\t\\t\"{} for {}\".format(self.__class__.__name__, self.user or \"unknown user\")\\n\\t\\t)\\n\\n\\nclass GCMDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn GCMDeviceQuerySet(self.model)\\n\\n\\nclass GCMDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\t\\tif message is not None:\\n\\t\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\\n\\t\\t\\t\\t\"application_id\"\\n\\t\\t\\t).values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tresponse = []\\n\\t\\t\\tfor cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\t\\treg_ids = list(\\n\\t\\t\\t\\t\\t\\tself.filter(\\n\\t\\t\\t\\t\\t\\t\\tactive=True, cloud_message_type=cloud_type, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\tif reg_ids:\\n\\t\\t\\t\\t\\t\\tr = gcm_send_message(reg_ids, data, cloud_type, application_id=app_id, **kwargs)\\n\\t\\t\\t\\t\\t\\tresponse.append(r)\\n\\n\\t\\t\\treturn response\\n\\n\\nclass GCMDevice(Device):\\n\\t# device_id cannot be a reliable primary key as fragmentation between different devices\\n\\t# can make it turn out to be null and such:\\n\\t# http://android-developers.blogspot.co.uk/2011/03/identifying-app-installations.html\\n\\tdevice_id = HexIntegerField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tcloud_message_type = models.CharField(\\n\\t\\tverbose_name=_(\"Cloud Message Type\"), max_length=3,\\n\\t\\tchoices=CLOUD_MESSAGE_TYPES, default=\"GCM\",\\n\\t\\thelp_text=_(\"You should choose FCM or GCM\")\\n\\t)\\n\\tobjects = GCMDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"GCM device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\tif message is not None:\\n\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\treturn gcm_send_message(\\n\\t\\t\\tself.registration_id, data, self.cloud_message_type,\\n\\t\\t\\tapplication_id=self.application_id, **kwargs\\n\\t\\t)\\n\\n\\nclass APNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn APNSDeviceQuerySet(self.model)\\n\\n\\nclass APNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .apns import apns_send_bulk_message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\")\\\\\\n\\t\\t\\t\\t.values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tres = []\\n\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\treg_ids = list(self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\"registration_id\", flat=True)\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tr = apns_send_bulk_message(\\n\\t\\t\\t\\t\\tregistration_ids=reg_ids, alert=message, application_id=app_id,\\n\\t\\t\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\t\\tres += [r]\\n\\t\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\t\\tres += r\\n\\t\\t\\treturn res\\n\\n\\nclass APNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"UUID / UIDevice.identifierForVendor()\")\\n\\t)\\n\\tregistration_id = models.CharField(\\n\\t\\tverbose_name=_(\"Registration ID\"), max_length=200, unique=SETTINGS[\"UNIQUE_REG_ID\"]\\n\\t)\\n\\n\\tobjects = APNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"APNS device\")\\n\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tfrom .apns import apns_send_message\\n\\n\\t\\treturn apns_send_message(\\n\\t\\t\\tregistration_id=self.registration_id,\\n\\t\\t\\talert=message,\\n\\t\\t\\tapplication_id=self.application_id, creds=creds,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WNSDeviceQuerySet(self.model)\\n\\n\\nclass WNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_bulk_message\\n\\n\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\").values_list(\\n\\t\\t\\t\"application_id\", flat=True\\n\\t\\t).distinct()\\n\\t\\tres = []\\n\\t\\tfor app_id in app_ids:\\n\\t\\t\\treg_ids = self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t)\\n\\t\\t\\tr = wns_send_bulk_message(uri_list=list(reg_ids), message=message, **kwargs)\\n\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\tres += [r]\\n\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\tres += r\\n\\n\\t\\treturn res\\n\\n\\nclass WNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"GUID()\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Notification URI\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\n\\tobjects = WNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WNS device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_message\\n\\n\\t\\treturn wns_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, application_id=self.application_id,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WebPushDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WebPushDeviceQuerySet(self.model)\\n\\n\\nclass WebPushDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tdevices = self.filter(active=True).order_by(\"application_id\").distinct()\\n\\t\\tres = []\\n\\t\\tfor device in devices:\\n\\t\\t\\tres.append(device.send_message(message))\\n\\n\\t\\treturn res\\n\\n\\nclass WebPushDevice(Device):\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tp256dh = models.CharField(\\n\\t\\tverbose_name=_(\"User public encryption key\"),\\n\\t\\tmax_length=88)\\n\\tauth = models.CharField(\\n\\t\\tverbose_name=_(\"User auth secret\"),\\n\\t\\tmax_length=24)\\n\\tbrowser = models.CharField(\\n\\t\\tverbose_name=_(\"Browser\"), max_length=10,\\n\\t\\tchoices=BROWSER_TYPES, default=BROWSER_TYPES[0][0],\\n\\t\\thelp_text=_(\"Currently only support to Chrome, Firefox, Edge and Opera browsers\")\\n\\t)\\n\\tobjects = WebPushDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WebPush device\")\\n\\n\\t@property\\n\\tdef device_id(self):\\n\\t\\treturn None\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .webpush import webpush_send_message\\n\\n\\t\\treturn webpush_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, browser=self.browser,\\n\\t\\t\\tauth=self.auth, p256dh=self.p256dh, application_id=self.application_id, **kwargs)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/settings.py'"}, "return_value": "'from django.conf import settings\\n\\n\\nPUSH_NOTIFICATIONS_SETTINGS = getattr(settings, \"PUSH_NOTIFICATIONS_SETTINGS\", {})\\n\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"CONFIG\", \"push_notifications.conf.LegacyConfig\"\\n)\\n\\n# GCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"GCM_POST_URL\", \"https://android.googleapis.com/gcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_ERROR_TIMEOUT\", None)\\n\\n# FCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"FCM_POST_URL\", \"https://fcm.googleapis.com/fcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_ERROR_TIMEOUT\", None)\\n\\n# APNS\\nif settings.DEBUG:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", True)\\nelse:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_ALTERNATIVE_PORT\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_TOPIC\", None)\\n\\n# WNS\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_PACKAGE_SECURITY_ID\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_SECRET_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\"\\n)\\n\\n# WP (WebPush)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_POST_URL\", {\\n\\t\"CHROME\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"OPERA\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n})\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_PRIVATE_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_CLAIMS\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_ERROR_TIMEOUT\", None)\\n\\n# User model\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"USER_MODEL\", settings.AUTH_USER_MODEL)\\n\\n# Unique registration ID for all devices\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UNIQUE_REG_ID\", False)\\n\\n# API endpoint settings\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UPDATE_ON_DUPLICATE_REG_ID\", False)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/webpush.py'"}, "return_value": "'from pywebpush import WebPushException, webpush\\n\\nfrom .conf import get_manager\\nfrom .exceptions import WebPushError\\n\\n\\ndef get_subscription_info(application_id, uri, browser, auth, p256dh):\\n\\turl = get_manager().get_wp_post_url(application_id, browser)\\n\\treturn {\\n\\t\\t\"endpoint\": \"{}/{}\".format(url, uri),\\n\\t\\t\"keys\": {\\n\\t\\t\\t\"auth\": auth,\\n\\t\\t\\t\"p256dh\": p256dh,\\n\\t\\t}\\n\\t}\\n\\n\\ndef webpush_send_message(\\n\\turi, message, browser, auth, p256dh, application_id=None, **kwargs\\n):\\n\\tsubscription_info = get_subscription_info(application_id, uri, browser, auth, p256dh)\\n\\n\\ttry:\\n\\t\\tresponse = webpush(\\n\\t\\t\\tsubscription_info=subscription_info,\\n\\t\\t\\tdata=message,\\n\\t\\t\\tvapid_private_key=get_manager().get_wp_private_key(application_id),\\n\\t\\t\\tvapid_claims=get_manager().get_wp_claims(application_id).copy(),\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\t\\tresults = {\"results\": [{}]}\\n\\t\\tif not response.ok:\\n\\t\\t\\tresults[\"results\"][0][\"error\"] = response.content\\n\\t\\t\\tresults[\"results\"][0][\"original_registration_id\"] = response.content\\n\\t\\telse:\\n\\t\\t\\tresults[\"success\"] = 1\\n\\t\\treturn results\\n\\texcept WebPushException as e:\\n\\t\\traise WebPushError(e.message)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-push-notifications/push_notifications/wns.py'"}, "return_value": "'\"\"\"\\nWindows Notification Service\\n\\nDocumentation is available on the Windows Dev Center:\\nhttps://msdn.microsoft.com/en-us/windows/uwp/controls-and-patterns/tiles-and-notifications-windows-push-notification-services--wns--overview\\n\"\"\"\\n\\nimport json\\nimport xml.etree.ElementTree as ET\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import HTTPError, Request, urlencode, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import NotificationError\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass WNSError(NotificationError):\\n\\tpass\\n\\n\\nclass WNSAuthenticationError(WNSError):\\n\\tpass\\n\\n\\nclass WNSNotificationResponseError(WNSError):\\n\\tpass\\n\\n\\ndef _wns_authenticate(scope=\"notify.windows.com\", application_id=None):\\n\\t\"\"\"\\n\\tRequests an Access token for WNS communication.\\n\\n\\t:return: dict: {\\'access_token\\': <str>, \\'expires_in\\': <int>, \\'token_type\\': \\'bearer\\'}\\n\\t\"\"\"\\n\\tclient_id = get_manager().get_wns_package_security_id(application_id)\\n\\tclient_secret = get_manager().get_wns_secret_key(application_id)\\n\\tif not client_id:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_PACKAGE_SECURITY_ID\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\tif not client_secret:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_SECRET_KEY\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": \"application/x-www-form-urlencoded\",\\n\\t}\\n\\tparams = {\\n\\t\\t\"grant_type\": \"client_credentials\",\\n\\t\\t\"client_id\": client_id,\\n\\t\\t\"client_secret\": client_secret,\\n\\t\\t\"scope\": scope,\\n\\t}\\n\\tdata = urlencode(params).encode(\"utf-8\")\\n\\n\\trequest = Request(SETTINGS[\"WNS_ACCESS_URL\"], data=data, headers=headers)\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\t# One of your settings is probably jacked up.\\n\\t\\t\\t# https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh868245\\n\\t\\t\\traise WNSAuthenticationError(\"Authentication failed, check your WNS settings.\")\\n\\t\\traise err\\n\\n\\toauth_data = response.read().decode(\"utf-8\")\\n\\ttry:\\n\\t\\toauth_data = json.loads(oauth_data)\\n\\texcept Exception:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Received invalid JSON data from WNS.\")\\n\\n\\taccess_token = oauth_data.get(\"access_token\")\\n\\tif not access_token:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Access token missing from WNS response.\")\\n\\n\\treturn access_token\\n\\n\\ndef _wns_send(uri, data, wns_type=\"wns/toast\", application_id=None):\\n\\t\"\"\"\\n\\tSends a notification data and authentication to WNS.\\n\\n\\t:param uri: str: The device\\'s unique notification URI\\n\\t:param data: dict: The notification data to be sent.\\n\\t:return:\\n\\t\"\"\"\\n\\taccess_token = _wns_authenticate(application_id=application_id)\\n\\n\\tcontent_type = \"text/xml\"\\n\\tif wns_type == \"wns/raw\":\\n\\t\\tcontent_type = \"application/octet-stream\"\\n\\n\\theaders = {\\n\\t\\t# content_type is \"text/xml\" (toast/badge/tile) | \"application/octet-stream\" (raw)\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"Bearer %s\" % (access_token),\\n\\t\\t\"X-WNS-Type\": wns_type,  # wns/toast | wns/badge | wns/tile | wns/raw\\n\\t}\\n\\n\\tif type(data) is str:\\n\\t\\tdata = data.encode(\"utf-8\")\\n\\n\\trequest = Request(uri, data, headers)\\n\\n\\t# A lot of things can happen, let them know which one.\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\tmsg = \"One or more headers were specified incorrectly or conflict with another header.\"\\n\\t\\telif err.code == 401:\\n\\t\\t\\tmsg = \"The cloud service did not present a valid authentication ticket.\"\\n\\t\\telif err.code == 403:\\n\\t\\t\\tmsg = \"The cloud service is not authorized to send a notification to this URI.\"\\n\\t\\telif err.code == 404:\\n\\t\\t\\tmsg = \"The channel URI is not valid or is not recognized by WNS.\"\\n\\t\\telif err.code == 405:\\n\\t\\t\\tmsg = \"Invalid method. Only POST or DELETE is allowed.\"\\n\\t\\telif err.code == 406:\\n\\t\\t\\tmsg = \"The cloud service exceeded its throttle limit\"\\n\\t\\telif err.code == 410:\\n\\t\\t\\tmsg = \"The channel expired.\"\\n\\t\\telif err.code == 413:\\n\\t\\t\\tmsg = \"The notification payload exceeds the 500 byte limit.\"\\n\\t\\telif err.code == 500:\\n\\t\\t\\tmsg = \"An internal failure caused notification delivery to fail.\"\\n\\t\\telif err.code == 503:\\n\\t\\t\\tmsg = \"The server is currently unavailable.\"\\n\\t\\telse:\\n\\t\\t\\traise err\\n\\t\\traise WNSNotificationResponseError(\"HTTP %i: %s\" % (err.code, msg))\\n\\n\\treturn response.read().decode(\"utf-8\")\\n\\n\\ndef _wns_prepare_toast(data, **kwargs):\\n\\t\"\"\"\\n\\tCreates the xml tree for a `toast` notification\\n\\n\\t:param data: dict: The notification data to be converted to an xml tree.\\n\\n\\t{\\n\\t\\t\"text\": [\"Title text\", \"Message Text\", \"Another message!\"],\\n\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t}\\n\\n\\t:return: str\\n\\t\"\"\"\\n\\troot = ET.Element(\"toast\")\\n\\tvisual = ET.SubElement(root, \"visual\")\\n\\tbinding = ET.SubElement(visual, \"binding\")\\n\\tbinding.attrib[\"template\"] = kwargs.pop(\"template\", \"ToastText01\")\\n\\tif \"text\" in data:\\n\\t\\tfor count, item in enumerate(data[\"text\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"text\")\\n\\t\\t\\telem.text = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\tif \"image\" in data:\\n\\t\\tfor count, item in enumerate(data[\"image\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"img\")\\n\\t\\t\\telem.attrib[\"src\"] = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\treturn ET.tostring(root)\\n\\n\\ndef wns_send_message(\\n\\turi, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a notification request to WNS.\\n\\tThere are four notification types that WNS can send: toast, tile, badge and raw.\\n\\tToast, tile, and badge can all be customized to use different\\n\\ttemplates/icons/sounds/launch params/etc.\\n\\tSee docs for more information:\\n\\thttps://msdn.microsoft.com/en-us/library/windows/apps/br212853.aspx\\n\\n\\tThere are multiple ways to input notification data:\\n\\n\\t1. The simplest and least custom notification to send is to just pass a string\\n\\tto `message`. This will create a toast notification with one text element. e.g.:\\n\\t\\t\"This is my notification title\"\\n\\n\\t2. You can also pass a dictionary to `message`: it can only contain one or both\\n\\tkeys: [\"text\", \"image\"]. The value of each key must be a list with the text and\\n\\tsrc respectively. e.g.:\\n\\t\\t{\\n\\t\\t\\t\"text\": [\"text1\", \"text2\"],\\n\\t\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t\\t}\\n\\n\\t3. Passing a dictionary to `xml_data` will create one of three types of\\n\\tnotifications depending on the dictionary data (toast, tile, badge).\\n\\tSee `dict_to_xml_schema` docs for more information on dictionary formatting.\\n\\n\\t4. Passing a value to `raw_data` will create a `raw` notification and send the\\n\\tinput data as is.\\n\\n\\t:param uri: str: The device\\'s unique notification uri.\\n\\t:param message: str|dict: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\t# Create a simple toast notification\\n\\tif message:\\n\\t\\twns_type = \"wns/toast\"\\n\\t\\tif isinstance(message, str):\\n\\t\\t\\tmessage = {\\n\\t\\t\\t\\t\"text\": [message, ],\\n\\t\\t\\t}\\n\\t\\tprepared_data = _wns_prepare_toast(data=message, **kwargs)\\n\\t# Create a toast/tile/badge notification from a dictionary\\n\\telif xml_data:\\n\\t\\txml = dict_to_xml_schema(xml_data)\\n\\t\\twns_type = \"wns/%s\" % xml.tag\\n\\t\\tprepared_data = ET.tostring(xml)\\n\\t# Create a raw notification\\n\\telif raw_data:\\n\\t\\twns_type = \"wns/raw\"\\n\\t\\tprepared_data = raw_data\\n\\telse:\\n\\t\\traise TypeError(\\n\\t\\t\\t\"At least one of the following parameters must be set:\"\\n\\t\\t\\t\"`message`, `xml_data`, `raw_data`\"\\n\\t\\t)\\n\\n\\treturn _wns_send(\\n\\t\\turi=uri, data=prepared_data, wns_type=wns_type, application_id=application_id\\n\\t)\\n\\n\\ndef wns_send_bulk_message(\\n\\turi_list, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tWNS doesn\\'t support bulk notification, so we loop through each uri.\\n\\n\\t:param uri_list: list: A list of uris the notification will be sent to.\\n\\t:param message: str: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\tres = []\\n\\tif uri_list:\\n\\t\\tfor uri in uri_list:\\n\\t\\t\\tr = wns_send_message(\\n\\t\\t\\t\\turi=uri, message=message, xml_data=xml_data,\\n\\t\\t\\t\\traw_data=raw_data, application_id=application_id, **kwargs\\n\\t\\t\\t)\\n\\t\\t\\tres.append(r)\\n\\treturn res\\n\\n\\ndef dict_to_xml_schema(data):\\n\\t\"\"\"\\n\\tInput a dictionary to be converted to xml. There should be only one key at\\n\\tthe top level. The value must be a dict with (required) `children` key and\\n\\t(optional) `attrs` key. This will be called the `sub-element dictionary`.\\n\\n\\tThe `attrs` value must be a dictionary; each value will be added to the\\n\\telement\\'s xml tag as attributes. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\n\\twould result in:\\n\\t\\t<example key1=\"value1\" key2=\"value2\"></example>\\n\\n\\tIf the value is a dict it must contain one or more keys which will be used\\n\\tas the sub-element names. Each sub-element must have a value of a sub-element\\n\\tdictionary(see above) or a list of sub-element dictionaries.\\n\\tIf the value is not a dict, it will be the value of the element.\\n\\tIf the value is a list, multiple elements of the same tag will be created\\n\\tfrom each sub-element dict in the list.\\n\\n\\t:param data: dict: Used to create an XML tree. e.g.:\\n\\t\\texample_data = {\\n\\t\\t\\t\"toast\": {\\n\\t\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\\t\"launch\": \"param\",\\n\\t\\t\\t\\t\\t\"duration\": \"short\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\"visual\": {\\n\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\"binding\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"template\": \"ToastText01\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"text\": [\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"1\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text1\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"2\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text2\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor key, value in data.items():\\n\\t\\troot = _add_element_attrs(ET.Element(key), value.get(\"attrs\", {}))\\n\\t\\tchildren = value.get(\"children\", None)\\n\\t\\tif isinstance(children, dict):\\n\\t\\t\\t_add_sub_elements_from_dict(root, children)\\n\\t\\treturn root\\n\\n\\ndef _add_sub_elements_from_dict(parent, sub_dict):\\n\\t\"\"\"\\n\\tAdd SubElements to the parent element.\\n\\n\\t:param parent: ElementTree.Element: The parent element for the newly created SubElement.\\n\\t:param sub_dict: dict: Used to create a new SubElement. See `dict_to_xml_schema`\\n\\tmethod docstring for more information. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\t\"\"\"\\n\\tfor key, value in sub_dict.items():\\n\\t\\tif isinstance(value, list):\\n\\t\\t\\tfor repeated_element in value:\\n\\t\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t\\t_add_element_attrs(sub_element, repeated_element.get(\"attrs\", {}))\\n\\t\\t\\t\\tchildren = repeated_element.get(\"children\", None)\\n\\t\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\t\\tsub_element.text = children\\n\\t\\telse:\\n\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t_add_element_attrs(sub_element, value.get(\"attrs\", {}))\\n\\t\\t\\tchildren = value.get(\"children\", None)\\n\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\tsub_element.text = children\\n\\n\\ndef _add_element_attrs(elem, attrs):\\n\\t\"\"\"\\n\\tAdd attributes to the given element.\\n\\n\\t:param elem: ElementTree.Element: The element the attributes are being added to.\\n\\t:param attrs: dict: A dictionary of attributes. e.g.:\\n\\t\\t{\"attribute1\": \"value\", \"attribute2\": \"another\"}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor attr, value in attrs.items():\\n\\t\\telem.attrib[attr] = value\\n\\treturn elem\\n'"}]}, "source_encoding": {"line": 184, "args": [{"func_args": {"source": "b'try:\\n    # Python 3.8+\\n    import importlib.metadata as importlib_metadata\\nexcept ImportError:\\n    # <Python 3.7 and lower\\n    import importlib_metadata\\n\\n__version__ = importlib_metadata.version(\"django-push-notifications\")\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.apps import apps\\nfrom django.contrib import admin, messages\\nfrom django.utils.encoding import force_str\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .exceptions import APNSServerError, GCMError, WebPushError\\nfrom .models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nUser = apps.get_model(*SETTINGS[\"USER_MODEL\"].split(\".\"))\\n\\n\\nclass DeviceAdmin(admin.ModelAdmin):\\n\\tlist_display = (\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\",)\\n\\tactions = (\"send_message\", \"send_bulk_message\", \"enable\", \"disable\")\\n\\traw_id_fields = (\"user\",)\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"device_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"device_id\")\\n\\n\\tdef send_messages(self, request, queryset, bulk=False):\\n\\t\\t\"\"\"\\n\\t\\tProvides error handling for DeviceAdmin send_message and send_bulk_message methods.\\n\\t\\t\"\"\"\\n\\t\\tret = []\\n\\t\\terrors = []\\n\\t\\tr = \"\"\\n\\n\\t\\tfor device in queryset:\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tif bulk:\\n\\t\\t\\t\\t\\tr = queryset.send_message(\"Test bulk notification\")\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = device.send_message(\"Test single notification\")\\n\\t\\t\\t\\tif r:\\n\\t\\t\\t\\t\\tret.append(r)\\n\\t\\t\\texcept GCMError as e:\\n\\t\\t\\t\\terrors.append(str(e))\\n\\t\\t\\texcept APNSServerError as e:\\n\\t\\t\\t\\terrors.append(e.status)\\n\\t\\t\\texcept WebPushError as e:\\n\\t\\t\\t\\terrors.append(force_str(e))\\n\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\t# Because NotRegistered and InvalidRegistration do not throw GCMError\\n\\t\\t# catch them here to display error msg.\\n\\t\\tif not bulk:\\n\\t\\t\\tfor r in ret:\\n\\t\\t\\t\\tif \"error\" in r[\"results\"][0]:\\n\\t\\t\\t\\t\\terrors.append(r[\"results\"][0][\"error\"])\\n\\t\\telse:\\n\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\terrors = [r[\"error\"] for r in ret[0][0][\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\terrors = errors + [r[\"error\"] for r in entry[\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept IndexError:\\n\\t\\t\\t\\t\\tpass\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\tif value.lower() != \"success\":\\n\\t\\t\\t\\t\\t\\terrors.append(value)\\n\\t\\tif errors:\\n\\t\\t\\tself.message_user(\\n\\t\\t\\t\\trequest, _(\"Some messages could not be processed: %r\" % (\", \".join(errors))),\\n\\t\\t\\t\\tlevel=messages.ERROR\\n\\t\\t\\t)\\n\\t\\tif ret:\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\t# When the queryset exceeds the max_recipients value, the\\n\\t\\t\\t\\t# send_message method returns a list of dicts, one per chunk\\n\\t\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\t\\tsuccess = ret[0][0][\"success\"]\\n\\t\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\t\\tsuccess = 0\\n\\t\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\t\\tsuccess = success + entry[\"success\"]\\n\\t\\t\\t\\t\\tif success == 0:\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\t\\tsuccess = []\\n\\t\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\t\\tif value.lower() == \"success\":\\n\\t\\t\\t\\t\\t\\t\\tsuccess.append(key)\\n\\n\\t\\t\\telif len(errors) == len(ret):\\n\\t\\t\\t\\treturn\\n\\t\\t\\tif errors:\\n\\t\\t\\t\\tmsg = _(\"Some messages were sent: %s\" % (ret))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = _(\"All messages were sent: %s\" % (ret))\\n\\t\\t\\tself.message_user(request, msg)\\n\\n\\tdef send_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset)\\n\\n\\tsend_message.short_description = _(\"Send test message\")\\n\\n\\tdef send_bulk_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset, True)\\n\\n\\tsend_bulk_message.short_description = _(\"Send test message in bulk\")\\n\\n\\tdef enable(self, request, queryset):\\n\\t\\tqueryset.update(active=True)\\n\\n\\tenable.short_description = _(\"Enable selected devices\")\\n\\n\\tdef disable(self, request, queryset):\\n\\t\\tqueryset.update(active=False)\\n\\n\\tdisable.short_description = _(\"Disable selected devices\")\\n\\n\\nclass GCMDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\\n\\t\\t\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\", \"cloud_message_type\"\\n\\t)\\n\\tlist_filter = (\"active\", \"cloud_message_type\")\\n\\n\\nclass WebPushDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\"__str__\", \"browser\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\", \"browser\")\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"registration_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"registration_id\")\\n\\n\\nadmin.site.register(APNSDevice, DeviceAdmin)\\nadmin.site.register(GCMDevice, GCMDeviceAdmin)\\nadmin.site.register(WNSDevice, DeviceAdmin)\\nadmin.site.register(WebPushDevice, WebPushDeviceAdmin)\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b''"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from rest_framework import permissions, status\\nfrom rest_framework.fields import IntegerField\\nfrom rest_framework.response import Response\\nfrom rest_framework.serializers import ModelSerializer, Serializer, ValidationError\\nfrom rest_framework.viewsets import ModelViewSet\\n\\nfrom ..fields import UNSIGNED_64BIT_INT_MAX_VALUE, hex_re\\nfrom ..models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\n# Fields\\nclass HexIntegerField(IntegerField):\\n\\t\"\"\"\\n\\tStore an integer represented as a hex string of form \"0x01\".\\n\\t\"\"\"\\n\\n\\tdef to_internal_value(self, data):\\n\\t\\t# validate hex string and convert it to the unsigned\\n\\t\\t# integer representation for internal use\\n\\t\\ttry:\\n\\t\\t\\tdata = int(data, 16) if type(data) != int else data\\n\\t\\texcept ValueError:\\n\\t\\t\\traise ValidationError(\"Device ID is not a valid hex number\")\\n\\t\\treturn super(HexIntegerField, self).to_internal_value(data)\\n\\n\\tdef to_representation(self, value):\\n\\t\\treturn value\\n\\n\\n# Serializers\\nclass DeviceSerializerMixin(ModelSerializer):\\n\\tclass Meta:\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"application_id\", \"registration_id\", \"device_id\",\\n\\t\\t\\t\"active\", \"date_created\"\\n\\t\\t)\\n\\t\\tread_only_fields = (\"date_created\",)\\n\\n\\t\\t# See https://github.com/tomchristie/django-rest-framework/issues/1101\\n\\t\\textra_kwargs = {\"active\": {\"default\": True}}\\n\\n\\nclass APNSDeviceSerializer(ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = APNSDevice\\n\\n\\tdef validate_registration_id(self, value):\\n\\t\\t# iOS device tokens are 256-bit hexadecimal (64 characters). In 2016 Apple is increasing\\n\\t\\t# iOS device tokens to 100 bytes hexadecimal (200 characters).\\n\\n\\t\\tif hex_re.match(value) is None or len(value) not in (64, 200):\\n\\t\\t\\traise ValidationError(\"Registration ID (device token) is invalid\")\\n\\n\\t\\treturn value\\n\\n\\nclass UniqueRegistrationSerializerMixin(Serializer):\\n\\tdef validate(self, attrs):\\n\\t\\tdevices = None\\n\\t\\tprimary_key = None\\n\\t\\trequest_method = None\\n\\n\\t\\tif self.initial_data.get(\"registration_id\", None):\\n\\t\\t\\tif self.instance:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telse:\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\t\\telse:\\n\\t\\t\\tif self.context[\"request\"].method in [\"PUT\", \"PATCH\"]:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telif self.context[\"request\"].method == \"POST\":\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\n\\t\\tDevice = self.Meta.model\\n\\t\\tif request_method == \"update\":\\n\\t\\t\\treg_id = attrs.get(\"registration_id\", self.instance.registration_id)\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=reg_id) \\\\\\n\\t\\t\\t\\t.exclude(id=primary_key)\\n\\t\\telif request_method == \"create\":\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=attrs[\"registration_id\"])\\n\\n\\t\\tif devices:\\n\\t\\t\\traise ValidationError({\"registration_id\": \"This field must be unique.\"})\\n\\t\\treturn attrs\\n\\n\\nclass GCMDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tdevice_id = HexIntegerField(\\n\\t\\thelp_text=\"ANDROID_ID / TelephonyManager.getDeviceId() (e.g: 0x01)\",\\n\\t\\tstyle={\"input_type\": \"text\"},\\n\\t\\trequired=False,\\n\\t\\tallow_null=True\\n\\t)\\n\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = GCMDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"device_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"cloud_message_type\", \"application_id\",\\n\\t\\t)\\n\\t\\textra_kwargs = {\"id\": {\"read_only\": False, \"required\": False}}\\n\\n\\tdef validate_device_id(self, value):\\n\\t\\t# device ids are 64 bit unsigned values\\n\\t\\tif value > UNSIGNED_64BIT_INT_MAX_VALUE:\\n\\t\\t\\traise ValidationError(\"Device ID is out of range\")\\n\\t\\treturn value\\n\\n\\nclass WNSDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WNSDevice\\n\\n\\nclass WebPushDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WebPushDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"p256dh\", \"auth\", \"browser\", \"application_id\",\\n\\t\\t)\\n\\n\\n# Permissions\\nclass IsOwner(permissions.BasePermission):\\n\\tdef has_object_permission(self, request, view, obj):\\n\\t\\t# must be the owner to view the object\\n\\t\\treturn obj.user == request.user\\n\\n\\n# Mixins\\nclass DeviceViewSetMixin:\\n\\tlookup_field = \"registration_id\"\\n\\n\\tdef create(self, request, *args, **kwargs):\\n\\t\\tserializer = None\\n\\t\\tis_update = False\\n\\t\\tif SETTINGS.get(\"UPDATE_ON_DUPLICATE_REG_ID\") and self.lookup_field in request.data:\\n\\t\\t\\tinstance = self.queryset.model.objects.filter(\\n\\t\\t\\t\\tregistration_id=request.data[self.lookup_field]\\n\\t\\t\\t).first()\\n\\t\\t\\tif instance:\\n\\t\\t\\t\\tserializer = self.get_serializer(instance, data=request.data)\\n\\t\\t\\t\\tis_update = True\\n\\t\\tif not serializer:\\n\\t\\t\\tserializer = self.get_serializer(data=request.data)\\n\\n\\t\\tserializer.is_valid(raise_exception=True)\\n\\t\\tif is_update:\\n\\t\\t\\tself.perform_update(serializer)\\n\\t\\t\\treturn Response(serializer.data)\\n\\t\\telse:\\n\\t\\t\\tself.perform_create(serializer)\\n\\t\\t\\theaders = self.get_success_headers(serializer.data)\\n\\t\\t\\treturn Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\\n\\n\\tdef perform_create(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_create(serializer)\\n\\n\\tdef perform_update(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_update(serializer)\\n\\n\\nclass AuthorizedMixin:\\n\\tpermission_classes = (permissions.IsAuthenticated, IsOwner)\\n\\n\\tdef get_queryset(self):\\n\\t\\t# filter all devices to only those belonging to the current user\\n\\t\\treturn self.queryset.filter(user=self.request.user)\\n\\n\\n# ViewSets\\nclass APNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = APNSDevice.objects.all()\\n\\tserializer_class = APNSDeviceSerializer\\n\\n\\nclass APNSDeviceAuthorizedViewSet(AuthorizedMixin, APNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass GCMDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = GCMDevice.objects.all()\\n\\tserializer_class = GCMDeviceSerializer\\n\\n\\nclass GCMDeviceAuthorizedViewSet(AuthorizedMixin, GCMDeviceViewSet):\\n\\tpass\\n\\n\\nclass WNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WNSDevice.objects.all()\\n\\tserializer_class = WNSDeviceSerializer\\n\\n\\nclass WNSDeviceAuthorizedViewSet(AuthorizedMixin, WNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass WebPushDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WebPushDevice.objects.all()\\n\\tserializer_class = WebPushDeviceSerializer\\n\\n\\nclass WebPushDeviceAuthorizedViewSet(AuthorizedMixin, WebPushDeviceViewSet):\\n\\tpass\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'\"\"\"\\nApple Push Notification Service\\nDocumentation is available on the iOS Developer Library:\\nhttps://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html\\n\"\"\"\\n\\nimport time\\n\\nfrom apns2 import client as apns2_client\\nfrom apns2 import credentials as apns2_credentials\\nfrom apns2 import errors as apns2_errors\\nfrom apns2 import payload as apns2_payload\\n\\nfrom . import models\\nfrom .conf import get_manager\\nfrom .exceptions import APNSError, APNSUnsupportedPriority, APNSServerError\\n\\n\\ndef _apns_create_socket(creds=None, application_id=None):\\n\\tif creds is None:\\n\\t\\tif not get_manager().has_auth_token_creds(application_id):\\n\\t\\t\\tcert = get_manager().get_apns_certificate(application_id)\\n\\t\\t\\tcreds = apns2_credentials.CertificateCredentials(cert)\\n\\t\\telse:\\n\\t\\t\\tkeyPath, keyId, teamId = get_manager().get_apns_auth_creds(application_id)\\n\\t\\t\\t# No use getting a lifetime because this credential is\\n\\t\\t\\t# ephemeral, but if you\\'re looking at this to see how to\\n\\t\\t\\t# create a credential, you could also pass the lifetime and\\n\\t\\t\\t# algorithm. Neither of those settings are exposed in the\\n\\t\\t\\t# settings API at the moment.\\n\\t\\t\\tcreds = creds or apns2_credentials.TokenCredentials(keyPath, keyId, teamId)\\n\\tclient = apns2_client.APNsClient(\\n\\t\\tcreds,\\n\\t\\tuse_sandbox=get_manager().get_apns_use_sandbox(application_id),\\n\\t\\tuse_alternative_port=get_manager().get_apns_use_alternative_port(application_id)\\n\\t)\\n\\tclient.connect()\\n\\treturn client\\n\\n\\ndef _apns_prepare(\\n\\ttoken, alert, application_id=None, badge=None, sound=None, category=None,\\n\\tcontent_available=False, action_loc_key=None, loc_key=None, loc_args=[],\\n\\textra={}, mutable_content=False, thread_id=None, url_args=None):\\n\\t\\tif action_loc_key or loc_key or loc_args:\\n\\t\\t\\tapns2_alert = apns2_payload.PayloadAlert(\\n\\t\\t\\t\\tbody=alert if alert else {}, body_localized_key=loc_key,\\n\\t\\t\\t\\tbody_localized_args=loc_args, action_localized_key=action_loc_key)\\n\\t\\telse:\\n\\t\\t\\tapns2_alert = alert\\n\\n\\t\\tif callable(badge):\\n\\t\\t\\tbadge = badge(token)\\n\\n\\t\\treturn apns2_payload.Payload(\\n\\t\\t\\talert=apns2_alert, badge=badge, sound=sound, category=category,\\n\\t\\t\\turl_args=url_args, custom=extra, thread_id=thread_id,\\n\\t\\t\\tcontent_available=content_available, mutable_content=mutable_content)\\n\\n\\ndef _apns_send(\\n\\tregistration_id, alert, batch=False, application_id=None, creds=None, **kwargs\\n):\\n\\tclient = _apns_create_socket(creds=creds, application_id=application_id)\\n\\n\\tnotification_kwargs = {}\\n\\n\\t# if expiration isn\"t specified use 1 month from now\\n\\tnotification_kwargs[\"expiration\"] = kwargs.pop(\"expiration\", None)\\n\\tif not notification_kwargs[\"expiration\"]:\\n\\t\\tnotification_kwargs[\"expiration\"] = int(time.time()) + 2592000\\n\\n\\tpriority = kwargs.pop(\"priority\", None)\\n\\tif priority:\\n\\t\\ttry:\\n\\t\\t\\tnotification_kwargs[\"priority\"] = apns2_client.NotificationPriority(str(priority))\\n\\t\\texcept ValueError:\\n\\t\\t\\traise APNSUnsupportedPriority(\"Unsupported priority %d\" % (priority))\\n\\n\\tnotification_kwargs[\"collapse_id\"] = kwargs.pop(\"collapse_id\", None)\\n\\n\\tif batch:\\n\\t\\tdata = [apns2_client.Notification(\\n\\t\\t\\ttoken=rid, payload=_apns_prepare(rid, alert, **kwargs)) for rid in registration_id]\\n\\t\\t# returns a dictionary mapping each token to its result. That\\n\\t\\t# result is either \"Success\" or the reason for the failure.\\n\\t\\treturn client.send_notification_batch(\\n\\t\\t\\tdata, get_manager().get_apns_topic(application_id=application_id),\\n\\t\\t\\t**notification_kwargs\\n\\t\\t)\\n\\n\\tdata = _apns_prepare(registration_id, alert, **kwargs)\\n\\tclient.send_notification(\\n\\t\\tregistration_id, data,\\n\\t\\tget_manager().get_apns_topic(application_id=application_id),\\n\\t\\t**notification_kwargs\\n\\t)\\n\\n\\ndef apns_send_message(registration_id, alert, application_id=None, creds=None, **kwargs):\\n\\t\"\"\"\\n\\tSends an APNS notification to a single registration_id.\\n\\tThis will send the notification as form data.\\n\\tIf sending multiple notifications, it is more efficient to use\\n\\tapns_send_bulk_message()\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\ttry:\\n\\t\\t_apns_send(\\n\\t\\t\\tregistration_id, alert, application_id=application_id,\\n\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t)\\n\\texcept apns2_errors.APNsException as apns2_exception:\\n\\t\\tif isinstance(apns2_exception, apns2_errors.Unregistered):\\n\\t\\t\\tdevice = models.APNSDevice.objects.get(registration_id=registration_id)\\n\\t\\t\\tdevice.active = False\\n\\t\\t\\tdevice.save()\\n\\n\\t\\traise APNSServerError(status=apns2_exception.__class__.__name__)\\n\\n\\ndef apns_send_bulk_message(\\n\\tregistration_ids, alert, application_id=None, creds=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends an APNS notification to one or more registration_ids.\\n\\tThe registration_ids argument needs to be a list.\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\tresults = _apns_send(\\n\\t\\tregistration_ids, alert, batch=True, application_id=application_id,\\n\\t\\tcreds=creds, **kwargs\\n\\t)\\n\\tinactive_tokens = [token for token, result in results.items() if result == \"Unregistered\"]\\n\\tmodels.APNSDevice.objects.filter(registration_id__in=inactive_tokens).update(active=False)\\n\\treturn results\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'# flake8:noqa\\nfrom urllib.error import HTTPError\\nfrom urllib.parse import urlencode\\nfrom urllib.request import Request, urlopen\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.utils.module_loading import import_string\\n\\nfrom .app import AppConfig  # noqa: F401\\nfrom .appmodel import AppModelConfig  # noqa: F401\\nfrom .legacy import LegacyConfig  # noqa: F401\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS  # noqa: I001\\n\\n\\nmanager = None\\n\\n\\ndef get_manager(reload=False):\\n\\tglobal manager\\n\\n\\tif not manager or reload is True:\\n\\t\\tmanager = import_string(SETTINGS[\"CONFIG\"])()\\n\\n\\treturn manager\\n\\n\\n# implementing get_manager as a function allows tests to reload settings\\nget_manager()\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig, check_apns_certificate\\n\\n\\nSETTING_MISMATCH = (\\n\\t\"Application \\'{application_id}\\' ({platform}) does not support the setting \\'{setting}\\'.\"\\n)\\n\\n# code can be \"missing\" or \"invalid\"\\nBAD_PLATFORM = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"PLATFORM\"] is {code}. \\'\\n\\t\"Must be one of: {platforms}.\"\\n)\\n\\nUNKNOWN_PLATFORM = (\\n\\t\"Unknown Platform: {platform}. Must be one of: {platforms}.\"\\n)\\n\\nMISSING_SETTING = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"{setting}\"] is missing.\\'\\n)\\n\\nPLATFORMS = [\\n\\t\"APNS\",\\n\\t\"FCM\",\\n\\t\"GCM\",\\n\\t\"WNS\",\\n\\t\"WP\",\\n]\\n\\n# Settings that all applications must have\\nREQUIRED_SETTINGS = [\\n\\t\"PLATFORM\",\\n]\\n\\n# Settings that an application may have to enable optional features\\n# these settings are stubs for registry support and have no effect on the operation\\n# of the application at this time.\\nOPTIONAL_SETTINGS = [\\n\\t\"APPLICATION_GROUP\", \"APPLICATION_SECRET\"\\n]\\n\\n# Since we can have an auth key, combined with a auth key id and team id *or*\\n# a certificate, we make these all optional, and then make sure we have one or\\n# the other (group) of settings.\\nAPNS_SETTINGS_CERT_CREDS = \"CERTIFICATE\"\\n\\n# Subkeys for APNS_SETTINGS_AUTH_CREDS\\nAPNS_AUTH_CREDS_REQUIRED = [\"AUTH_KEY_PATH\", \"AUTH_KEY_ID\", \"TEAM_ID\"]\\nAPNS_AUTH_CREDS_OPTIONAL = [\"CERTIFICATE\", \"ENCRYPTION_ALGORITHM\", \"TOKEN_LIFETIME\"]\\n\\nAPNS_OPTIONAL_SETTINGS = [\\n\\t\"USE_SANDBOX\", \"USE_ALTERNATIVE_PORT\", \"TOPIC\"\\n]\\n\\nFCM_REQUIRED_SETTINGS = GCM_REQUIRED_SETTINGS = [\"API_KEY\"]\\nFCM_OPTIONAL_SETTINGS = GCM_OPTIONAL_SETTINGS = [\\n\\t\"POST_URL\", \"MAX_RECIPIENTS\", \"ERROR_TIMEOUT\"\\n]\\n\\nWNS_REQUIRED_SETTINGS = [\"PACKAGE_SECURITY_ID\", \"SECRET_KEY\"]\\nWNS_OPTIONAL_SETTINGS = [\"WNS_ACCESS_URL\"]\\n\\nWP_REQUIRED_SETTINGS = [\"PRIVATE_KEY\", \"CLAIMS\"]\\nWP_OPTIONAL_SETTINGS = [\"ERROR_TIMEOUT\", \"POST_URL\"]\\n\\n\\nclass AppConfig(BaseConfig):\\n\\t\"\"\"\\n\\tSupports any number of push notification enabled applications.\\n\\t\"\"\"\\n\\n\\tdef __init__(self, settings=None):\\n\\t\\t# supports overriding the settings to be loaded. Will load from ..settings by default.\\n\\t\\tself._settings = settings or SETTINGS\\n\\n\\t\\t# initialize APPLICATIONS to an empty collection\\n\\t\\tself._settings.setdefault(\"APPLICATIONS\", {})\\n\\n\\t\\t# validate application configurations\\n\\t\\tself._validate_applications(self._settings[\"APPLICATIONS\"])\\n\\n\\tdef _validate_applications(self, apps):\\n\\t\\t\"\"\"Validate the application collection\"\"\"\\n\\t\\tfor application_id, application_config in apps.items():\\n\\t\\t\\tself._validate_config(application_id, application_config)\\n\\n\\t\\t\\tapplication_config[\"APPLICATION_ID\"] = application_id\\n\\n\\tdef _validate_config(self, application_id, application_config):\\n\\t\\tplatform = application_config.get(\"PLATFORM\", None)\\n\\n\\t\\t# platform is not present\\n\\t\\tif platform is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"required\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# platform is not a valid choice from PLATFORMS\\n\\t\\tif platform not in PLATFORMS:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"invalid\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\tvalidate_fn = \"_validate_{platform}_config\".format(platform=platform).lower()\\n\\n\\t\\tif hasattr(self, validate_fn):\\n\\t\\t\\tgetattr(self, validate_fn)(application_id, application_config)\\n\\t\\telse:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tUNKNOWN_PLATFORM.format(\\n\\t\\t\\t\\t\\tplatform=platform,\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\tdef _validate_apns_config(self, application_id, application_config):\\n\\t\\tallowed = REQUIRED_SETTINGS + OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\tAPNS_OPTIONAL_SETTINGS\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\t# We have two sets of settings, certificate and JWT auth key.\\n\\t\\t# Auth Key requires 3 values, so if that is set, that will take\\n\\t\\t# precedence. If None are set, we will throw an error.\\n\\t\\thas_cert_creds = APNS_SETTINGS_CERT_CREDS in \\\\\\n\\t\\t\\tapplication_config.keys()\\n\\t\\tself.has_token_creds = True\\n\\t\\tfor token_setting in APNS_AUTH_CREDS_REQUIRED:\\n\\t\\t\\tif token_setting not in application_config.keys():\\n\\t\\t\\t\\tself.has_token_creds = False\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif not has_cert_creds and not self.has_token_creds:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tsetting=(APNS_SETTINGS_CERT_CREDS, APNS_AUTH_CREDS_REQUIRED)))\\n\\t\\tcert_path = None\\n\\t\\tif has_cert_creds:\\n\\t\\t\\tcert_path = \"CERTIFICATE\"\\n\\t\\telif self.has_token_creds:\\n\\t\\t\\tcert_path = \"AUTH_KEY_PATH\"\\n\\t\\t\\tallowed_tokens = APNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\t\\tAPNS_OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\t\\tREQUIRED_SETTINGS\\n\\t\\t\\tself._validate_allowed_settings(application_id, application_config, allowed_tokens)\\n\\t\\t\\tself._validate_required_settings(\\n\\t\\t\\t\\tapplication_id, application_config, APNS_AUTH_CREDS_REQUIRED\\n\\t\\t\\t)\\n\\t\\tself._validate_apns_certificate(application_config[cert_path])\\n\\n\\t\\t# determine/set optional values\\n\\t\\tapplication_config.setdefault(\"USE_SANDBOX\", False)\\n\\t\\tapplication_config.setdefault(\"USE_ALTERNATIVE_PORT\", False)\\n\\t\\tapplication_config.setdefault(\"TOPIC\", None)\\n\\n\\tdef _validate_apns_certificate(self, certfile):\\n\\t\\t\"\"\"Validate the APNS certificate at startup.\"\"\"\\n\\n\\t\\ttry:\\n\\t\\t\\twith open(certfile, \"r\") as f:\\n\\t\\t\\t\\tcontent = f.read()\\n\\t\\t\\t\\tcheck_apns_certificate(content)\\n\\t\\texcept Exception as e:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"The APNS certificate file at {!r} is not readable: {}\".format(certfile, e)\\n\\t\\t\\t)\\n\\n\\tdef _validate_fcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + FCM_REQUIRED_SETTINGS + FCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, FCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://fcm.googleapis.com/fcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_gcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + GCM_REQUIRED_SETTINGS + GCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, GCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://android.googleapis.com/gcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_wns_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WNS_REQUIRED_SETTINGS + WNS_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WNS_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\")\\n\\n\\tdef _validate_wp_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WP_REQUIRED_SETTINGS + WP_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WP_REQUIRED_SETTINGS\\n\\t\\t)\\n\\t\\tapplication_config.setdefault(\"POST_URL\", {\\n\\t\\t\\t\"CHROME\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"OPERA\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n\\t\\t\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\\t})\\n\\n\\tdef _validate_allowed_settings(self, application_id, application_config, allowed_settings):\\n\\t\\t\"\"\"Confirm only allowed settings are present.\"\"\"\\n\\n\\t\\tfor setting_key in application_config.keys():\\n\\t\\t\\tif setting_key not in allowed_settings:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"Platform {}, app {} does not support the setting: {}.\".format(\\n\\t\\t\\t\\t\\t\\tapplication_config[\"PLATFORM\"], application_id, setting_key\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\n\\tdef _validate_required_settings(\\n\\t\\tself, application_id, application_config, required_settings,\\n\\t\\tshould_throw=True\\n\\t):\\n\\t\\t\"\"\"All required keys must be present\"\"\"\\n\\n\\t\\tfor setting_key in required_settings:\\n\\t\\t\\tif setting_key not in application_config.keys():\\n\\t\\t\\t\\tif should_throw:\\n\\t\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\t\\t\\tapplication_id=application_id, setting=setting_key\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tdef _get_application_settings(self, application_id, platform, settings_key):\\n\\t\\t\"\"\"\\n\\t\\tWalks through PUSH_NOTIFICATIONS_SETTINGS to find the correct setting value\\n\\t\\tor raises ImproperlyConfigured.\\n\\t\\t\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tconf_cls = \"push_notifications.conf.AppConfig\"\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"{} requires the application_id be specified at all times.\".format(conf_cls)\\n\\t\\t\\t)\\n\\n\\t\\t# verify that the application config exists\\n\\t\\tapp_config = self._settings.get(\"APPLICATIONS\").get(application_id, None)\\n\\t\\tif app_config is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"No application configured with application_id: {}.\".format(application_id)\\n\\t\\t\\t)\\n\\n\\t\\t# fetch a setting for the incorrect type of platform\\n\\t\\tif app_config.get(\"PLATFORM\") != platform:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tSETTING_MISMATCH.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tplatform=app_config.get(\"PLATFORM\"),\\n\\t\\t\\t\\t\\tsetting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# finally, try to fetch the setting\\n\\t\\tif settings_key not in app_config:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id, setting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\treturn app_config.get(settings_key)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\treturn self.has_token_creds\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"GCM\", \"API_KEY\")\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"FCM\", \"API_KEY\")\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"POST_URL\")\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"ERROR_TIMEOUT\")\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"MAX_RECIPIENTS\")\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(application_id, \"APNS\", \"CERTIFICATE\")\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn \\\\\\n\\t\\t(self._get_apns_auth_key_path(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key_path(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_PATH\")\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_ID\")\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TEAM_ID\")\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_SANDBOX\")\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_ALTERNATIVE_PORT\")\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TOPIC\")\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"PACKAGE_SECURITY_ID\")\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"SECRET_KEY\")\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"POST_URL\")[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"PRIVATE_KEY\")\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"CLAIMS\")\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from .base import BaseConfig\\n\\n\\nclass AppModelConfig(BaseConfig):\\n\\t\"\"\"Future home of the Application Model conf adapter\\n\\n\\tSupports multiple applications in the database.\\n\\t\"\"\"\\n\\n\\tpass\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.core.exceptions import ImproperlyConfigured\\n\\n\\nclass BaseConfig:\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_applications(self):\\n\\t\\t\"\"\"Returns a collection containing the configured applications.\"\"\"\\n\\n\\t\\traise NotImplementedError\\n\\n\\n# This works for both the certificate and the auth key (since that\\'s just\\n# a certificate).\\ndef check_apns_certificate(ss):\\n\\tmode = \"start\"\\n\\tfor s in ss.split(\"\\\\n\"):\\n\\t\\tif mode == \"start\":\\n\\t\\t\\tif \"BEGIN RSA PRIVATE KEY\" in s or \"BEGIN PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"key\"\\n\\t\\telif mode == \"key\":\\n\\t\\t\\tif \"END RSA PRIVATE KEY\" in s or \"END PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"end\"\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif s.startswith(\"Proc-Type\") and \"ENCRYPTED\" in s:\\n\\t\\t\\t\\traise ImproperlyConfigured(\"Encrypted APNS private keys are not supported\")\\n\\n\\tif mode != \"end\":\\n\\t\\traise ImproperlyConfigured(\"The APNS certificate doesn\\'t contain a private key\")\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig\\n\\n\\n__all__ = [\\n\\t\"LegacyConfig\"\\n]\\n\\n\\nclass empty:\\n\\tpass\\n\\n\\nclass LegacyConfig(BaseConfig):\\n\\n\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\n\\tdef _get_application_settings(self, application_id, settings_key, error_message):\\n\\t\\t\"\"\"Legacy behaviour\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tvalue = SETTINGS.get(settings_key, empty)\\n\\t\\t\\tif value is empty:\\n\\t\\t\\t\\traise ImproperlyConfigured(error_message)\\n\\t\\t\\treturn value\\n\\t\\telse:\\n\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\"LegacySettings does not support application_id. To enable \"\\n\\t\\t\\t\\t\"multiple application support, use push_notifications.conf.AppSettings.\"\\n\\t\\t\\t)\\n\\t\\t\\traise ImproperlyConfigured(msg)\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"GCM_API_KEY\"] to send messages through GCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"GCM_API_KEY\", msg)\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"FCM_API_KEY\"] to send messages through FCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"FCM_API_KEY\", msg)\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_POST_URL\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_ERROR_TIMEOUT\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_MAX_RECIPIENTS\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\ttry:\\n\\t\\t\\tself._get_apns_auth_key(application_id)\\n\\t\\t\\tself._get_apns_auth_key_id(application_id)\\n\\t\\t\\tself._get_apns_team_id(application_id)\\n\\t\\texcept ImproperlyConfigured:\\n\\t\\t\\treturn False\\n\\n\\t\\treturn True\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(\\n\\t\\t\\tapplication_id, \"APNS_CERTIFICATE\",\\n\\t\\t\\t\"You need to setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\t)\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\traise ImproperlyConfigured(msg)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn (\\n\\t\\t\\tself._get_apns_auth_key(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_PATH\", self.msg)\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TEAM_ID\", self.msg)\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_ID\", self.msg)\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_USE_SANDBOX\", self.msg)\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn\\n\\t\\tself._get_application_settings(application_id, \"APNS_USE_ALTERNATIVE_PORT\", self.msg)\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TOPIC\", self.msg)\\n\\n\\tdef get_apns_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_HOST\", self.msg)\\n\\n\\tdef get_apns_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_PORT\", self.msg)\\n\\n\\tdef get_apns_feedback_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_HOST\", self.msg)\\n\\n\\tdef get_apns_feedback_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_PORT\", self.msg)\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_PACKAGE_SECURITY_ID\", self.msg)\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_SECRET_KEY\", msg)\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_POST_URL\", msg)[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_PRIVATE_KEY\", msg)\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_CLAIMS\", msg)\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'class NotificationError(Exception):\\n\\tpass\\n\\n\\n# APNS\\nclass APNSError(NotificationError):\\n\\tpass\\n\\n\\nclass APNSUnsupportedPriority(APNSError):\\n\\tpass\\n\\n\\nclass APNSServerError(APNSError):\\n\\tdef __init__(self, status):\\n\\t\\tsuper().__init__(status)\\n\\t\\tself.status = status\\n\\n\\n# GCM\\nclass GCMError(NotificationError):\\n\\tpass\\n\\n\\n# Web Push\\nclass WebPushError(NotificationError):\\n\\tpass\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'import re\\nimport struct\\n\\nfrom django import forms\\nfrom django.core.validators import MaxValueValidator, MinValueValidator, RegexValidator\\nfrom django.db import connection, models\\nfrom django.utils.translation import gettext_lazy as _\\n\\n\\n__all__ = [\"HexadecimalField\", \"HexIntegerField\"]\\n\\nUNSIGNED_64BIT_INT_MIN_VALUE = 0\\nUNSIGNED_64BIT_INT_MAX_VALUE = 2 ** 64 - 1\\n\\n\\nhex_re = re.compile(r\"^(([0-9A-f])|(0x[0-9A-f]))+$\")\\nsigned_integer_vendors = [\\n\\t\"postgresql\",\\n\\t\"sqlite\",\\n]\\n\\n\\ndef _using_signed_storage():\\n\\treturn connection.vendor in signed_integer_vendors\\n\\n\\ndef _signed_to_unsigned_integer(value):\\n\\treturn struct.unpack(\"Q\", struct.pack(\"q\", value))[0]\\n\\n\\ndef _unsigned_to_signed_integer(value):\\n\\treturn struct.unpack(\"q\", struct.pack(\"Q\", value))[0]\\n\\n\\ndef _hex_string_to_unsigned_integer(value):\\n\\treturn int(value, 16)\\n\\n\\ndef _unsigned_integer_to_hex_string(value):\\n\\treturn hex(value).rstrip(\"L\")\\n\\n\\nclass HexadecimalField(forms.CharField):\\n\\t\"\"\"\\n\\tA form field that accepts only hexadecimal numbers\\n\\t\"\"\"\\n\\tdef __init__(self, *args, **kwargs):\\n\\t\\tself.default_validators = [\\n\\t\\t\\tRegexValidator(hex_re, _(\"Enter a valid hexadecimal number\"), \"invalid\")\\n\\t\\t]\\n\\t\\tsuper(HexadecimalField, self).__init__(*args, **kwargs)\\n\\n\\tdef prepare_value(self, value):\\n\\t\\t# converts bigint from db to hex before it is displayed in admin\\n\\t\\tif value and not isinstance(value, str) \\\\\\n\\t\\t\\tand connection.vendor in (\"mysql\", \"sqlite\"):\\n\\t\\t\\tvalue = _unsigned_integer_to_hex_string(value)\\n\\t\\treturn super(forms.CharField, self).prepare_value(value)\\n\\n\\nclass HexIntegerField(models.BigIntegerField):\\n\\t\"\"\"\\n\\tThis field stores a hexadecimal *string* of up to 64 bits as an unsigned integer\\n\\ton *all* backends including postgres.\\n\\n\\tReasoning: Postgres only supports signed bigints. Since we don\\'t care about\\n\\tsignedness, we store it as signed, and cast it to unsigned when we deal with\\n\\tthe actual value (with struct)\\n\\n\\tOn sqlite and mysql, native unsigned bigint types are used. In all cases, the\\n\\tvalue we deal with in python is always in hex.\\n\\t\"\"\"\\n\\n\\tvalidators = [\\n\\t\\tMinValueValidator(UNSIGNED_64BIT_INT_MIN_VALUE),\\n\\t\\tMaxValueValidator(UNSIGNED_64BIT_INT_MAX_VALUE)\\n\\t]\\n\\n\\tdef db_type(self, connection):\\n\\t\\tif \"mysql\" == connection.vendor:\\n\\t\\t\\treturn \"bigint unsigned\"\\n\\t\\telif \"sqlite\" == connection.vendor:\\n\\t\\t\\treturn \"UNSIGNED BIG INT\"\\n\\t\\telse:\\n\\t\\t\\treturn super(HexIntegerField, self).db_type(connection=connection)\\n\\n\\tdef get_prep_value(self, value):\\n\\t\\t\"\"\" Return the integer value to be stored from the hex string \"\"\"\\n\\t\\tif value is None or value == \"\":\\n\\t\\t\\treturn None\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _unsigned_to_signed_integer(value)\\n\\t\\treturn value\\n\\n\\tdef from_db_value(self, value, *args):\\n\\t\\t\"\"\" Return an unsigned int representation from all db backends \"\"\"\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _signed_to_unsigned_integer(value)\\n\\t\\treturn value\\n\\n\\tdef to_python(self, value):\\n\\t\\t\"\"\" Return a str representation of the hexadecimal \"\"\"\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\treturn value\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\treturn _unsigned_integer_to_hex_string(value)\\n\\n\\tdef formfield(self, **kwargs):\\n\\t\\tdefaults = {\"form_class\": HexadecimalField}\\n\\t\\tdefaults.update(kwargs)\\n\\t\\t# yes, that super call is right\\n\\t\\treturn super(models.IntegerField, self).formfield(**defaults)\\n\\n\\tdef run_validators(self, value):\\n\\t\\t# make sure validation is performed on integer value not string value\\n\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\treturn super(models.BigIntegerField, self).run_validators(value)\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'\"\"\"\\nFirebase Cloud Messaging\\nPreviously known as GCM / C2DM\\nDocumentation is available on the Firebase Developer website:\\nhttps://firebase.google.com/docs/cloud-messaging/\\n\"\"\"\\n\\nimport json\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import Request, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import GCMError\\nfrom .models import GCMDevice\\n\\n\\n# Valid keys for FCM messages. Reference:\\n# https://firebase.google.com/docs/cloud-messaging/http-server-ref\\nFCM_TARGETS_KEYS = [\\n\\t\"to\", \"condition\", \"notification_key\"\\n]\\nFCM_OPTIONS_KEYS = [\\n\\t\"collapse_key\", \"priority\", \"content_available\", \"delay_while_idle\", \"time_to_live\",\\n\\t\"restricted_package_name\", \"dry_run\", \"mutable_content\"\\n]\\nFCM_NOTIFICATIONS_PAYLOAD_KEYS = [\\n\\t\"title\", \"body\", \"icon\", \"image\", \"sound\", \"badge\", \"color\", \"tag\", \"click_action\",\\n\\t\"body_loc_key\", \"body_loc_args\", \"title_loc_key\", \"title_loc_args\", \"android_channel_id\"\\n]\\n\\ndef _chunks(l, n):\\n\\t\"\"\"\\n\\tYield successive chunks from list \\\\a l with a minimum size \\\\a n\\n\\t\"\"\"\\n\\tfor i in range(0, len(l), n):\\n\\t\\tyield l[i:i + n]\\n\\n\\ndef _gcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_gcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"GCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"GCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _fcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_fcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"FCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"FCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _cm_handle_response(registration_ids, response_data, cloud_type, application_id=None):\\n\\tresponse = response_data\\n\\tif response.get(\"failure\") or response.get(\"canonical_ids\"):\\n\\t\\tids_to_remove, old_new_ids = [], []\\n\\t\\tthrow_error = False\\n\\t\\tfor index, result in enumerate(response[\"results\"]):\\n\\t\\t\\terror = result.get(\"error\")\\n\\t\\t\\tif error:\\n\\t\\t\\t\\t# https://firebase.google.com/docs/cloud-messaging/http-server-ref#error-codes\\n\\t\\t\\t\\t# If error is NotRegistered or InvalidRegistration, then we will deactivate devices\\n\\t\\t\\t\\t# because this registration ID is no more valid and can\\'t be used to send messages,\\n\\t\\t\\t\\t# otherwise raise error\\n\\t\\t\\t\\tif error in (\"NotRegistered\", \"InvalidRegistration\"):\\n\\t\\t\\t\\t\\tids_to_remove.append(registration_ids[index])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tthrow_error = True\\n\\t\\t\\tresult[\"original_registration_id\"] = registration_ids[index]\\n\\t\\t\\t# If registration_id is set, replace the original ID with the new value (canonical ID)\\n\\t\\t\\t# in your server database. Note that the original ID is not part of the result, you need\\n\\t\\t\\t# to obtain it from the list of registration_ids in the request (using the same index).\\n\\t\\t\\tnew_id = result.get(\"registration_id\")\\n\\t\\t\\tif new_id:\\n\\t\\t\\t\\told_new_ids.append((registration_ids[index], new_id))\\n\\n\\t\\tif ids_to_remove:\\n\\t\\t\\tremoved = GCMDevice.objects.filter(\\n\\t\\t\\t\\tregistration_id__in=ids_to_remove, cloud_message_type=cloud_type\\n\\t\\t\\t)\\n\\t\\t\\tremoved.update(active=False)\\n\\n\\t\\tfor old_id, new_id in old_new_ids:\\n\\t\\t\\t_cm_handle_canonical_id(new_id, old_id, cloud_type)\\n\\n\\t\\tif throw_error:\\n\\t\\t\\traise GCMError(response)\\n\\treturn response\\n\\n\\ndef _cm_send_request(\\n\\tregistration_ids, data, cloud_type=\"GCM\", application_id=None,\\n\\tuse_fcm_notifications=True, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a FCM or GCM notification to one or more registration_ids as json data.\\n\\tThe registration_ids needs to be a list.\\n\\t\"\"\"\\n\\n\\tpayload = {\"registration_ids\": registration_ids} if registration_ids else {}\\n\\n\\tdata = data.copy()\\n\\n\\t# If using FCM, optionally autodiscovers notification related keys\\n\\t# https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages\\n\\tif cloud_type == \"FCM\" and use_fcm_notifications:\\n\\t\\tnotification_payload = {}\\n\\t\\tif \"message\" in data:\\n\\t\\t\\tnotification_payload[\"body\"] = data.pop(\"message\", None)\\n\\n\\t\\tfor key in FCM_NOTIFICATIONS_PAYLOAD_KEYS:\\n\\t\\t\\tvalue_from_extra = data.pop(key, None)\\n\\t\\t\\tif value_from_extra:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_extra\\n\\t\\t\\tvalue_from_kwargs = kwargs.pop(key, None)\\n\\t\\t\\tif value_from_kwargs:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_kwargs\\n\\t\\tif notification_payload:\\n\\t\\t\\tpayload[\"notification\"] = notification_payload\\n\\n\\tif data:\\n\\t\\tpayload[\"data\"] = data\\n\\n\\t# Attach any additional non falsy keyword args (targets, options)\\n\\t# See ref : https://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\tpayload.update({\\n\\t\\tk: v for k, v in kwargs.items() if v and (k in FCM_TARGETS_KEYS or k in FCM_OPTIONS_KEYS)\\n\\t})\\n\\n\\t# Sort the keys for deterministic output (useful for tests)\\n\\tjson_payload = json.dumps(payload, separators=(\",\", \":\"), sort_keys=True).encode(\"utf-8\")\\n\\n\\t# Sends requests and handles the response\\n\\tif cloud_type == \"GCM\":\\n\\t\\tresponse = json.loads(_gcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telif cloud_type == \"FCM\":\\n\\t\\tresponse = json.loads(_fcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\treturn _cm_handle_response(registration_ids, response, cloud_type, application_id)\\n\\n\\ndef _cm_handle_canonical_id(canonical_id, current_id, cloud_type):\\n\\t\"\"\"\\n\\tHandle situation when FCM server response contains canonical ID\\n\\t\"\"\"\\n\\tdevices = GCMDevice.objects.filter(cloud_message_type=cloud_type)\\n\\tif devices.filter(registration_id=canonical_id, active=True).exists():\\n\\t\\tdevices.filter(registration_id=current_id).update(active=False)\\n\\telse:\\n\\t\\tdevices.filter(registration_id=current_id).update(registration_id=canonical_id)\\n\\n\\ndef send_message(registration_ids, data, cloud_type, application_id=None, **kwargs):\\n\\t\"\"\"\\n\\tSends a FCM (or GCM) notification to one or more registration_ids. The registration_ids\\n\\tcan be a list or a single string. This will send the notification as json data.\\n\\n\\tA reference of extra keyword arguments sent to the server is available here:\\n\\thttps://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\t\"\"\"\\n\\tif cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\tmax_recipients = get_manager().get_max_recipients(cloud_type, application_id)\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\n\\t# Checks for valid recipient\\n\\tif registration_ids is None and \"/topics/\" not in kwargs.get(\"to\", \"\"):\\n\\t\\treturn\\n\\n\\t# Bundles the registration_ids in an list if only one is sent\\n\\tif not isinstance(registration_ids, list):\\n\\t\\tregistration_ids = [registration_ids] if registration_ids else None\\n\\n\\t# FCM only allows up to 1000 reg ids per bulk message\\n\\t# https://firebase.google.com/docs/cloud-messaging/server#http-request\\n\\tif registration_ids:\\n\\t\\tret = []\\n\\t\\tfor chunk in _chunks(registration_ids, max_recipients):\\n\\t\\t\\tret.append(_cm_send_request(\\n\\t\\t\\t\\tchunk, data, cloud_type=cloud_type, application_id=application_id, **kwargs\\n\\t\\t\\t))\\n\\t\\treturn ret[0] if len(ret) == 1 else ret\\n\\telse:\\n\\t\\treturn _cm_send_request(None, data, cloud_type=cloud_type, **kwargs)\\n\\n\\nsend_bulk_message = send_message\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\nimport push_notifications.fields\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='APNSDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', models.UUIDField(help_text='UDID / UIDevice.identifierForVendor()', max_length=32, null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.CharField(unique=True, max_length=64, verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'APNS device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n        migrations.CreateModel(\\n            name='GCMDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', push_notifications.fields.HexIntegerField(help_text='ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)', null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'GCM device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n    ]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.1 on 2016-01-06 08:50\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0001_initial'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=True, verbose_name='Registration ID'),\\n        ),\\n    ]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nimport django.db.models.deletion\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0002_auto_20160106_0850'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WNSDevice',\\n            fields=[\\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\\n                ('name', models.CharField(blank=True, max_length=255, null=True, verbose_name='Name')),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, null=True, verbose_name='Creation date')),\\n                ('device_id', models.UUIDField(blank=True, db_index=True, help_text='GUID()', null=True, verbose_name='Device ID')),\\n                ('registration_id', models.TextField(verbose_name='Notification URI')),\\n                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\\n            ],\\n            options={\\n                'verbose_name': 'WNS device',\\n            },\\n        ),\\n    ]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n\\tdependencies = [\\n\\t\\tmigrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n\\t\\t('push_notifications', '0003_wnsdevice'),\\n\\t]\\n\\n\\toperations = [\\n\\t\\tmigrations.AddField(\\n\\t\\t\\tmodel_name='gcmdevice',\\n\\t\\t\\tname='cloud_message_type',\\n\\t\\t\\tfield=models.CharField(choices=[('FCM', 'Firebase Cloud Message'), ('GCM', 'Google Cloud Message')], default='GCM', help_text='You should choose FCM or GCM', max_length=3, verbose_name='Cloud Message Type')\\n\\t\\t),\\n\\t]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0004_fcm'),\\n    ]\\n\\n    operations = [\\n        migrations.AddField(\\n            model_name='apnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='gcmdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='wnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n    ]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0005_applicationid'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WebPushDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('application_id', models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('p256dh', models.CharField(max_length=88, verbose_name='User public encryption key')),\\n                ('auth', models.CharField(max_length=24, verbose_name='User auth secret')),\\n                ('browser', models.CharField(default='CHROME', help_text='Currently only support to Chrome, Firefox and Opera browsers', max_length=10, verbose_name='Browser', choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera')])),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'WebPush device',\\n            },\\n        ),\\n    ]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"from django.db import migrations, models\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0006_webpushdevice'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='gcmdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='wnsdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Notification URI'),\\n        ),\\n    ]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# Generated by Django 3.2.8 on 2021-11-12 09:49\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0007_uniquesetting'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='browser',\\n            field=models.CharField(choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera'), ('EDGE', 'Edge')], default='CHROME', help_text='Currently only support to Chrome, Firefox, Edge and Opera browsers', max_length=10, verbose_name='Browser'),\\n        ),\\n    ]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# Generated by Django 3.2.9 on 2022-01-10 09:03\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0008_webpush_add_edge'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='device_id',\\n            field=models.UUIDField(blank=True, db_index=True, help_text='UUID / UIDevice.identifierForVendor()', null=True, verbose_name='Device ID'),\\n        ),\\n    ]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b''"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.db import models\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .fields import HexIntegerField\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nCLOUD_MESSAGE_TYPES = (\\n\\t(\"FCM\", \"Firebase Cloud Message\"),\\n\\t(\"GCM\", \"Google Cloud Message\"),\\n)\\n\\nBROWSER_TYPES = (\\n\\t(\"CHROME\", \"Chrome\"),\\n\\t(\"FIREFOX\", \"Firefox\"),\\n\\t(\"OPERA\", \"Opera\"),\\n\\t(\"EDGE\", \"Edge\")\\n)\\n\\n\\nclass Device(models.Model):\\n\\tname = models.CharField(max_length=255, verbose_name=_(\"Name\"), blank=True, null=True)\\n\\tactive = models.BooleanField(\\n\\t\\tverbose_name=_(\"Is active\"), default=True,\\n\\t\\thelp_text=_(\"Inactive devices will not be sent notifications\")\\n\\t)\\n\\tuser = models.ForeignKey(\\n\\t\\tSETTINGS[\"USER_MODEL\"], blank=True, null=True, on_delete=models.CASCADE\\n\\t)\\n\\tdate_created = models.DateTimeField(\\n\\t\\tverbose_name=_(\"Creation date\"), auto_now_add=True, null=True\\n\\t)\\n\\tapplication_id = models.CharField(\\n\\t\\tmax_length=64, verbose_name=_(\"Application ID\"),\\n\\t\\thelp_text=_(\\n\\t\\t\\t\"Opaque application identity, should be filled in for multiple\"\\n\\t\\t\\t\" key/certificate access\"\\n\\t\\t),\\n\\t\\tblank=True, null=True\\n\\t)\\n\\n\\tclass Meta:\\n\\t\\tabstract = True\\n\\n\\tdef __str__(self):\\n\\t\\treturn (\\n\\t\\t\\tself.name or\\n\\t\\t\\tstr(self.device_id or \"\") or\\n\\t\\t\\t\"{} for {}\".format(self.__class__.__name__, self.user or \"unknown user\")\\n\\t\\t)\\n\\n\\nclass GCMDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn GCMDeviceQuerySet(self.model)\\n\\n\\nclass GCMDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\t\\tif message is not None:\\n\\t\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\\n\\t\\t\\t\\t\"application_id\"\\n\\t\\t\\t).values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tresponse = []\\n\\t\\t\\tfor cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\t\\treg_ids = list(\\n\\t\\t\\t\\t\\t\\tself.filter(\\n\\t\\t\\t\\t\\t\\t\\tactive=True, cloud_message_type=cloud_type, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\tif reg_ids:\\n\\t\\t\\t\\t\\t\\tr = gcm_send_message(reg_ids, data, cloud_type, application_id=app_id, **kwargs)\\n\\t\\t\\t\\t\\t\\tresponse.append(r)\\n\\n\\t\\t\\treturn response\\n\\n\\nclass GCMDevice(Device):\\n\\t# device_id cannot be a reliable primary key as fragmentation between different devices\\n\\t# can make it turn out to be null and such:\\n\\t# http://android-developers.blogspot.co.uk/2011/03/identifying-app-installations.html\\n\\tdevice_id = HexIntegerField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tcloud_message_type = models.CharField(\\n\\t\\tverbose_name=_(\"Cloud Message Type\"), max_length=3,\\n\\t\\tchoices=CLOUD_MESSAGE_TYPES, default=\"GCM\",\\n\\t\\thelp_text=_(\"You should choose FCM or GCM\")\\n\\t)\\n\\tobjects = GCMDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"GCM device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\tif message is not None:\\n\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\treturn gcm_send_message(\\n\\t\\t\\tself.registration_id, data, self.cloud_message_type,\\n\\t\\t\\tapplication_id=self.application_id, **kwargs\\n\\t\\t)\\n\\n\\nclass APNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn APNSDeviceQuerySet(self.model)\\n\\n\\nclass APNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .apns import apns_send_bulk_message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\")\\\\\\n\\t\\t\\t\\t.values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tres = []\\n\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\treg_ids = list(self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\"registration_id\", flat=True)\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tr = apns_send_bulk_message(\\n\\t\\t\\t\\t\\tregistration_ids=reg_ids, alert=message, application_id=app_id,\\n\\t\\t\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\t\\tres += [r]\\n\\t\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\t\\tres += r\\n\\t\\t\\treturn res\\n\\n\\nclass APNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"UUID / UIDevice.identifierForVendor()\")\\n\\t)\\n\\tregistration_id = models.CharField(\\n\\t\\tverbose_name=_(\"Registration ID\"), max_length=200, unique=SETTINGS[\"UNIQUE_REG_ID\"]\\n\\t)\\n\\n\\tobjects = APNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"APNS device\")\\n\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tfrom .apns import apns_send_message\\n\\n\\t\\treturn apns_send_message(\\n\\t\\t\\tregistration_id=self.registration_id,\\n\\t\\t\\talert=message,\\n\\t\\t\\tapplication_id=self.application_id, creds=creds,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WNSDeviceQuerySet(self.model)\\n\\n\\nclass WNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_bulk_message\\n\\n\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\").values_list(\\n\\t\\t\\t\"application_id\", flat=True\\n\\t\\t).distinct()\\n\\t\\tres = []\\n\\t\\tfor app_id in app_ids:\\n\\t\\t\\treg_ids = self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t)\\n\\t\\t\\tr = wns_send_bulk_message(uri_list=list(reg_ids), message=message, **kwargs)\\n\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\tres += [r]\\n\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\tres += r\\n\\n\\t\\treturn res\\n\\n\\nclass WNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"GUID()\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Notification URI\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\n\\tobjects = WNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WNS device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_message\\n\\n\\t\\treturn wns_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, application_id=self.application_id,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WebPushDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WebPushDeviceQuerySet(self.model)\\n\\n\\nclass WebPushDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tdevices = self.filter(active=True).order_by(\"application_id\").distinct()\\n\\t\\tres = []\\n\\t\\tfor device in devices:\\n\\t\\t\\tres.append(device.send_message(message))\\n\\n\\t\\treturn res\\n\\n\\nclass WebPushDevice(Device):\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tp256dh = models.CharField(\\n\\t\\tverbose_name=_(\"User public encryption key\"),\\n\\t\\tmax_length=88)\\n\\tauth = models.CharField(\\n\\t\\tverbose_name=_(\"User auth secret\"),\\n\\t\\tmax_length=24)\\n\\tbrowser = models.CharField(\\n\\t\\tverbose_name=_(\"Browser\"), max_length=10,\\n\\t\\tchoices=BROWSER_TYPES, default=BROWSER_TYPES[0][0],\\n\\t\\thelp_text=_(\"Currently only support to Chrome, Firefox, Edge and Opera browsers\")\\n\\t)\\n\\tobjects = WebPushDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WebPush device\")\\n\\n\\t@property\\n\\tdef device_id(self):\\n\\t\\treturn None\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .webpush import webpush_send_message\\n\\n\\t\\treturn webpush_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, browser=self.browser,\\n\\t\\t\\tauth=self.auth, p256dh=self.p256dh, application_id=self.application_id, **kwargs)\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.conf import settings\\n\\n\\nPUSH_NOTIFICATIONS_SETTINGS = getattr(settings, \"PUSH_NOTIFICATIONS_SETTINGS\", {})\\n\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"CONFIG\", \"push_notifications.conf.LegacyConfig\"\\n)\\n\\n# GCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"GCM_POST_URL\", \"https://android.googleapis.com/gcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_ERROR_TIMEOUT\", None)\\n\\n# FCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"FCM_POST_URL\", \"https://fcm.googleapis.com/fcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_ERROR_TIMEOUT\", None)\\n\\n# APNS\\nif settings.DEBUG:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", True)\\nelse:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_ALTERNATIVE_PORT\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_TOPIC\", None)\\n\\n# WNS\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_PACKAGE_SECURITY_ID\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_SECRET_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\"\\n)\\n\\n# WP (WebPush)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_POST_URL\", {\\n\\t\"CHROME\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"OPERA\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n})\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_PRIVATE_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_CLAIMS\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_ERROR_TIMEOUT\", None)\\n\\n# User model\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"USER_MODEL\", settings.AUTH_USER_MODEL)\\n\\n# Unique registration ID for all devices\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UNIQUE_REG_ID\", False)\\n\\n# API endpoint settings\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UPDATE_ON_DUPLICATE_REG_ID\", False)\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from pywebpush import WebPushException, webpush\\n\\nfrom .conf import get_manager\\nfrom .exceptions import WebPushError\\n\\n\\ndef get_subscription_info(application_id, uri, browser, auth, p256dh):\\n\\turl = get_manager().get_wp_post_url(application_id, browser)\\n\\treturn {\\n\\t\\t\"endpoint\": \"{}/{}\".format(url, uri),\\n\\t\\t\"keys\": {\\n\\t\\t\\t\"auth\": auth,\\n\\t\\t\\t\"p256dh\": p256dh,\\n\\t\\t}\\n\\t}\\n\\n\\ndef webpush_send_message(\\n\\turi, message, browser, auth, p256dh, application_id=None, **kwargs\\n):\\n\\tsubscription_info = get_subscription_info(application_id, uri, browser, auth, p256dh)\\n\\n\\ttry:\\n\\t\\tresponse = webpush(\\n\\t\\t\\tsubscription_info=subscription_info,\\n\\t\\t\\tdata=message,\\n\\t\\t\\tvapid_private_key=get_manager().get_wp_private_key(application_id),\\n\\t\\t\\tvapid_claims=get_manager().get_wp_claims(application_id).copy(),\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\t\\tresults = {\"results\": [{}]}\\n\\t\\tif not response.ok:\\n\\t\\t\\tresults[\"results\"][0][\"error\"] = response.content\\n\\t\\t\\tresults[\"results\"][0][\"original_registration_id\"] = response.content\\n\\t\\telse:\\n\\t\\t\\tresults[\"success\"] = 1\\n\\t\\treturn results\\n\\texcept WebPushException as e:\\n\\t\\traise WebPushError(e.message)\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'\"\"\"\\nWindows Notification Service\\n\\nDocumentation is available on the Windows Dev Center:\\nhttps://msdn.microsoft.com/en-us/windows/uwp/controls-and-patterns/tiles-and-notifications-windows-push-notification-services--wns--overview\\n\"\"\"\\n\\nimport json\\nimport xml.etree.ElementTree as ET\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import HTTPError, Request, urlencode, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import NotificationError\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass WNSError(NotificationError):\\n\\tpass\\n\\n\\nclass WNSAuthenticationError(WNSError):\\n\\tpass\\n\\n\\nclass WNSNotificationResponseError(WNSError):\\n\\tpass\\n\\n\\ndef _wns_authenticate(scope=\"notify.windows.com\", application_id=None):\\n\\t\"\"\"\\n\\tRequests an Access token for WNS communication.\\n\\n\\t:return: dict: {\\'access_token\\': <str>, \\'expires_in\\': <int>, \\'token_type\\': \\'bearer\\'}\\n\\t\"\"\"\\n\\tclient_id = get_manager().get_wns_package_security_id(application_id)\\n\\tclient_secret = get_manager().get_wns_secret_key(application_id)\\n\\tif not client_id:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_PACKAGE_SECURITY_ID\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\tif not client_secret:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_SECRET_KEY\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": \"application/x-www-form-urlencoded\",\\n\\t}\\n\\tparams = {\\n\\t\\t\"grant_type\": \"client_credentials\",\\n\\t\\t\"client_id\": client_id,\\n\\t\\t\"client_secret\": client_secret,\\n\\t\\t\"scope\": scope,\\n\\t}\\n\\tdata = urlencode(params).encode(\"utf-8\")\\n\\n\\trequest = Request(SETTINGS[\"WNS_ACCESS_URL\"], data=data, headers=headers)\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\t# One of your settings is probably jacked up.\\n\\t\\t\\t# https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh868245\\n\\t\\t\\traise WNSAuthenticationError(\"Authentication failed, check your WNS settings.\")\\n\\t\\traise err\\n\\n\\toauth_data = response.read().decode(\"utf-8\")\\n\\ttry:\\n\\t\\toauth_data = json.loads(oauth_data)\\n\\texcept Exception:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Received invalid JSON data from WNS.\")\\n\\n\\taccess_token = oauth_data.get(\"access_token\")\\n\\tif not access_token:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Access token missing from WNS response.\")\\n\\n\\treturn access_token\\n\\n\\ndef _wns_send(uri, data, wns_type=\"wns/toast\", application_id=None):\\n\\t\"\"\"\\n\\tSends a notification data and authentication to WNS.\\n\\n\\t:param uri: str: The device\\'s unique notification URI\\n\\t:param data: dict: The notification data to be sent.\\n\\t:return:\\n\\t\"\"\"\\n\\taccess_token = _wns_authenticate(application_id=application_id)\\n\\n\\tcontent_type = \"text/xml\"\\n\\tif wns_type == \"wns/raw\":\\n\\t\\tcontent_type = \"application/octet-stream\"\\n\\n\\theaders = {\\n\\t\\t# content_type is \"text/xml\" (toast/badge/tile) | \"application/octet-stream\" (raw)\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"Bearer %s\" % (access_token),\\n\\t\\t\"X-WNS-Type\": wns_type,  # wns/toast | wns/badge | wns/tile | wns/raw\\n\\t}\\n\\n\\tif type(data) is str:\\n\\t\\tdata = data.encode(\"utf-8\")\\n\\n\\trequest = Request(uri, data, headers)\\n\\n\\t# A lot of things can happen, let them know which one.\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\tmsg = \"One or more headers were specified incorrectly or conflict with another header.\"\\n\\t\\telif err.code == 401:\\n\\t\\t\\tmsg = \"The cloud service did not present a valid authentication ticket.\"\\n\\t\\telif err.code == 403:\\n\\t\\t\\tmsg = \"The cloud service is not authorized to send a notification to this URI.\"\\n\\t\\telif err.code == 404:\\n\\t\\t\\tmsg = \"The channel URI is not valid or is not recognized by WNS.\"\\n\\t\\telif err.code == 405:\\n\\t\\t\\tmsg = \"Invalid method. Only POST or DELETE is allowed.\"\\n\\t\\telif err.code == 406:\\n\\t\\t\\tmsg = \"The cloud service exceeded its throttle limit\"\\n\\t\\telif err.code == 410:\\n\\t\\t\\tmsg = \"The channel expired.\"\\n\\t\\telif err.code == 413:\\n\\t\\t\\tmsg = \"The notification payload exceeds the 500 byte limit.\"\\n\\t\\telif err.code == 500:\\n\\t\\t\\tmsg = \"An internal failure caused notification delivery to fail.\"\\n\\t\\telif err.code == 503:\\n\\t\\t\\tmsg = \"The server is currently unavailable.\"\\n\\t\\telse:\\n\\t\\t\\traise err\\n\\t\\traise WNSNotificationResponseError(\"HTTP %i: %s\" % (err.code, msg))\\n\\n\\treturn response.read().decode(\"utf-8\")\\n\\n\\ndef _wns_prepare_toast(data, **kwargs):\\n\\t\"\"\"\\n\\tCreates the xml tree for a `toast` notification\\n\\n\\t:param data: dict: The notification data to be converted to an xml tree.\\n\\n\\t{\\n\\t\\t\"text\": [\"Title text\", \"Message Text\", \"Another message!\"],\\n\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t}\\n\\n\\t:return: str\\n\\t\"\"\"\\n\\troot = ET.Element(\"toast\")\\n\\tvisual = ET.SubElement(root, \"visual\")\\n\\tbinding = ET.SubElement(visual, \"binding\")\\n\\tbinding.attrib[\"template\"] = kwargs.pop(\"template\", \"ToastText01\")\\n\\tif \"text\" in data:\\n\\t\\tfor count, item in enumerate(data[\"text\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"text\")\\n\\t\\t\\telem.text = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\tif \"image\" in data:\\n\\t\\tfor count, item in enumerate(data[\"image\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"img\")\\n\\t\\t\\telem.attrib[\"src\"] = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\treturn ET.tostring(root)\\n\\n\\ndef wns_send_message(\\n\\turi, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a notification request to WNS.\\n\\tThere are four notification types that WNS can send: toast, tile, badge and raw.\\n\\tToast, tile, and badge can all be customized to use different\\n\\ttemplates/icons/sounds/launch params/etc.\\n\\tSee docs for more information:\\n\\thttps://msdn.microsoft.com/en-us/library/windows/apps/br212853.aspx\\n\\n\\tThere are multiple ways to input notification data:\\n\\n\\t1. The simplest and least custom notification to send is to just pass a string\\n\\tto `message`. This will create a toast notification with one text element. e.g.:\\n\\t\\t\"This is my notification title\"\\n\\n\\t2. You can also pass a dictionary to `message`: it can only contain one or both\\n\\tkeys: [\"text\", \"image\"]. The value of each key must be a list with the text and\\n\\tsrc respectively. e.g.:\\n\\t\\t{\\n\\t\\t\\t\"text\": [\"text1\", \"text2\"],\\n\\t\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t\\t}\\n\\n\\t3. Passing a dictionary to `xml_data` will create one of three types of\\n\\tnotifications depending on the dictionary data (toast, tile, badge).\\n\\tSee `dict_to_xml_schema` docs for more information on dictionary formatting.\\n\\n\\t4. Passing a value to `raw_data` will create a `raw` notification and send the\\n\\tinput data as is.\\n\\n\\t:param uri: str: The device\\'s unique notification uri.\\n\\t:param message: str|dict: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\t# Create a simple toast notification\\n\\tif message:\\n\\t\\twns_type = \"wns/toast\"\\n\\t\\tif isinstance(message, str):\\n\\t\\t\\tmessage = {\\n\\t\\t\\t\\t\"text\": [message, ],\\n\\t\\t\\t}\\n\\t\\tprepared_data = _wns_prepare_toast(data=message, **kwargs)\\n\\t# Create a toast/tile/badge notification from a dictionary\\n\\telif xml_data:\\n\\t\\txml = dict_to_xml_schema(xml_data)\\n\\t\\twns_type = \"wns/%s\" % xml.tag\\n\\t\\tprepared_data = ET.tostring(xml)\\n\\t# Create a raw notification\\n\\telif raw_data:\\n\\t\\twns_type = \"wns/raw\"\\n\\t\\tprepared_data = raw_data\\n\\telse:\\n\\t\\traise TypeError(\\n\\t\\t\\t\"At least one of the following parameters must be set:\"\\n\\t\\t\\t\"`message`, `xml_data`, `raw_data`\"\\n\\t\\t)\\n\\n\\treturn _wns_send(\\n\\t\\turi=uri, data=prepared_data, wns_type=wns_type, application_id=application_id\\n\\t)\\n\\n\\ndef wns_send_bulk_message(\\n\\turi_list, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tWNS doesn\\'t support bulk notification, so we loop through each uri.\\n\\n\\t:param uri_list: list: A list of uris the notification will be sent to.\\n\\t:param message: str: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\tres = []\\n\\tif uri_list:\\n\\t\\tfor uri in uri_list:\\n\\t\\t\\tr = wns_send_message(\\n\\t\\t\\t\\turi=uri, message=message, xml_data=xml_data,\\n\\t\\t\\t\\traw_data=raw_data, application_id=application_id, **kwargs\\n\\t\\t\\t)\\n\\t\\t\\tres.append(r)\\n\\treturn res\\n\\n\\ndef dict_to_xml_schema(data):\\n\\t\"\"\"\\n\\tInput a dictionary to be converted to xml. There should be only one key at\\n\\tthe top level. The value must be a dict with (required) `children` key and\\n\\t(optional) `attrs` key. This will be called the `sub-element dictionary`.\\n\\n\\tThe `attrs` value must be a dictionary; each value will be added to the\\n\\telement\\'s xml tag as attributes. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\n\\twould result in:\\n\\t\\t<example key1=\"value1\" key2=\"value2\"></example>\\n\\n\\tIf the value is a dict it must contain one or more keys which will be used\\n\\tas the sub-element names. Each sub-element must have a value of a sub-element\\n\\tdictionary(see above) or a list of sub-element dictionaries.\\n\\tIf the value is not a dict, it will be the value of the element.\\n\\tIf the value is a list, multiple elements of the same tag will be created\\n\\tfrom each sub-element dict in the list.\\n\\n\\t:param data: dict: Used to create an XML tree. e.g.:\\n\\t\\texample_data = {\\n\\t\\t\\t\"toast\": {\\n\\t\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\\t\"launch\": \"param\",\\n\\t\\t\\t\\t\\t\"duration\": \"short\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\"visual\": {\\n\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\"binding\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"template\": \"ToastText01\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"text\": [\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"1\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text1\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"2\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text2\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor key, value in data.items():\\n\\t\\troot = _add_element_attrs(ET.Element(key), value.get(\"attrs\", {}))\\n\\t\\tchildren = value.get(\"children\", None)\\n\\t\\tif isinstance(children, dict):\\n\\t\\t\\t_add_sub_elements_from_dict(root, children)\\n\\t\\treturn root\\n\\n\\ndef _add_sub_elements_from_dict(parent, sub_dict):\\n\\t\"\"\"\\n\\tAdd SubElements to the parent element.\\n\\n\\t:param parent: ElementTree.Element: The parent element for the newly created SubElement.\\n\\t:param sub_dict: dict: Used to create a new SubElement. See `dict_to_xml_schema`\\n\\tmethod docstring for more information. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\t\"\"\"\\n\\tfor key, value in sub_dict.items():\\n\\t\\tif isinstance(value, list):\\n\\t\\t\\tfor repeated_element in value:\\n\\t\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t\\t_add_element_attrs(sub_element, repeated_element.get(\"attrs\", {}))\\n\\t\\t\\t\\tchildren = repeated_element.get(\"children\", None)\\n\\t\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\t\\tsub_element.text = children\\n\\t\\telse:\\n\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t_add_element_attrs(sub_element, value.get(\"attrs\", {}))\\n\\t\\t\\tchildren = value.get(\"children\", None)\\n\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\tsub_element.text = children\\n\\n\\ndef _add_element_attrs(elem, attrs):\\n\\t\"\"\"\\n\\tAdd attributes to the given element.\\n\\n\\t:param elem: ElementTree.Element: The element the attributes are being added to.\\n\\t:param attrs: dict: A dictionary of attributes. e.g.:\\n\\t\\t{\"attribute1\": \"value\", \"attribute2\": \"another\"}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor attr, value in attrs.items():\\n\\t\\telem.attrib[attr] = value\\n\\treturn elem\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'try:\\n    # Python 3.8+\\n    import importlib.metadata as importlib_metadata\\nexcept ImportError:\\n    # <Python 3.7 and lower\\n    import importlib_metadata\\n\\n__version__ = importlib_metadata.version(\"django-push-notifications\")\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.apps import apps\\nfrom django.contrib import admin, messages\\nfrom django.utils.encoding import force_str\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .exceptions import APNSServerError, GCMError, WebPushError\\nfrom .models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nUser = apps.get_model(*SETTINGS[\"USER_MODEL\"].split(\".\"))\\n\\n\\nclass DeviceAdmin(admin.ModelAdmin):\\n\\tlist_display = (\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\",)\\n\\tactions = (\"send_message\", \"send_bulk_message\", \"enable\", \"disable\")\\n\\traw_id_fields = (\"user\",)\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"device_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"device_id\")\\n\\n\\tdef send_messages(self, request, queryset, bulk=False):\\n\\t\\t\"\"\"\\n\\t\\tProvides error handling for DeviceAdmin send_message and send_bulk_message methods.\\n\\t\\t\"\"\"\\n\\t\\tret = []\\n\\t\\terrors = []\\n\\t\\tr = \"\"\\n\\n\\t\\tfor device in queryset:\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tif bulk:\\n\\t\\t\\t\\t\\tr = queryset.send_message(\"Test bulk notification\")\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = device.send_message(\"Test single notification\")\\n\\t\\t\\t\\tif r:\\n\\t\\t\\t\\t\\tret.append(r)\\n\\t\\t\\texcept GCMError as e:\\n\\t\\t\\t\\terrors.append(str(e))\\n\\t\\t\\texcept APNSServerError as e:\\n\\t\\t\\t\\terrors.append(e.status)\\n\\t\\t\\texcept WebPushError as e:\\n\\t\\t\\t\\terrors.append(force_str(e))\\n\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\t# Because NotRegistered and InvalidRegistration do not throw GCMError\\n\\t\\t# catch them here to display error msg.\\n\\t\\tif not bulk:\\n\\t\\t\\tfor r in ret:\\n\\t\\t\\t\\tif \"error\" in r[\"results\"][0]:\\n\\t\\t\\t\\t\\terrors.append(r[\"results\"][0][\"error\"])\\n\\t\\telse:\\n\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\terrors = [r[\"error\"] for r in ret[0][0][\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\terrors = errors + [r[\"error\"] for r in entry[\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept IndexError:\\n\\t\\t\\t\\t\\tpass\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\tif value.lower() != \"success\":\\n\\t\\t\\t\\t\\t\\terrors.append(value)\\n\\t\\tif errors:\\n\\t\\t\\tself.message_user(\\n\\t\\t\\t\\trequest, _(\"Some messages could not be processed: %r\" % (\", \".join(errors))),\\n\\t\\t\\t\\tlevel=messages.ERROR\\n\\t\\t\\t)\\n\\t\\tif ret:\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\t# When the queryset exceeds the max_recipients value, the\\n\\t\\t\\t\\t# send_message method returns a list of dicts, one per chunk\\n\\t\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\t\\tsuccess = ret[0][0][\"success\"]\\n\\t\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\t\\tsuccess = 0\\n\\t\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\t\\tsuccess = success + entry[\"success\"]\\n\\t\\t\\t\\t\\tif success == 0:\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\t\\tsuccess = []\\n\\t\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\t\\tif value.lower() == \"success\":\\n\\t\\t\\t\\t\\t\\t\\tsuccess.append(key)\\n\\n\\t\\t\\telif len(errors) == len(ret):\\n\\t\\t\\t\\treturn\\n\\t\\t\\tif errors:\\n\\t\\t\\t\\tmsg = _(\"Some messages were sent: %s\" % (ret))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = _(\"All messages were sent: %s\" % (ret))\\n\\t\\t\\tself.message_user(request, msg)\\n\\n\\tdef send_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset)\\n\\n\\tsend_message.short_description = _(\"Send test message\")\\n\\n\\tdef send_bulk_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset, True)\\n\\n\\tsend_bulk_message.short_description = _(\"Send test message in bulk\")\\n\\n\\tdef enable(self, request, queryset):\\n\\t\\tqueryset.update(active=True)\\n\\n\\tenable.short_description = _(\"Enable selected devices\")\\n\\n\\tdef disable(self, request, queryset):\\n\\t\\tqueryset.update(active=False)\\n\\n\\tdisable.short_description = _(\"Disable selected devices\")\\n\\n\\nclass GCMDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\\n\\t\\t\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\", \"cloud_message_type\"\\n\\t)\\n\\tlist_filter = (\"active\", \"cloud_message_type\")\\n\\n\\nclass WebPushDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\"__str__\", \"browser\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\", \"browser\")\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"registration_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"registration_id\")\\n\\n\\nadmin.site.register(APNSDevice, DeviceAdmin)\\nadmin.site.register(GCMDevice, GCMDeviceAdmin)\\nadmin.site.register(WNSDevice, DeviceAdmin)\\nadmin.site.register(WebPushDevice, WebPushDeviceAdmin)\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b''"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from rest_framework import permissions, status\\nfrom rest_framework.fields import IntegerField\\nfrom rest_framework.response import Response\\nfrom rest_framework.serializers import ModelSerializer, Serializer, ValidationError\\nfrom rest_framework.viewsets import ModelViewSet\\n\\nfrom ..fields import UNSIGNED_64BIT_INT_MAX_VALUE, hex_re\\nfrom ..models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\n# Fields\\nclass HexIntegerField(IntegerField):\\n\\t\"\"\"\\n\\tStore an integer represented as a hex string of form \"0x01\".\\n\\t\"\"\"\\n\\n\\tdef to_internal_value(self, data):\\n\\t\\t# validate hex string and convert it to the unsigned\\n\\t\\t# integer representation for internal use\\n\\t\\ttry:\\n\\t\\t\\tdata = int(data, 16) if type(data) != int else data\\n\\t\\texcept ValueError:\\n\\t\\t\\traise ValidationError(\"Device ID is not a valid hex number\")\\n\\t\\treturn super(HexIntegerField, self).to_internal_value(data)\\n\\n\\tdef to_representation(self, value):\\n\\t\\treturn value\\n\\n\\n# Serializers\\nclass DeviceSerializerMixin(ModelSerializer):\\n\\tclass Meta:\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"application_id\", \"registration_id\", \"device_id\",\\n\\t\\t\\t\"active\", \"date_created\"\\n\\t\\t)\\n\\t\\tread_only_fields = (\"date_created\",)\\n\\n\\t\\t# See https://github.com/tomchristie/django-rest-framework/issues/1101\\n\\t\\textra_kwargs = {\"active\": {\"default\": True}}\\n\\n\\nclass APNSDeviceSerializer(ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = APNSDevice\\n\\n\\tdef validate_registration_id(self, value):\\n\\t\\t# iOS device tokens are 256-bit hexadecimal (64 characters). In 2016 Apple is increasing\\n\\t\\t# iOS device tokens to 100 bytes hexadecimal (200 characters).\\n\\n\\t\\tif hex_re.match(value) is None or len(value) not in (64, 200):\\n\\t\\t\\traise ValidationError(\"Registration ID (device token) is invalid\")\\n\\n\\t\\treturn value\\n\\n\\nclass UniqueRegistrationSerializerMixin(Serializer):\\n\\tdef validate(self, attrs):\\n\\t\\tdevices = None\\n\\t\\tprimary_key = None\\n\\t\\trequest_method = None\\n\\n\\t\\tif self.initial_data.get(\"registration_id\", None):\\n\\t\\t\\tif self.instance:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telse:\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\t\\telse:\\n\\t\\t\\tif self.context[\"request\"].method in [\"PUT\", \"PATCH\"]:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telif self.context[\"request\"].method == \"POST\":\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\n\\t\\tDevice = self.Meta.model\\n\\t\\tif request_method == \"update\":\\n\\t\\t\\treg_id = attrs.get(\"registration_id\", self.instance.registration_id)\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=reg_id) \\\\\\n\\t\\t\\t\\t.exclude(id=primary_key)\\n\\t\\telif request_method == \"create\":\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=attrs[\"registration_id\"])\\n\\n\\t\\tif devices:\\n\\t\\t\\traise ValidationError({\"registration_id\": \"This field must be unique.\"})\\n\\t\\treturn attrs\\n\\n\\nclass GCMDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tdevice_id = HexIntegerField(\\n\\t\\thelp_text=\"ANDROID_ID / TelephonyManager.getDeviceId() (e.g: 0x01)\",\\n\\t\\tstyle={\"input_type\": \"text\"},\\n\\t\\trequired=False,\\n\\t\\tallow_null=True\\n\\t)\\n\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = GCMDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"device_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"cloud_message_type\", \"application_id\",\\n\\t\\t)\\n\\t\\textra_kwargs = {\"id\": {\"read_only\": False, \"required\": False}}\\n\\n\\tdef validate_device_id(self, value):\\n\\t\\t# device ids are 64 bit unsigned values\\n\\t\\tif value > UNSIGNED_64BIT_INT_MAX_VALUE:\\n\\t\\t\\traise ValidationError(\"Device ID is out of range\")\\n\\t\\treturn value\\n\\n\\nclass WNSDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WNSDevice\\n\\n\\nclass WebPushDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WebPushDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"p256dh\", \"auth\", \"browser\", \"application_id\",\\n\\t\\t)\\n\\n\\n# Permissions\\nclass IsOwner(permissions.BasePermission):\\n\\tdef has_object_permission(self, request, view, obj):\\n\\t\\t# must be the owner to view the object\\n\\t\\treturn obj.user == request.user\\n\\n\\n# Mixins\\nclass DeviceViewSetMixin:\\n\\tlookup_field = \"registration_id\"\\n\\n\\tdef create(self, request, *args, **kwargs):\\n\\t\\tserializer = None\\n\\t\\tis_update = False\\n\\t\\tif SETTINGS.get(\"UPDATE_ON_DUPLICATE_REG_ID\") and self.lookup_field in request.data:\\n\\t\\t\\tinstance = self.queryset.model.objects.filter(\\n\\t\\t\\t\\tregistration_id=request.data[self.lookup_field]\\n\\t\\t\\t).first()\\n\\t\\t\\tif instance:\\n\\t\\t\\t\\tserializer = self.get_serializer(instance, data=request.data)\\n\\t\\t\\t\\tis_update = True\\n\\t\\tif not serializer:\\n\\t\\t\\tserializer = self.get_serializer(data=request.data)\\n\\n\\t\\tserializer.is_valid(raise_exception=True)\\n\\t\\tif is_update:\\n\\t\\t\\tself.perform_update(serializer)\\n\\t\\t\\treturn Response(serializer.data)\\n\\t\\telse:\\n\\t\\t\\tself.perform_create(serializer)\\n\\t\\t\\theaders = self.get_success_headers(serializer.data)\\n\\t\\t\\treturn Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\\n\\n\\tdef perform_create(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_create(serializer)\\n\\n\\tdef perform_update(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_update(serializer)\\n\\n\\nclass AuthorizedMixin:\\n\\tpermission_classes = (permissions.IsAuthenticated, IsOwner)\\n\\n\\tdef get_queryset(self):\\n\\t\\t# filter all devices to only those belonging to the current user\\n\\t\\treturn self.queryset.filter(user=self.request.user)\\n\\n\\n# ViewSets\\nclass APNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = APNSDevice.objects.all()\\n\\tserializer_class = APNSDeviceSerializer\\n\\n\\nclass APNSDeviceAuthorizedViewSet(AuthorizedMixin, APNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass GCMDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = GCMDevice.objects.all()\\n\\tserializer_class = GCMDeviceSerializer\\n\\n\\nclass GCMDeviceAuthorizedViewSet(AuthorizedMixin, GCMDeviceViewSet):\\n\\tpass\\n\\n\\nclass WNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WNSDevice.objects.all()\\n\\tserializer_class = WNSDeviceSerializer\\n\\n\\nclass WNSDeviceAuthorizedViewSet(AuthorizedMixin, WNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass WebPushDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WebPushDevice.objects.all()\\n\\tserializer_class = WebPushDeviceSerializer\\n\\n\\nclass WebPushDeviceAuthorizedViewSet(AuthorizedMixin, WebPushDeviceViewSet):\\n\\tpass\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'\"\"\"\\nApple Push Notification Service\\nDocumentation is available on the iOS Developer Library:\\nhttps://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html\\n\"\"\"\\n\\nimport time\\n\\nfrom apns2 import client as apns2_client\\nfrom apns2 import credentials as apns2_credentials\\nfrom apns2 import errors as apns2_errors\\nfrom apns2 import payload as apns2_payload\\n\\nfrom . import models\\nfrom .conf import get_manager\\nfrom .exceptions import APNSError, APNSUnsupportedPriority, APNSServerError\\n\\n\\ndef _apns_create_socket(creds=None, application_id=None):\\n\\tif creds is None:\\n\\t\\tif not get_manager().has_auth_token_creds(application_id):\\n\\t\\t\\tcert = get_manager().get_apns_certificate(application_id)\\n\\t\\t\\tcreds = apns2_credentials.CertificateCredentials(cert)\\n\\t\\telse:\\n\\t\\t\\tkeyPath, keyId, teamId = get_manager().get_apns_auth_creds(application_id)\\n\\t\\t\\t# No use getting a lifetime because this credential is\\n\\t\\t\\t# ephemeral, but if you\\'re looking at this to see how to\\n\\t\\t\\t# create a credential, you could also pass the lifetime and\\n\\t\\t\\t# algorithm. Neither of those settings are exposed in the\\n\\t\\t\\t# settings API at the moment.\\n\\t\\t\\tcreds = creds or apns2_credentials.TokenCredentials(keyPath, keyId, teamId)\\n\\tclient = apns2_client.APNsClient(\\n\\t\\tcreds,\\n\\t\\tuse_sandbox=get_manager().get_apns_use_sandbox(application_id),\\n\\t\\tuse_alternative_port=get_manager().get_apns_use_alternative_port(application_id)\\n\\t)\\n\\tclient.connect()\\n\\treturn client\\n\\n\\ndef _apns_prepare(\\n\\ttoken, alert, application_id=None, badge=None, sound=None, category=None,\\n\\tcontent_available=False, action_loc_key=None, loc_key=None, loc_args=[],\\n\\textra={}, mutable_content=False, thread_id=None, url_args=None):\\n\\t\\tif action_loc_key or loc_key or loc_args:\\n\\t\\t\\tapns2_alert = apns2_payload.PayloadAlert(\\n\\t\\t\\t\\tbody=alert if alert else {}, body_localized_key=loc_key,\\n\\t\\t\\t\\tbody_localized_args=loc_args, action_localized_key=action_loc_key)\\n\\t\\telse:\\n\\t\\t\\tapns2_alert = alert\\n\\n\\t\\tif callable(badge):\\n\\t\\t\\tbadge = badge(token)\\n\\n\\t\\treturn apns2_payload.Payload(\\n\\t\\t\\talert=apns2_alert, badge=badge, sound=sound, category=category,\\n\\t\\t\\turl_args=url_args, custom=extra, thread_id=thread_id,\\n\\t\\t\\tcontent_available=content_available, mutable_content=mutable_content)\\n\\n\\ndef _apns_send(\\n\\tregistration_id, alert, batch=False, application_id=None, creds=None, **kwargs\\n):\\n\\tclient = _apns_create_socket(creds=creds, application_id=application_id)\\n\\n\\tnotification_kwargs = {}\\n\\n\\t# if expiration isn\"t specified use 1 month from now\\n\\tnotification_kwargs[\"expiration\"] = kwargs.pop(\"expiration\", None)\\n\\tif not notification_kwargs[\"expiration\"]:\\n\\t\\tnotification_kwargs[\"expiration\"] = int(time.time()) + 2592000\\n\\n\\tpriority = kwargs.pop(\"priority\", None)\\n\\tif priority:\\n\\t\\ttry:\\n\\t\\t\\tnotification_kwargs[\"priority\"] = apns2_client.NotificationPriority(str(priority))\\n\\t\\texcept ValueError:\\n\\t\\t\\traise APNSUnsupportedPriority(\"Unsupported priority %d\" % (priority))\\n\\n\\tnotification_kwargs[\"collapse_id\"] = kwargs.pop(\"collapse_id\", None)\\n\\n\\tif batch:\\n\\t\\tdata = [apns2_client.Notification(\\n\\t\\t\\ttoken=rid, payload=_apns_prepare(rid, alert, **kwargs)) for rid in registration_id]\\n\\t\\t# returns a dictionary mapping each token to its result. That\\n\\t\\t# result is either \"Success\" or the reason for the failure.\\n\\t\\treturn client.send_notification_batch(\\n\\t\\t\\tdata, get_manager().get_apns_topic(application_id=application_id),\\n\\t\\t\\t**notification_kwargs\\n\\t\\t)\\n\\n\\tdata = _apns_prepare(registration_id, alert, **kwargs)\\n\\tclient.send_notification(\\n\\t\\tregistration_id, data,\\n\\t\\tget_manager().get_apns_topic(application_id=application_id),\\n\\t\\t**notification_kwargs\\n\\t)\\n\\n\\ndef apns_send_message(registration_id, alert, application_id=None, creds=None, **kwargs):\\n\\t\"\"\"\\n\\tSends an APNS notification to a single registration_id.\\n\\tThis will send the notification as form data.\\n\\tIf sending multiple notifications, it is more efficient to use\\n\\tapns_send_bulk_message()\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\ttry:\\n\\t\\t_apns_send(\\n\\t\\t\\tregistration_id, alert, application_id=application_id,\\n\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t)\\n\\texcept apns2_errors.APNsException as apns2_exception:\\n\\t\\tif isinstance(apns2_exception, apns2_errors.Unregistered):\\n\\t\\t\\tdevice = models.APNSDevice.objects.get(registration_id=registration_id)\\n\\t\\t\\tdevice.active = False\\n\\t\\t\\tdevice.save()\\n\\n\\t\\traise APNSServerError(status=apns2_exception.__class__.__name__)\\n\\n\\ndef apns_send_bulk_message(\\n\\tregistration_ids, alert, application_id=None, creds=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends an APNS notification to one or more registration_ids.\\n\\tThe registration_ids argument needs to be a list.\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\tresults = _apns_send(\\n\\t\\tregistration_ids, alert, batch=True, application_id=application_id,\\n\\t\\tcreds=creds, **kwargs\\n\\t)\\n\\tinactive_tokens = [token for token, result in results.items() if result == \"Unregistered\"]\\n\\tmodels.APNSDevice.objects.filter(registration_id__in=inactive_tokens).update(active=False)\\n\\treturn results\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'# flake8:noqa\\nfrom urllib.error import HTTPError\\nfrom urllib.parse import urlencode\\nfrom urllib.request import Request, urlopen\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.utils.module_loading import import_string\\n\\nfrom .app import AppConfig  # noqa: F401\\nfrom .appmodel import AppModelConfig  # noqa: F401\\nfrom .legacy import LegacyConfig  # noqa: F401\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS  # noqa: I001\\n\\n\\nmanager = None\\n\\n\\ndef get_manager(reload=False):\\n\\tglobal manager\\n\\n\\tif not manager or reload is True:\\n\\t\\tmanager = import_string(SETTINGS[\"CONFIG\"])()\\n\\n\\treturn manager\\n\\n\\n# implementing get_manager as a function allows tests to reload settings\\nget_manager()\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig, check_apns_certificate\\n\\n\\nSETTING_MISMATCH = (\\n\\t\"Application \\'{application_id}\\' ({platform}) does not support the setting \\'{setting}\\'.\"\\n)\\n\\n# code can be \"missing\" or \"invalid\"\\nBAD_PLATFORM = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"PLATFORM\"] is {code}. \\'\\n\\t\"Must be one of: {platforms}.\"\\n)\\n\\nUNKNOWN_PLATFORM = (\\n\\t\"Unknown Platform: {platform}. Must be one of: {platforms}.\"\\n)\\n\\nMISSING_SETTING = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"{setting}\"] is missing.\\'\\n)\\n\\nPLATFORMS = [\\n\\t\"APNS\",\\n\\t\"FCM\",\\n\\t\"GCM\",\\n\\t\"WNS\",\\n\\t\"WP\",\\n]\\n\\n# Settings that all applications must have\\nREQUIRED_SETTINGS = [\\n\\t\"PLATFORM\",\\n]\\n\\n# Settings that an application may have to enable optional features\\n# these settings are stubs for registry support and have no effect on the operation\\n# of the application at this time.\\nOPTIONAL_SETTINGS = [\\n\\t\"APPLICATION_GROUP\", \"APPLICATION_SECRET\"\\n]\\n\\n# Since we can have an auth key, combined with a auth key id and team id *or*\\n# a certificate, we make these all optional, and then make sure we have one or\\n# the other (group) of settings.\\nAPNS_SETTINGS_CERT_CREDS = \"CERTIFICATE\"\\n\\n# Subkeys for APNS_SETTINGS_AUTH_CREDS\\nAPNS_AUTH_CREDS_REQUIRED = [\"AUTH_KEY_PATH\", \"AUTH_KEY_ID\", \"TEAM_ID\"]\\nAPNS_AUTH_CREDS_OPTIONAL = [\"CERTIFICATE\", \"ENCRYPTION_ALGORITHM\", \"TOKEN_LIFETIME\"]\\n\\nAPNS_OPTIONAL_SETTINGS = [\\n\\t\"USE_SANDBOX\", \"USE_ALTERNATIVE_PORT\", \"TOPIC\"\\n]\\n\\nFCM_REQUIRED_SETTINGS = GCM_REQUIRED_SETTINGS = [\"API_KEY\"]\\nFCM_OPTIONAL_SETTINGS = GCM_OPTIONAL_SETTINGS = [\\n\\t\"POST_URL\", \"MAX_RECIPIENTS\", \"ERROR_TIMEOUT\"\\n]\\n\\nWNS_REQUIRED_SETTINGS = [\"PACKAGE_SECURITY_ID\", \"SECRET_KEY\"]\\nWNS_OPTIONAL_SETTINGS = [\"WNS_ACCESS_URL\"]\\n\\nWP_REQUIRED_SETTINGS = [\"PRIVATE_KEY\", \"CLAIMS\"]\\nWP_OPTIONAL_SETTINGS = [\"ERROR_TIMEOUT\", \"POST_URL\"]\\n\\n\\nclass AppConfig(BaseConfig):\\n\\t\"\"\"\\n\\tSupports any number of push notification enabled applications.\\n\\t\"\"\"\\n\\n\\tdef __init__(self, settings=None):\\n\\t\\t# supports overriding the settings to be loaded. Will load from ..settings by default.\\n\\t\\tself._settings = settings or SETTINGS\\n\\n\\t\\t# initialize APPLICATIONS to an empty collection\\n\\t\\tself._settings.setdefault(\"APPLICATIONS\", {})\\n\\n\\t\\t# validate application configurations\\n\\t\\tself._validate_applications(self._settings[\"APPLICATIONS\"])\\n\\n\\tdef _validate_applications(self, apps):\\n\\t\\t\"\"\"Validate the application collection\"\"\"\\n\\t\\tfor application_id, application_config in apps.items():\\n\\t\\t\\tself._validate_config(application_id, application_config)\\n\\n\\t\\t\\tapplication_config[\"APPLICATION_ID\"] = application_id\\n\\n\\tdef _validate_config(self, application_id, application_config):\\n\\t\\tplatform = application_config.get(\"PLATFORM\", None)\\n\\n\\t\\t# platform is not present\\n\\t\\tif platform is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"required\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# platform is not a valid choice from PLATFORMS\\n\\t\\tif platform not in PLATFORMS:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"invalid\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\tvalidate_fn = \"_validate_{platform}_config\".format(platform=platform).lower()\\n\\n\\t\\tif hasattr(self, validate_fn):\\n\\t\\t\\tgetattr(self, validate_fn)(application_id, application_config)\\n\\t\\telse:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tUNKNOWN_PLATFORM.format(\\n\\t\\t\\t\\t\\tplatform=platform,\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\tdef _validate_apns_config(self, application_id, application_config):\\n\\t\\tallowed = REQUIRED_SETTINGS + OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\tAPNS_OPTIONAL_SETTINGS\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\t# We have two sets of settings, certificate and JWT auth key.\\n\\t\\t# Auth Key requires 3 values, so if that is set, that will take\\n\\t\\t# precedence. If None are set, we will throw an error.\\n\\t\\thas_cert_creds = APNS_SETTINGS_CERT_CREDS in \\\\\\n\\t\\t\\tapplication_config.keys()\\n\\t\\tself.has_token_creds = True\\n\\t\\tfor token_setting in APNS_AUTH_CREDS_REQUIRED:\\n\\t\\t\\tif token_setting not in application_config.keys():\\n\\t\\t\\t\\tself.has_token_creds = False\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif not has_cert_creds and not self.has_token_creds:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tsetting=(APNS_SETTINGS_CERT_CREDS, APNS_AUTH_CREDS_REQUIRED)))\\n\\t\\tcert_path = None\\n\\t\\tif has_cert_creds:\\n\\t\\t\\tcert_path = \"CERTIFICATE\"\\n\\t\\telif self.has_token_creds:\\n\\t\\t\\tcert_path = \"AUTH_KEY_PATH\"\\n\\t\\t\\tallowed_tokens = APNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\t\\tAPNS_OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\t\\tREQUIRED_SETTINGS\\n\\t\\t\\tself._validate_allowed_settings(application_id, application_config, allowed_tokens)\\n\\t\\t\\tself._validate_required_settings(\\n\\t\\t\\t\\tapplication_id, application_config, APNS_AUTH_CREDS_REQUIRED\\n\\t\\t\\t)\\n\\t\\tself._validate_apns_certificate(application_config[cert_path])\\n\\n\\t\\t# determine/set optional values\\n\\t\\tapplication_config.setdefault(\"USE_SANDBOX\", False)\\n\\t\\tapplication_config.setdefault(\"USE_ALTERNATIVE_PORT\", False)\\n\\t\\tapplication_config.setdefault(\"TOPIC\", None)\\n\\n\\tdef _validate_apns_certificate(self, certfile):\\n\\t\\t\"\"\"Validate the APNS certificate at startup.\"\"\"\\n\\n\\t\\ttry:\\n\\t\\t\\twith open(certfile, \"r\") as f:\\n\\t\\t\\t\\tcontent = f.read()\\n\\t\\t\\t\\tcheck_apns_certificate(content)\\n\\t\\texcept Exception as e:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"The APNS certificate file at {!r} is not readable: {}\".format(certfile, e)\\n\\t\\t\\t)\\n\\n\\tdef _validate_fcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + FCM_REQUIRED_SETTINGS + FCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, FCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://fcm.googleapis.com/fcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_gcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + GCM_REQUIRED_SETTINGS + GCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, GCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://android.googleapis.com/gcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_wns_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WNS_REQUIRED_SETTINGS + WNS_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WNS_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\")\\n\\n\\tdef _validate_wp_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WP_REQUIRED_SETTINGS + WP_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WP_REQUIRED_SETTINGS\\n\\t\\t)\\n\\t\\tapplication_config.setdefault(\"POST_URL\", {\\n\\t\\t\\t\"CHROME\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"OPERA\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n\\t\\t\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\\t})\\n\\n\\tdef _validate_allowed_settings(self, application_id, application_config, allowed_settings):\\n\\t\\t\"\"\"Confirm only allowed settings are present.\"\"\"\\n\\n\\t\\tfor setting_key in application_config.keys():\\n\\t\\t\\tif setting_key not in allowed_settings:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"Platform {}, app {} does not support the setting: {}.\".format(\\n\\t\\t\\t\\t\\t\\tapplication_config[\"PLATFORM\"], application_id, setting_key\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\n\\tdef _validate_required_settings(\\n\\t\\tself, application_id, application_config, required_settings,\\n\\t\\tshould_throw=True\\n\\t):\\n\\t\\t\"\"\"All required keys must be present\"\"\"\\n\\n\\t\\tfor setting_key in required_settings:\\n\\t\\t\\tif setting_key not in application_config.keys():\\n\\t\\t\\t\\tif should_throw:\\n\\t\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\t\\t\\tapplication_id=application_id, setting=setting_key\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tdef _get_application_settings(self, application_id, platform, settings_key):\\n\\t\\t\"\"\"\\n\\t\\tWalks through PUSH_NOTIFICATIONS_SETTINGS to find the correct setting value\\n\\t\\tor raises ImproperlyConfigured.\\n\\t\\t\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tconf_cls = \"push_notifications.conf.AppConfig\"\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"{} requires the application_id be specified at all times.\".format(conf_cls)\\n\\t\\t\\t)\\n\\n\\t\\t# verify that the application config exists\\n\\t\\tapp_config = self._settings.get(\"APPLICATIONS\").get(application_id, None)\\n\\t\\tif app_config is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"No application configured with application_id: {}.\".format(application_id)\\n\\t\\t\\t)\\n\\n\\t\\t# fetch a setting for the incorrect type of platform\\n\\t\\tif app_config.get(\"PLATFORM\") != platform:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tSETTING_MISMATCH.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tplatform=app_config.get(\"PLATFORM\"),\\n\\t\\t\\t\\t\\tsetting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# finally, try to fetch the setting\\n\\t\\tif settings_key not in app_config:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id, setting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\treturn app_config.get(settings_key)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\treturn self.has_token_creds\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"GCM\", \"API_KEY\")\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"FCM\", \"API_KEY\")\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"POST_URL\")\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"ERROR_TIMEOUT\")\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"MAX_RECIPIENTS\")\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(application_id, \"APNS\", \"CERTIFICATE\")\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn \\\\\\n\\t\\t(self._get_apns_auth_key_path(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key_path(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_PATH\")\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_ID\")\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TEAM_ID\")\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_SANDBOX\")\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_ALTERNATIVE_PORT\")\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TOPIC\")\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"PACKAGE_SECURITY_ID\")\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"SECRET_KEY\")\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"POST_URL\")[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"PRIVATE_KEY\")\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"CLAIMS\")\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from .base import BaseConfig\\n\\n\\nclass AppModelConfig(BaseConfig):\\n\\t\"\"\"Future home of the Application Model conf adapter\\n\\n\\tSupports multiple applications in the database.\\n\\t\"\"\"\\n\\n\\tpass\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.core.exceptions import ImproperlyConfigured\\n\\n\\nclass BaseConfig:\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_applications(self):\\n\\t\\t\"\"\"Returns a collection containing the configured applications.\"\"\"\\n\\n\\t\\traise NotImplementedError\\n\\n\\n# This works for both the certificate and the auth key (since that\\'s just\\n# a certificate).\\ndef check_apns_certificate(ss):\\n\\tmode = \"start\"\\n\\tfor s in ss.split(\"\\\\n\"):\\n\\t\\tif mode == \"start\":\\n\\t\\t\\tif \"BEGIN RSA PRIVATE KEY\" in s or \"BEGIN PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"key\"\\n\\t\\telif mode == \"key\":\\n\\t\\t\\tif \"END RSA PRIVATE KEY\" in s or \"END PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"end\"\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif s.startswith(\"Proc-Type\") and \"ENCRYPTED\" in s:\\n\\t\\t\\t\\traise ImproperlyConfigured(\"Encrypted APNS private keys are not supported\")\\n\\n\\tif mode != \"end\":\\n\\t\\traise ImproperlyConfigured(\"The APNS certificate doesn\\'t contain a private key\")\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig\\n\\n\\n__all__ = [\\n\\t\"LegacyConfig\"\\n]\\n\\n\\nclass empty:\\n\\tpass\\n\\n\\nclass LegacyConfig(BaseConfig):\\n\\n\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\n\\tdef _get_application_settings(self, application_id, settings_key, error_message):\\n\\t\\t\"\"\"Legacy behaviour\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tvalue = SETTINGS.get(settings_key, empty)\\n\\t\\t\\tif value is empty:\\n\\t\\t\\t\\traise ImproperlyConfigured(error_message)\\n\\t\\t\\treturn value\\n\\t\\telse:\\n\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\"LegacySettings does not support application_id. To enable \"\\n\\t\\t\\t\\t\"multiple application support, use push_notifications.conf.AppSettings.\"\\n\\t\\t\\t)\\n\\t\\t\\traise ImproperlyConfigured(msg)\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"GCM_API_KEY\"] to send messages through GCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"GCM_API_KEY\", msg)\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"FCM_API_KEY\"] to send messages through FCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"FCM_API_KEY\", msg)\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_POST_URL\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_ERROR_TIMEOUT\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_MAX_RECIPIENTS\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\ttry:\\n\\t\\t\\tself._get_apns_auth_key(application_id)\\n\\t\\t\\tself._get_apns_auth_key_id(application_id)\\n\\t\\t\\tself._get_apns_team_id(application_id)\\n\\t\\texcept ImproperlyConfigured:\\n\\t\\t\\treturn False\\n\\n\\t\\treturn True\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(\\n\\t\\t\\tapplication_id, \"APNS_CERTIFICATE\",\\n\\t\\t\\t\"You need to setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\t)\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\traise ImproperlyConfigured(msg)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn (\\n\\t\\t\\tself._get_apns_auth_key(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_PATH\", self.msg)\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TEAM_ID\", self.msg)\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_ID\", self.msg)\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_USE_SANDBOX\", self.msg)\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn\\n\\t\\tself._get_application_settings(application_id, \"APNS_USE_ALTERNATIVE_PORT\", self.msg)\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TOPIC\", self.msg)\\n\\n\\tdef get_apns_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_HOST\", self.msg)\\n\\n\\tdef get_apns_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_PORT\", self.msg)\\n\\n\\tdef get_apns_feedback_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_HOST\", self.msg)\\n\\n\\tdef get_apns_feedback_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_PORT\", self.msg)\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_PACKAGE_SECURITY_ID\", self.msg)\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_SECRET_KEY\", msg)\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_POST_URL\", msg)[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_PRIVATE_KEY\", msg)\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_CLAIMS\", msg)\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'class NotificationError(Exception):\\n\\tpass\\n\\n\\n# APNS\\nclass APNSError(NotificationError):\\n\\tpass\\n\\n\\nclass APNSUnsupportedPriority(APNSError):\\n\\tpass\\n\\n\\nclass APNSServerError(APNSError):\\n\\tdef __init__(self, status):\\n\\t\\tsuper().__init__(status)\\n\\t\\tself.status = status\\n\\n\\n# GCM\\nclass GCMError(NotificationError):\\n\\tpass\\n\\n\\n# Web Push\\nclass WebPushError(NotificationError):\\n\\tpass\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'import re\\nimport struct\\n\\nfrom django import forms\\nfrom django.core.validators import MaxValueValidator, MinValueValidator, RegexValidator\\nfrom django.db import connection, models\\nfrom django.utils.translation import gettext_lazy as _\\n\\n\\n__all__ = [\"HexadecimalField\", \"HexIntegerField\"]\\n\\nUNSIGNED_64BIT_INT_MIN_VALUE = 0\\nUNSIGNED_64BIT_INT_MAX_VALUE = 2 ** 64 - 1\\n\\n\\nhex_re = re.compile(r\"^(([0-9A-f])|(0x[0-9A-f]))+$\")\\nsigned_integer_vendors = [\\n\\t\"postgresql\",\\n\\t\"sqlite\",\\n]\\n\\n\\ndef _using_signed_storage():\\n\\treturn connection.vendor in signed_integer_vendors\\n\\n\\ndef _signed_to_unsigned_integer(value):\\n\\treturn struct.unpack(\"Q\", struct.pack(\"q\", value))[0]\\n\\n\\ndef _unsigned_to_signed_integer(value):\\n\\treturn struct.unpack(\"q\", struct.pack(\"Q\", value))[0]\\n\\n\\ndef _hex_string_to_unsigned_integer(value):\\n\\treturn int(value, 16)\\n\\n\\ndef _unsigned_integer_to_hex_string(value):\\n\\treturn hex(value).rstrip(\"L\")\\n\\n\\nclass HexadecimalField(forms.CharField):\\n\\t\"\"\"\\n\\tA form field that accepts only hexadecimal numbers\\n\\t\"\"\"\\n\\tdef __init__(self, *args, **kwargs):\\n\\t\\tself.default_validators = [\\n\\t\\t\\tRegexValidator(hex_re, _(\"Enter a valid hexadecimal number\"), \"invalid\")\\n\\t\\t]\\n\\t\\tsuper(HexadecimalField, self).__init__(*args, **kwargs)\\n\\n\\tdef prepare_value(self, value):\\n\\t\\t# converts bigint from db to hex before it is displayed in admin\\n\\t\\tif value and not isinstance(value, str) \\\\\\n\\t\\t\\tand connection.vendor in (\"mysql\", \"sqlite\"):\\n\\t\\t\\tvalue = _unsigned_integer_to_hex_string(value)\\n\\t\\treturn super(forms.CharField, self).prepare_value(value)\\n\\n\\nclass HexIntegerField(models.BigIntegerField):\\n\\t\"\"\"\\n\\tThis field stores a hexadecimal *string* of up to 64 bits as an unsigned integer\\n\\ton *all* backends including postgres.\\n\\n\\tReasoning: Postgres only supports signed bigints. Since we don\\'t care about\\n\\tsignedness, we store it as signed, and cast it to unsigned when we deal with\\n\\tthe actual value (with struct)\\n\\n\\tOn sqlite and mysql, native unsigned bigint types are used. In all cases, the\\n\\tvalue we deal with in python is always in hex.\\n\\t\"\"\"\\n\\n\\tvalidators = [\\n\\t\\tMinValueValidator(UNSIGNED_64BIT_INT_MIN_VALUE),\\n\\t\\tMaxValueValidator(UNSIGNED_64BIT_INT_MAX_VALUE)\\n\\t]\\n\\n\\tdef db_type(self, connection):\\n\\t\\tif \"mysql\" == connection.vendor:\\n\\t\\t\\treturn \"bigint unsigned\"\\n\\t\\telif \"sqlite\" == connection.vendor:\\n\\t\\t\\treturn \"UNSIGNED BIG INT\"\\n\\t\\telse:\\n\\t\\t\\treturn super(HexIntegerField, self).db_type(connection=connection)\\n\\n\\tdef get_prep_value(self, value):\\n\\t\\t\"\"\" Return the integer value to be stored from the hex string \"\"\"\\n\\t\\tif value is None or value == \"\":\\n\\t\\t\\treturn None\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _unsigned_to_signed_integer(value)\\n\\t\\treturn value\\n\\n\\tdef from_db_value(self, value, *args):\\n\\t\\t\"\"\" Return an unsigned int representation from all db backends \"\"\"\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _signed_to_unsigned_integer(value)\\n\\t\\treturn value\\n\\n\\tdef to_python(self, value):\\n\\t\\t\"\"\" Return a str representation of the hexadecimal \"\"\"\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\treturn value\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\treturn _unsigned_integer_to_hex_string(value)\\n\\n\\tdef formfield(self, **kwargs):\\n\\t\\tdefaults = {\"form_class\": HexadecimalField}\\n\\t\\tdefaults.update(kwargs)\\n\\t\\t# yes, that super call is right\\n\\t\\treturn super(models.IntegerField, self).formfield(**defaults)\\n\\n\\tdef run_validators(self, value):\\n\\t\\t# make sure validation is performed on integer value not string value\\n\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\treturn super(models.BigIntegerField, self).run_validators(value)\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'\"\"\"\\nFirebase Cloud Messaging\\nPreviously known as GCM / C2DM\\nDocumentation is available on the Firebase Developer website:\\nhttps://firebase.google.com/docs/cloud-messaging/\\n\"\"\"\\n\\nimport json\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import Request, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import GCMError\\nfrom .models import GCMDevice\\n\\n\\n# Valid keys for FCM messages. Reference:\\n# https://firebase.google.com/docs/cloud-messaging/http-server-ref\\nFCM_TARGETS_KEYS = [\\n\\t\"to\", \"condition\", \"notification_key\"\\n]\\nFCM_OPTIONS_KEYS = [\\n\\t\"collapse_key\", \"priority\", \"content_available\", \"delay_while_idle\", \"time_to_live\",\\n\\t\"restricted_package_name\", \"dry_run\", \"mutable_content\"\\n]\\nFCM_NOTIFICATIONS_PAYLOAD_KEYS = [\\n\\t\"title\", \"body\", \"icon\", \"image\", \"sound\", \"badge\", \"color\", \"tag\", \"click_action\",\\n\\t\"body_loc_key\", \"body_loc_args\", \"title_loc_key\", \"title_loc_args\", \"android_channel_id\"\\n]\\n\\ndef _chunks(l, n):\\n\\t\"\"\"\\n\\tYield successive chunks from list \\\\a l with a minimum size \\\\a n\\n\\t\"\"\"\\n\\tfor i in range(0, len(l), n):\\n\\t\\tyield l[i:i + n]\\n\\n\\ndef _gcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_gcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"GCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"GCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _fcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_fcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"FCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"FCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _cm_handle_response(registration_ids, response_data, cloud_type, application_id=None):\\n\\tresponse = response_data\\n\\tif response.get(\"failure\") or response.get(\"canonical_ids\"):\\n\\t\\tids_to_remove, old_new_ids = [], []\\n\\t\\tthrow_error = False\\n\\t\\tfor index, result in enumerate(response[\"results\"]):\\n\\t\\t\\terror = result.get(\"error\")\\n\\t\\t\\tif error:\\n\\t\\t\\t\\t# https://firebase.google.com/docs/cloud-messaging/http-server-ref#error-codes\\n\\t\\t\\t\\t# If error is NotRegistered or InvalidRegistration, then we will deactivate devices\\n\\t\\t\\t\\t# because this registration ID is no more valid and can\\'t be used to send messages,\\n\\t\\t\\t\\t# otherwise raise error\\n\\t\\t\\t\\tif error in (\"NotRegistered\", \"InvalidRegistration\"):\\n\\t\\t\\t\\t\\tids_to_remove.append(registration_ids[index])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tthrow_error = True\\n\\t\\t\\tresult[\"original_registration_id\"] = registration_ids[index]\\n\\t\\t\\t# If registration_id is set, replace the original ID with the new value (canonical ID)\\n\\t\\t\\t# in your server database. Note that the original ID is not part of the result, you need\\n\\t\\t\\t# to obtain it from the list of registration_ids in the request (using the same index).\\n\\t\\t\\tnew_id = result.get(\"registration_id\")\\n\\t\\t\\tif new_id:\\n\\t\\t\\t\\told_new_ids.append((registration_ids[index], new_id))\\n\\n\\t\\tif ids_to_remove:\\n\\t\\t\\tremoved = GCMDevice.objects.filter(\\n\\t\\t\\t\\tregistration_id__in=ids_to_remove, cloud_message_type=cloud_type\\n\\t\\t\\t)\\n\\t\\t\\tremoved.update(active=False)\\n\\n\\t\\tfor old_id, new_id in old_new_ids:\\n\\t\\t\\t_cm_handle_canonical_id(new_id, old_id, cloud_type)\\n\\n\\t\\tif throw_error:\\n\\t\\t\\traise GCMError(response)\\n\\treturn response\\n\\n\\ndef _cm_send_request(\\n\\tregistration_ids, data, cloud_type=\"GCM\", application_id=None,\\n\\tuse_fcm_notifications=True, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a FCM or GCM notification to one or more registration_ids as json data.\\n\\tThe registration_ids needs to be a list.\\n\\t\"\"\"\\n\\n\\tpayload = {\"registration_ids\": registration_ids} if registration_ids else {}\\n\\n\\tdata = data.copy()\\n\\n\\t# If using FCM, optionally autodiscovers notification related keys\\n\\t# https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages\\n\\tif cloud_type == \"FCM\" and use_fcm_notifications:\\n\\t\\tnotification_payload = {}\\n\\t\\tif \"message\" in data:\\n\\t\\t\\tnotification_payload[\"body\"] = data.pop(\"message\", None)\\n\\n\\t\\tfor key in FCM_NOTIFICATIONS_PAYLOAD_KEYS:\\n\\t\\t\\tvalue_from_extra = data.pop(key, None)\\n\\t\\t\\tif value_from_extra:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_extra\\n\\t\\t\\tvalue_from_kwargs = kwargs.pop(key, None)\\n\\t\\t\\tif value_from_kwargs:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_kwargs\\n\\t\\tif notification_payload:\\n\\t\\t\\tpayload[\"notification\"] = notification_payload\\n\\n\\tif data:\\n\\t\\tpayload[\"data\"] = data\\n\\n\\t# Attach any additional non falsy keyword args (targets, options)\\n\\t# See ref : https://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\tpayload.update({\\n\\t\\tk: v for k, v in kwargs.items() if v and (k in FCM_TARGETS_KEYS or k in FCM_OPTIONS_KEYS)\\n\\t})\\n\\n\\t# Sort the keys for deterministic output (useful for tests)\\n\\tjson_payload = json.dumps(payload, separators=(\",\", \":\"), sort_keys=True).encode(\"utf-8\")\\n\\n\\t# Sends requests and handles the response\\n\\tif cloud_type == \"GCM\":\\n\\t\\tresponse = json.loads(_gcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telif cloud_type == \"FCM\":\\n\\t\\tresponse = json.loads(_fcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\treturn _cm_handle_response(registration_ids, response, cloud_type, application_id)\\n\\n\\ndef _cm_handle_canonical_id(canonical_id, current_id, cloud_type):\\n\\t\"\"\"\\n\\tHandle situation when FCM server response contains canonical ID\\n\\t\"\"\"\\n\\tdevices = GCMDevice.objects.filter(cloud_message_type=cloud_type)\\n\\tif devices.filter(registration_id=canonical_id, active=True).exists():\\n\\t\\tdevices.filter(registration_id=current_id).update(active=False)\\n\\telse:\\n\\t\\tdevices.filter(registration_id=current_id).update(registration_id=canonical_id)\\n\\n\\ndef send_message(registration_ids, data, cloud_type, application_id=None, **kwargs):\\n\\t\"\"\"\\n\\tSends a FCM (or GCM) notification to one or more registration_ids. The registration_ids\\n\\tcan be a list or a single string. This will send the notification as json data.\\n\\n\\tA reference of extra keyword arguments sent to the server is available here:\\n\\thttps://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\t\"\"\"\\n\\tif cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\tmax_recipients = get_manager().get_max_recipients(cloud_type, application_id)\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\n\\t# Checks for valid recipient\\n\\tif registration_ids is None and \"/topics/\" not in kwargs.get(\"to\", \"\"):\\n\\t\\treturn\\n\\n\\t# Bundles the registration_ids in an list if only one is sent\\n\\tif not isinstance(registration_ids, list):\\n\\t\\tregistration_ids = [registration_ids] if registration_ids else None\\n\\n\\t# FCM only allows up to 1000 reg ids per bulk message\\n\\t# https://firebase.google.com/docs/cloud-messaging/server#http-request\\n\\tif registration_ids:\\n\\t\\tret = []\\n\\t\\tfor chunk in _chunks(registration_ids, max_recipients):\\n\\t\\t\\tret.append(_cm_send_request(\\n\\t\\t\\t\\tchunk, data, cloud_type=cloud_type, application_id=application_id, **kwargs\\n\\t\\t\\t))\\n\\t\\treturn ret[0] if len(ret) == 1 else ret\\n\\telse:\\n\\t\\treturn _cm_send_request(None, data, cloud_type=cloud_type, **kwargs)\\n\\n\\nsend_bulk_message = send_message\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\nimport push_notifications.fields\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='APNSDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', models.UUIDField(help_text='UDID / UIDevice.identifierForVendor()', max_length=32, null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.CharField(unique=True, max_length=64, verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'APNS device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n        migrations.CreateModel(\\n            name='GCMDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', push_notifications.fields.HexIntegerField(help_text='ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)', null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'GCM device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n    ]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.1 on 2016-01-06 08:50\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0001_initial'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=True, verbose_name='Registration ID'),\\n        ),\\n    ]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nimport django.db.models.deletion\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0002_auto_20160106_0850'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WNSDevice',\\n            fields=[\\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\\n                ('name', models.CharField(blank=True, max_length=255, null=True, verbose_name='Name')),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, null=True, verbose_name='Creation date')),\\n                ('device_id', models.UUIDField(blank=True, db_index=True, help_text='GUID()', null=True, verbose_name='Device ID')),\\n                ('registration_id', models.TextField(verbose_name='Notification URI')),\\n                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\\n            ],\\n            options={\\n                'verbose_name': 'WNS device',\\n            },\\n        ),\\n    ]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n\\tdependencies = [\\n\\t\\tmigrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n\\t\\t('push_notifications', '0003_wnsdevice'),\\n\\t]\\n\\n\\toperations = [\\n\\t\\tmigrations.AddField(\\n\\t\\t\\tmodel_name='gcmdevice',\\n\\t\\t\\tname='cloud_message_type',\\n\\t\\t\\tfield=models.CharField(choices=[('FCM', 'Firebase Cloud Message'), ('GCM', 'Google Cloud Message')], default='GCM', help_text='You should choose FCM or GCM', max_length=3, verbose_name='Cloud Message Type')\\n\\t\\t),\\n\\t]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0004_fcm'),\\n    ]\\n\\n    operations = [\\n        migrations.AddField(\\n            model_name='apnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='gcmdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='wnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n    ]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0005_applicationid'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WebPushDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('application_id', models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('p256dh', models.CharField(max_length=88, verbose_name='User public encryption key')),\\n                ('auth', models.CharField(max_length=24, verbose_name='User auth secret')),\\n                ('browser', models.CharField(default='CHROME', help_text='Currently only support to Chrome, Firefox and Opera browsers', max_length=10, verbose_name='Browser', choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera')])),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'WebPush device',\\n            },\\n        ),\\n    ]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"from django.db import migrations, models\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0006_webpushdevice'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='gcmdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='wnsdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Notification URI'),\\n        ),\\n    ]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# Generated by Django 3.2.8 on 2021-11-12 09:49\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0007_uniquesetting'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='browser',\\n            field=models.CharField(choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera'), ('EDGE', 'Edge')], default='CHROME', help_text='Currently only support to Chrome, Firefox, Edge and Opera browsers', max_length=10, verbose_name='Browser'),\\n        ),\\n    ]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# Generated by Django 3.2.9 on 2022-01-10 09:03\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0008_webpush_add_edge'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='device_id',\\n            field=models.UUIDField(blank=True, db_index=True, help_text='UUID / UIDevice.identifierForVendor()', null=True, verbose_name='Device ID'),\\n        ),\\n    ]\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b''"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.db import models\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .fields import HexIntegerField\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nCLOUD_MESSAGE_TYPES = (\\n\\t(\"FCM\", \"Firebase Cloud Message\"),\\n\\t(\"GCM\", \"Google Cloud Message\"),\\n)\\n\\nBROWSER_TYPES = (\\n\\t(\"CHROME\", \"Chrome\"),\\n\\t(\"FIREFOX\", \"Firefox\"),\\n\\t(\"OPERA\", \"Opera\"),\\n\\t(\"EDGE\", \"Edge\")\\n)\\n\\n\\nclass Device(models.Model):\\n\\tname = models.CharField(max_length=255, verbose_name=_(\"Name\"), blank=True, null=True)\\n\\tactive = models.BooleanField(\\n\\t\\tverbose_name=_(\"Is active\"), default=True,\\n\\t\\thelp_text=_(\"Inactive devices will not be sent notifications\")\\n\\t)\\n\\tuser = models.ForeignKey(\\n\\t\\tSETTINGS[\"USER_MODEL\"], blank=True, null=True, on_delete=models.CASCADE\\n\\t)\\n\\tdate_created = models.DateTimeField(\\n\\t\\tverbose_name=_(\"Creation date\"), auto_now_add=True, null=True\\n\\t)\\n\\tapplication_id = models.CharField(\\n\\t\\tmax_length=64, verbose_name=_(\"Application ID\"),\\n\\t\\thelp_text=_(\\n\\t\\t\\t\"Opaque application identity, should be filled in for multiple\"\\n\\t\\t\\t\" key/certificate access\"\\n\\t\\t),\\n\\t\\tblank=True, null=True\\n\\t)\\n\\n\\tclass Meta:\\n\\t\\tabstract = True\\n\\n\\tdef __str__(self):\\n\\t\\treturn (\\n\\t\\t\\tself.name or\\n\\t\\t\\tstr(self.device_id or \"\") or\\n\\t\\t\\t\"{} for {}\".format(self.__class__.__name__, self.user or \"unknown user\")\\n\\t\\t)\\n\\n\\nclass GCMDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn GCMDeviceQuerySet(self.model)\\n\\n\\nclass GCMDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\t\\tif message is not None:\\n\\t\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\\n\\t\\t\\t\\t\"application_id\"\\n\\t\\t\\t).values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tresponse = []\\n\\t\\t\\tfor cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\t\\treg_ids = list(\\n\\t\\t\\t\\t\\t\\tself.filter(\\n\\t\\t\\t\\t\\t\\t\\tactive=True, cloud_message_type=cloud_type, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\tif reg_ids:\\n\\t\\t\\t\\t\\t\\tr = gcm_send_message(reg_ids, data, cloud_type, application_id=app_id, **kwargs)\\n\\t\\t\\t\\t\\t\\tresponse.append(r)\\n\\n\\t\\t\\treturn response\\n\\n\\nclass GCMDevice(Device):\\n\\t# device_id cannot be a reliable primary key as fragmentation between different devices\\n\\t# can make it turn out to be null and such:\\n\\t# http://android-developers.blogspot.co.uk/2011/03/identifying-app-installations.html\\n\\tdevice_id = HexIntegerField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tcloud_message_type = models.CharField(\\n\\t\\tverbose_name=_(\"Cloud Message Type\"), max_length=3,\\n\\t\\tchoices=CLOUD_MESSAGE_TYPES, default=\"GCM\",\\n\\t\\thelp_text=_(\"You should choose FCM or GCM\")\\n\\t)\\n\\tobjects = GCMDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"GCM device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\tif message is not None:\\n\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\treturn gcm_send_message(\\n\\t\\t\\tself.registration_id, data, self.cloud_message_type,\\n\\t\\t\\tapplication_id=self.application_id, **kwargs\\n\\t\\t)\\n\\n\\nclass APNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn APNSDeviceQuerySet(self.model)\\n\\n\\nclass APNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .apns import apns_send_bulk_message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\")\\\\\\n\\t\\t\\t\\t.values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tres = []\\n\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\treg_ids = list(self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\"registration_id\", flat=True)\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tr = apns_send_bulk_message(\\n\\t\\t\\t\\t\\tregistration_ids=reg_ids, alert=message, application_id=app_id,\\n\\t\\t\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\t\\tres += [r]\\n\\t\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\t\\tres += r\\n\\t\\t\\treturn res\\n\\n\\nclass APNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"UUID / UIDevice.identifierForVendor()\")\\n\\t)\\n\\tregistration_id = models.CharField(\\n\\t\\tverbose_name=_(\"Registration ID\"), max_length=200, unique=SETTINGS[\"UNIQUE_REG_ID\"]\\n\\t)\\n\\n\\tobjects = APNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"APNS device\")\\n\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tfrom .apns import apns_send_message\\n\\n\\t\\treturn apns_send_message(\\n\\t\\t\\tregistration_id=self.registration_id,\\n\\t\\t\\talert=message,\\n\\t\\t\\tapplication_id=self.application_id, creds=creds,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WNSDeviceQuerySet(self.model)\\n\\n\\nclass WNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_bulk_message\\n\\n\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\").values_list(\\n\\t\\t\\t\"application_id\", flat=True\\n\\t\\t).distinct()\\n\\t\\tres = []\\n\\t\\tfor app_id in app_ids:\\n\\t\\t\\treg_ids = self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t)\\n\\t\\t\\tr = wns_send_bulk_message(uri_list=list(reg_ids), message=message, **kwargs)\\n\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\tres += [r]\\n\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\tres += r\\n\\n\\t\\treturn res\\n\\n\\nclass WNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"GUID()\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Notification URI\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\n\\tobjects = WNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WNS device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_message\\n\\n\\t\\treturn wns_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, application_id=self.application_id,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WebPushDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WebPushDeviceQuerySet(self.model)\\n\\n\\nclass WebPushDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tdevices = self.filter(active=True).order_by(\"application_id\").distinct()\\n\\t\\tres = []\\n\\t\\tfor device in devices:\\n\\t\\t\\tres.append(device.send_message(message))\\n\\n\\t\\treturn res\\n\\n\\nclass WebPushDevice(Device):\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tp256dh = models.CharField(\\n\\t\\tverbose_name=_(\"User public encryption key\"),\\n\\t\\tmax_length=88)\\n\\tauth = models.CharField(\\n\\t\\tverbose_name=_(\"User auth secret\"),\\n\\t\\tmax_length=24)\\n\\tbrowser = models.CharField(\\n\\t\\tverbose_name=_(\"Browser\"), max_length=10,\\n\\t\\tchoices=BROWSER_TYPES, default=BROWSER_TYPES[0][0],\\n\\t\\thelp_text=_(\"Currently only support to Chrome, Firefox, Edge and Opera browsers\")\\n\\t)\\n\\tobjects = WebPushDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WebPush device\")\\n\\n\\t@property\\n\\tdef device_id(self):\\n\\t\\treturn None\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .webpush import webpush_send_message\\n\\n\\t\\treturn webpush_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, browser=self.browser,\\n\\t\\t\\tauth=self.auth, p256dh=self.p256dh, application_id=self.application_id, **kwargs)\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.conf import settings\\n\\n\\nPUSH_NOTIFICATIONS_SETTINGS = getattr(settings, \"PUSH_NOTIFICATIONS_SETTINGS\", {})\\n\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"CONFIG\", \"push_notifications.conf.LegacyConfig\"\\n)\\n\\n# GCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"GCM_POST_URL\", \"https://android.googleapis.com/gcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_ERROR_TIMEOUT\", None)\\n\\n# FCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"FCM_POST_URL\", \"https://fcm.googleapis.com/fcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_ERROR_TIMEOUT\", None)\\n\\n# APNS\\nif settings.DEBUG:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", True)\\nelse:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_ALTERNATIVE_PORT\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_TOPIC\", None)\\n\\n# WNS\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_PACKAGE_SECURITY_ID\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_SECRET_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\"\\n)\\n\\n# WP (WebPush)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_POST_URL\", {\\n\\t\"CHROME\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"OPERA\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n})\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_PRIVATE_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_CLAIMS\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_ERROR_TIMEOUT\", None)\\n\\n# User model\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"USER_MODEL\", settings.AUTH_USER_MODEL)\\n\\n# Unique registration ID for all devices\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UNIQUE_REG_ID\", False)\\n\\n# API endpoint settings\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UPDATE_ON_DUPLICATE_REG_ID\", False)\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from pywebpush import WebPushException, webpush\\n\\nfrom .conf import get_manager\\nfrom .exceptions import WebPushError\\n\\n\\ndef get_subscription_info(application_id, uri, browser, auth, p256dh):\\n\\turl = get_manager().get_wp_post_url(application_id, browser)\\n\\treturn {\\n\\t\\t\"endpoint\": \"{}/{}\".format(url, uri),\\n\\t\\t\"keys\": {\\n\\t\\t\\t\"auth\": auth,\\n\\t\\t\\t\"p256dh\": p256dh,\\n\\t\\t}\\n\\t}\\n\\n\\ndef webpush_send_message(\\n\\turi, message, browser, auth, p256dh, application_id=None, **kwargs\\n):\\n\\tsubscription_info = get_subscription_info(application_id, uri, browser, auth, p256dh)\\n\\n\\ttry:\\n\\t\\tresponse = webpush(\\n\\t\\t\\tsubscription_info=subscription_info,\\n\\t\\t\\tdata=message,\\n\\t\\t\\tvapid_private_key=get_manager().get_wp_private_key(application_id),\\n\\t\\t\\tvapid_claims=get_manager().get_wp_claims(application_id).copy(),\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\t\\tresults = {\"results\": [{}]}\\n\\t\\tif not response.ok:\\n\\t\\t\\tresults[\"results\"][0][\"error\"] = response.content\\n\\t\\t\\tresults[\"results\"][0][\"original_registration_id\"] = response.content\\n\\t\\telse:\\n\\t\\t\\tresults[\"success\"] = 1\\n\\t\\treturn results\\n\\texcept WebPushException as e:\\n\\t\\traise WebPushError(e.message)\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'\"\"\"\\nWindows Notification Service\\n\\nDocumentation is available on the Windows Dev Center:\\nhttps://msdn.microsoft.com/en-us/windows/uwp/controls-and-patterns/tiles-and-notifications-windows-push-notification-services--wns--overview\\n\"\"\"\\n\\nimport json\\nimport xml.etree.ElementTree as ET\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import HTTPError, Request, urlencode, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import NotificationError\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass WNSError(NotificationError):\\n\\tpass\\n\\n\\nclass WNSAuthenticationError(WNSError):\\n\\tpass\\n\\n\\nclass WNSNotificationResponseError(WNSError):\\n\\tpass\\n\\n\\ndef _wns_authenticate(scope=\"notify.windows.com\", application_id=None):\\n\\t\"\"\"\\n\\tRequests an Access token for WNS communication.\\n\\n\\t:return: dict: {\\'access_token\\': <str>, \\'expires_in\\': <int>, \\'token_type\\': \\'bearer\\'}\\n\\t\"\"\"\\n\\tclient_id = get_manager().get_wns_package_security_id(application_id)\\n\\tclient_secret = get_manager().get_wns_secret_key(application_id)\\n\\tif not client_id:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_PACKAGE_SECURITY_ID\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\tif not client_secret:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_SECRET_KEY\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": \"application/x-www-form-urlencoded\",\\n\\t}\\n\\tparams = {\\n\\t\\t\"grant_type\": \"client_credentials\",\\n\\t\\t\"client_id\": client_id,\\n\\t\\t\"client_secret\": client_secret,\\n\\t\\t\"scope\": scope,\\n\\t}\\n\\tdata = urlencode(params).encode(\"utf-8\")\\n\\n\\trequest = Request(SETTINGS[\"WNS_ACCESS_URL\"], data=data, headers=headers)\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\t# One of your settings is probably jacked up.\\n\\t\\t\\t# https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh868245\\n\\t\\t\\traise WNSAuthenticationError(\"Authentication failed, check your WNS settings.\")\\n\\t\\traise err\\n\\n\\toauth_data = response.read().decode(\"utf-8\")\\n\\ttry:\\n\\t\\toauth_data = json.loads(oauth_data)\\n\\texcept Exception:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Received invalid JSON data from WNS.\")\\n\\n\\taccess_token = oauth_data.get(\"access_token\")\\n\\tif not access_token:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Access token missing from WNS response.\")\\n\\n\\treturn access_token\\n\\n\\ndef _wns_send(uri, data, wns_type=\"wns/toast\", application_id=None):\\n\\t\"\"\"\\n\\tSends a notification data and authentication to WNS.\\n\\n\\t:param uri: str: The device\\'s unique notification URI\\n\\t:param data: dict: The notification data to be sent.\\n\\t:return:\\n\\t\"\"\"\\n\\taccess_token = _wns_authenticate(application_id=application_id)\\n\\n\\tcontent_type = \"text/xml\"\\n\\tif wns_type == \"wns/raw\":\\n\\t\\tcontent_type = \"application/octet-stream\"\\n\\n\\theaders = {\\n\\t\\t# content_type is \"text/xml\" (toast/badge/tile) | \"application/octet-stream\" (raw)\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"Bearer %s\" % (access_token),\\n\\t\\t\"X-WNS-Type\": wns_type,  # wns/toast | wns/badge | wns/tile | wns/raw\\n\\t}\\n\\n\\tif type(data) is str:\\n\\t\\tdata = data.encode(\"utf-8\")\\n\\n\\trequest = Request(uri, data, headers)\\n\\n\\t# A lot of things can happen, let them know which one.\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\tmsg = \"One or more headers were specified incorrectly or conflict with another header.\"\\n\\t\\telif err.code == 401:\\n\\t\\t\\tmsg = \"The cloud service did not present a valid authentication ticket.\"\\n\\t\\telif err.code == 403:\\n\\t\\t\\tmsg = \"The cloud service is not authorized to send a notification to this URI.\"\\n\\t\\telif err.code == 404:\\n\\t\\t\\tmsg = \"The channel URI is not valid or is not recognized by WNS.\"\\n\\t\\telif err.code == 405:\\n\\t\\t\\tmsg = \"Invalid method. Only POST or DELETE is allowed.\"\\n\\t\\telif err.code == 406:\\n\\t\\t\\tmsg = \"The cloud service exceeded its throttle limit\"\\n\\t\\telif err.code == 410:\\n\\t\\t\\tmsg = \"The channel expired.\"\\n\\t\\telif err.code == 413:\\n\\t\\t\\tmsg = \"The notification payload exceeds the 500 byte limit.\"\\n\\t\\telif err.code == 500:\\n\\t\\t\\tmsg = \"An internal failure caused notification delivery to fail.\"\\n\\t\\telif err.code == 503:\\n\\t\\t\\tmsg = \"The server is currently unavailable.\"\\n\\t\\telse:\\n\\t\\t\\traise err\\n\\t\\traise WNSNotificationResponseError(\"HTTP %i: %s\" % (err.code, msg))\\n\\n\\treturn response.read().decode(\"utf-8\")\\n\\n\\ndef _wns_prepare_toast(data, **kwargs):\\n\\t\"\"\"\\n\\tCreates the xml tree for a `toast` notification\\n\\n\\t:param data: dict: The notification data to be converted to an xml tree.\\n\\n\\t{\\n\\t\\t\"text\": [\"Title text\", \"Message Text\", \"Another message!\"],\\n\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t}\\n\\n\\t:return: str\\n\\t\"\"\"\\n\\troot = ET.Element(\"toast\")\\n\\tvisual = ET.SubElement(root, \"visual\")\\n\\tbinding = ET.SubElement(visual, \"binding\")\\n\\tbinding.attrib[\"template\"] = kwargs.pop(\"template\", \"ToastText01\")\\n\\tif \"text\" in data:\\n\\t\\tfor count, item in enumerate(data[\"text\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"text\")\\n\\t\\t\\telem.text = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\tif \"image\" in data:\\n\\t\\tfor count, item in enumerate(data[\"image\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"img\")\\n\\t\\t\\telem.attrib[\"src\"] = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\treturn ET.tostring(root)\\n\\n\\ndef wns_send_message(\\n\\turi, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a notification request to WNS.\\n\\tThere are four notification types that WNS can send: toast, tile, badge and raw.\\n\\tToast, tile, and badge can all be customized to use different\\n\\ttemplates/icons/sounds/launch params/etc.\\n\\tSee docs for more information:\\n\\thttps://msdn.microsoft.com/en-us/library/windows/apps/br212853.aspx\\n\\n\\tThere are multiple ways to input notification data:\\n\\n\\t1. The simplest and least custom notification to send is to just pass a string\\n\\tto `message`. This will create a toast notification with one text element. e.g.:\\n\\t\\t\"This is my notification title\"\\n\\n\\t2. You can also pass a dictionary to `message`: it can only contain one or both\\n\\tkeys: [\"text\", \"image\"]. The value of each key must be a list with the text and\\n\\tsrc respectively. e.g.:\\n\\t\\t{\\n\\t\\t\\t\"text\": [\"text1\", \"text2\"],\\n\\t\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t\\t}\\n\\n\\t3. Passing a dictionary to `xml_data` will create one of three types of\\n\\tnotifications depending on the dictionary data (toast, tile, badge).\\n\\tSee `dict_to_xml_schema` docs for more information on dictionary formatting.\\n\\n\\t4. Passing a value to `raw_data` will create a `raw` notification and send the\\n\\tinput data as is.\\n\\n\\t:param uri: str: The device\\'s unique notification uri.\\n\\t:param message: str|dict: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\t# Create a simple toast notification\\n\\tif message:\\n\\t\\twns_type = \"wns/toast\"\\n\\t\\tif isinstance(message, str):\\n\\t\\t\\tmessage = {\\n\\t\\t\\t\\t\"text\": [message, ],\\n\\t\\t\\t}\\n\\t\\tprepared_data = _wns_prepare_toast(data=message, **kwargs)\\n\\t# Create a toast/tile/badge notification from a dictionary\\n\\telif xml_data:\\n\\t\\txml = dict_to_xml_schema(xml_data)\\n\\t\\twns_type = \"wns/%s\" % xml.tag\\n\\t\\tprepared_data = ET.tostring(xml)\\n\\t# Create a raw notification\\n\\telif raw_data:\\n\\t\\twns_type = \"wns/raw\"\\n\\t\\tprepared_data = raw_data\\n\\telse:\\n\\t\\traise TypeError(\\n\\t\\t\\t\"At least one of the following parameters must be set:\"\\n\\t\\t\\t\"`message`, `xml_data`, `raw_data`\"\\n\\t\\t)\\n\\n\\treturn _wns_send(\\n\\t\\turi=uri, data=prepared_data, wns_type=wns_type, application_id=application_id\\n\\t)\\n\\n\\ndef wns_send_bulk_message(\\n\\turi_list, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tWNS doesn\\'t support bulk notification, so we loop through each uri.\\n\\n\\t:param uri_list: list: A list of uris the notification will be sent to.\\n\\t:param message: str: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\tres = []\\n\\tif uri_list:\\n\\t\\tfor uri in uri_list:\\n\\t\\t\\tr = wns_send_message(\\n\\t\\t\\t\\turi=uri, message=message, xml_data=xml_data,\\n\\t\\t\\t\\traw_data=raw_data, application_id=application_id, **kwargs\\n\\t\\t\\t)\\n\\t\\t\\tres.append(r)\\n\\treturn res\\n\\n\\ndef dict_to_xml_schema(data):\\n\\t\"\"\"\\n\\tInput a dictionary to be converted to xml. There should be only one key at\\n\\tthe top level. The value must be a dict with (required) `children` key and\\n\\t(optional) `attrs` key. This will be called the `sub-element dictionary`.\\n\\n\\tThe `attrs` value must be a dictionary; each value will be added to the\\n\\telement\\'s xml tag as attributes. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\n\\twould result in:\\n\\t\\t<example key1=\"value1\" key2=\"value2\"></example>\\n\\n\\tIf the value is a dict it must contain one or more keys which will be used\\n\\tas the sub-element names. Each sub-element must have a value of a sub-element\\n\\tdictionary(see above) or a list of sub-element dictionaries.\\n\\tIf the value is not a dict, it will be the value of the element.\\n\\tIf the value is a list, multiple elements of the same tag will be created\\n\\tfrom each sub-element dict in the list.\\n\\n\\t:param data: dict: Used to create an XML tree. e.g.:\\n\\t\\texample_data = {\\n\\t\\t\\t\"toast\": {\\n\\t\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\\t\"launch\": \"param\",\\n\\t\\t\\t\\t\\t\"duration\": \"short\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\"visual\": {\\n\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\"binding\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"template\": \"ToastText01\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"text\": [\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"1\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text1\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"2\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text2\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor key, value in data.items():\\n\\t\\troot = _add_element_attrs(ET.Element(key), value.get(\"attrs\", {}))\\n\\t\\tchildren = value.get(\"children\", None)\\n\\t\\tif isinstance(children, dict):\\n\\t\\t\\t_add_sub_elements_from_dict(root, children)\\n\\t\\treturn root\\n\\n\\ndef _add_sub_elements_from_dict(parent, sub_dict):\\n\\t\"\"\"\\n\\tAdd SubElements to the parent element.\\n\\n\\t:param parent: ElementTree.Element: The parent element for the newly created SubElement.\\n\\t:param sub_dict: dict: Used to create a new SubElement. See `dict_to_xml_schema`\\n\\tmethod docstring for more information. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\t\"\"\"\\n\\tfor key, value in sub_dict.items():\\n\\t\\tif isinstance(value, list):\\n\\t\\t\\tfor repeated_element in value:\\n\\t\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t\\t_add_element_attrs(sub_element, repeated_element.get(\"attrs\", {}))\\n\\t\\t\\t\\tchildren = repeated_element.get(\"children\", None)\\n\\t\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\t\\tsub_element.text = children\\n\\t\\telse:\\n\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t_add_element_attrs(sub_element, value.get(\"attrs\", {}))\\n\\t\\t\\tchildren = value.get(\"children\", None)\\n\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\tsub_element.text = children\\n\\n\\ndef _add_element_attrs(elem, attrs):\\n\\t\"\"\"\\n\\tAdd attributes to the given element.\\n\\n\\t:param elem: ElementTree.Element: The element the attributes are being added to.\\n\\t:param attrs: dict: A dictionary of attributes. e.g.:\\n\\t\\t{\"attribute1\": \"value\", \"attribute2\": \"another\"}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor attr, value in attrs.items():\\n\\t\\telem.attrib[attr] = value\\n\\treturn elem\\n'"}, "return_value": "'utf-8'"}]}, "neuter_encoding_declaration": {"line": 214, "args": [{"func_args": {"source": "'try:\\n    # Python 3.8+\\n    import importlib.metadata as importlib_metadata\\nexcept ImportError:\\n    # <Python 3.7 and lower\\n    import importlib_metadata\\n\\n__version__ = importlib_metadata.version(\"django-push-notifications\")\\n'"}, "return_value": "'try:\\n    # Python 3.8+\\n    import importlib.metadata as importlib_metadata\\nexcept ImportError:\\n    # <Python 3.7 and lower\\n    import importlib_metadata\\n\\n__version__ = importlib_metadata.version(\"django-push-notifications\")\\n'"}, {"func_args": {"source": "'try:\\n    # Python 3.8+\\n    import importlib.metadata as importlib_metadata\\nexcept ImportError:\\n    # <Python 3.7 and lower\\n    import importlib_metadata\\n\\n__version__ = importlib_metadata.version(\"django-push-notifications\")\\n'"}, "return_value": "'try:\\n    # Python 3.8+\\n    import importlib.metadata as importlib_metadata\\nexcept ImportError:\\n    # <Python 3.7 and lower\\n    import importlib_metadata\\n\\n__version__ = importlib_metadata.version(\"django-push-notifications\")\\n'"}, {"func_args": {"source": "'from django.apps import apps\\nfrom django.contrib import admin, messages\\nfrom django.utils.encoding import force_str\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .exceptions import APNSServerError, GCMError, WebPushError\\nfrom .models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nUser = apps.get_model(*SETTINGS[\"USER_MODEL\"].split(\".\"))\\n\\n\\nclass DeviceAdmin(admin.ModelAdmin):\\n\\tlist_display = (\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\",)\\n\\tactions = (\"send_message\", \"send_bulk_message\", \"enable\", \"disable\")\\n\\traw_id_fields = (\"user\",)\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"device_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"device_id\")\\n\\n\\tdef send_messages(self, request, queryset, bulk=False):\\n\\t\\t\"\"\"\\n\\t\\tProvides error handling for DeviceAdmin send_message and send_bulk_message methods.\\n\\t\\t\"\"\"\\n\\t\\tret = []\\n\\t\\terrors = []\\n\\t\\tr = \"\"\\n\\n\\t\\tfor device in queryset:\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tif bulk:\\n\\t\\t\\t\\t\\tr = queryset.send_message(\"Test bulk notification\")\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = device.send_message(\"Test single notification\")\\n\\t\\t\\t\\tif r:\\n\\t\\t\\t\\t\\tret.append(r)\\n\\t\\t\\texcept GCMError as e:\\n\\t\\t\\t\\terrors.append(str(e))\\n\\t\\t\\texcept APNSServerError as e:\\n\\t\\t\\t\\terrors.append(e.status)\\n\\t\\t\\texcept WebPushError as e:\\n\\t\\t\\t\\terrors.append(force_str(e))\\n\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\t# Because NotRegistered and InvalidRegistration do not throw GCMError\\n\\t\\t# catch them here to display error msg.\\n\\t\\tif not bulk:\\n\\t\\t\\tfor r in ret:\\n\\t\\t\\t\\tif \"error\" in r[\"results\"][0]:\\n\\t\\t\\t\\t\\terrors.append(r[\"results\"][0][\"error\"])\\n\\t\\telse:\\n\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\terrors = [r[\"error\"] for r in ret[0][0][\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\terrors = errors + [r[\"error\"] for r in entry[\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept IndexError:\\n\\t\\t\\t\\t\\tpass\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\tif value.lower() != \"success\":\\n\\t\\t\\t\\t\\t\\terrors.append(value)\\n\\t\\tif errors:\\n\\t\\t\\tself.message_user(\\n\\t\\t\\t\\trequest, _(\"Some messages could not be processed: %r\" % (\", \".join(errors))),\\n\\t\\t\\t\\tlevel=messages.ERROR\\n\\t\\t\\t)\\n\\t\\tif ret:\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\t# When the queryset exceeds the max_recipients value, the\\n\\t\\t\\t\\t# send_message method returns a list of dicts, one per chunk\\n\\t\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\t\\tsuccess = ret[0][0][\"success\"]\\n\\t\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\t\\tsuccess = 0\\n\\t\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\t\\tsuccess = success + entry[\"success\"]\\n\\t\\t\\t\\t\\tif success == 0:\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\t\\tsuccess = []\\n\\t\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\t\\tif value.lower() == \"success\":\\n\\t\\t\\t\\t\\t\\t\\tsuccess.append(key)\\n\\n\\t\\t\\telif len(errors) == len(ret):\\n\\t\\t\\t\\treturn\\n\\t\\t\\tif errors:\\n\\t\\t\\t\\tmsg = _(\"Some messages were sent: %s\" % (ret))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = _(\"All messages were sent: %s\" % (ret))\\n\\t\\t\\tself.message_user(request, msg)\\n\\n\\tdef send_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset)\\n\\n\\tsend_message.short_description = _(\"Send test message\")\\n\\n\\tdef send_bulk_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset, True)\\n\\n\\tsend_bulk_message.short_description = _(\"Send test message in bulk\")\\n\\n\\tdef enable(self, request, queryset):\\n\\t\\tqueryset.update(active=True)\\n\\n\\tenable.short_description = _(\"Enable selected devices\")\\n\\n\\tdef disable(self, request, queryset):\\n\\t\\tqueryset.update(active=False)\\n\\n\\tdisable.short_description = _(\"Disable selected devices\")\\n\\n\\nclass GCMDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\\n\\t\\t\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\", \"cloud_message_type\"\\n\\t)\\n\\tlist_filter = (\"active\", \"cloud_message_type\")\\n\\n\\nclass WebPushDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\"__str__\", \"browser\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\", \"browser\")\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"registration_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"registration_id\")\\n\\n\\nadmin.site.register(APNSDevice, DeviceAdmin)\\nadmin.site.register(GCMDevice, GCMDeviceAdmin)\\nadmin.site.register(WNSDevice, DeviceAdmin)\\nadmin.site.register(WebPushDevice, WebPushDeviceAdmin)\\n'"}, "return_value": "'from django.apps import apps\\nfrom django.contrib import admin, messages\\nfrom django.utils.encoding import force_str\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .exceptions import APNSServerError, GCMError, WebPushError\\nfrom .models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nUser = apps.get_model(*SETTINGS[\"USER_MODEL\"].split(\".\"))\\n\\n\\nclass DeviceAdmin(admin.ModelAdmin):\\n\\tlist_display = (\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\",)\\n\\tactions = (\"send_message\", \"send_bulk_message\", \"enable\", \"disable\")\\n\\traw_id_fields = (\"user\",)\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"device_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"device_id\")\\n\\n\\tdef send_messages(self, request, queryset, bulk=False):\\n\\t\\t\"\"\"\\n\\t\\tProvides error handling for DeviceAdmin send_message and send_bulk_message methods.\\n\\t\\t\"\"\"\\n\\t\\tret = []\\n\\t\\terrors = []\\n\\t\\tr = \"\"\\n\\n\\t\\tfor device in queryset:\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tif bulk:\\n\\t\\t\\t\\t\\tr = queryset.send_message(\"Test bulk notification\")\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = device.send_message(\"Test single notification\")\\n\\t\\t\\t\\tif r:\\n\\t\\t\\t\\t\\tret.append(r)\\n\\t\\t\\texcept GCMError as e:\\n\\t\\t\\t\\terrors.append(str(e))\\n\\t\\t\\texcept APNSServerError as e:\\n\\t\\t\\t\\terrors.append(e.status)\\n\\t\\t\\texcept WebPushError as e:\\n\\t\\t\\t\\terrors.append(force_str(e))\\n\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\t# Because NotRegistered and InvalidRegistration do not throw GCMError\\n\\t\\t# catch them here to display error msg.\\n\\t\\tif not bulk:\\n\\t\\t\\tfor r in ret:\\n\\t\\t\\t\\tif \"error\" in r[\"results\"][0]:\\n\\t\\t\\t\\t\\terrors.append(r[\"results\"][0][\"error\"])\\n\\t\\telse:\\n\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\terrors = [r[\"error\"] for r in ret[0][0][\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\terrors = errors + [r[\"error\"] for r in entry[\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept IndexError:\\n\\t\\t\\t\\t\\tpass\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\tif value.lower() != \"success\":\\n\\t\\t\\t\\t\\t\\terrors.append(value)\\n\\t\\tif errors:\\n\\t\\t\\tself.message_user(\\n\\t\\t\\t\\trequest, _(\"Some messages could not be processed: %r\" % (\", \".join(errors))),\\n\\t\\t\\t\\tlevel=messages.ERROR\\n\\t\\t\\t)\\n\\t\\tif ret:\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\t# When the queryset exceeds the max_recipients value, the\\n\\t\\t\\t\\t# send_message method returns a list of dicts, one per chunk\\n\\t\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\t\\tsuccess = ret[0][0][\"success\"]\\n\\t\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\t\\tsuccess = 0\\n\\t\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\t\\tsuccess = success + entry[\"success\"]\\n\\t\\t\\t\\t\\tif success == 0:\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\t\\tsuccess = []\\n\\t\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\t\\tif value.lower() == \"success\":\\n\\t\\t\\t\\t\\t\\t\\tsuccess.append(key)\\n\\n\\t\\t\\telif len(errors) == len(ret):\\n\\t\\t\\t\\treturn\\n\\t\\t\\tif errors:\\n\\t\\t\\t\\tmsg = _(\"Some messages were sent: %s\" % (ret))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = _(\"All messages were sent: %s\" % (ret))\\n\\t\\t\\tself.message_user(request, msg)\\n\\n\\tdef send_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset)\\n\\n\\tsend_message.short_description = _(\"Send test message\")\\n\\n\\tdef send_bulk_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset, True)\\n\\n\\tsend_bulk_message.short_description = _(\"Send test message in bulk\")\\n\\n\\tdef enable(self, request, queryset):\\n\\t\\tqueryset.update(active=True)\\n\\n\\tenable.short_description = _(\"Enable selected devices\")\\n\\n\\tdef disable(self, request, queryset):\\n\\t\\tqueryset.update(active=False)\\n\\n\\tdisable.short_description = _(\"Disable selected devices\")\\n\\n\\nclass GCMDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\\n\\t\\t\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\", \"cloud_message_type\"\\n\\t)\\n\\tlist_filter = (\"active\", \"cloud_message_type\")\\n\\n\\nclass WebPushDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\"__str__\", \"browser\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\", \"browser\")\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"registration_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"registration_id\")\\n\\n\\nadmin.site.register(APNSDevice, DeviceAdmin)\\nadmin.site.register(GCMDevice, GCMDeviceAdmin)\\nadmin.site.register(WNSDevice, DeviceAdmin)\\nadmin.site.register(WebPushDevice, WebPushDeviceAdmin)\\n'"}, {"func_args": {"source": "'from django.apps import apps\\nfrom django.contrib import admin, messages\\nfrom django.utils.encoding import force_str\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .exceptions import APNSServerError, GCMError, WebPushError\\nfrom .models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nUser = apps.get_model(*SETTINGS[\"USER_MODEL\"].split(\".\"))\\n\\n\\nclass DeviceAdmin(admin.ModelAdmin):\\n\\tlist_display = (\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\",)\\n\\tactions = (\"send_message\", \"send_bulk_message\", \"enable\", \"disable\")\\n\\traw_id_fields = (\"user\",)\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"device_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"device_id\")\\n\\n\\tdef send_messages(self, request, queryset, bulk=False):\\n\\t\\t\"\"\"\\n\\t\\tProvides error handling for DeviceAdmin send_message and send_bulk_message methods.\\n\\t\\t\"\"\"\\n\\t\\tret = []\\n\\t\\terrors = []\\n\\t\\tr = \"\"\\n\\n\\t\\tfor device in queryset:\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tif bulk:\\n\\t\\t\\t\\t\\tr = queryset.send_message(\"Test bulk notification\")\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = device.send_message(\"Test single notification\")\\n\\t\\t\\t\\tif r:\\n\\t\\t\\t\\t\\tret.append(r)\\n\\t\\t\\texcept GCMError as e:\\n\\t\\t\\t\\terrors.append(str(e))\\n\\t\\t\\texcept APNSServerError as e:\\n\\t\\t\\t\\terrors.append(e.status)\\n\\t\\t\\texcept WebPushError as e:\\n\\t\\t\\t\\terrors.append(force_str(e))\\n\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\t# Because NotRegistered and InvalidRegistration do not throw GCMError\\n\\t\\t# catch them here to display error msg.\\n\\t\\tif not bulk:\\n\\t\\t\\tfor r in ret:\\n\\t\\t\\t\\tif \"error\" in r[\"results\"][0]:\\n\\t\\t\\t\\t\\terrors.append(r[\"results\"][0][\"error\"])\\n\\t\\telse:\\n\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\terrors = [r[\"error\"] for r in ret[0][0][\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\terrors = errors + [r[\"error\"] for r in entry[\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept IndexError:\\n\\t\\t\\t\\t\\tpass\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\tif value.lower() != \"success\":\\n\\t\\t\\t\\t\\t\\terrors.append(value)\\n\\t\\tif errors:\\n\\t\\t\\tself.message_user(\\n\\t\\t\\t\\trequest, _(\"Some messages could not be processed: %r\" % (\", \".join(errors))),\\n\\t\\t\\t\\tlevel=messages.ERROR\\n\\t\\t\\t)\\n\\t\\tif ret:\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\t# When the queryset exceeds the max_recipients value, the\\n\\t\\t\\t\\t# send_message method returns a list of dicts, one per chunk\\n\\t\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\t\\tsuccess = ret[0][0][\"success\"]\\n\\t\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\t\\tsuccess = 0\\n\\t\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\t\\tsuccess = success + entry[\"success\"]\\n\\t\\t\\t\\t\\tif success == 0:\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\t\\tsuccess = []\\n\\t\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\t\\tif value.lower() == \"success\":\\n\\t\\t\\t\\t\\t\\t\\tsuccess.append(key)\\n\\n\\t\\t\\telif len(errors) == len(ret):\\n\\t\\t\\t\\treturn\\n\\t\\t\\tif errors:\\n\\t\\t\\t\\tmsg = _(\"Some messages were sent: %s\" % (ret))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = _(\"All messages were sent: %s\" % (ret))\\n\\t\\t\\tself.message_user(request, msg)\\n\\n\\tdef send_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset)\\n\\n\\tsend_message.short_description = _(\"Send test message\")\\n\\n\\tdef send_bulk_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset, True)\\n\\n\\tsend_bulk_message.short_description = _(\"Send test message in bulk\")\\n\\n\\tdef enable(self, request, queryset):\\n\\t\\tqueryset.update(active=True)\\n\\n\\tenable.short_description = _(\"Enable selected devices\")\\n\\n\\tdef disable(self, request, queryset):\\n\\t\\tqueryset.update(active=False)\\n\\n\\tdisable.short_description = _(\"Disable selected devices\")\\n\\n\\nclass GCMDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\\n\\t\\t\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\", \"cloud_message_type\"\\n\\t)\\n\\tlist_filter = (\"active\", \"cloud_message_type\")\\n\\n\\nclass WebPushDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\"__str__\", \"browser\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\", \"browser\")\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"registration_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"registration_id\")\\n\\n\\nadmin.site.register(APNSDevice, DeviceAdmin)\\nadmin.site.register(GCMDevice, GCMDeviceAdmin)\\nadmin.site.register(WNSDevice, DeviceAdmin)\\nadmin.site.register(WebPushDevice, WebPushDeviceAdmin)\\n'"}, "return_value": "'from django.apps import apps\\nfrom django.contrib import admin, messages\\nfrom django.utils.encoding import force_str\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .exceptions import APNSServerError, GCMError, WebPushError\\nfrom .models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nUser = apps.get_model(*SETTINGS[\"USER_MODEL\"].split(\".\"))\\n\\n\\nclass DeviceAdmin(admin.ModelAdmin):\\n\\tlist_display = (\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\",)\\n\\tactions = (\"send_message\", \"send_bulk_message\", \"enable\", \"disable\")\\n\\traw_id_fields = (\"user\",)\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"device_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"device_id\")\\n\\n\\tdef send_messages(self, request, queryset, bulk=False):\\n\\t\\t\"\"\"\\n\\t\\tProvides error handling for DeviceAdmin send_message and send_bulk_message methods.\\n\\t\\t\"\"\"\\n\\t\\tret = []\\n\\t\\terrors = []\\n\\t\\tr = \"\"\\n\\n\\t\\tfor device in queryset:\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tif bulk:\\n\\t\\t\\t\\t\\tr = queryset.send_message(\"Test bulk notification\")\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = device.send_message(\"Test single notification\")\\n\\t\\t\\t\\tif r:\\n\\t\\t\\t\\t\\tret.append(r)\\n\\t\\t\\texcept GCMError as e:\\n\\t\\t\\t\\terrors.append(str(e))\\n\\t\\t\\texcept APNSServerError as e:\\n\\t\\t\\t\\terrors.append(e.status)\\n\\t\\t\\texcept WebPushError as e:\\n\\t\\t\\t\\terrors.append(force_str(e))\\n\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\t# Because NotRegistered and InvalidRegistration do not throw GCMError\\n\\t\\t# catch them here to display error msg.\\n\\t\\tif not bulk:\\n\\t\\t\\tfor r in ret:\\n\\t\\t\\t\\tif \"error\" in r[\"results\"][0]:\\n\\t\\t\\t\\t\\terrors.append(r[\"results\"][0][\"error\"])\\n\\t\\telse:\\n\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\terrors = [r[\"error\"] for r in ret[0][0][\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\terrors = errors + [r[\"error\"] for r in entry[\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept IndexError:\\n\\t\\t\\t\\t\\tpass\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\tif value.lower() != \"success\":\\n\\t\\t\\t\\t\\t\\terrors.append(value)\\n\\t\\tif errors:\\n\\t\\t\\tself.message_user(\\n\\t\\t\\t\\trequest, _(\"Some messages could not be processed: %r\" % (\", \".join(errors))),\\n\\t\\t\\t\\tlevel=messages.ERROR\\n\\t\\t\\t)\\n\\t\\tif ret:\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\t# When the queryset exceeds the max_recipients value, the\\n\\t\\t\\t\\t# send_message method returns a list of dicts, one per chunk\\n\\t\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\t\\tsuccess = ret[0][0][\"success\"]\\n\\t\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\t\\tsuccess = 0\\n\\t\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\t\\tsuccess = success + entry[\"success\"]\\n\\t\\t\\t\\t\\tif success == 0:\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\t\\tsuccess = []\\n\\t\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\t\\tif value.lower() == \"success\":\\n\\t\\t\\t\\t\\t\\t\\tsuccess.append(key)\\n\\n\\t\\t\\telif len(errors) == len(ret):\\n\\t\\t\\t\\treturn\\n\\t\\t\\tif errors:\\n\\t\\t\\t\\tmsg = _(\"Some messages were sent: %s\" % (ret))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = _(\"All messages were sent: %s\" % (ret))\\n\\t\\t\\tself.message_user(request, msg)\\n\\n\\tdef send_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset)\\n\\n\\tsend_message.short_description = _(\"Send test message\")\\n\\n\\tdef send_bulk_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset, True)\\n\\n\\tsend_bulk_message.short_description = _(\"Send test message in bulk\")\\n\\n\\tdef enable(self, request, queryset):\\n\\t\\tqueryset.update(active=True)\\n\\n\\tenable.short_description = _(\"Enable selected devices\")\\n\\n\\tdef disable(self, request, queryset):\\n\\t\\tqueryset.update(active=False)\\n\\n\\tdisable.short_description = _(\"Disable selected devices\")\\n\\n\\nclass GCMDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\\n\\t\\t\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\", \"cloud_message_type\"\\n\\t)\\n\\tlist_filter = (\"active\", \"cloud_message_type\")\\n\\n\\nclass WebPushDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\"__str__\", \"browser\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\", \"browser\")\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"registration_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"registration_id\")\\n\\n\\nadmin.site.register(APNSDevice, DeviceAdmin)\\nadmin.site.register(GCMDevice, GCMDeviceAdmin)\\nadmin.site.register(WNSDevice, DeviceAdmin)\\nadmin.site.register(WebPushDevice, WebPushDeviceAdmin)\\n'"}, {"func_args": {"source": "''"}, "return_value": "''"}, {"func_args": {"source": "'from rest_framework import permissions, status\\nfrom rest_framework.fields import IntegerField\\nfrom rest_framework.response import Response\\nfrom rest_framework.serializers import ModelSerializer, Serializer, ValidationError\\nfrom rest_framework.viewsets import ModelViewSet\\n\\nfrom ..fields import UNSIGNED_64BIT_INT_MAX_VALUE, hex_re\\nfrom ..models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\n# Fields\\nclass HexIntegerField(IntegerField):\\n\\t\"\"\"\\n\\tStore an integer represented as a hex string of form \"0x01\".\\n\\t\"\"\"\\n\\n\\tdef to_internal_value(self, data):\\n\\t\\t# validate hex string and convert it to the unsigned\\n\\t\\t# integer representation for internal use\\n\\t\\ttry:\\n\\t\\t\\tdata = int(data, 16) if type(data) != int else data\\n\\t\\texcept ValueError:\\n\\t\\t\\traise ValidationError(\"Device ID is not a valid hex number\")\\n\\t\\treturn super(HexIntegerField, self).to_internal_value(data)\\n\\n\\tdef to_representation(self, value):\\n\\t\\treturn value\\n\\n\\n# Serializers\\nclass DeviceSerializerMixin(ModelSerializer):\\n\\tclass Meta:\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"application_id\", \"registration_id\", \"device_id\",\\n\\t\\t\\t\"active\", \"date_created\"\\n\\t\\t)\\n\\t\\tread_only_fields = (\"date_created\",)\\n\\n\\t\\t# See https://github.com/tomchristie/django-rest-framework/issues/1101\\n\\t\\textra_kwargs = {\"active\": {\"default\": True}}\\n\\n\\nclass APNSDeviceSerializer(ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = APNSDevice\\n\\n\\tdef validate_registration_id(self, value):\\n\\t\\t# iOS device tokens are 256-bit hexadecimal (64 characters). In 2016 Apple is increasing\\n\\t\\t# iOS device tokens to 100 bytes hexadecimal (200 characters).\\n\\n\\t\\tif hex_re.match(value) is None or len(value) not in (64, 200):\\n\\t\\t\\traise ValidationError(\"Registration ID (device token) is invalid\")\\n\\n\\t\\treturn value\\n\\n\\nclass UniqueRegistrationSerializerMixin(Serializer):\\n\\tdef validate(self, attrs):\\n\\t\\tdevices = None\\n\\t\\tprimary_key = None\\n\\t\\trequest_method = None\\n\\n\\t\\tif self.initial_data.get(\"registration_id\", None):\\n\\t\\t\\tif self.instance:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telse:\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\t\\telse:\\n\\t\\t\\tif self.context[\"request\"].method in [\"PUT\", \"PATCH\"]:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telif self.context[\"request\"].method == \"POST\":\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\n\\t\\tDevice = self.Meta.model\\n\\t\\tif request_method == \"update\":\\n\\t\\t\\treg_id = attrs.get(\"registration_id\", self.instance.registration_id)\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=reg_id) \\\\\\n\\t\\t\\t\\t.exclude(id=primary_key)\\n\\t\\telif request_method == \"create\":\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=attrs[\"registration_id\"])\\n\\n\\t\\tif devices:\\n\\t\\t\\traise ValidationError({\"registration_id\": \"This field must be unique.\"})\\n\\t\\treturn attrs\\n\\n\\nclass GCMDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tdevice_id = HexIntegerField(\\n\\t\\thelp_text=\"ANDROID_ID / TelephonyManager.getDeviceId() (e.g: 0x01)\",\\n\\t\\tstyle={\"input_type\": \"text\"},\\n\\t\\trequired=False,\\n\\t\\tallow_null=True\\n\\t)\\n\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = GCMDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"device_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"cloud_message_type\", \"application_id\",\\n\\t\\t)\\n\\t\\textra_kwargs = {\"id\": {\"read_only\": False, \"required\": False}}\\n\\n\\tdef validate_device_id(self, value):\\n\\t\\t# device ids are 64 bit unsigned values\\n\\t\\tif value > UNSIGNED_64BIT_INT_MAX_VALUE:\\n\\t\\t\\traise ValidationError(\"Device ID is out of range\")\\n\\t\\treturn value\\n\\n\\nclass WNSDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WNSDevice\\n\\n\\nclass WebPushDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WebPushDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"p256dh\", \"auth\", \"browser\", \"application_id\",\\n\\t\\t)\\n\\n\\n# Permissions\\nclass IsOwner(permissions.BasePermission):\\n\\tdef has_object_permission(self, request, view, obj):\\n\\t\\t# must be the owner to view the object\\n\\t\\treturn obj.user == request.user\\n\\n\\n# Mixins\\nclass DeviceViewSetMixin:\\n\\tlookup_field = \"registration_id\"\\n\\n\\tdef create(self, request, *args, **kwargs):\\n\\t\\tserializer = None\\n\\t\\tis_update = False\\n\\t\\tif SETTINGS.get(\"UPDATE_ON_DUPLICATE_REG_ID\") and self.lookup_field in request.data:\\n\\t\\t\\tinstance = self.queryset.model.objects.filter(\\n\\t\\t\\t\\tregistration_id=request.data[self.lookup_field]\\n\\t\\t\\t).first()\\n\\t\\t\\tif instance:\\n\\t\\t\\t\\tserializer = self.get_serializer(instance, data=request.data)\\n\\t\\t\\t\\tis_update = True\\n\\t\\tif not serializer:\\n\\t\\t\\tserializer = self.get_serializer(data=request.data)\\n\\n\\t\\tserializer.is_valid(raise_exception=True)\\n\\t\\tif is_update:\\n\\t\\t\\tself.perform_update(serializer)\\n\\t\\t\\treturn Response(serializer.data)\\n\\t\\telse:\\n\\t\\t\\tself.perform_create(serializer)\\n\\t\\t\\theaders = self.get_success_headers(serializer.data)\\n\\t\\t\\treturn Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\\n\\n\\tdef perform_create(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_create(serializer)\\n\\n\\tdef perform_update(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_update(serializer)\\n\\n\\nclass AuthorizedMixin:\\n\\tpermission_classes = (permissions.IsAuthenticated, IsOwner)\\n\\n\\tdef get_queryset(self):\\n\\t\\t# filter all devices to only those belonging to the current user\\n\\t\\treturn self.queryset.filter(user=self.request.user)\\n\\n\\n# ViewSets\\nclass APNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = APNSDevice.objects.all()\\n\\tserializer_class = APNSDeviceSerializer\\n\\n\\nclass APNSDeviceAuthorizedViewSet(AuthorizedMixin, APNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass GCMDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = GCMDevice.objects.all()\\n\\tserializer_class = GCMDeviceSerializer\\n\\n\\nclass GCMDeviceAuthorizedViewSet(AuthorizedMixin, GCMDeviceViewSet):\\n\\tpass\\n\\n\\nclass WNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WNSDevice.objects.all()\\n\\tserializer_class = WNSDeviceSerializer\\n\\n\\nclass WNSDeviceAuthorizedViewSet(AuthorizedMixin, WNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass WebPushDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WebPushDevice.objects.all()\\n\\tserializer_class = WebPushDeviceSerializer\\n\\n\\nclass WebPushDeviceAuthorizedViewSet(AuthorizedMixin, WebPushDeviceViewSet):\\n\\tpass\\n'"}, "return_value": "'from rest_framework import permissions, status\\nfrom rest_framework.fields import IntegerField\\nfrom rest_framework.response import Response\\nfrom rest_framework.serializers import ModelSerializer, Serializer, ValidationError\\nfrom rest_framework.viewsets import ModelViewSet\\n\\nfrom ..fields import UNSIGNED_64BIT_INT_MAX_VALUE, hex_re\\nfrom ..models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\n# Fields\\nclass HexIntegerField(IntegerField):\\n\\t\"\"\"\\n\\tStore an integer represented as a hex string of form \"0x01\".\\n\\t\"\"\"\\n\\n\\tdef to_internal_value(self, data):\\n\\t\\t# validate hex string and convert it to the unsigned\\n\\t\\t# integer representation for internal use\\n\\t\\ttry:\\n\\t\\t\\tdata = int(data, 16) if type(data) != int else data\\n\\t\\texcept ValueError:\\n\\t\\t\\traise ValidationError(\"Device ID is not a valid hex number\")\\n\\t\\treturn super(HexIntegerField, self).to_internal_value(data)\\n\\n\\tdef to_representation(self, value):\\n\\t\\treturn value\\n\\n\\n# Serializers\\nclass DeviceSerializerMixin(ModelSerializer):\\n\\tclass Meta:\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"application_id\", \"registration_id\", \"device_id\",\\n\\t\\t\\t\"active\", \"date_created\"\\n\\t\\t)\\n\\t\\tread_only_fields = (\"date_created\",)\\n\\n\\t\\t# See https://github.com/tomchristie/django-rest-framework/issues/1101\\n\\t\\textra_kwargs = {\"active\": {\"default\": True}}\\n\\n\\nclass APNSDeviceSerializer(ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = APNSDevice\\n\\n\\tdef validate_registration_id(self, value):\\n\\t\\t# iOS device tokens are 256-bit hexadecimal (64 characters). In 2016 Apple is increasing\\n\\t\\t# iOS device tokens to 100 bytes hexadecimal (200 characters).\\n\\n\\t\\tif hex_re.match(value) is None or len(value) not in (64, 200):\\n\\t\\t\\traise ValidationError(\"Registration ID (device token) is invalid\")\\n\\n\\t\\treturn value\\n\\n\\nclass UniqueRegistrationSerializerMixin(Serializer):\\n\\tdef validate(self, attrs):\\n\\t\\tdevices = None\\n\\t\\tprimary_key = None\\n\\t\\trequest_method = None\\n\\n\\t\\tif self.initial_data.get(\"registration_id\", None):\\n\\t\\t\\tif self.instance:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telse:\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\t\\telse:\\n\\t\\t\\tif self.context[\"request\"].method in [\"PUT\", \"PATCH\"]:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telif self.context[\"request\"].method == \"POST\":\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\n\\t\\tDevice = self.Meta.model\\n\\t\\tif request_method == \"update\":\\n\\t\\t\\treg_id = attrs.get(\"registration_id\", self.instance.registration_id)\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=reg_id) \\\\\\n\\t\\t\\t\\t.exclude(id=primary_key)\\n\\t\\telif request_method == \"create\":\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=attrs[\"registration_id\"])\\n\\n\\t\\tif devices:\\n\\t\\t\\traise ValidationError({\"registration_id\": \"This field must be unique.\"})\\n\\t\\treturn attrs\\n\\n\\nclass GCMDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tdevice_id = HexIntegerField(\\n\\t\\thelp_text=\"ANDROID_ID / TelephonyManager.getDeviceId() (e.g: 0x01)\",\\n\\t\\tstyle={\"input_type\": \"text\"},\\n\\t\\trequired=False,\\n\\t\\tallow_null=True\\n\\t)\\n\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = GCMDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"device_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"cloud_message_type\", \"application_id\",\\n\\t\\t)\\n\\t\\textra_kwargs = {\"id\": {\"read_only\": False, \"required\": False}}\\n\\n\\tdef validate_device_id(self, value):\\n\\t\\t# device ids are 64 bit unsigned values\\n\\t\\tif value > UNSIGNED_64BIT_INT_MAX_VALUE:\\n\\t\\t\\traise ValidationError(\"Device ID is out of range\")\\n\\t\\treturn value\\n\\n\\nclass WNSDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WNSDevice\\n\\n\\nclass WebPushDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WebPushDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"p256dh\", \"auth\", \"browser\", \"application_id\",\\n\\t\\t)\\n\\n\\n# Permissions\\nclass IsOwner(permissions.BasePermission):\\n\\tdef has_object_permission(self, request, view, obj):\\n\\t\\t# must be the owner to view the object\\n\\t\\treturn obj.user == request.user\\n\\n\\n# Mixins\\nclass DeviceViewSetMixin:\\n\\tlookup_field = \"registration_id\"\\n\\n\\tdef create(self, request, *args, **kwargs):\\n\\t\\tserializer = None\\n\\t\\tis_update = False\\n\\t\\tif SETTINGS.get(\"UPDATE_ON_DUPLICATE_REG_ID\") and self.lookup_field in request.data:\\n\\t\\t\\tinstance = self.queryset.model.objects.filter(\\n\\t\\t\\t\\tregistration_id=request.data[self.lookup_field]\\n\\t\\t\\t).first()\\n\\t\\t\\tif instance:\\n\\t\\t\\t\\tserializer = self.get_serializer(instance, data=request.data)\\n\\t\\t\\t\\tis_update = True\\n\\t\\tif not serializer:\\n\\t\\t\\tserializer = self.get_serializer(data=request.data)\\n\\n\\t\\tserializer.is_valid(raise_exception=True)\\n\\t\\tif is_update:\\n\\t\\t\\tself.perform_update(serializer)\\n\\t\\t\\treturn Response(serializer.data)\\n\\t\\telse:\\n\\t\\t\\tself.perform_create(serializer)\\n\\t\\t\\theaders = self.get_success_headers(serializer.data)\\n\\t\\t\\treturn Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\\n\\n\\tdef perform_create(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_create(serializer)\\n\\n\\tdef perform_update(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_update(serializer)\\n\\n\\nclass AuthorizedMixin:\\n\\tpermission_classes = (permissions.IsAuthenticated, IsOwner)\\n\\n\\tdef get_queryset(self):\\n\\t\\t# filter all devices to only those belonging to the current user\\n\\t\\treturn self.queryset.filter(user=self.request.user)\\n\\n\\n# ViewSets\\nclass APNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = APNSDevice.objects.all()\\n\\tserializer_class = APNSDeviceSerializer\\n\\n\\nclass APNSDeviceAuthorizedViewSet(AuthorizedMixin, APNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass GCMDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = GCMDevice.objects.all()\\n\\tserializer_class = GCMDeviceSerializer\\n\\n\\nclass GCMDeviceAuthorizedViewSet(AuthorizedMixin, GCMDeviceViewSet):\\n\\tpass\\n\\n\\nclass WNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WNSDevice.objects.all()\\n\\tserializer_class = WNSDeviceSerializer\\n\\n\\nclass WNSDeviceAuthorizedViewSet(AuthorizedMixin, WNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass WebPushDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WebPushDevice.objects.all()\\n\\tserializer_class = WebPushDeviceSerializer\\n\\n\\nclass WebPushDeviceAuthorizedViewSet(AuthorizedMixin, WebPushDeviceViewSet):\\n\\tpass\\n'"}, {"func_args": {"source": "'from rest_framework import permissions, status\\nfrom rest_framework.fields import IntegerField\\nfrom rest_framework.response import Response\\nfrom rest_framework.serializers import ModelSerializer, Serializer, ValidationError\\nfrom rest_framework.viewsets import ModelViewSet\\n\\nfrom ..fields import UNSIGNED_64BIT_INT_MAX_VALUE, hex_re\\nfrom ..models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\n# Fields\\nclass HexIntegerField(IntegerField):\\n\\t\"\"\"\\n\\tStore an integer represented as a hex string of form \"0x01\".\\n\\t\"\"\"\\n\\n\\tdef to_internal_value(self, data):\\n\\t\\t# validate hex string and convert it to the unsigned\\n\\t\\t# integer representation for internal use\\n\\t\\ttry:\\n\\t\\t\\tdata = int(data, 16) if type(data) != int else data\\n\\t\\texcept ValueError:\\n\\t\\t\\traise ValidationError(\"Device ID is not a valid hex number\")\\n\\t\\treturn super(HexIntegerField, self).to_internal_value(data)\\n\\n\\tdef to_representation(self, value):\\n\\t\\treturn value\\n\\n\\n# Serializers\\nclass DeviceSerializerMixin(ModelSerializer):\\n\\tclass Meta:\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"application_id\", \"registration_id\", \"device_id\",\\n\\t\\t\\t\"active\", \"date_created\"\\n\\t\\t)\\n\\t\\tread_only_fields = (\"date_created\",)\\n\\n\\t\\t# See https://github.com/tomchristie/django-rest-framework/issues/1101\\n\\t\\textra_kwargs = {\"active\": {\"default\": True}}\\n\\n\\nclass APNSDeviceSerializer(ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = APNSDevice\\n\\n\\tdef validate_registration_id(self, value):\\n\\t\\t# iOS device tokens are 256-bit hexadecimal (64 characters). In 2016 Apple is increasing\\n\\t\\t# iOS device tokens to 100 bytes hexadecimal (200 characters).\\n\\n\\t\\tif hex_re.match(value) is None or len(value) not in (64, 200):\\n\\t\\t\\traise ValidationError(\"Registration ID (device token) is invalid\")\\n\\n\\t\\treturn value\\n\\n\\nclass UniqueRegistrationSerializerMixin(Serializer):\\n\\tdef validate(self, attrs):\\n\\t\\tdevices = None\\n\\t\\tprimary_key = None\\n\\t\\trequest_method = None\\n\\n\\t\\tif self.initial_data.get(\"registration_id\", None):\\n\\t\\t\\tif self.instance:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telse:\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\t\\telse:\\n\\t\\t\\tif self.context[\"request\"].method in [\"PUT\", \"PATCH\"]:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telif self.context[\"request\"].method == \"POST\":\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\n\\t\\tDevice = self.Meta.model\\n\\t\\tif request_method == \"update\":\\n\\t\\t\\treg_id = attrs.get(\"registration_id\", self.instance.registration_id)\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=reg_id) \\\\\\n\\t\\t\\t\\t.exclude(id=primary_key)\\n\\t\\telif request_method == \"create\":\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=attrs[\"registration_id\"])\\n\\n\\t\\tif devices:\\n\\t\\t\\traise ValidationError({\"registration_id\": \"This field must be unique.\"})\\n\\t\\treturn attrs\\n\\n\\nclass GCMDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tdevice_id = HexIntegerField(\\n\\t\\thelp_text=\"ANDROID_ID / TelephonyManager.getDeviceId() (e.g: 0x01)\",\\n\\t\\tstyle={\"input_type\": \"text\"},\\n\\t\\trequired=False,\\n\\t\\tallow_null=True\\n\\t)\\n\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = GCMDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"device_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"cloud_message_type\", \"application_id\",\\n\\t\\t)\\n\\t\\textra_kwargs = {\"id\": {\"read_only\": False, \"required\": False}}\\n\\n\\tdef validate_device_id(self, value):\\n\\t\\t# device ids are 64 bit unsigned values\\n\\t\\tif value > UNSIGNED_64BIT_INT_MAX_VALUE:\\n\\t\\t\\traise ValidationError(\"Device ID is out of range\")\\n\\t\\treturn value\\n\\n\\nclass WNSDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WNSDevice\\n\\n\\nclass WebPushDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WebPushDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"p256dh\", \"auth\", \"browser\", \"application_id\",\\n\\t\\t)\\n\\n\\n# Permissions\\nclass IsOwner(permissions.BasePermission):\\n\\tdef has_object_permission(self, request, view, obj):\\n\\t\\t# must be the owner to view the object\\n\\t\\treturn obj.user == request.user\\n\\n\\n# Mixins\\nclass DeviceViewSetMixin:\\n\\tlookup_field = \"registration_id\"\\n\\n\\tdef create(self, request, *args, **kwargs):\\n\\t\\tserializer = None\\n\\t\\tis_update = False\\n\\t\\tif SETTINGS.get(\"UPDATE_ON_DUPLICATE_REG_ID\") and self.lookup_field in request.data:\\n\\t\\t\\tinstance = self.queryset.model.objects.filter(\\n\\t\\t\\t\\tregistration_id=request.data[self.lookup_field]\\n\\t\\t\\t).first()\\n\\t\\t\\tif instance:\\n\\t\\t\\t\\tserializer = self.get_serializer(instance, data=request.data)\\n\\t\\t\\t\\tis_update = True\\n\\t\\tif not serializer:\\n\\t\\t\\tserializer = self.get_serializer(data=request.data)\\n\\n\\t\\tserializer.is_valid(raise_exception=True)\\n\\t\\tif is_update:\\n\\t\\t\\tself.perform_update(serializer)\\n\\t\\t\\treturn Response(serializer.data)\\n\\t\\telse:\\n\\t\\t\\tself.perform_create(serializer)\\n\\t\\t\\theaders = self.get_success_headers(serializer.data)\\n\\t\\t\\treturn Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\\n\\n\\tdef perform_create(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_create(serializer)\\n\\n\\tdef perform_update(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_update(serializer)\\n\\n\\nclass AuthorizedMixin:\\n\\tpermission_classes = (permissions.IsAuthenticated, IsOwner)\\n\\n\\tdef get_queryset(self):\\n\\t\\t# filter all devices to only those belonging to the current user\\n\\t\\treturn self.queryset.filter(user=self.request.user)\\n\\n\\n# ViewSets\\nclass APNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = APNSDevice.objects.all()\\n\\tserializer_class = APNSDeviceSerializer\\n\\n\\nclass APNSDeviceAuthorizedViewSet(AuthorizedMixin, APNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass GCMDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = GCMDevice.objects.all()\\n\\tserializer_class = GCMDeviceSerializer\\n\\n\\nclass GCMDeviceAuthorizedViewSet(AuthorizedMixin, GCMDeviceViewSet):\\n\\tpass\\n\\n\\nclass WNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WNSDevice.objects.all()\\n\\tserializer_class = WNSDeviceSerializer\\n\\n\\nclass WNSDeviceAuthorizedViewSet(AuthorizedMixin, WNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass WebPushDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WebPushDevice.objects.all()\\n\\tserializer_class = WebPushDeviceSerializer\\n\\n\\nclass WebPushDeviceAuthorizedViewSet(AuthorizedMixin, WebPushDeviceViewSet):\\n\\tpass\\n'"}, "return_value": "'from rest_framework import permissions, status\\nfrom rest_framework.fields import IntegerField\\nfrom rest_framework.response import Response\\nfrom rest_framework.serializers import ModelSerializer, Serializer, ValidationError\\nfrom rest_framework.viewsets import ModelViewSet\\n\\nfrom ..fields import UNSIGNED_64BIT_INT_MAX_VALUE, hex_re\\nfrom ..models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\n# Fields\\nclass HexIntegerField(IntegerField):\\n\\t\"\"\"\\n\\tStore an integer represented as a hex string of form \"0x01\".\\n\\t\"\"\"\\n\\n\\tdef to_internal_value(self, data):\\n\\t\\t# validate hex string and convert it to the unsigned\\n\\t\\t# integer representation for internal use\\n\\t\\ttry:\\n\\t\\t\\tdata = int(data, 16) if type(data) != int else data\\n\\t\\texcept ValueError:\\n\\t\\t\\traise ValidationError(\"Device ID is not a valid hex number\")\\n\\t\\treturn super(HexIntegerField, self).to_internal_value(data)\\n\\n\\tdef to_representation(self, value):\\n\\t\\treturn value\\n\\n\\n# Serializers\\nclass DeviceSerializerMixin(ModelSerializer):\\n\\tclass Meta:\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"application_id\", \"registration_id\", \"device_id\",\\n\\t\\t\\t\"active\", \"date_created\"\\n\\t\\t)\\n\\t\\tread_only_fields = (\"date_created\",)\\n\\n\\t\\t# See https://github.com/tomchristie/django-rest-framework/issues/1101\\n\\t\\textra_kwargs = {\"active\": {\"default\": True}}\\n\\n\\nclass APNSDeviceSerializer(ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = APNSDevice\\n\\n\\tdef validate_registration_id(self, value):\\n\\t\\t# iOS device tokens are 256-bit hexadecimal (64 characters). In 2016 Apple is increasing\\n\\t\\t# iOS device tokens to 100 bytes hexadecimal (200 characters).\\n\\n\\t\\tif hex_re.match(value) is None or len(value) not in (64, 200):\\n\\t\\t\\traise ValidationError(\"Registration ID (device token) is invalid\")\\n\\n\\t\\treturn value\\n\\n\\nclass UniqueRegistrationSerializerMixin(Serializer):\\n\\tdef validate(self, attrs):\\n\\t\\tdevices = None\\n\\t\\tprimary_key = None\\n\\t\\trequest_method = None\\n\\n\\t\\tif self.initial_data.get(\"registration_id\", None):\\n\\t\\t\\tif self.instance:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telse:\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\t\\telse:\\n\\t\\t\\tif self.context[\"request\"].method in [\"PUT\", \"PATCH\"]:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telif self.context[\"request\"].method == \"POST\":\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\n\\t\\tDevice = self.Meta.model\\n\\t\\tif request_method == \"update\":\\n\\t\\t\\treg_id = attrs.get(\"registration_id\", self.instance.registration_id)\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=reg_id) \\\\\\n\\t\\t\\t\\t.exclude(id=primary_key)\\n\\t\\telif request_method == \"create\":\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=attrs[\"registration_id\"])\\n\\n\\t\\tif devices:\\n\\t\\t\\traise ValidationError({\"registration_id\": \"This field must be unique.\"})\\n\\t\\treturn attrs\\n\\n\\nclass GCMDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tdevice_id = HexIntegerField(\\n\\t\\thelp_text=\"ANDROID_ID / TelephonyManager.getDeviceId() (e.g: 0x01)\",\\n\\t\\tstyle={\"input_type\": \"text\"},\\n\\t\\trequired=False,\\n\\t\\tallow_null=True\\n\\t)\\n\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = GCMDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"device_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"cloud_message_type\", \"application_id\",\\n\\t\\t)\\n\\t\\textra_kwargs = {\"id\": {\"read_only\": False, \"required\": False}}\\n\\n\\tdef validate_device_id(self, value):\\n\\t\\t# device ids are 64 bit unsigned values\\n\\t\\tif value > UNSIGNED_64BIT_INT_MAX_VALUE:\\n\\t\\t\\traise ValidationError(\"Device ID is out of range\")\\n\\t\\treturn value\\n\\n\\nclass WNSDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WNSDevice\\n\\n\\nclass WebPushDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WebPushDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"p256dh\", \"auth\", \"browser\", \"application_id\",\\n\\t\\t)\\n\\n\\n# Permissions\\nclass IsOwner(permissions.BasePermission):\\n\\tdef has_object_permission(self, request, view, obj):\\n\\t\\t# must be the owner to view the object\\n\\t\\treturn obj.user == request.user\\n\\n\\n# Mixins\\nclass DeviceViewSetMixin:\\n\\tlookup_field = \"registration_id\"\\n\\n\\tdef create(self, request, *args, **kwargs):\\n\\t\\tserializer = None\\n\\t\\tis_update = False\\n\\t\\tif SETTINGS.get(\"UPDATE_ON_DUPLICATE_REG_ID\") and self.lookup_field in request.data:\\n\\t\\t\\tinstance = self.queryset.model.objects.filter(\\n\\t\\t\\t\\tregistration_id=request.data[self.lookup_field]\\n\\t\\t\\t).first()\\n\\t\\t\\tif instance:\\n\\t\\t\\t\\tserializer = self.get_serializer(instance, data=request.data)\\n\\t\\t\\t\\tis_update = True\\n\\t\\tif not serializer:\\n\\t\\t\\tserializer = self.get_serializer(data=request.data)\\n\\n\\t\\tserializer.is_valid(raise_exception=True)\\n\\t\\tif is_update:\\n\\t\\t\\tself.perform_update(serializer)\\n\\t\\t\\treturn Response(serializer.data)\\n\\t\\telse:\\n\\t\\t\\tself.perform_create(serializer)\\n\\t\\t\\theaders = self.get_success_headers(serializer.data)\\n\\t\\t\\treturn Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\\n\\n\\tdef perform_create(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_create(serializer)\\n\\n\\tdef perform_update(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_update(serializer)\\n\\n\\nclass AuthorizedMixin:\\n\\tpermission_classes = (permissions.IsAuthenticated, IsOwner)\\n\\n\\tdef get_queryset(self):\\n\\t\\t# filter all devices to only those belonging to the current user\\n\\t\\treturn self.queryset.filter(user=self.request.user)\\n\\n\\n# ViewSets\\nclass APNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = APNSDevice.objects.all()\\n\\tserializer_class = APNSDeviceSerializer\\n\\n\\nclass APNSDeviceAuthorizedViewSet(AuthorizedMixin, APNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass GCMDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = GCMDevice.objects.all()\\n\\tserializer_class = GCMDeviceSerializer\\n\\n\\nclass GCMDeviceAuthorizedViewSet(AuthorizedMixin, GCMDeviceViewSet):\\n\\tpass\\n\\n\\nclass WNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WNSDevice.objects.all()\\n\\tserializer_class = WNSDeviceSerializer\\n\\n\\nclass WNSDeviceAuthorizedViewSet(AuthorizedMixin, WNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass WebPushDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WebPushDevice.objects.all()\\n\\tserializer_class = WebPushDeviceSerializer\\n\\n\\nclass WebPushDeviceAuthorizedViewSet(AuthorizedMixin, WebPushDeviceViewSet):\\n\\tpass\\n'"}, {"func_args": {"source": "'\"\"\"\\nApple Push Notification Service\\nDocumentation is available on the iOS Developer Library:\\nhttps://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html\\n\"\"\"\\n\\nimport time\\n\\nfrom apns2 import client as apns2_client\\nfrom apns2 import credentials as apns2_credentials\\nfrom apns2 import errors as apns2_errors\\nfrom apns2 import payload as apns2_payload\\n\\nfrom . import models\\nfrom .conf import get_manager\\nfrom .exceptions import APNSError, APNSUnsupportedPriority, APNSServerError\\n\\n\\ndef _apns_create_socket(creds=None, application_id=None):\\n\\tif creds is None:\\n\\t\\tif not get_manager().has_auth_token_creds(application_id):\\n\\t\\t\\tcert = get_manager().get_apns_certificate(application_id)\\n\\t\\t\\tcreds = apns2_credentials.CertificateCredentials(cert)\\n\\t\\telse:\\n\\t\\t\\tkeyPath, keyId, teamId = get_manager().get_apns_auth_creds(application_id)\\n\\t\\t\\t# No use getting a lifetime because this credential is\\n\\t\\t\\t# ephemeral, but if you\\'re looking at this to see how to\\n\\t\\t\\t# create a credential, you could also pass the lifetime and\\n\\t\\t\\t# algorithm. Neither of those settings are exposed in the\\n\\t\\t\\t# settings API at the moment.\\n\\t\\t\\tcreds = creds or apns2_credentials.TokenCredentials(keyPath, keyId, teamId)\\n\\tclient = apns2_client.APNsClient(\\n\\t\\tcreds,\\n\\t\\tuse_sandbox=get_manager().get_apns_use_sandbox(application_id),\\n\\t\\tuse_alternative_port=get_manager().get_apns_use_alternative_port(application_id)\\n\\t)\\n\\tclient.connect()\\n\\treturn client\\n\\n\\ndef _apns_prepare(\\n\\ttoken, alert, application_id=None, badge=None, sound=None, category=None,\\n\\tcontent_available=False, action_loc_key=None, loc_key=None, loc_args=[],\\n\\textra={}, mutable_content=False, thread_id=None, url_args=None):\\n\\t\\tif action_loc_key or loc_key or loc_args:\\n\\t\\t\\tapns2_alert = apns2_payload.PayloadAlert(\\n\\t\\t\\t\\tbody=alert if alert else {}, body_localized_key=loc_key,\\n\\t\\t\\t\\tbody_localized_args=loc_args, action_localized_key=action_loc_key)\\n\\t\\telse:\\n\\t\\t\\tapns2_alert = alert\\n\\n\\t\\tif callable(badge):\\n\\t\\t\\tbadge = badge(token)\\n\\n\\t\\treturn apns2_payload.Payload(\\n\\t\\t\\talert=apns2_alert, badge=badge, sound=sound, category=category,\\n\\t\\t\\turl_args=url_args, custom=extra, thread_id=thread_id,\\n\\t\\t\\tcontent_available=content_available, mutable_content=mutable_content)\\n\\n\\ndef _apns_send(\\n\\tregistration_id, alert, batch=False, application_id=None, creds=None, **kwargs\\n):\\n\\tclient = _apns_create_socket(creds=creds, application_id=application_id)\\n\\n\\tnotification_kwargs = {}\\n\\n\\t# if expiration isn\"t specified use 1 month from now\\n\\tnotification_kwargs[\"expiration\"] = kwargs.pop(\"expiration\", None)\\n\\tif not notification_kwargs[\"expiration\"]:\\n\\t\\tnotification_kwargs[\"expiration\"] = int(time.time()) + 2592000\\n\\n\\tpriority = kwargs.pop(\"priority\", None)\\n\\tif priority:\\n\\t\\ttry:\\n\\t\\t\\tnotification_kwargs[\"priority\"] = apns2_client.NotificationPriority(str(priority))\\n\\t\\texcept ValueError:\\n\\t\\t\\traise APNSUnsupportedPriority(\"Unsupported priority %d\" % (priority))\\n\\n\\tnotification_kwargs[\"collapse_id\"] = kwargs.pop(\"collapse_id\", None)\\n\\n\\tif batch:\\n\\t\\tdata = [apns2_client.Notification(\\n\\t\\t\\ttoken=rid, payload=_apns_prepare(rid, alert, **kwargs)) for rid in registration_id]\\n\\t\\t# returns a dictionary mapping each token to its result. That\\n\\t\\t# result is either \"Success\" or the reason for the failure.\\n\\t\\treturn client.send_notification_batch(\\n\\t\\t\\tdata, get_manager().get_apns_topic(application_id=application_id),\\n\\t\\t\\t**notification_kwargs\\n\\t\\t)\\n\\n\\tdata = _apns_prepare(registration_id, alert, **kwargs)\\n\\tclient.send_notification(\\n\\t\\tregistration_id, data,\\n\\t\\tget_manager().get_apns_topic(application_id=application_id),\\n\\t\\t**notification_kwargs\\n\\t)\\n\\n\\ndef apns_send_message(registration_id, alert, application_id=None, creds=None, **kwargs):\\n\\t\"\"\"\\n\\tSends an APNS notification to a single registration_id.\\n\\tThis will send the notification as form data.\\n\\tIf sending multiple notifications, it is more efficient to use\\n\\tapns_send_bulk_message()\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\ttry:\\n\\t\\t_apns_send(\\n\\t\\t\\tregistration_id, alert, application_id=application_id,\\n\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t)\\n\\texcept apns2_errors.APNsException as apns2_exception:\\n\\t\\tif isinstance(apns2_exception, apns2_errors.Unregistered):\\n\\t\\t\\tdevice = models.APNSDevice.objects.get(registration_id=registration_id)\\n\\t\\t\\tdevice.active = False\\n\\t\\t\\tdevice.save()\\n\\n\\t\\traise APNSServerError(status=apns2_exception.__class__.__name__)\\n\\n\\ndef apns_send_bulk_message(\\n\\tregistration_ids, alert, application_id=None, creds=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends an APNS notification to one or more registration_ids.\\n\\tThe registration_ids argument needs to be a list.\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\tresults = _apns_send(\\n\\t\\tregistration_ids, alert, batch=True, application_id=application_id,\\n\\t\\tcreds=creds, **kwargs\\n\\t)\\n\\tinactive_tokens = [token for token, result in results.items() if result == \"Unregistered\"]\\n\\tmodels.APNSDevice.objects.filter(registration_id__in=inactive_tokens).update(active=False)\\n\\treturn results\\n'"}, "return_value": "'\"\"\"\\nApple Push Notification Service\\nDocumentation is available on the iOS Developer Library:\\nhttps://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html\\n\"\"\"\\n\\nimport time\\n\\nfrom apns2 import client as apns2_client\\nfrom apns2 import credentials as apns2_credentials\\nfrom apns2 import errors as apns2_errors\\nfrom apns2 import payload as apns2_payload\\n\\nfrom . import models\\nfrom .conf import get_manager\\nfrom .exceptions import APNSError, APNSUnsupportedPriority, APNSServerError\\n\\n\\ndef _apns_create_socket(creds=None, application_id=None):\\n\\tif creds is None:\\n\\t\\tif not get_manager().has_auth_token_creds(application_id):\\n\\t\\t\\tcert = get_manager().get_apns_certificate(application_id)\\n\\t\\t\\tcreds = apns2_credentials.CertificateCredentials(cert)\\n\\t\\telse:\\n\\t\\t\\tkeyPath, keyId, teamId = get_manager().get_apns_auth_creds(application_id)\\n\\t\\t\\t# No use getting a lifetime because this credential is\\n\\t\\t\\t# ephemeral, but if you\\'re looking at this to see how to\\n\\t\\t\\t# create a credential, you could also pass the lifetime and\\n\\t\\t\\t# algorithm. Neither of those settings are exposed in the\\n\\t\\t\\t# settings API at the moment.\\n\\t\\t\\tcreds = creds or apns2_credentials.TokenCredentials(keyPath, keyId, teamId)\\n\\tclient = apns2_client.APNsClient(\\n\\t\\tcreds,\\n\\t\\tuse_sandbox=get_manager().get_apns_use_sandbox(application_id),\\n\\t\\tuse_alternative_port=get_manager().get_apns_use_alternative_port(application_id)\\n\\t)\\n\\tclient.connect()\\n\\treturn client\\n\\n\\ndef _apns_prepare(\\n\\ttoken, alert, application_id=None, badge=None, sound=None, category=None,\\n\\tcontent_available=False, action_loc_key=None, loc_key=None, loc_args=[],\\n\\textra={}, mutable_content=False, thread_id=None, url_args=None):\\n\\t\\tif action_loc_key or loc_key or loc_args:\\n\\t\\t\\tapns2_alert = apns2_payload.PayloadAlert(\\n\\t\\t\\t\\tbody=alert if alert else {}, body_localized_key=loc_key,\\n\\t\\t\\t\\tbody_localized_args=loc_args, action_localized_key=action_loc_key)\\n\\t\\telse:\\n\\t\\t\\tapns2_alert = alert\\n\\n\\t\\tif callable(badge):\\n\\t\\t\\tbadge = badge(token)\\n\\n\\t\\treturn apns2_payload.Payload(\\n\\t\\t\\talert=apns2_alert, badge=badge, sound=sound, category=category,\\n\\t\\t\\turl_args=url_args, custom=extra, thread_id=thread_id,\\n\\t\\t\\tcontent_available=content_available, mutable_content=mutable_content)\\n\\n\\ndef _apns_send(\\n\\tregistration_id, alert, batch=False, application_id=None, creds=None, **kwargs\\n):\\n\\tclient = _apns_create_socket(creds=creds, application_id=application_id)\\n\\n\\tnotification_kwargs = {}\\n\\n\\t# if expiration isn\"t specified use 1 month from now\\n\\tnotification_kwargs[\"expiration\"] = kwargs.pop(\"expiration\", None)\\n\\tif not notification_kwargs[\"expiration\"]:\\n\\t\\tnotification_kwargs[\"expiration\"] = int(time.time()) + 2592000\\n\\n\\tpriority = kwargs.pop(\"priority\", None)\\n\\tif priority:\\n\\t\\ttry:\\n\\t\\t\\tnotification_kwargs[\"priority\"] = apns2_client.NotificationPriority(str(priority))\\n\\t\\texcept ValueError:\\n\\t\\t\\traise APNSUnsupportedPriority(\"Unsupported priority %d\" % (priority))\\n\\n\\tnotification_kwargs[\"collapse_id\"] = kwargs.pop(\"collapse_id\", None)\\n\\n\\tif batch:\\n\\t\\tdata = [apns2_client.Notification(\\n\\t\\t\\ttoken=rid, payload=_apns_prepare(rid, alert, **kwargs)) for rid in registration_id]\\n\\t\\t# returns a dictionary mapping each token to its result. That\\n\\t\\t# result is either \"Success\" or the reason for the failure.\\n\\t\\treturn client.send_notification_batch(\\n\\t\\t\\tdata, get_manager().get_apns_topic(application_id=application_id),\\n\\t\\t\\t**notification_kwargs\\n\\t\\t)\\n\\n\\tdata = _apns_prepare(registration_id, alert, **kwargs)\\n\\tclient.send_notification(\\n\\t\\tregistration_id, data,\\n\\t\\tget_manager().get_apns_topic(application_id=application_id),\\n\\t\\t**notification_kwargs\\n\\t)\\n\\n\\ndef apns_send_message(registration_id, alert, application_id=None, creds=None, **kwargs):\\n\\t\"\"\"\\n\\tSends an APNS notification to a single registration_id.\\n\\tThis will send the notification as form data.\\n\\tIf sending multiple notifications, it is more efficient to use\\n\\tapns_send_bulk_message()\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\ttry:\\n\\t\\t_apns_send(\\n\\t\\t\\tregistration_id, alert, application_id=application_id,\\n\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t)\\n\\texcept apns2_errors.APNsException as apns2_exception:\\n\\t\\tif isinstance(apns2_exception, apns2_errors.Unregistered):\\n\\t\\t\\tdevice = models.APNSDevice.objects.get(registration_id=registration_id)\\n\\t\\t\\tdevice.active = False\\n\\t\\t\\tdevice.save()\\n\\n\\t\\traise APNSServerError(status=apns2_exception.__class__.__name__)\\n\\n\\ndef apns_send_bulk_message(\\n\\tregistration_ids, alert, application_id=None, creds=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends an APNS notification to one or more registration_ids.\\n\\tThe registration_ids argument needs to be a list.\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\tresults = _apns_send(\\n\\t\\tregistration_ids, alert, batch=True, application_id=application_id,\\n\\t\\tcreds=creds, **kwargs\\n\\t)\\n\\tinactive_tokens = [token for token, result in results.items() if result == \"Unregistered\"]\\n\\tmodels.APNSDevice.objects.filter(registration_id__in=inactive_tokens).update(active=False)\\n\\treturn results\\n'"}, {"func_args": {"source": "'\"\"\"\\nApple Push Notification Service\\nDocumentation is available on the iOS Developer Library:\\nhttps://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html\\n\"\"\"\\n\\nimport time\\n\\nfrom apns2 import client as apns2_client\\nfrom apns2 import credentials as apns2_credentials\\nfrom apns2 import errors as apns2_errors\\nfrom apns2 import payload as apns2_payload\\n\\nfrom . import models\\nfrom .conf import get_manager\\nfrom .exceptions import APNSError, APNSUnsupportedPriority, APNSServerError\\n\\n\\ndef _apns_create_socket(creds=None, application_id=None):\\n\\tif creds is None:\\n\\t\\tif not get_manager().has_auth_token_creds(application_id):\\n\\t\\t\\tcert = get_manager().get_apns_certificate(application_id)\\n\\t\\t\\tcreds = apns2_credentials.CertificateCredentials(cert)\\n\\t\\telse:\\n\\t\\t\\tkeyPath, keyId, teamId = get_manager().get_apns_auth_creds(application_id)\\n\\t\\t\\t# No use getting a lifetime because this credential is\\n\\t\\t\\t# ephemeral, but if you\\'re looking at this to see how to\\n\\t\\t\\t# create a credential, you could also pass the lifetime and\\n\\t\\t\\t# algorithm. Neither of those settings are exposed in the\\n\\t\\t\\t# settings API at the moment.\\n\\t\\t\\tcreds = creds or apns2_credentials.TokenCredentials(keyPath, keyId, teamId)\\n\\tclient = apns2_client.APNsClient(\\n\\t\\tcreds,\\n\\t\\tuse_sandbox=get_manager().get_apns_use_sandbox(application_id),\\n\\t\\tuse_alternative_port=get_manager().get_apns_use_alternative_port(application_id)\\n\\t)\\n\\tclient.connect()\\n\\treturn client\\n\\n\\ndef _apns_prepare(\\n\\ttoken, alert, application_id=None, badge=None, sound=None, category=None,\\n\\tcontent_available=False, action_loc_key=None, loc_key=None, loc_args=[],\\n\\textra={}, mutable_content=False, thread_id=None, url_args=None):\\n\\t\\tif action_loc_key or loc_key or loc_args:\\n\\t\\t\\tapns2_alert = apns2_payload.PayloadAlert(\\n\\t\\t\\t\\tbody=alert if alert else {}, body_localized_key=loc_key,\\n\\t\\t\\t\\tbody_localized_args=loc_args, action_localized_key=action_loc_key)\\n\\t\\telse:\\n\\t\\t\\tapns2_alert = alert\\n\\n\\t\\tif callable(badge):\\n\\t\\t\\tbadge = badge(token)\\n\\n\\t\\treturn apns2_payload.Payload(\\n\\t\\t\\talert=apns2_alert, badge=badge, sound=sound, category=category,\\n\\t\\t\\turl_args=url_args, custom=extra, thread_id=thread_id,\\n\\t\\t\\tcontent_available=content_available, mutable_content=mutable_content)\\n\\n\\ndef _apns_send(\\n\\tregistration_id, alert, batch=False, application_id=None, creds=None, **kwargs\\n):\\n\\tclient = _apns_create_socket(creds=creds, application_id=application_id)\\n\\n\\tnotification_kwargs = {}\\n\\n\\t# if expiration isn\"t specified use 1 month from now\\n\\tnotification_kwargs[\"expiration\"] = kwargs.pop(\"expiration\", None)\\n\\tif not notification_kwargs[\"expiration\"]:\\n\\t\\tnotification_kwargs[\"expiration\"] = int(time.time()) + 2592000\\n\\n\\tpriority = kwargs.pop(\"priority\", None)\\n\\tif priority:\\n\\t\\ttry:\\n\\t\\t\\tnotification_kwargs[\"priority\"] = apns2_client.NotificationPriority(str(priority))\\n\\t\\texcept ValueError:\\n\\t\\t\\traise APNSUnsupportedPriority(\"Unsupported priority %d\" % (priority))\\n\\n\\tnotification_kwargs[\"collapse_id\"] = kwargs.pop(\"collapse_id\", None)\\n\\n\\tif batch:\\n\\t\\tdata = [apns2_client.Notification(\\n\\t\\t\\ttoken=rid, payload=_apns_prepare(rid, alert, **kwargs)) for rid in registration_id]\\n\\t\\t# returns a dictionary mapping each token to its result. That\\n\\t\\t# result is either \"Success\" or the reason for the failure.\\n\\t\\treturn client.send_notification_batch(\\n\\t\\t\\tdata, get_manager().get_apns_topic(application_id=application_id),\\n\\t\\t\\t**notification_kwargs\\n\\t\\t)\\n\\n\\tdata = _apns_prepare(registration_id, alert, **kwargs)\\n\\tclient.send_notification(\\n\\t\\tregistration_id, data,\\n\\t\\tget_manager().get_apns_topic(application_id=application_id),\\n\\t\\t**notification_kwargs\\n\\t)\\n\\n\\ndef apns_send_message(registration_id, alert, application_id=None, creds=None, **kwargs):\\n\\t\"\"\"\\n\\tSends an APNS notification to a single registration_id.\\n\\tThis will send the notification as form data.\\n\\tIf sending multiple notifications, it is more efficient to use\\n\\tapns_send_bulk_message()\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\ttry:\\n\\t\\t_apns_send(\\n\\t\\t\\tregistration_id, alert, application_id=application_id,\\n\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t)\\n\\texcept apns2_errors.APNsException as apns2_exception:\\n\\t\\tif isinstance(apns2_exception, apns2_errors.Unregistered):\\n\\t\\t\\tdevice = models.APNSDevice.objects.get(registration_id=registration_id)\\n\\t\\t\\tdevice.active = False\\n\\t\\t\\tdevice.save()\\n\\n\\t\\traise APNSServerError(status=apns2_exception.__class__.__name__)\\n\\n\\ndef apns_send_bulk_message(\\n\\tregistration_ids, alert, application_id=None, creds=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends an APNS notification to one or more registration_ids.\\n\\tThe registration_ids argument needs to be a list.\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\tresults = _apns_send(\\n\\t\\tregistration_ids, alert, batch=True, application_id=application_id,\\n\\t\\tcreds=creds, **kwargs\\n\\t)\\n\\tinactive_tokens = [token for token, result in results.items() if result == \"Unregistered\"]\\n\\tmodels.APNSDevice.objects.filter(registration_id__in=inactive_tokens).update(active=False)\\n\\treturn results\\n'"}, "return_value": "'\"\"\"\\nApple Push Notification Service\\nDocumentation is available on the iOS Developer Library:\\nhttps://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html\\n\"\"\"\\n\\nimport time\\n\\nfrom apns2 import client as apns2_client\\nfrom apns2 import credentials as apns2_credentials\\nfrom apns2 import errors as apns2_errors\\nfrom apns2 import payload as apns2_payload\\n\\nfrom . import models\\nfrom .conf import get_manager\\nfrom .exceptions import APNSError, APNSUnsupportedPriority, APNSServerError\\n\\n\\ndef _apns_create_socket(creds=None, application_id=None):\\n\\tif creds is None:\\n\\t\\tif not get_manager().has_auth_token_creds(application_id):\\n\\t\\t\\tcert = get_manager().get_apns_certificate(application_id)\\n\\t\\t\\tcreds = apns2_credentials.CertificateCredentials(cert)\\n\\t\\telse:\\n\\t\\t\\tkeyPath, keyId, teamId = get_manager().get_apns_auth_creds(application_id)\\n\\t\\t\\t# No use getting a lifetime because this credential is\\n\\t\\t\\t# ephemeral, but if you\\'re looking at this to see how to\\n\\t\\t\\t# create a credential, you could also pass the lifetime and\\n\\t\\t\\t# algorithm. Neither of those settings are exposed in the\\n\\t\\t\\t# settings API at the moment.\\n\\t\\t\\tcreds = creds or apns2_credentials.TokenCredentials(keyPath, keyId, teamId)\\n\\tclient = apns2_client.APNsClient(\\n\\t\\tcreds,\\n\\t\\tuse_sandbox=get_manager().get_apns_use_sandbox(application_id),\\n\\t\\tuse_alternative_port=get_manager().get_apns_use_alternative_port(application_id)\\n\\t)\\n\\tclient.connect()\\n\\treturn client\\n\\n\\ndef _apns_prepare(\\n\\ttoken, alert, application_id=None, badge=None, sound=None, category=None,\\n\\tcontent_available=False, action_loc_key=None, loc_key=None, loc_args=[],\\n\\textra={}, mutable_content=False, thread_id=None, url_args=None):\\n\\t\\tif action_loc_key or loc_key or loc_args:\\n\\t\\t\\tapns2_alert = apns2_payload.PayloadAlert(\\n\\t\\t\\t\\tbody=alert if alert else {}, body_localized_key=loc_key,\\n\\t\\t\\t\\tbody_localized_args=loc_args, action_localized_key=action_loc_key)\\n\\t\\telse:\\n\\t\\t\\tapns2_alert = alert\\n\\n\\t\\tif callable(badge):\\n\\t\\t\\tbadge = badge(token)\\n\\n\\t\\treturn apns2_payload.Payload(\\n\\t\\t\\talert=apns2_alert, badge=badge, sound=sound, category=category,\\n\\t\\t\\turl_args=url_args, custom=extra, thread_id=thread_id,\\n\\t\\t\\tcontent_available=content_available, mutable_content=mutable_content)\\n\\n\\ndef _apns_send(\\n\\tregistration_id, alert, batch=False, application_id=None, creds=None, **kwargs\\n):\\n\\tclient = _apns_create_socket(creds=creds, application_id=application_id)\\n\\n\\tnotification_kwargs = {}\\n\\n\\t# if expiration isn\"t specified use 1 month from now\\n\\tnotification_kwargs[\"expiration\"] = kwargs.pop(\"expiration\", None)\\n\\tif not notification_kwargs[\"expiration\"]:\\n\\t\\tnotification_kwargs[\"expiration\"] = int(time.time()) + 2592000\\n\\n\\tpriority = kwargs.pop(\"priority\", None)\\n\\tif priority:\\n\\t\\ttry:\\n\\t\\t\\tnotification_kwargs[\"priority\"] = apns2_client.NotificationPriority(str(priority))\\n\\t\\texcept ValueError:\\n\\t\\t\\traise APNSUnsupportedPriority(\"Unsupported priority %d\" % (priority))\\n\\n\\tnotification_kwargs[\"collapse_id\"] = kwargs.pop(\"collapse_id\", None)\\n\\n\\tif batch:\\n\\t\\tdata = [apns2_client.Notification(\\n\\t\\t\\ttoken=rid, payload=_apns_prepare(rid, alert, **kwargs)) for rid in registration_id]\\n\\t\\t# returns a dictionary mapping each token to its result. That\\n\\t\\t# result is either \"Success\" or the reason for the failure.\\n\\t\\treturn client.send_notification_batch(\\n\\t\\t\\tdata, get_manager().get_apns_topic(application_id=application_id),\\n\\t\\t\\t**notification_kwargs\\n\\t\\t)\\n\\n\\tdata = _apns_prepare(registration_id, alert, **kwargs)\\n\\tclient.send_notification(\\n\\t\\tregistration_id, data,\\n\\t\\tget_manager().get_apns_topic(application_id=application_id),\\n\\t\\t**notification_kwargs\\n\\t)\\n\\n\\ndef apns_send_message(registration_id, alert, application_id=None, creds=None, **kwargs):\\n\\t\"\"\"\\n\\tSends an APNS notification to a single registration_id.\\n\\tThis will send the notification as form data.\\n\\tIf sending multiple notifications, it is more efficient to use\\n\\tapns_send_bulk_message()\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\ttry:\\n\\t\\t_apns_send(\\n\\t\\t\\tregistration_id, alert, application_id=application_id,\\n\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t)\\n\\texcept apns2_errors.APNsException as apns2_exception:\\n\\t\\tif isinstance(apns2_exception, apns2_errors.Unregistered):\\n\\t\\t\\tdevice = models.APNSDevice.objects.get(registration_id=registration_id)\\n\\t\\t\\tdevice.active = False\\n\\t\\t\\tdevice.save()\\n\\n\\t\\traise APNSServerError(status=apns2_exception.__class__.__name__)\\n\\n\\ndef apns_send_bulk_message(\\n\\tregistration_ids, alert, application_id=None, creds=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends an APNS notification to one or more registration_ids.\\n\\tThe registration_ids argument needs to be a list.\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\tresults = _apns_send(\\n\\t\\tregistration_ids, alert, batch=True, application_id=application_id,\\n\\t\\tcreds=creds, **kwargs\\n\\t)\\n\\tinactive_tokens = [token for token, result in results.items() if result == \"Unregistered\"]\\n\\tmodels.APNSDevice.objects.filter(registration_id__in=inactive_tokens).update(active=False)\\n\\treturn results\\n'"}, {"func_args": {"source": "'# flake8:noqa\\nfrom urllib.error import HTTPError\\nfrom urllib.parse import urlencode\\nfrom urllib.request import Request, urlopen\\n'"}, "return_value": "'# flake8:noqa\\nfrom urllib.error import HTTPError\\nfrom urllib.parse import urlencode\\nfrom urllib.request import Request, urlopen\\n'"}, {"func_args": {"source": "'# flake8:noqa\\nfrom urllib.error import HTTPError\\nfrom urllib.parse import urlencode\\nfrom urllib.request import Request, urlopen\\n'"}, "return_value": "'# flake8:noqa\\nfrom urllib.error import HTTPError\\nfrom urllib.parse import urlencode\\nfrom urllib.request import Request, urlopen\\n'"}, {"func_args": {"source": "'from django.utils.module_loading import import_string\\n\\nfrom .app import AppConfig  # noqa: F401\\nfrom .appmodel import AppModelConfig  # noqa: F401\\nfrom .legacy import LegacyConfig  # noqa: F401\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS  # noqa: I001\\n\\n\\nmanager = None\\n\\n\\ndef get_manager(reload=False):\\n\\tglobal manager\\n\\n\\tif not manager or reload is True:\\n\\t\\tmanager = import_string(SETTINGS[\"CONFIG\"])()\\n\\n\\treturn manager\\n\\n\\n# implementing get_manager as a function allows tests to reload settings\\nget_manager()\\n'"}, "return_value": "'from django.utils.module_loading import import_string\\n\\nfrom .app import AppConfig  # noqa: F401\\nfrom .appmodel import AppModelConfig  # noqa: F401\\nfrom .legacy import LegacyConfig  # noqa: F401\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS  # noqa: I001\\n\\n\\nmanager = None\\n\\n\\ndef get_manager(reload=False):\\n\\tglobal manager\\n\\n\\tif not manager or reload is True:\\n\\t\\tmanager = import_string(SETTINGS[\"CONFIG\"])()\\n\\n\\treturn manager\\n\\n\\n# implementing get_manager as a function allows tests to reload settings\\nget_manager()\\n'"}, {"func_args": {"source": "'from django.utils.module_loading import import_string\\n\\nfrom .app import AppConfig  # noqa: F401\\nfrom .appmodel import AppModelConfig  # noqa: F401\\nfrom .legacy import LegacyConfig  # noqa: F401\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS  # noqa: I001\\n\\n\\nmanager = None\\n\\n\\ndef get_manager(reload=False):\\n\\tglobal manager\\n\\n\\tif not manager or reload is True:\\n\\t\\tmanager = import_string(SETTINGS[\"CONFIG\"])()\\n\\n\\treturn manager\\n\\n\\n# implementing get_manager as a function allows tests to reload settings\\nget_manager()\\n'"}, "return_value": "'from django.utils.module_loading import import_string\\n\\nfrom .app import AppConfig  # noqa: F401\\nfrom .appmodel import AppModelConfig  # noqa: F401\\nfrom .legacy import LegacyConfig  # noqa: F401\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS  # noqa: I001\\n\\n\\nmanager = None\\n\\n\\ndef get_manager(reload=False):\\n\\tglobal manager\\n\\n\\tif not manager or reload is True:\\n\\t\\tmanager = import_string(SETTINGS[\"CONFIG\"])()\\n\\n\\treturn manager\\n\\n\\n# implementing get_manager as a function allows tests to reload settings\\nget_manager()\\n'"}, {"func_args": {"source": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig, check_apns_certificate\\n\\n\\nSETTING_MISMATCH = (\\n\\t\"Application \\'{application_id}\\' ({platform}) does not support the setting \\'{setting}\\'.\"\\n)\\n\\n# code can be \"missing\" or \"invalid\"\\nBAD_PLATFORM = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"PLATFORM\"] is {code}. \\'\\n\\t\"Must be one of: {platforms}.\"\\n)\\n\\nUNKNOWN_PLATFORM = (\\n\\t\"Unknown Platform: {platform}. Must be one of: {platforms}.\"\\n)\\n\\nMISSING_SETTING = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"{setting}\"] is missing.\\'\\n)\\n\\nPLATFORMS = [\\n\\t\"APNS\",\\n\\t\"FCM\",\\n\\t\"GCM\",\\n\\t\"WNS\",\\n\\t\"WP\",\\n]\\n\\n# Settings that all applications must have\\nREQUIRED_SETTINGS = [\\n\\t\"PLATFORM\",\\n]\\n\\n# Settings that an application may have to enable optional features\\n# these settings are stubs for registry support and have no effect on the operation\\n# of the application at this time.\\nOPTIONAL_SETTINGS = [\\n\\t\"APPLICATION_GROUP\", \"APPLICATION_SECRET\"\\n]\\n\\n# Since we can have an auth key, combined with a auth key id and team id *or*\\n# a certificate, we make these all optional, and then make sure we have one or\\n# the other (group) of settings.\\nAPNS_SETTINGS_CERT_CREDS = \"CERTIFICATE\"\\n\\n# Subkeys for APNS_SETTINGS_AUTH_CREDS\\nAPNS_AUTH_CREDS_REQUIRED = [\"AUTH_KEY_PATH\", \"AUTH_KEY_ID\", \"TEAM_ID\"]\\nAPNS_AUTH_CREDS_OPTIONAL = [\"CERTIFICATE\", \"ENCRYPTION_ALGORITHM\", \"TOKEN_LIFETIME\"]\\n\\nAPNS_OPTIONAL_SETTINGS = [\\n\\t\"USE_SANDBOX\", \"USE_ALTERNATIVE_PORT\", \"TOPIC\"\\n]\\n\\nFCM_REQUIRED_SETTINGS = GCM_REQUIRED_SETTINGS = [\"API_KEY\"]\\nFCM_OPTIONAL_SETTINGS = GCM_OPTIONAL_SETTINGS = [\\n\\t\"POST_URL\", \"MAX_RECIPIENTS\", \"ERROR_TIMEOUT\"\\n]\\n\\nWNS_REQUIRED_SETTINGS = [\"PACKAGE_SECURITY_ID\", \"SECRET_KEY\"]\\nWNS_OPTIONAL_SETTINGS = [\"WNS_ACCESS_URL\"]\\n\\nWP_REQUIRED_SETTINGS = [\"PRIVATE_KEY\", \"CLAIMS\"]\\nWP_OPTIONAL_SETTINGS = [\"ERROR_TIMEOUT\", \"POST_URL\"]\\n\\n\\nclass AppConfig(BaseConfig):\\n\\t\"\"\"\\n\\tSupports any number of push notification enabled applications.\\n\\t\"\"\"\\n\\n\\tdef __init__(self, settings=None):\\n\\t\\t# supports overriding the settings to be loaded. Will load from ..settings by default.\\n\\t\\tself._settings = settings or SETTINGS\\n\\n\\t\\t# initialize APPLICATIONS to an empty collection\\n\\t\\tself._settings.setdefault(\"APPLICATIONS\", {})\\n\\n\\t\\t# validate application configurations\\n\\t\\tself._validate_applications(self._settings[\"APPLICATIONS\"])\\n\\n\\tdef _validate_applications(self, apps):\\n\\t\\t\"\"\"Validate the application collection\"\"\"\\n\\t\\tfor application_id, application_config in apps.items():\\n\\t\\t\\tself._validate_config(application_id, application_config)\\n\\n\\t\\t\\tapplication_config[\"APPLICATION_ID\"] = application_id\\n\\n\\tdef _validate_config(self, application_id, application_config):\\n\\t\\tplatform = application_config.get(\"PLATFORM\", None)\\n\\n\\t\\t# platform is not present\\n\\t\\tif platform is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"required\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# platform is not a valid choice from PLATFORMS\\n\\t\\tif platform not in PLATFORMS:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"invalid\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\tvalidate_fn = \"_validate_{platform}_config\".format(platform=platform).lower()\\n\\n\\t\\tif hasattr(self, validate_fn):\\n\\t\\t\\tgetattr(self, validate_fn)(application_id, application_config)\\n\\t\\telse:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tUNKNOWN_PLATFORM.format(\\n\\t\\t\\t\\t\\tplatform=platform,\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\tdef _validate_apns_config(self, application_id, application_config):\\n\\t\\tallowed = REQUIRED_SETTINGS + OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\tAPNS_OPTIONAL_SETTINGS\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\t# We have two sets of settings, certificate and JWT auth key.\\n\\t\\t# Auth Key requires 3 values, so if that is set, that will take\\n\\t\\t# precedence. If None are set, we will throw an error.\\n\\t\\thas_cert_creds = APNS_SETTINGS_CERT_CREDS in \\\\\\n\\t\\t\\tapplication_config.keys()\\n\\t\\tself.has_token_creds = True\\n\\t\\tfor token_setting in APNS_AUTH_CREDS_REQUIRED:\\n\\t\\t\\tif token_setting not in application_config.keys():\\n\\t\\t\\t\\tself.has_token_creds = False\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif not has_cert_creds and not self.has_token_creds:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tsetting=(APNS_SETTINGS_CERT_CREDS, APNS_AUTH_CREDS_REQUIRED)))\\n\\t\\tcert_path = None\\n\\t\\tif has_cert_creds:\\n\\t\\t\\tcert_path = \"CERTIFICATE\"\\n\\t\\telif self.has_token_creds:\\n\\t\\t\\tcert_path = \"AUTH_KEY_PATH\"\\n\\t\\t\\tallowed_tokens = APNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\t\\tAPNS_OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\t\\tREQUIRED_SETTINGS\\n\\t\\t\\tself._validate_allowed_settings(application_id, application_config, allowed_tokens)\\n\\t\\t\\tself._validate_required_settings(\\n\\t\\t\\t\\tapplication_id, application_config, APNS_AUTH_CREDS_REQUIRED\\n\\t\\t\\t)\\n\\t\\tself._validate_apns_certificate(application_config[cert_path])\\n\\n\\t\\t# determine/set optional values\\n\\t\\tapplication_config.setdefault(\"USE_SANDBOX\", False)\\n\\t\\tapplication_config.setdefault(\"USE_ALTERNATIVE_PORT\", False)\\n\\t\\tapplication_config.setdefault(\"TOPIC\", None)\\n\\n\\tdef _validate_apns_certificate(self, certfile):\\n\\t\\t\"\"\"Validate the APNS certificate at startup.\"\"\"\\n\\n\\t\\ttry:\\n\\t\\t\\twith open(certfile, \"r\") as f:\\n\\t\\t\\t\\tcontent = f.read()\\n\\t\\t\\t\\tcheck_apns_certificate(content)\\n\\t\\texcept Exception as e:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"The APNS certificate file at {!r} is not readable: {}\".format(certfile, e)\\n\\t\\t\\t)\\n\\n\\tdef _validate_fcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + FCM_REQUIRED_SETTINGS + FCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, FCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://fcm.googleapis.com/fcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_gcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + GCM_REQUIRED_SETTINGS + GCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, GCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://android.googleapis.com/gcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_wns_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WNS_REQUIRED_SETTINGS + WNS_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WNS_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\")\\n\\n\\tdef _validate_wp_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WP_REQUIRED_SETTINGS + WP_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WP_REQUIRED_SETTINGS\\n\\t\\t)\\n\\t\\tapplication_config.setdefault(\"POST_URL\", {\\n\\t\\t\\t\"CHROME\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"OPERA\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n\\t\\t\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\\t})\\n\\n\\tdef _validate_allowed_settings(self, application_id, application_config, allowed_settings):\\n\\t\\t\"\"\"Confirm only allowed settings are present.\"\"\"\\n\\n\\t\\tfor setting_key in application_config.keys():\\n\\t\\t\\tif setting_key not in allowed_settings:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"Platform {}, app {} does not support the setting: {}.\".format(\\n\\t\\t\\t\\t\\t\\tapplication_config[\"PLATFORM\"], application_id, setting_key\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\n\\tdef _validate_required_settings(\\n\\t\\tself, application_id, application_config, required_settings,\\n\\t\\tshould_throw=True\\n\\t):\\n\\t\\t\"\"\"All required keys must be present\"\"\"\\n\\n\\t\\tfor setting_key in required_settings:\\n\\t\\t\\tif setting_key not in application_config.keys():\\n\\t\\t\\t\\tif should_throw:\\n\\t\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\t\\t\\tapplication_id=application_id, setting=setting_key\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tdef _get_application_settings(self, application_id, platform, settings_key):\\n\\t\\t\"\"\"\\n\\t\\tWalks through PUSH_NOTIFICATIONS_SETTINGS to find the correct setting value\\n\\t\\tor raises ImproperlyConfigured.\\n\\t\\t\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tconf_cls = \"push_notifications.conf.AppConfig\"\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"{} requires the application_id be specified at all times.\".format(conf_cls)\\n\\t\\t\\t)\\n\\n\\t\\t# verify that the application config exists\\n\\t\\tapp_config = self._settings.get(\"APPLICATIONS\").get(application_id, None)\\n\\t\\tif app_config is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"No application configured with application_id: {}.\".format(application_id)\\n\\t\\t\\t)\\n\\n\\t\\t# fetch a setting for the incorrect type of platform\\n\\t\\tif app_config.get(\"PLATFORM\") != platform:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tSETTING_MISMATCH.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tplatform=app_config.get(\"PLATFORM\"),\\n\\t\\t\\t\\t\\tsetting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# finally, try to fetch the setting\\n\\t\\tif settings_key not in app_config:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id, setting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\treturn app_config.get(settings_key)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\treturn self.has_token_creds\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"GCM\", \"API_KEY\")\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"FCM\", \"API_KEY\")\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"POST_URL\")\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"ERROR_TIMEOUT\")\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"MAX_RECIPIENTS\")\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(application_id, \"APNS\", \"CERTIFICATE\")\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn \\\\\\n\\t\\t(self._get_apns_auth_key_path(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key_path(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_PATH\")\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_ID\")\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TEAM_ID\")\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_SANDBOX\")\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_ALTERNATIVE_PORT\")\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TOPIC\")\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"PACKAGE_SECURITY_ID\")\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"SECRET_KEY\")\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"POST_URL\")[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"PRIVATE_KEY\")\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"CLAIMS\")\\n'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig, check_apns_certificate\\n\\n\\nSETTING_MISMATCH = (\\n\\t\"Application \\'{application_id}\\' ({platform}) does not support the setting \\'{setting}\\'.\"\\n)\\n\\n# code can be \"missing\" or \"invalid\"\\nBAD_PLATFORM = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"PLATFORM\"] is {code}. \\'\\n\\t\"Must be one of: {platforms}.\"\\n)\\n\\nUNKNOWN_PLATFORM = (\\n\\t\"Unknown Platform: {platform}. Must be one of: {platforms}.\"\\n)\\n\\nMISSING_SETTING = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"{setting}\"] is missing.\\'\\n)\\n\\nPLATFORMS = [\\n\\t\"APNS\",\\n\\t\"FCM\",\\n\\t\"GCM\",\\n\\t\"WNS\",\\n\\t\"WP\",\\n]\\n\\n# Settings that all applications must have\\nREQUIRED_SETTINGS = [\\n\\t\"PLATFORM\",\\n]\\n\\n# Settings that an application may have to enable optional features\\n# these settings are stubs for registry support and have no effect on the operation\\n# of the application at this time.\\nOPTIONAL_SETTINGS = [\\n\\t\"APPLICATION_GROUP\", \"APPLICATION_SECRET\"\\n]\\n\\n# Since we can have an auth key, combined with a auth key id and team id *or*\\n# a certificate, we make these all optional, and then make sure we have one or\\n# the other (group) of settings.\\nAPNS_SETTINGS_CERT_CREDS = \"CERTIFICATE\"\\n\\n# Subkeys for APNS_SETTINGS_AUTH_CREDS\\nAPNS_AUTH_CREDS_REQUIRED = [\"AUTH_KEY_PATH\", \"AUTH_KEY_ID\", \"TEAM_ID\"]\\nAPNS_AUTH_CREDS_OPTIONAL = [\"CERTIFICATE\", \"ENCRYPTION_ALGORITHM\", \"TOKEN_LIFETIME\"]\\n\\nAPNS_OPTIONAL_SETTINGS = [\\n\\t\"USE_SANDBOX\", \"USE_ALTERNATIVE_PORT\", \"TOPIC\"\\n]\\n\\nFCM_REQUIRED_SETTINGS = GCM_REQUIRED_SETTINGS = [\"API_KEY\"]\\nFCM_OPTIONAL_SETTINGS = GCM_OPTIONAL_SETTINGS = [\\n\\t\"POST_URL\", \"MAX_RECIPIENTS\", \"ERROR_TIMEOUT\"\\n]\\n\\nWNS_REQUIRED_SETTINGS = [\"PACKAGE_SECURITY_ID\", \"SECRET_KEY\"]\\nWNS_OPTIONAL_SETTINGS = [\"WNS_ACCESS_URL\"]\\n\\nWP_REQUIRED_SETTINGS = [\"PRIVATE_KEY\", \"CLAIMS\"]\\nWP_OPTIONAL_SETTINGS = [\"ERROR_TIMEOUT\", \"POST_URL\"]\\n\\n\\nclass AppConfig(BaseConfig):\\n\\t\"\"\"\\n\\tSupports any number of push notification enabled applications.\\n\\t\"\"\"\\n\\n\\tdef __init__(self, settings=None):\\n\\t\\t# supports overriding the settings to be loaded. Will load from ..settings by default.\\n\\t\\tself._settings = settings or SETTINGS\\n\\n\\t\\t# initialize APPLICATIONS to an empty collection\\n\\t\\tself._settings.setdefault(\"APPLICATIONS\", {})\\n\\n\\t\\t# validate application configurations\\n\\t\\tself._validate_applications(self._settings[\"APPLICATIONS\"])\\n\\n\\tdef _validate_applications(self, apps):\\n\\t\\t\"\"\"Validate the application collection\"\"\"\\n\\t\\tfor application_id, application_config in apps.items():\\n\\t\\t\\tself._validate_config(application_id, application_config)\\n\\n\\t\\t\\tapplication_config[\"APPLICATION_ID\"] = application_id\\n\\n\\tdef _validate_config(self, application_id, application_config):\\n\\t\\tplatform = application_config.get(\"PLATFORM\", None)\\n\\n\\t\\t# platform is not present\\n\\t\\tif platform is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"required\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# platform is not a valid choice from PLATFORMS\\n\\t\\tif platform not in PLATFORMS:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"invalid\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\tvalidate_fn = \"_validate_{platform}_config\".format(platform=platform).lower()\\n\\n\\t\\tif hasattr(self, validate_fn):\\n\\t\\t\\tgetattr(self, validate_fn)(application_id, application_config)\\n\\t\\telse:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tUNKNOWN_PLATFORM.format(\\n\\t\\t\\t\\t\\tplatform=platform,\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\tdef _validate_apns_config(self, application_id, application_config):\\n\\t\\tallowed = REQUIRED_SETTINGS + OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\tAPNS_OPTIONAL_SETTINGS\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\t# We have two sets of settings, certificate and JWT auth key.\\n\\t\\t# Auth Key requires 3 values, so if that is set, that will take\\n\\t\\t# precedence. If None are set, we will throw an error.\\n\\t\\thas_cert_creds = APNS_SETTINGS_CERT_CREDS in \\\\\\n\\t\\t\\tapplication_config.keys()\\n\\t\\tself.has_token_creds = True\\n\\t\\tfor token_setting in APNS_AUTH_CREDS_REQUIRED:\\n\\t\\t\\tif token_setting not in application_config.keys():\\n\\t\\t\\t\\tself.has_token_creds = False\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif not has_cert_creds and not self.has_token_creds:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tsetting=(APNS_SETTINGS_CERT_CREDS, APNS_AUTH_CREDS_REQUIRED)))\\n\\t\\tcert_path = None\\n\\t\\tif has_cert_creds:\\n\\t\\t\\tcert_path = \"CERTIFICATE\"\\n\\t\\telif self.has_token_creds:\\n\\t\\t\\tcert_path = \"AUTH_KEY_PATH\"\\n\\t\\t\\tallowed_tokens = APNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\t\\tAPNS_OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\t\\tREQUIRED_SETTINGS\\n\\t\\t\\tself._validate_allowed_settings(application_id, application_config, allowed_tokens)\\n\\t\\t\\tself._validate_required_settings(\\n\\t\\t\\t\\tapplication_id, application_config, APNS_AUTH_CREDS_REQUIRED\\n\\t\\t\\t)\\n\\t\\tself._validate_apns_certificate(application_config[cert_path])\\n\\n\\t\\t# determine/set optional values\\n\\t\\tapplication_config.setdefault(\"USE_SANDBOX\", False)\\n\\t\\tapplication_config.setdefault(\"USE_ALTERNATIVE_PORT\", False)\\n\\t\\tapplication_config.setdefault(\"TOPIC\", None)\\n\\n\\tdef _validate_apns_certificate(self, certfile):\\n\\t\\t\"\"\"Validate the APNS certificate at startup.\"\"\"\\n\\n\\t\\ttry:\\n\\t\\t\\twith open(certfile, \"r\") as f:\\n\\t\\t\\t\\tcontent = f.read()\\n\\t\\t\\t\\tcheck_apns_certificate(content)\\n\\t\\texcept Exception as e:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"The APNS certificate file at {!r} is not readable: {}\".format(certfile, e)\\n\\t\\t\\t)\\n\\n\\tdef _validate_fcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + FCM_REQUIRED_SETTINGS + FCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, FCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://fcm.googleapis.com/fcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_gcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + GCM_REQUIRED_SETTINGS + GCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, GCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://android.googleapis.com/gcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_wns_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WNS_REQUIRED_SETTINGS + WNS_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WNS_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\")\\n\\n\\tdef _validate_wp_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WP_REQUIRED_SETTINGS + WP_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WP_REQUIRED_SETTINGS\\n\\t\\t)\\n\\t\\tapplication_config.setdefault(\"POST_URL\", {\\n\\t\\t\\t\"CHROME\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"OPERA\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n\\t\\t\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\\t})\\n\\n\\tdef _validate_allowed_settings(self, application_id, application_config, allowed_settings):\\n\\t\\t\"\"\"Confirm only allowed settings are present.\"\"\"\\n\\n\\t\\tfor setting_key in application_config.keys():\\n\\t\\t\\tif setting_key not in allowed_settings:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"Platform {}, app {} does not support the setting: {}.\".format(\\n\\t\\t\\t\\t\\t\\tapplication_config[\"PLATFORM\"], application_id, setting_key\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\n\\tdef _validate_required_settings(\\n\\t\\tself, application_id, application_config, required_settings,\\n\\t\\tshould_throw=True\\n\\t):\\n\\t\\t\"\"\"All required keys must be present\"\"\"\\n\\n\\t\\tfor setting_key in required_settings:\\n\\t\\t\\tif setting_key not in application_config.keys():\\n\\t\\t\\t\\tif should_throw:\\n\\t\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\t\\t\\tapplication_id=application_id, setting=setting_key\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tdef _get_application_settings(self, application_id, platform, settings_key):\\n\\t\\t\"\"\"\\n\\t\\tWalks through PUSH_NOTIFICATIONS_SETTINGS to find the correct setting value\\n\\t\\tor raises ImproperlyConfigured.\\n\\t\\t\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tconf_cls = \"push_notifications.conf.AppConfig\"\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"{} requires the application_id be specified at all times.\".format(conf_cls)\\n\\t\\t\\t)\\n\\n\\t\\t# verify that the application config exists\\n\\t\\tapp_config = self._settings.get(\"APPLICATIONS\").get(application_id, None)\\n\\t\\tif app_config is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"No application configured with application_id: {}.\".format(application_id)\\n\\t\\t\\t)\\n\\n\\t\\t# fetch a setting for the incorrect type of platform\\n\\t\\tif app_config.get(\"PLATFORM\") != platform:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tSETTING_MISMATCH.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tplatform=app_config.get(\"PLATFORM\"),\\n\\t\\t\\t\\t\\tsetting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# finally, try to fetch the setting\\n\\t\\tif settings_key not in app_config:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id, setting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\treturn app_config.get(settings_key)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\treturn self.has_token_creds\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"GCM\", \"API_KEY\")\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"FCM\", \"API_KEY\")\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"POST_URL\")\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"ERROR_TIMEOUT\")\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"MAX_RECIPIENTS\")\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(application_id, \"APNS\", \"CERTIFICATE\")\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn \\\\\\n\\t\\t(self._get_apns_auth_key_path(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key_path(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_PATH\")\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_ID\")\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TEAM_ID\")\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_SANDBOX\")\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_ALTERNATIVE_PORT\")\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TOPIC\")\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"PACKAGE_SECURITY_ID\")\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"SECRET_KEY\")\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"POST_URL\")[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"PRIVATE_KEY\")\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"CLAIMS\")\\n'"}, {"func_args": {"source": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig, check_apns_certificate\\n\\n\\nSETTING_MISMATCH = (\\n\\t\"Application \\'{application_id}\\' ({platform}) does not support the setting \\'{setting}\\'.\"\\n)\\n\\n# code can be \"missing\" or \"invalid\"\\nBAD_PLATFORM = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"PLATFORM\"] is {code}. \\'\\n\\t\"Must be one of: {platforms}.\"\\n)\\n\\nUNKNOWN_PLATFORM = (\\n\\t\"Unknown Platform: {platform}. Must be one of: {platforms}.\"\\n)\\n\\nMISSING_SETTING = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"{setting}\"] is missing.\\'\\n)\\n\\nPLATFORMS = [\\n\\t\"APNS\",\\n\\t\"FCM\",\\n\\t\"GCM\",\\n\\t\"WNS\",\\n\\t\"WP\",\\n]\\n\\n# Settings that all applications must have\\nREQUIRED_SETTINGS = [\\n\\t\"PLATFORM\",\\n]\\n\\n# Settings that an application may have to enable optional features\\n# these settings are stubs for registry support and have no effect on the operation\\n# of the application at this time.\\nOPTIONAL_SETTINGS = [\\n\\t\"APPLICATION_GROUP\", \"APPLICATION_SECRET\"\\n]\\n\\n# Since we can have an auth key, combined with a auth key id and team id *or*\\n# a certificate, we make these all optional, and then make sure we have one or\\n# the other (group) of settings.\\nAPNS_SETTINGS_CERT_CREDS = \"CERTIFICATE\"\\n\\n# Subkeys for APNS_SETTINGS_AUTH_CREDS\\nAPNS_AUTH_CREDS_REQUIRED = [\"AUTH_KEY_PATH\", \"AUTH_KEY_ID\", \"TEAM_ID\"]\\nAPNS_AUTH_CREDS_OPTIONAL = [\"CERTIFICATE\", \"ENCRYPTION_ALGORITHM\", \"TOKEN_LIFETIME\"]\\n\\nAPNS_OPTIONAL_SETTINGS = [\\n\\t\"USE_SANDBOX\", \"USE_ALTERNATIVE_PORT\", \"TOPIC\"\\n]\\n\\nFCM_REQUIRED_SETTINGS = GCM_REQUIRED_SETTINGS = [\"API_KEY\"]\\nFCM_OPTIONAL_SETTINGS = GCM_OPTIONAL_SETTINGS = [\\n\\t\"POST_URL\", \"MAX_RECIPIENTS\", \"ERROR_TIMEOUT\"\\n]\\n\\nWNS_REQUIRED_SETTINGS = [\"PACKAGE_SECURITY_ID\", \"SECRET_KEY\"]\\nWNS_OPTIONAL_SETTINGS = [\"WNS_ACCESS_URL\"]\\n\\nWP_REQUIRED_SETTINGS = [\"PRIVATE_KEY\", \"CLAIMS\"]\\nWP_OPTIONAL_SETTINGS = [\"ERROR_TIMEOUT\", \"POST_URL\"]\\n\\n\\nclass AppConfig(BaseConfig):\\n\\t\"\"\"\\n\\tSupports any number of push notification enabled applications.\\n\\t\"\"\"\\n\\n\\tdef __init__(self, settings=None):\\n\\t\\t# supports overriding the settings to be loaded. Will load from ..settings by default.\\n\\t\\tself._settings = settings or SETTINGS\\n\\n\\t\\t# initialize APPLICATIONS to an empty collection\\n\\t\\tself._settings.setdefault(\"APPLICATIONS\", {})\\n\\n\\t\\t# validate application configurations\\n\\t\\tself._validate_applications(self._settings[\"APPLICATIONS\"])\\n\\n\\tdef _validate_applications(self, apps):\\n\\t\\t\"\"\"Validate the application collection\"\"\"\\n\\t\\tfor application_id, application_config in apps.items():\\n\\t\\t\\tself._validate_config(application_id, application_config)\\n\\n\\t\\t\\tapplication_config[\"APPLICATION_ID\"] = application_id\\n\\n\\tdef _validate_config(self, application_id, application_config):\\n\\t\\tplatform = application_config.get(\"PLATFORM\", None)\\n\\n\\t\\t# platform is not present\\n\\t\\tif platform is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"required\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# platform is not a valid choice from PLATFORMS\\n\\t\\tif platform not in PLATFORMS:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"invalid\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\tvalidate_fn = \"_validate_{platform}_config\".format(platform=platform).lower()\\n\\n\\t\\tif hasattr(self, validate_fn):\\n\\t\\t\\tgetattr(self, validate_fn)(application_id, application_config)\\n\\t\\telse:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tUNKNOWN_PLATFORM.format(\\n\\t\\t\\t\\t\\tplatform=platform,\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\tdef _validate_apns_config(self, application_id, application_config):\\n\\t\\tallowed = REQUIRED_SETTINGS + OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\tAPNS_OPTIONAL_SETTINGS\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\t# We have two sets of settings, certificate and JWT auth key.\\n\\t\\t# Auth Key requires 3 values, so if that is set, that will take\\n\\t\\t# precedence. If None are set, we will throw an error.\\n\\t\\thas_cert_creds = APNS_SETTINGS_CERT_CREDS in \\\\\\n\\t\\t\\tapplication_config.keys()\\n\\t\\tself.has_token_creds = True\\n\\t\\tfor token_setting in APNS_AUTH_CREDS_REQUIRED:\\n\\t\\t\\tif token_setting not in application_config.keys():\\n\\t\\t\\t\\tself.has_token_creds = False\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif not has_cert_creds and not self.has_token_creds:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tsetting=(APNS_SETTINGS_CERT_CREDS, APNS_AUTH_CREDS_REQUIRED)))\\n\\t\\tcert_path = None\\n\\t\\tif has_cert_creds:\\n\\t\\t\\tcert_path = \"CERTIFICATE\"\\n\\t\\telif self.has_token_creds:\\n\\t\\t\\tcert_path = \"AUTH_KEY_PATH\"\\n\\t\\t\\tallowed_tokens = APNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\t\\tAPNS_OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\t\\tREQUIRED_SETTINGS\\n\\t\\t\\tself._validate_allowed_settings(application_id, application_config, allowed_tokens)\\n\\t\\t\\tself._validate_required_settings(\\n\\t\\t\\t\\tapplication_id, application_config, APNS_AUTH_CREDS_REQUIRED\\n\\t\\t\\t)\\n\\t\\tself._validate_apns_certificate(application_config[cert_path])\\n\\n\\t\\t# determine/set optional values\\n\\t\\tapplication_config.setdefault(\"USE_SANDBOX\", False)\\n\\t\\tapplication_config.setdefault(\"USE_ALTERNATIVE_PORT\", False)\\n\\t\\tapplication_config.setdefault(\"TOPIC\", None)\\n\\n\\tdef _validate_apns_certificate(self, certfile):\\n\\t\\t\"\"\"Validate the APNS certificate at startup.\"\"\"\\n\\n\\t\\ttry:\\n\\t\\t\\twith open(certfile, \"r\") as f:\\n\\t\\t\\t\\tcontent = f.read()\\n\\t\\t\\t\\tcheck_apns_certificate(content)\\n\\t\\texcept Exception as e:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"The APNS certificate file at {!r} is not readable: {}\".format(certfile, e)\\n\\t\\t\\t)\\n\\n\\tdef _validate_fcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + FCM_REQUIRED_SETTINGS + FCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, FCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://fcm.googleapis.com/fcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_gcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + GCM_REQUIRED_SETTINGS + GCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, GCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://android.googleapis.com/gcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_wns_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WNS_REQUIRED_SETTINGS + WNS_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WNS_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\")\\n\\n\\tdef _validate_wp_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WP_REQUIRED_SETTINGS + WP_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WP_REQUIRED_SETTINGS\\n\\t\\t)\\n\\t\\tapplication_config.setdefault(\"POST_URL\", {\\n\\t\\t\\t\"CHROME\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"OPERA\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n\\t\\t\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\\t})\\n\\n\\tdef _validate_allowed_settings(self, application_id, application_config, allowed_settings):\\n\\t\\t\"\"\"Confirm only allowed settings are present.\"\"\"\\n\\n\\t\\tfor setting_key in application_config.keys():\\n\\t\\t\\tif setting_key not in allowed_settings:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"Platform {}, app {} does not support the setting: {}.\".format(\\n\\t\\t\\t\\t\\t\\tapplication_config[\"PLATFORM\"], application_id, setting_key\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\n\\tdef _validate_required_settings(\\n\\t\\tself, application_id, application_config, required_settings,\\n\\t\\tshould_throw=True\\n\\t):\\n\\t\\t\"\"\"All required keys must be present\"\"\"\\n\\n\\t\\tfor setting_key in required_settings:\\n\\t\\t\\tif setting_key not in application_config.keys():\\n\\t\\t\\t\\tif should_throw:\\n\\t\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\t\\t\\tapplication_id=application_id, setting=setting_key\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tdef _get_application_settings(self, application_id, platform, settings_key):\\n\\t\\t\"\"\"\\n\\t\\tWalks through PUSH_NOTIFICATIONS_SETTINGS to find the correct setting value\\n\\t\\tor raises ImproperlyConfigured.\\n\\t\\t\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tconf_cls = \"push_notifications.conf.AppConfig\"\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"{} requires the application_id be specified at all times.\".format(conf_cls)\\n\\t\\t\\t)\\n\\n\\t\\t# verify that the application config exists\\n\\t\\tapp_config = self._settings.get(\"APPLICATIONS\").get(application_id, None)\\n\\t\\tif app_config is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"No application configured with application_id: {}.\".format(application_id)\\n\\t\\t\\t)\\n\\n\\t\\t# fetch a setting for the incorrect type of platform\\n\\t\\tif app_config.get(\"PLATFORM\") != platform:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tSETTING_MISMATCH.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tplatform=app_config.get(\"PLATFORM\"),\\n\\t\\t\\t\\t\\tsetting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# finally, try to fetch the setting\\n\\t\\tif settings_key not in app_config:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id, setting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\treturn app_config.get(settings_key)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\treturn self.has_token_creds\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"GCM\", \"API_KEY\")\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"FCM\", \"API_KEY\")\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"POST_URL\")\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"ERROR_TIMEOUT\")\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"MAX_RECIPIENTS\")\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(application_id, \"APNS\", \"CERTIFICATE\")\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn \\\\\\n\\t\\t(self._get_apns_auth_key_path(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key_path(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_PATH\")\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_ID\")\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TEAM_ID\")\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_SANDBOX\")\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_ALTERNATIVE_PORT\")\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TOPIC\")\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"PACKAGE_SECURITY_ID\")\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"SECRET_KEY\")\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"POST_URL\")[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"PRIVATE_KEY\")\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"CLAIMS\")\\n'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig, check_apns_certificate\\n\\n\\nSETTING_MISMATCH = (\\n\\t\"Application \\'{application_id}\\' ({platform}) does not support the setting \\'{setting}\\'.\"\\n)\\n\\n# code can be \"missing\" or \"invalid\"\\nBAD_PLATFORM = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"PLATFORM\"] is {code}. \\'\\n\\t\"Must be one of: {platforms}.\"\\n)\\n\\nUNKNOWN_PLATFORM = (\\n\\t\"Unknown Platform: {platform}. Must be one of: {platforms}.\"\\n)\\n\\nMISSING_SETTING = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"{setting}\"] is missing.\\'\\n)\\n\\nPLATFORMS = [\\n\\t\"APNS\",\\n\\t\"FCM\",\\n\\t\"GCM\",\\n\\t\"WNS\",\\n\\t\"WP\",\\n]\\n\\n# Settings that all applications must have\\nREQUIRED_SETTINGS = [\\n\\t\"PLATFORM\",\\n]\\n\\n# Settings that an application may have to enable optional features\\n# these settings are stubs for registry support and have no effect on the operation\\n# of the application at this time.\\nOPTIONAL_SETTINGS = [\\n\\t\"APPLICATION_GROUP\", \"APPLICATION_SECRET\"\\n]\\n\\n# Since we can have an auth key, combined with a auth key id and team id *or*\\n# a certificate, we make these all optional, and then make sure we have one or\\n# the other (group) of settings.\\nAPNS_SETTINGS_CERT_CREDS = \"CERTIFICATE\"\\n\\n# Subkeys for APNS_SETTINGS_AUTH_CREDS\\nAPNS_AUTH_CREDS_REQUIRED = [\"AUTH_KEY_PATH\", \"AUTH_KEY_ID\", \"TEAM_ID\"]\\nAPNS_AUTH_CREDS_OPTIONAL = [\"CERTIFICATE\", \"ENCRYPTION_ALGORITHM\", \"TOKEN_LIFETIME\"]\\n\\nAPNS_OPTIONAL_SETTINGS = [\\n\\t\"USE_SANDBOX\", \"USE_ALTERNATIVE_PORT\", \"TOPIC\"\\n]\\n\\nFCM_REQUIRED_SETTINGS = GCM_REQUIRED_SETTINGS = [\"API_KEY\"]\\nFCM_OPTIONAL_SETTINGS = GCM_OPTIONAL_SETTINGS = [\\n\\t\"POST_URL\", \"MAX_RECIPIENTS\", \"ERROR_TIMEOUT\"\\n]\\n\\nWNS_REQUIRED_SETTINGS = [\"PACKAGE_SECURITY_ID\", \"SECRET_KEY\"]\\nWNS_OPTIONAL_SETTINGS = [\"WNS_ACCESS_URL\"]\\n\\nWP_REQUIRED_SETTINGS = [\"PRIVATE_KEY\", \"CLAIMS\"]\\nWP_OPTIONAL_SETTINGS = [\"ERROR_TIMEOUT\", \"POST_URL\"]\\n\\n\\nclass AppConfig(BaseConfig):\\n\\t\"\"\"\\n\\tSupports any number of push notification enabled applications.\\n\\t\"\"\"\\n\\n\\tdef __init__(self, settings=None):\\n\\t\\t# supports overriding the settings to be loaded. Will load from ..settings by default.\\n\\t\\tself._settings = settings or SETTINGS\\n\\n\\t\\t# initialize APPLICATIONS to an empty collection\\n\\t\\tself._settings.setdefault(\"APPLICATIONS\", {})\\n\\n\\t\\t# validate application configurations\\n\\t\\tself._validate_applications(self._settings[\"APPLICATIONS\"])\\n\\n\\tdef _validate_applications(self, apps):\\n\\t\\t\"\"\"Validate the application collection\"\"\"\\n\\t\\tfor application_id, application_config in apps.items():\\n\\t\\t\\tself._validate_config(application_id, application_config)\\n\\n\\t\\t\\tapplication_config[\"APPLICATION_ID\"] = application_id\\n\\n\\tdef _validate_config(self, application_id, application_config):\\n\\t\\tplatform = application_config.get(\"PLATFORM\", None)\\n\\n\\t\\t# platform is not present\\n\\t\\tif platform is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"required\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# platform is not a valid choice from PLATFORMS\\n\\t\\tif platform not in PLATFORMS:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"invalid\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\tvalidate_fn = \"_validate_{platform}_config\".format(platform=platform).lower()\\n\\n\\t\\tif hasattr(self, validate_fn):\\n\\t\\t\\tgetattr(self, validate_fn)(application_id, application_config)\\n\\t\\telse:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tUNKNOWN_PLATFORM.format(\\n\\t\\t\\t\\t\\tplatform=platform,\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\tdef _validate_apns_config(self, application_id, application_config):\\n\\t\\tallowed = REQUIRED_SETTINGS + OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\tAPNS_OPTIONAL_SETTINGS\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\t# We have two sets of settings, certificate and JWT auth key.\\n\\t\\t# Auth Key requires 3 values, so if that is set, that will take\\n\\t\\t# precedence. If None are set, we will throw an error.\\n\\t\\thas_cert_creds = APNS_SETTINGS_CERT_CREDS in \\\\\\n\\t\\t\\tapplication_config.keys()\\n\\t\\tself.has_token_creds = True\\n\\t\\tfor token_setting in APNS_AUTH_CREDS_REQUIRED:\\n\\t\\t\\tif token_setting not in application_config.keys():\\n\\t\\t\\t\\tself.has_token_creds = False\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif not has_cert_creds and not self.has_token_creds:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tsetting=(APNS_SETTINGS_CERT_CREDS, APNS_AUTH_CREDS_REQUIRED)))\\n\\t\\tcert_path = None\\n\\t\\tif has_cert_creds:\\n\\t\\t\\tcert_path = \"CERTIFICATE\"\\n\\t\\telif self.has_token_creds:\\n\\t\\t\\tcert_path = \"AUTH_KEY_PATH\"\\n\\t\\t\\tallowed_tokens = APNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\t\\tAPNS_OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\t\\tREQUIRED_SETTINGS\\n\\t\\t\\tself._validate_allowed_settings(application_id, application_config, allowed_tokens)\\n\\t\\t\\tself._validate_required_settings(\\n\\t\\t\\t\\tapplication_id, application_config, APNS_AUTH_CREDS_REQUIRED\\n\\t\\t\\t)\\n\\t\\tself._validate_apns_certificate(application_config[cert_path])\\n\\n\\t\\t# determine/set optional values\\n\\t\\tapplication_config.setdefault(\"USE_SANDBOX\", False)\\n\\t\\tapplication_config.setdefault(\"USE_ALTERNATIVE_PORT\", False)\\n\\t\\tapplication_config.setdefault(\"TOPIC\", None)\\n\\n\\tdef _validate_apns_certificate(self, certfile):\\n\\t\\t\"\"\"Validate the APNS certificate at startup.\"\"\"\\n\\n\\t\\ttry:\\n\\t\\t\\twith open(certfile, \"r\") as f:\\n\\t\\t\\t\\tcontent = f.read()\\n\\t\\t\\t\\tcheck_apns_certificate(content)\\n\\t\\texcept Exception as e:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"The APNS certificate file at {!r} is not readable: {}\".format(certfile, e)\\n\\t\\t\\t)\\n\\n\\tdef _validate_fcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + FCM_REQUIRED_SETTINGS + FCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, FCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://fcm.googleapis.com/fcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_gcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + GCM_REQUIRED_SETTINGS + GCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, GCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://android.googleapis.com/gcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_wns_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WNS_REQUIRED_SETTINGS + WNS_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WNS_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\")\\n\\n\\tdef _validate_wp_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WP_REQUIRED_SETTINGS + WP_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WP_REQUIRED_SETTINGS\\n\\t\\t)\\n\\t\\tapplication_config.setdefault(\"POST_URL\", {\\n\\t\\t\\t\"CHROME\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"OPERA\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n\\t\\t\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\\t})\\n\\n\\tdef _validate_allowed_settings(self, application_id, application_config, allowed_settings):\\n\\t\\t\"\"\"Confirm only allowed settings are present.\"\"\"\\n\\n\\t\\tfor setting_key in application_config.keys():\\n\\t\\t\\tif setting_key not in allowed_settings:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"Platform {}, app {} does not support the setting: {}.\".format(\\n\\t\\t\\t\\t\\t\\tapplication_config[\"PLATFORM\"], application_id, setting_key\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\n\\tdef _validate_required_settings(\\n\\t\\tself, application_id, application_config, required_settings,\\n\\t\\tshould_throw=True\\n\\t):\\n\\t\\t\"\"\"All required keys must be present\"\"\"\\n\\n\\t\\tfor setting_key in required_settings:\\n\\t\\t\\tif setting_key not in application_config.keys():\\n\\t\\t\\t\\tif should_throw:\\n\\t\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\t\\t\\tapplication_id=application_id, setting=setting_key\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tdef _get_application_settings(self, application_id, platform, settings_key):\\n\\t\\t\"\"\"\\n\\t\\tWalks through PUSH_NOTIFICATIONS_SETTINGS to find the correct setting value\\n\\t\\tor raises ImproperlyConfigured.\\n\\t\\t\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tconf_cls = \"push_notifications.conf.AppConfig\"\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"{} requires the application_id be specified at all times.\".format(conf_cls)\\n\\t\\t\\t)\\n\\n\\t\\t# verify that the application config exists\\n\\t\\tapp_config = self._settings.get(\"APPLICATIONS\").get(application_id, None)\\n\\t\\tif app_config is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"No application configured with application_id: {}.\".format(application_id)\\n\\t\\t\\t)\\n\\n\\t\\t# fetch a setting for the incorrect type of platform\\n\\t\\tif app_config.get(\"PLATFORM\") != platform:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tSETTING_MISMATCH.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tplatform=app_config.get(\"PLATFORM\"),\\n\\t\\t\\t\\t\\tsetting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# finally, try to fetch the setting\\n\\t\\tif settings_key not in app_config:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id, setting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\treturn app_config.get(settings_key)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\treturn self.has_token_creds\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"GCM\", \"API_KEY\")\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"FCM\", \"API_KEY\")\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"POST_URL\")\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"ERROR_TIMEOUT\")\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"MAX_RECIPIENTS\")\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(application_id, \"APNS\", \"CERTIFICATE\")\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn \\\\\\n\\t\\t(self._get_apns_auth_key_path(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key_path(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_PATH\")\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_ID\")\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TEAM_ID\")\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_SANDBOX\")\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_ALTERNATIVE_PORT\")\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TOPIC\")\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"PACKAGE_SECURITY_ID\")\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"SECRET_KEY\")\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"POST_URL\")[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"PRIVATE_KEY\")\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"CLAIMS\")\\n'"}, {"func_args": {"source": "'from .base import BaseConfig\\n\\n\\nclass AppModelConfig(BaseConfig):\\n\\t\"\"\"Future home of the Application Model conf adapter\\n\\n\\tSupports multiple applications in the database.\\n\\t\"\"\"\\n\\n\\tpass\\n'"}, "return_value": "'from .base import BaseConfig\\n\\n\\nclass AppModelConfig(BaseConfig):\\n\\t\"\"\"Future home of the Application Model conf adapter\\n\\n\\tSupports multiple applications in the database.\\n\\t\"\"\"\\n\\n\\tpass\\n'"}, {"func_args": {"source": "'from .base import BaseConfig\\n\\n\\nclass AppModelConfig(BaseConfig):\\n\\t\"\"\"Future home of the Application Model conf adapter\\n\\n\\tSupports multiple applications in the database.\\n\\t\"\"\"\\n\\n\\tpass\\n'"}, "return_value": "'from .base import BaseConfig\\n\\n\\nclass AppModelConfig(BaseConfig):\\n\\t\"\"\"Future home of the Application Model conf adapter\\n\\n\\tSupports multiple applications in the database.\\n\\t\"\"\"\\n\\n\\tpass\\n'"}, {"func_args": {"source": "'from django.core.exceptions import ImproperlyConfigured\\n\\n\\nclass BaseConfig:\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_applications(self):\\n\\t\\t\"\"\"Returns a collection containing the configured applications.\"\"\"\\n\\n\\t\\traise NotImplementedError\\n\\n\\n# This works for both the certificate and the auth key (since that\\'s just\\n# a certificate).\\ndef check_apns_certificate(ss):\\n\\tmode = \"start\"\\n\\tfor s in ss.split(\"\\\\n\"):\\n\\t\\tif mode == \"start\":\\n\\t\\t\\tif \"BEGIN RSA PRIVATE KEY\" in s or \"BEGIN PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"key\"\\n\\t\\telif mode == \"key\":\\n\\t\\t\\tif \"END RSA PRIVATE KEY\" in s or \"END PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"end\"\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif s.startswith(\"Proc-Type\") and \"ENCRYPTED\" in s:\\n\\t\\t\\t\\traise ImproperlyConfigured(\"Encrypted APNS private keys are not supported\")\\n\\n\\tif mode != \"end\":\\n\\t\\traise ImproperlyConfigured(\"The APNS certificate doesn\\'t contain a private key\")\\n'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\n\\nclass BaseConfig:\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_applications(self):\\n\\t\\t\"\"\"Returns a collection containing the configured applications.\"\"\"\\n\\n\\t\\traise NotImplementedError\\n\\n\\n# This works for both the certificate and the auth key (since that\\'s just\\n# a certificate).\\ndef check_apns_certificate(ss):\\n\\tmode = \"start\"\\n\\tfor s in ss.split(\"\\\\n\"):\\n\\t\\tif mode == \"start\":\\n\\t\\t\\tif \"BEGIN RSA PRIVATE KEY\" in s or \"BEGIN PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"key\"\\n\\t\\telif mode == \"key\":\\n\\t\\t\\tif \"END RSA PRIVATE KEY\" in s or \"END PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"end\"\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif s.startswith(\"Proc-Type\") and \"ENCRYPTED\" in s:\\n\\t\\t\\t\\traise ImproperlyConfigured(\"Encrypted APNS private keys are not supported\")\\n\\n\\tif mode != \"end\":\\n\\t\\traise ImproperlyConfigured(\"The APNS certificate doesn\\'t contain a private key\")\\n'"}, {"func_args": {"source": "'from django.core.exceptions import ImproperlyConfigured\\n\\n\\nclass BaseConfig:\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_applications(self):\\n\\t\\t\"\"\"Returns a collection containing the configured applications.\"\"\"\\n\\n\\t\\traise NotImplementedError\\n\\n\\n# This works for both the certificate and the auth key (since that\\'s just\\n# a certificate).\\ndef check_apns_certificate(ss):\\n\\tmode = \"start\"\\n\\tfor s in ss.split(\"\\\\n\"):\\n\\t\\tif mode == \"start\":\\n\\t\\t\\tif \"BEGIN RSA PRIVATE KEY\" in s or \"BEGIN PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"key\"\\n\\t\\telif mode == \"key\":\\n\\t\\t\\tif \"END RSA PRIVATE KEY\" in s or \"END PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"end\"\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif s.startswith(\"Proc-Type\") and \"ENCRYPTED\" in s:\\n\\t\\t\\t\\traise ImproperlyConfigured(\"Encrypted APNS private keys are not supported\")\\n\\n\\tif mode != \"end\":\\n\\t\\traise ImproperlyConfigured(\"The APNS certificate doesn\\'t contain a private key\")\\n'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\n\\nclass BaseConfig:\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_applications(self):\\n\\t\\t\"\"\"Returns a collection containing the configured applications.\"\"\"\\n\\n\\t\\traise NotImplementedError\\n\\n\\n# This works for both the certificate and the auth key (since that\\'s just\\n# a certificate).\\ndef check_apns_certificate(ss):\\n\\tmode = \"start\"\\n\\tfor s in ss.split(\"\\\\n\"):\\n\\t\\tif mode == \"start\":\\n\\t\\t\\tif \"BEGIN RSA PRIVATE KEY\" in s or \"BEGIN PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"key\"\\n\\t\\telif mode == \"key\":\\n\\t\\t\\tif \"END RSA PRIVATE KEY\" in s or \"END PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"end\"\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif s.startswith(\"Proc-Type\") and \"ENCRYPTED\" in s:\\n\\t\\t\\t\\traise ImproperlyConfigured(\"Encrypted APNS private keys are not supported\")\\n\\n\\tif mode != \"end\":\\n\\t\\traise ImproperlyConfigured(\"The APNS certificate doesn\\'t contain a private key\")\\n'"}, {"func_args": {"source": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig\\n\\n\\n__all__ = [\\n\\t\"LegacyConfig\"\\n]\\n\\n\\nclass empty:\\n\\tpass\\n\\n\\nclass LegacyConfig(BaseConfig):\\n\\n\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\n\\tdef _get_application_settings(self, application_id, settings_key, error_message):\\n\\t\\t\"\"\"Legacy behaviour\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tvalue = SETTINGS.get(settings_key, empty)\\n\\t\\t\\tif value is empty:\\n\\t\\t\\t\\traise ImproperlyConfigured(error_message)\\n\\t\\t\\treturn value\\n\\t\\telse:\\n\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\"LegacySettings does not support application_id. To enable \"\\n\\t\\t\\t\\t\"multiple application support, use push_notifications.conf.AppSettings.\"\\n\\t\\t\\t)\\n\\t\\t\\traise ImproperlyConfigured(msg)\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"GCM_API_KEY\"] to send messages through GCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"GCM_API_KEY\", msg)\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"FCM_API_KEY\"] to send messages through FCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"FCM_API_KEY\", msg)\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_POST_URL\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_ERROR_TIMEOUT\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_MAX_RECIPIENTS\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\ttry:\\n\\t\\t\\tself._get_apns_auth_key(application_id)\\n\\t\\t\\tself._get_apns_auth_key_id(application_id)\\n\\t\\t\\tself._get_apns_team_id(application_id)\\n\\t\\texcept ImproperlyConfigured:\\n\\t\\t\\treturn False\\n\\n\\t\\treturn True\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(\\n\\t\\t\\tapplication_id, \"APNS_CERTIFICATE\",\\n\\t\\t\\t\"You need to setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\t)\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\traise ImproperlyConfigured(msg)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn (\\n\\t\\t\\tself._get_apns_auth_key(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_PATH\", self.msg)\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TEAM_ID\", self.msg)\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_ID\", self.msg)\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_USE_SANDBOX\", self.msg)\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn\\n\\t\\tself._get_application_settings(application_id, \"APNS_USE_ALTERNATIVE_PORT\", self.msg)\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TOPIC\", self.msg)\\n\\n\\tdef get_apns_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_HOST\", self.msg)\\n\\n\\tdef get_apns_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_PORT\", self.msg)\\n\\n\\tdef get_apns_feedback_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_HOST\", self.msg)\\n\\n\\tdef get_apns_feedback_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_PORT\", self.msg)\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_PACKAGE_SECURITY_ID\", self.msg)\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_SECRET_KEY\", msg)\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_POST_URL\", msg)[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_PRIVATE_KEY\", msg)\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_CLAIMS\", msg)\\n'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig\\n\\n\\n__all__ = [\\n\\t\"LegacyConfig\"\\n]\\n\\n\\nclass empty:\\n\\tpass\\n\\n\\nclass LegacyConfig(BaseConfig):\\n\\n\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\n\\tdef _get_application_settings(self, application_id, settings_key, error_message):\\n\\t\\t\"\"\"Legacy behaviour\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tvalue = SETTINGS.get(settings_key, empty)\\n\\t\\t\\tif value is empty:\\n\\t\\t\\t\\traise ImproperlyConfigured(error_message)\\n\\t\\t\\treturn value\\n\\t\\telse:\\n\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\"LegacySettings does not support application_id. To enable \"\\n\\t\\t\\t\\t\"multiple application support, use push_notifications.conf.AppSettings.\"\\n\\t\\t\\t)\\n\\t\\t\\traise ImproperlyConfigured(msg)\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"GCM_API_KEY\"] to send messages through GCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"GCM_API_KEY\", msg)\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"FCM_API_KEY\"] to send messages through FCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"FCM_API_KEY\", msg)\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_POST_URL\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_ERROR_TIMEOUT\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_MAX_RECIPIENTS\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\ttry:\\n\\t\\t\\tself._get_apns_auth_key(application_id)\\n\\t\\t\\tself._get_apns_auth_key_id(application_id)\\n\\t\\t\\tself._get_apns_team_id(application_id)\\n\\t\\texcept ImproperlyConfigured:\\n\\t\\t\\treturn False\\n\\n\\t\\treturn True\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(\\n\\t\\t\\tapplication_id, \"APNS_CERTIFICATE\",\\n\\t\\t\\t\"You need to setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\t)\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\traise ImproperlyConfigured(msg)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn (\\n\\t\\t\\tself._get_apns_auth_key(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_PATH\", self.msg)\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TEAM_ID\", self.msg)\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_ID\", self.msg)\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_USE_SANDBOX\", self.msg)\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn\\n\\t\\tself._get_application_settings(application_id, \"APNS_USE_ALTERNATIVE_PORT\", self.msg)\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TOPIC\", self.msg)\\n\\n\\tdef get_apns_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_HOST\", self.msg)\\n\\n\\tdef get_apns_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_PORT\", self.msg)\\n\\n\\tdef get_apns_feedback_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_HOST\", self.msg)\\n\\n\\tdef get_apns_feedback_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_PORT\", self.msg)\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_PACKAGE_SECURITY_ID\", self.msg)\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_SECRET_KEY\", msg)\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_POST_URL\", msg)[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_PRIVATE_KEY\", msg)\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_CLAIMS\", msg)\\n'"}, {"func_args": {"source": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig\\n\\n\\n__all__ = [\\n\\t\"LegacyConfig\"\\n]\\n\\n\\nclass empty:\\n\\tpass\\n\\n\\nclass LegacyConfig(BaseConfig):\\n\\n\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\n\\tdef _get_application_settings(self, application_id, settings_key, error_message):\\n\\t\\t\"\"\"Legacy behaviour\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tvalue = SETTINGS.get(settings_key, empty)\\n\\t\\t\\tif value is empty:\\n\\t\\t\\t\\traise ImproperlyConfigured(error_message)\\n\\t\\t\\treturn value\\n\\t\\telse:\\n\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\"LegacySettings does not support application_id. To enable \"\\n\\t\\t\\t\\t\"multiple application support, use push_notifications.conf.AppSettings.\"\\n\\t\\t\\t)\\n\\t\\t\\traise ImproperlyConfigured(msg)\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"GCM_API_KEY\"] to send messages through GCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"GCM_API_KEY\", msg)\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"FCM_API_KEY\"] to send messages through FCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"FCM_API_KEY\", msg)\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_POST_URL\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_ERROR_TIMEOUT\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_MAX_RECIPIENTS\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\ttry:\\n\\t\\t\\tself._get_apns_auth_key(application_id)\\n\\t\\t\\tself._get_apns_auth_key_id(application_id)\\n\\t\\t\\tself._get_apns_team_id(application_id)\\n\\t\\texcept ImproperlyConfigured:\\n\\t\\t\\treturn False\\n\\n\\t\\treturn True\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(\\n\\t\\t\\tapplication_id, \"APNS_CERTIFICATE\",\\n\\t\\t\\t\"You need to setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\t)\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\traise ImproperlyConfigured(msg)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn (\\n\\t\\t\\tself._get_apns_auth_key(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_PATH\", self.msg)\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TEAM_ID\", self.msg)\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_ID\", self.msg)\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_USE_SANDBOX\", self.msg)\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn\\n\\t\\tself._get_application_settings(application_id, \"APNS_USE_ALTERNATIVE_PORT\", self.msg)\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TOPIC\", self.msg)\\n\\n\\tdef get_apns_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_HOST\", self.msg)\\n\\n\\tdef get_apns_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_PORT\", self.msg)\\n\\n\\tdef get_apns_feedback_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_HOST\", self.msg)\\n\\n\\tdef get_apns_feedback_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_PORT\", self.msg)\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_PACKAGE_SECURITY_ID\", self.msg)\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_SECRET_KEY\", msg)\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_POST_URL\", msg)[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_PRIVATE_KEY\", msg)\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_CLAIMS\", msg)\\n'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig\\n\\n\\n__all__ = [\\n\\t\"LegacyConfig\"\\n]\\n\\n\\nclass empty:\\n\\tpass\\n\\n\\nclass LegacyConfig(BaseConfig):\\n\\n\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\n\\tdef _get_application_settings(self, application_id, settings_key, error_message):\\n\\t\\t\"\"\"Legacy behaviour\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tvalue = SETTINGS.get(settings_key, empty)\\n\\t\\t\\tif value is empty:\\n\\t\\t\\t\\traise ImproperlyConfigured(error_message)\\n\\t\\t\\treturn value\\n\\t\\telse:\\n\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\"LegacySettings does not support application_id. To enable \"\\n\\t\\t\\t\\t\"multiple application support, use push_notifications.conf.AppSettings.\"\\n\\t\\t\\t)\\n\\t\\t\\traise ImproperlyConfigured(msg)\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"GCM_API_KEY\"] to send messages through GCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"GCM_API_KEY\", msg)\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"FCM_API_KEY\"] to send messages through FCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"FCM_API_KEY\", msg)\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_POST_URL\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_ERROR_TIMEOUT\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_MAX_RECIPIENTS\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\ttry:\\n\\t\\t\\tself._get_apns_auth_key(application_id)\\n\\t\\t\\tself._get_apns_auth_key_id(application_id)\\n\\t\\t\\tself._get_apns_team_id(application_id)\\n\\t\\texcept ImproperlyConfigured:\\n\\t\\t\\treturn False\\n\\n\\t\\treturn True\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(\\n\\t\\t\\tapplication_id, \"APNS_CERTIFICATE\",\\n\\t\\t\\t\"You need to setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\t)\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\traise ImproperlyConfigured(msg)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn (\\n\\t\\t\\tself._get_apns_auth_key(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_PATH\", self.msg)\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TEAM_ID\", self.msg)\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_ID\", self.msg)\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_USE_SANDBOX\", self.msg)\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn\\n\\t\\tself._get_application_settings(application_id, \"APNS_USE_ALTERNATIVE_PORT\", self.msg)\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TOPIC\", self.msg)\\n\\n\\tdef get_apns_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_HOST\", self.msg)\\n\\n\\tdef get_apns_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_PORT\", self.msg)\\n\\n\\tdef get_apns_feedback_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_HOST\", self.msg)\\n\\n\\tdef get_apns_feedback_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_PORT\", self.msg)\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_PACKAGE_SECURITY_ID\", self.msg)\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_SECRET_KEY\", msg)\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_POST_URL\", msg)[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_PRIVATE_KEY\", msg)\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_CLAIMS\", msg)\\n'"}, {"func_args": {"source": "'class NotificationError(Exception):\\n\\tpass\\n\\n\\n# APNS\\nclass APNSError(NotificationError):\\n\\tpass\\n\\n\\nclass APNSUnsupportedPriority(APNSError):\\n\\tpass\\n\\n\\nclass APNSServerError(APNSError):\\n\\tdef __init__(self, status):\\n\\t\\tsuper().__init__(status)\\n\\t\\tself.status = status\\n\\n\\n# GCM\\nclass GCMError(NotificationError):\\n\\tpass\\n\\n\\n# Web Push\\nclass WebPushError(NotificationError):\\n\\tpass\\n'"}, "return_value": "'class NotificationError(Exception):\\n\\tpass\\n\\n\\n# APNS\\nclass APNSError(NotificationError):\\n\\tpass\\n\\n\\nclass APNSUnsupportedPriority(APNSError):\\n\\tpass\\n\\n\\nclass APNSServerError(APNSError):\\n\\tdef __init__(self, status):\\n\\t\\tsuper().__init__(status)\\n\\t\\tself.status = status\\n\\n\\n# GCM\\nclass GCMError(NotificationError):\\n\\tpass\\n\\n\\n# Web Push\\nclass WebPushError(NotificationError):\\n\\tpass\\n'"}, {"func_args": {"source": "'class NotificationError(Exception):\\n\\tpass\\n\\n\\n# APNS\\nclass APNSError(NotificationError):\\n\\tpass\\n\\n\\nclass APNSUnsupportedPriority(APNSError):\\n\\tpass\\n\\n\\nclass APNSServerError(APNSError):\\n\\tdef __init__(self, status):\\n\\t\\tsuper().__init__(status)\\n\\t\\tself.status = status\\n\\n\\n# GCM\\nclass GCMError(NotificationError):\\n\\tpass\\n\\n\\n# Web Push\\nclass WebPushError(NotificationError):\\n\\tpass\\n'"}, "return_value": "'class NotificationError(Exception):\\n\\tpass\\n\\n\\n# APNS\\nclass APNSError(NotificationError):\\n\\tpass\\n\\n\\nclass APNSUnsupportedPriority(APNSError):\\n\\tpass\\n\\n\\nclass APNSServerError(APNSError):\\n\\tdef __init__(self, status):\\n\\t\\tsuper().__init__(status)\\n\\t\\tself.status = status\\n\\n\\n# GCM\\nclass GCMError(NotificationError):\\n\\tpass\\n\\n\\n# Web Push\\nclass WebPushError(NotificationError):\\n\\tpass\\n'"}, {"func_args": {"source": "'import re\\nimport struct\\n\\nfrom django import forms\\nfrom django.core.validators import MaxValueValidator, MinValueValidator, RegexValidator\\nfrom django.db import connection, models\\nfrom django.utils.translation import gettext_lazy as _\\n\\n\\n__all__ = [\"HexadecimalField\", \"HexIntegerField\"]\\n\\nUNSIGNED_64BIT_INT_MIN_VALUE = 0\\nUNSIGNED_64BIT_INT_MAX_VALUE = 2 ** 64 - 1\\n\\n\\nhex_re = re.compile(r\"^(([0-9A-f])|(0x[0-9A-f]))+$\")\\nsigned_integer_vendors = [\\n\\t\"postgresql\",\\n\\t\"sqlite\",\\n]\\n\\n\\ndef _using_signed_storage():\\n\\treturn connection.vendor in signed_integer_vendors\\n\\n\\ndef _signed_to_unsigned_integer(value):\\n\\treturn struct.unpack(\"Q\", struct.pack(\"q\", value))[0]\\n\\n\\ndef _unsigned_to_signed_integer(value):\\n\\treturn struct.unpack(\"q\", struct.pack(\"Q\", value))[0]\\n\\n\\ndef _hex_string_to_unsigned_integer(value):\\n\\treturn int(value, 16)\\n\\n\\ndef _unsigned_integer_to_hex_string(value):\\n\\treturn hex(value).rstrip(\"L\")\\n\\n\\nclass HexadecimalField(forms.CharField):\\n\\t\"\"\"\\n\\tA form field that accepts only hexadecimal numbers\\n\\t\"\"\"\\n\\tdef __init__(self, *args, **kwargs):\\n\\t\\tself.default_validators = [\\n\\t\\t\\tRegexValidator(hex_re, _(\"Enter a valid hexadecimal number\"), \"invalid\")\\n\\t\\t]\\n\\t\\tsuper(HexadecimalField, self).__init__(*args, **kwargs)\\n\\n\\tdef prepare_value(self, value):\\n\\t\\t# converts bigint from db to hex before it is displayed in admin\\n\\t\\tif value and not isinstance(value, str) \\\\\\n\\t\\t\\tand connection.vendor in (\"mysql\", \"sqlite\"):\\n\\t\\t\\tvalue = _unsigned_integer_to_hex_string(value)\\n\\t\\treturn super(forms.CharField, self).prepare_value(value)\\n\\n\\nclass HexIntegerField(models.BigIntegerField):\\n\\t\"\"\"\\n\\tThis field stores a hexadecimal *string* of up to 64 bits as an unsigned integer\\n\\ton *all* backends including postgres.\\n\\n\\tReasoning: Postgres only supports signed bigints. Since we don\\'t care about\\n\\tsignedness, we store it as signed, and cast it to unsigned when we deal with\\n\\tthe actual value (with struct)\\n\\n\\tOn sqlite and mysql, native unsigned bigint types are used. In all cases, the\\n\\tvalue we deal with in python is always in hex.\\n\\t\"\"\"\\n\\n\\tvalidators = [\\n\\t\\tMinValueValidator(UNSIGNED_64BIT_INT_MIN_VALUE),\\n\\t\\tMaxValueValidator(UNSIGNED_64BIT_INT_MAX_VALUE)\\n\\t]\\n\\n\\tdef db_type(self, connection):\\n\\t\\tif \"mysql\" == connection.vendor:\\n\\t\\t\\treturn \"bigint unsigned\"\\n\\t\\telif \"sqlite\" == connection.vendor:\\n\\t\\t\\treturn \"UNSIGNED BIG INT\"\\n\\t\\telse:\\n\\t\\t\\treturn super(HexIntegerField, self).db_type(connection=connection)\\n\\n\\tdef get_prep_value(self, value):\\n\\t\\t\"\"\" Return the integer value to be stored from the hex string \"\"\"\\n\\t\\tif value is None or value == \"\":\\n\\t\\t\\treturn None\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _unsigned_to_signed_integer(value)\\n\\t\\treturn value\\n\\n\\tdef from_db_value(self, value, *args):\\n\\t\\t\"\"\" Return an unsigned int representation from all db backends \"\"\"\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _signed_to_unsigned_integer(value)\\n\\t\\treturn value\\n\\n\\tdef to_python(self, value):\\n\\t\\t\"\"\" Return a str representation of the hexadecimal \"\"\"\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\treturn value\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\treturn _unsigned_integer_to_hex_string(value)\\n\\n\\tdef formfield(self, **kwargs):\\n\\t\\tdefaults = {\"form_class\": HexadecimalField}\\n\\t\\tdefaults.update(kwargs)\\n\\t\\t# yes, that super call is right\\n\\t\\treturn super(models.IntegerField, self).formfield(**defaults)\\n\\n\\tdef run_validators(self, value):\\n\\t\\t# make sure validation is performed on integer value not string value\\n\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\treturn super(models.BigIntegerField, self).run_validators(value)\\n'"}, "return_value": "'import re\\nimport struct\\n\\nfrom django import forms\\nfrom django.core.validators import MaxValueValidator, MinValueValidator, RegexValidator\\nfrom django.db import connection, models\\nfrom django.utils.translation import gettext_lazy as _\\n\\n\\n__all__ = [\"HexadecimalField\", \"HexIntegerField\"]\\n\\nUNSIGNED_64BIT_INT_MIN_VALUE = 0\\nUNSIGNED_64BIT_INT_MAX_VALUE = 2 ** 64 - 1\\n\\n\\nhex_re = re.compile(r\"^(([0-9A-f])|(0x[0-9A-f]))+$\")\\nsigned_integer_vendors = [\\n\\t\"postgresql\",\\n\\t\"sqlite\",\\n]\\n\\n\\ndef _using_signed_storage():\\n\\treturn connection.vendor in signed_integer_vendors\\n\\n\\ndef _signed_to_unsigned_integer(value):\\n\\treturn struct.unpack(\"Q\", struct.pack(\"q\", value))[0]\\n\\n\\ndef _unsigned_to_signed_integer(value):\\n\\treturn struct.unpack(\"q\", struct.pack(\"Q\", value))[0]\\n\\n\\ndef _hex_string_to_unsigned_integer(value):\\n\\treturn int(value, 16)\\n\\n\\ndef _unsigned_integer_to_hex_string(value):\\n\\treturn hex(value).rstrip(\"L\")\\n\\n\\nclass HexadecimalField(forms.CharField):\\n\\t\"\"\"\\n\\tA form field that accepts only hexadecimal numbers\\n\\t\"\"\"\\n\\tdef __init__(self, *args, **kwargs):\\n\\t\\tself.default_validators = [\\n\\t\\t\\tRegexValidator(hex_re, _(\"Enter a valid hexadecimal number\"), \"invalid\")\\n\\t\\t]\\n\\t\\tsuper(HexadecimalField, self).__init__(*args, **kwargs)\\n\\n\\tdef prepare_value(self, value):\\n\\t\\t# converts bigint from db to hex before it is displayed in admin\\n\\t\\tif value and not isinstance(value, str) \\\\\\n\\t\\t\\tand connection.vendor in (\"mysql\", \"sqlite\"):\\n\\t\\t\\tvalue = _unsigned_integer_to_hex_string(value)\\n\\t\\treturn super(forms.CharField, self).prepare_value(value)\\n\\n\\nclass HexIntegerField(models.BigIntegerField):\\n\\t\"\"\"\\n\\tThis field stores a hexadecimal *string* of up to 64 bits as an unsigned integer\\n\\ton *all* backends including postgres.\\n\\n\\tReasoning: Postgres only supports signed bigints. Since we don\\'t care about\\n\\tsignedness, we store it as signed, and cast it to unsigned when we deal with\\n\\tthe actual value (with struct)\\n\\n\\tOn sqlite and mysql, native unsigned bigint types are used. In all cases, the\\n\\tvalue we deal with in python is always in hex.\\n\\t\"\"\"\\n\\n\\tvalidators = [\\n\\t\\tMinValueValidator(UNSIGNED_64BIT_INT_MIN_VALUE),\\n\\t\\tMaxValueValidator(UNSIGNED_64BIT_INT_MAX_VALUE)\\n\\t]\\n\\n\\tdef db_type(self, connection):\\n\\t\\tif \"mysql\" == connection.vendor:\\n\\t\\t\\treturn \"bigint unsigned\"\\n\\t\\telif \"sqlite\" == connection.vendor:\\n\\t\\t\\treturn \"UNSIGNED BIG INT\"\\n\\t\\telse:\\n\\t\\t\\treturn super(HexIntegerField, self).db_type(connection=connection)\\n\\n\\tdef get_prep_value(self, value):\\n\\t\\t\"\"\" Return the integer value to be stored from the hex string \"\"\"\\n\\t\\tif value is None or value == \"\":\\n\\t\\t\\treturn None\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _unsigned_to_signed_integer(value)\\n\\t\\treturn value\\n\\n\\tdef from_db_value(self, value, *args):\\n\\t\\t\"\"\" Return an unsigned int representation from all db backends \"\"\"\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _signed_to_unsigned_integer(value)\\n\\t\\treturn value\\n\\n\\tdef to_python(self, value):\\n\\t\\t\"\"\" Return a str representation of the hexadecimal \"\"\"\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\treturn value\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\treturn _unsigned_integer_to_hex_string(value)\\n\\n\\tdef formfield(self, **kwargs):\\n\\t\\tdefaults = {\"form_class\": HexadecimalField}\\n\\t\\tdefaults.update(kwargs)\\n\\t\\t# yes, that super call is right\\n\\t\\treturn super(models.IntegerField, self).formfield(**defaults)\\n\\n\\tdef run_validators(self, value):\\n\\t\\t# make sure validation is performed on integer value not string value\\n\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\treturn super(models.BigIntegerField, self).run_validators(value)\\n'"}, {"func_args": {"source": "'import re\\nimport struct\\n\\nfrom django import forms\\nfrom django.core.validators import MaxValueValidator, MinValueValidator, RegexValidator\\nfrom django.db import connection, models\\nfrom django.utils.translation import gettext_lazy as _\\n\\n\\n__all__ = [\"HexadecimalField\", \"HexIntegerField\"]\\n\\nUNSIGNED_64BIT_INT_MIN_VALUE = 0\\nUNSIGNED_64BIT_INT_MAX_VALUE = 2 ** 64 - 1\\n\\n\\nhex_re = re.compile(r\"^(([0-9A-f])|(0x[0-9A-f]))+$\")\\nsigned_integer_vendors = [\\n\\t\"postgresql\",\\n\\t\"sqlite\",\\n]\\n\\n\\ndef _using_signed_storage():\\n\\treturn connection.vendor in signed_integer_vendors\\n\\n\\ndef _signed_to_unsigned_integer(value):\\n\\treturn struct.unpack(\"Q\", struct.pack(\"q\", value))[0]\\n\\n\\ndef _unsigned_to_signed_integer(value):\\n\\treturn struct.unpack(\"q\", struct.pack(\"Q\", value))[0]\\n\\n\\ndef _hex_string_to_unsigned_integer(value):\\n\\treturn int(value, 16)\\n\\n\\ndef _unsigned_integer_to_hex_string(value):\\n\\treturn hex(value).rstrip(\"L\")\\n\\n\\nclass HexadecimalField(forms.CharField):\\n\\t\"\"\"\\n\\tA form field that accepts only hexadecimal numbers\\n\\t\"\"\"\\n\\tdef __init__(self, *args, **kwargs):\\n\\t\\tself.default_validators = [\\n\\t\\t\\tRegexValidator(hex_re, _(\"Enter a valid hexadecimal number\"), \"invalid\")\\n\\t\\t]\\n\\t\\tsuper(HexadecimalField, self).__init__(*args, **kwargs)\\n\\n\\tdef prepare_value(self, value):\\n\\t\\t# converts bigint from db to hex before it is displayed in admin\\n\\t\\tif value and not isinstance(value, str) \\\\\\n\\t\\t\\tand connection.vendor in (\"mysql\", \"sqlite\"):\\n\\t\\t\\tvalue = _unsigned_integer_to_hex_string(value)\\n\\t\\treturn super(forms.CharField, self).prepare_value(value)\\n\\n\\nclass HexIntegerField(models.BigIntegerField):\\n\\t\"\"\"\\n\\tThis field stores a hexadecimal *string* of up to 64 bits as an unsigned integer\\n\\ton *all* backends including postgres.\\n\\n\\tReasoning: Postgres only supports signed bigints. Since we don\\'t care about\\n\\tsignedness, we store it as signed, and cast it to unsigned when we deal with\\n\\tthe actual value (with struct)\\n\\n\\tOn sqlite and mysql, native unsigned bigint types are used. In all cases, the\\n\\tvalue we deal with in python is always in hex.\\n\\t\"\"\"\\n\\n\\tvalidators = [\\n\\t\\tMinValueValidator(UNSIGNED_64BIT_INT_MIN_VALUE),\\n\\t\\tMaxValueValidator(UNSIGNED_64BIT_INT_MAX_VALUE)\\n\\t]\\n\\n\\tdef db_type(self, connection):\\n\\t\\tif \"mysql\" == connection.vendor:\\n\\t\\t\\treturn \"bigint unsigned\"\\n\\t\\telif \"sqlite\" == connection.vendor:\\n\\t\\t\\treturn \"UNSIGNED BIG INT\"\\n\\t\\telse:\\n\\t\\t\\treturn super(HexIntegerField, self).db_type(connection=connection)\\n\\n\\tdef get_prep_value(self, value):\\n\\t\\t\"\"\" Return the integer value to be stored from the hex string \"\"\"\\n\\t\\tif value is None or value == \"\":\\n\\t\\t\\treturn None\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _unsigned_to_signed_integer(value)\\n\\t\\treturn value\\n\\n\\tdef from_db_value(self, value, *args):\\n\\t\\t\"\"\" Return an unsigned int representation from all db backends \"\"\"\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _signed_to_unsigned_integer(value)\\n\\t\\treturn value\\n\\n\\tdef to_python(self, value):\\n\\t\\t\"\"\" Return a str representation of the hexadecimal \"\"\"\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\treturn value\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\treturn _unsigned_integer_to_hex_string(value)\\n\\n\\tdef formfield(self, **kwargs):\\n\\t\\tdefaults = {\"form_class\": HexadecimalField}\\n\\t\\tdefaults.update(kwargs)\\n\\t\\t# yes, that super call is right\\n\\t\\treturn super(models.IntegerField, self).formfield(**defaults)\\n\\n\\tdef run_validators(self, value):\\n\\t\\t# make sure validation is performed on integer value not string value\\n\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\treturn super(models.BigIntegerField, self).run_validators(value)\\n'"}, "return_value": "'import re\\nimport struct\\n\\nfrom django import forms\\nfrom django.core.validators import MaxValueValidator, MinValueValidator, RegexValidator\\nfrom django.db import connection, models\\nfrom django.utils.translation import gettext_lazy as _\\n\\n\\n__all__ = [\"HexadecimalField\", \"HexIntegerField\"]\\n\\nUNSIGNED_64BIT_INT_MIN_VALUE = 0\\nUNSIGNED_64BIT_INT_MAX_VALUE = 2 ** 64 - 1\\n\\n\\nhex_re = re.compile(r\"^(([0-9A-f])|(0x[0-9A-f]))+$\")\\nsigned_integer_vendors = [\\n\\t\"postgresql\",\\n\\t\"sqlite\",\\n]\\n\\n\\ndef _using_signed_storage():\\n\\treturn connection.vendor in signed_integer_vendors\\n\\n\\ndef _signed_to_unsigned_integer(value):\\n\\treturn struct.unpack(\"Q\", struct.pack(\"q\", value))[0]\\n\\n\\ndef _unsigned_to_signed_integer(value):\\n\\treturn struct.unpack(\"q\", struct.pack(\"Q\", value))[0]\\n\\n\\ndef _hex_string_to_unsigned_integer(value):\\n\\treturn int(value, 16)\\n\\n\\ndef _unsigned_integer_to_hex_string(value):\\n\\treturn hex(value).rstrip(\"L\")\\n\\n\\nclass HexadecimalField(forms.CharField):\\n\\t\"\"\"\\n\\tA form field that accepts only hexadecimal numbers\\n\\t\"\"\"\\n\\tdef __init__(self, *args, **kwargs):\\n\\t\\tself.default_validators = [\\n\\t\\t\\tRegexValidator(hex_re, _(\"Enter a valid hexadecimal number\"), \"invalid\")\\n\\t\\t]\\n\\t\\tsuper(HexadecimalField, self).__init__(*args, **kwargs)\\n\\n\\tdef prepare_value(self, value):\\n\\t\\t# converts bigint from db to hex before it is displayed in admin\\n\\t\\tif value and not isinstance(value, str) \\\\\\n\\t\\t\\tand connection.vendor in (\"mysql\", \"sqlite\"):\\n\\t\\t\\tvalue = _unsigned_integer_to_hex_string(value)\\n\\t\\treturn super(forms.CharField, self).prepare_value(value)\\n\\n\\nclass HexIntegerField(models.BigIntegerField):\\n\\t\"\"\"\\n\\tThis field stores a hexadecimal *string* of up to 64 bits as an unsigned integer\\n\\ton *all* backends including postgres.\\n\\n\\tReasoning: Postgres only supports signed bigints. Since we don\\'t care about\\n\\tsignedness, we store it as signed, and cast it to unsigned when we deal with\\n\\tthe actual value (with struct)\\n\\n\\tOn sqlite and mysql, native unsigned bigint types are used. In all cases, the\\n\\tvalue we deal with in python is always in hex.\\n\\t\"\"\"\\n\\n\\tvalidators = [\\n\\t\\tMinValueValidator(UNSIGNED_64BIT_INT_MIN_VALUE),\\n\\t\\tMaxValueValidator(UNSIGNED_64BIT_INT_MAX_VALUE)\\n\\t]\\n\\n\\tdef db_type(self, connection):\\n\\t\\tif \"mysql\" == connection.vendor:\\n\\t\\t\\treturn \"bigint unsigned\"\\n\\t\\telif \"sqlite\" == connection.vendor:\\n\\t\\t\\treturn \"UNSIGNED BIG INT\"\\n\\t\\telse:\\n\\t\\t\\treturn super(HexIntegerField, self).db_type(connection=connection)\\n\\n\\tdef get_prep_value(self, value):\\n\\t\\t\"\"\" Return the integer value to be stored from the hex string \"\"\"\\n\\t\\tif value is None or value == \"\":\\n\\t\\t\\treturn None\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _unsigned_to_signed_integer(value)\\n\\t\\treturn value\\n\\n\\tdef from_db_value(self, value, *args):\\n\\t\\t\"\"\" Return an unsigned int representation from all db backends \"\"\"\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _signed_to_unsigned_integer(value)\\n\\t\\treturn value\\n\\n\\tdef to_python(self, value):\\n\\t\\t\"\"\" Return a str representation of the hexadecimal \"\"\"\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\treturn value\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\treturn _unsigned_integer_to_hex_string(value)\\n\\n\\tdef formfield(self, **kwargs):\\n\\t\\tdefaults = {\"form_class\": HexadecimalField}\\n\\t\\tdefaults.update(kwargs)\\n\\t\\t# yes, that super call is right\\n\\t\\treturn super(models.IntegerField, self).formfield(**defaults)\\n\\n\\tdef run_validators(self, value):\\n\\t\\t# make sure validation is performed on integer value not string value\\n\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\treturn super(models.BigIntegerField, self).run_validators(value)\\n'"}, {"func_args": {"source": "'\"\"\"\\nFirebase Cloud Messaging\\nPreviously known as GCM / C2DM\\nDocumentation is available on the Firebase Developer website:\\nhttps://firebase.google.com/docs/cloud-messaging/\\n\"\"\"\\n\\nimport json\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import Request, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import GCMError\\nfrom .models import GCMDevice\\n\\n\\n# Valid keys for FCM messages. Reference:\\n# https://firebase.google.com/docs/cloud-messaging/http-server-ref\\nFCM_TARGETS_KEYS = [\\n\\t\"to\", \"condition\", \"notification_key\"\\n]\\nFCM_OPTIONS_KEYS = [\\n\\t\"collapse_key\", \"priority\", \"content_available\", \"delay_while_idle\", \"time_to_live\",\\n\\t\"restricted_package_name\", \"dry_run\", \"mutable_content\"\\n]\\nFCM_NOTIFICATIONS_PAYLOAD_KEYS = [\\n\\t\"title\", \"body\", \"icon\", \"image\", \"sound\", \"badge\", \"color\", \"tag\", \"click_action\",\\n\\t\"body_loc_key\", \"body_loc_args\", \"title_loc_key\", \"title_loc_args\", \"android_channel_id\"\\n]\\n\\ndef _chunks(l, n):\\n\\t\"\"\"\\n\\tYield successive chunks from list \\\\a l with a minimum size \\\\a n\\n\\t\"\"\"\\n\\tfor i in range(0, len(l), n):\\n\\t\\tyield l[i:i + n]\\n\\n\\ndef _gcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_gcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"GCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"GCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _fcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_fcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"FCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"FCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _cm_handle_response(registration_ids, response_data, cloud_type, application_id=None):\\n\\tresponse = response_data\\n\\tif response.get(\"failure\") or response.get(\"canonical_ids\"):\\n\\t\\tids_to_remove, old_new_ids = [], []\\n\\t\\tthrow_error = False\\n\\t\\tfor index, result in enumerate(response[\"results\"]):\\n\\t\\t\\terror = result.get(\"error\")\\n\\t\\t\\tif error:\\n\\t\\t\\t\\t# https://firebase.google.com/docs/cloud-messaging/http-server-ref#error-codes\\n\\t\\t\\t\\t# If error is NotRegistered or InvalidRegistration, then we will deactivate devices\\n\\t\\t\\t\\t# because this registration ID is no more valid and can\\'t be used to send messages,\\n\\t\\t\\t\\t# otherwise raise error\\n\\t\\t\\t\\tif error in (\"NotRegistered\", \"InvalidRegistration\"):\\n\\t\\t\\t\\t\\tids_to_remove.append(registration_ids[index])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tthrow_error = True\\n\\t\\t\\tresult[\"original_registration_id\"] = registration_ids[index]\\n\\t\\t\\t# If registration_id is set, replace the original ID with the new value (canonical ID)\\n\\t\\t\\t# in your server database. Note that the original ID is not part of the result, you need\\n\\t\\t\\t# to obtain it from the list of registration_ids in the request (using the same index).\\n\\t\\t\\tnew_id = result.get(\"registration_id\")\\n\\t\\t\\tif new_id:\\n\\t\\t\\t\\told_new_ids.append((registration_ids[index], new_id))\\n\\n\\t\\tif ids_to_remove:\\n\\t\\t\\tremoved = GCMDevice.objects.filter(\\n\\t\\t\\t\\tregistration_id__in=ids_to_remove, cloud_message_type=cloud_type\\n\\t\\t\\t)\\n\\t\\t\\tremoved.update(active=False)\\n\\n\\t\\tfor old_id, new_id in old_new_ids:\\n\\t\\t\\t_cm_handle_canonical_id(new_id, old_id, cloud_type)\\n\\n\\t\\tif throw_error:\\n\\t\\t\\traise GCMError(response)\\n\\treturn response\\n\\n\\ndef _cm_send_request(\\n\\tregistration_ids, data, cloud_type=\"GCM\", application_id=None,\\n\\tuse_fcm_notifications=True, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a FCM or GCM notification to one or more registration_ids as json data.\\n\\tThe registration_ids needs to be a list.\\n\\t\"\"\"\\n\\n\\tpayload = {\"registration_ids\": registration_ids} if registration_ids else {}\\n\\n\\tdata = data.copy()\\n\\n\\t# If using FCM, optionally autodiscovers notification related keys\\n\\t# https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages\\n\\tif cloud_type == \"FCM\" and use_fcm_notifications:\\n\\t\\tnotification_payload = {}\\n\\t\\tif \"message\" in data:\\n\\t\\t\\tnotification_payload[\"body\"] = data.pop(\"message\", None)\\n\\n\\t\\tfor key in FCM_NOTIFICATIONS_PAYLOAD_KEYS:\\n\\t\\t\\tvalue_from_extra = data.pop(key, None)\\n\\t\\t\\tif value_from_extra:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_extra\\n\\t\\t\\tvalue_from_kwargs = kwargs.pop(key, None)\\n\\t\\t\\tif value_from_kwargs:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_kwargs\\n\\t\\tif notification_payload:\\n\\t\\t\\tpayload[\"notification\"] = notification_payload\\n\\n\\tif data:\\n\\t\\tpayload[\"data\"] = data\\n\\n\\t# Attach any additional non falsy keyword args (targets, options)\\n\\t# See ref : https://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\tpayload.update({\\n\\t\\tk: v for k, v in kwargs.items() if v and (k in FCM_TARGETS_KEYS or k in FCM_OPTIONS_KEYS)\\n\\t})\\n\\n\\t# Sort the keys for deterministic output (useful for tests)\\n\\tjson_payload = json.dumps(payload, separators=(\",\", \":\"), sort_keys=True).encode(\"utf-8\")\\n\\n\\t# Sends requests and handles the response\\n\\tif cloud_type == \"GCM\":\\n\\t\\tresponse = json.loads(_gcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telif cloud_type == \"FCM\":\\n\\t\\tresponse = json.loads(_fcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\treturn _cm_handle_response(registration_ids, response, cloud_type, application_id)\\n\\n\\ndef _cm_handle_canonical_id(canonical_id, current_id, cloud_type):\\n\\t\"\"\"\\n\\tHandle situation when FCM server response contains canonical ID\\n\\t\"\"\"\\n\\tdevices = GCMDevice.objects.filter(cloud_message_type=cloud_type)\\n\\tif devices.filter(registration_id=canonical_id, active=True).exists():\\n\\t\\tdevices.filter(registration_id=current_id).update(active=False)\\n\\telse:\\n\\t\\tdevices.filter(registration_id=current_id).update(registration_id=canonical_id)\\n\\n\\ndef send_message(registration_ids, data, cloud_type, application_id=None, **kwargs):\\n\\t\"\"\"\\n\\tSends a FCM (or GCM) notification to one or more registration_ids. The registration_ids\\n\\tcan be a list or a single string. This will send the notification as json data.\\n\\n\\tA reference of extra keyword arguments sent to the server is available here:\\n\\thttps://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\t\"\"\"\\n\\tif cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\tmax_recipients = get_manager().get_max_recipients(cloud_type, application_id)\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\n\\t# Checks for valid recipient\\n\\tif registration_ids is None and \"/topics/\" not in kwargs.get(\"to\", \"\"):\\n\\t\\treturn\\n\\n\\t# Bundles the registration_ids in an list if only one is sent\\n\\tif not isinstance(registration_ids, list):\\n\\t\\tregistration_ids = [registration_ids] if registration_ids else None\\n\\n\\t# FCM only allows up to 1000 reg ids per bulk message\\n\\t# https://firebase.google.com/docs/cloud-messaging/server#http-request\\n\\tif registration_ids:\\n\\t\\tret = []\\n\\t\\tfor chunk in _chunks(registration_ids, max_recipients):\\n\\t\\t\\tret.append(_cm_send_request(\\n\\t\\t\\t\\tchunk, data, cloud_type=cloud_type, application_id=application_id, **kwargs\\n\\t\\t\\t))\\n\\t\\treturn ret[0] if len(ret) == 1 else ret\\n\\telse:\\n\\t\\treturn _cm_send_request(None, data, cloud_type=cloud_type, **kwargs)\\n\\n\\nsend_bulk_message = send_message\\n'"}, "return_value": "'\"\"\"\\nFirebase Cloud Messaging\\nPreviously known as GCM / C2DM\\nDocumentation is available on the Firebase Developer website:\\nhttps://firebase.google.com/docs/cloud-messaging/\\n\"\"\"\\n\\nimport json\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import Request, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import GCMError\\nfrom .models import GCMDevice\\n\\n\\n# Valid keys for FCM messages. Reference:\\n# https://firebase.google.com/docs/cloud-messaging/http-server-ref\\nFCM_TARGETS_KEYS = [\\n\\t\"to\", \"condition\", \"notification_key\"\\n]\\nFCM_OPTIONS_KEYS = [\\n\\t\"collapse_key\", \"priority\", \"content_available\", \"delay_while_idle\", \"time_to_live\",\\n\\t\"restricted_package_name\", \"dry_run\", \"mutable_content\"\\n]\\nFCM_NOTIFICATIONS_PAYLOAD_KEYS = [\\n\\t\"title\", \"body\", \"icon\", \"image\", \"sound\", \"badge\", \"color\", \"tag\", \"click_action\",\\n\\t\"body_loc_key\", \"body_loc_args\", \"title_loc_key\", \"title_loc_args\", \"android_channel_id\"\\n]\\n\\ndef _chunks(l, n):\\n\\t\"\"\"\\n\\tYield successive chunks from list \\\\a l with a minimum size \\\\a n\\n\\t\"\"\"\\n\\tfor i in range(0, len(l), n):\\n\\t\\tyield l[i:i + n]\\n\\n\\ndef _gcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_gcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"GCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"GCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _fcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_fcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"FCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"FCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _cm_handle_response(registration_ids, response_data, cloud_type, application_id=None):\\n\\tresponse = response_data\\n\\tif response.get(\"failure\") or response.get(\"canonical_ids\"):\\n\\t\\tids_to_remove, old_new_ids = [], []\\n\\t\\tthrow_error = False\\n\\t\\tfor index, result in enumerate(response[\"results\"]):\\n\\t\\t\\terror = result.get(\"error\")\\n\\t\\t\\tif error:\\n\\t\\t\\t\\t# https://firebase.google.com/docs/cloud-messaging/http-server-ref#error-codes\\n\\t\\t\\t\\t# If error is NotRegistered or InvalidRegistration, then we will deactivate devices\\n\\t\\t\\t\\t# because this registration ID is no more valid and can\\'t be used to send messages,\\n\\t\\t\\t\\t# otherwise raise error\\n\\t\\t\\t\\tif error in (\"NotRegistered\", \"InvalidRegistration\"):\\n\\t\\t\\t\\t\\tids_to_remove.append(registration_ids[index])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tthrow_error = True\\n\\t\\t\\tresult[\"original_registration_id\"] = registration_ids[index]\\n\\t\\t\\t# If registration_id is set, replace the original ID with the new value (canonical ID)\\n\\t\\t\\t# in your server database. Note that the original ID is not part of the result, you need\\n\\t\\t\\t# to obtain it from the list of registration_ids in the request (using the same index).\\n\\t\\t\\tnew_id = result.get(\"registration_id\")\\n\\t\\t\\tif new_id:\\n\\t\\t\\t\\told_new_ids.append((registration_ids[index], new_id))\\n\\n\\t\\tif ids_to_remove:\\n\\t\\t\\tremoved = GCMDevice.objects.filter(\\n\\t\\t\\t\\tregistration_id__in=ids_to_remove, cloud_message_type=cloud_type\\n\\t\\t\\t)\\n\\t\\t\\tremoved.update(active=False)\\n\\n\\t\\tfor old_id, new_id in old_new_ids:\\n\\t\\t\\t_cm_handle_canonical_id(new_id, old_id, cloud_type)\\n\\n\\t\\tif throw_error:\\n\\t\\t\\traise GCMError(response)\\n\\treturn response\\n\\n\\ndef _cm_send_request(\\n\\tregistration_ids, data, cloud_type=\"GCM\", application_id=None,\\n\\tuse_fcm_notifications=True, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a FCM or GCM notification to one or more registration_ids as json data.\\n\\tThe registration_ids needs to be a list.\\n\\t\"\"\"\\n\\n\\tpayload = {\"registration_ids\": registration_ids} if registration_ids else {}\\n\\n\\tdata = data.copy()\\n\\n\\t# If using FCM, optionally autodiscovers notification related keys\\n\\t# https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages\\n\\tif cloud_type == \"FCM\" and use_fcm_notifications:\\n\\t\\tnotification_payload = {}\\n\\t\\tif \"message\" in data:\\n\\t\\t\\tnotification_payload[\"body\"] = data.pop(\"message\", None)\\n\\n\\t\\tfor key in FCM_NOTIFICATIONS_PAYLOAD_KEYS:\\n\\t\\t\\tvalue_from_extra = data.pop(key, None)\\n\\t\\t\\tif value_from_extra:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_extra\\n\\t\\t\\tvalue_from_kwargs = kwargs.pop(key, None)\\n\\t\\t\\tif value_from_kwargs:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_kwargs\\n\\t\\tif notification_payload:\\n\\t\\t\\tpayload[\"notification\"] = notification_payload\\n\\n\\tif data:\\n\\t\\tpayload[\"data\"] = data\\n\\n\\t# Attach any additional non falsy keyword args (targets, options)\\n\\t# See ref : https://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\tpayload.update({\\n\\t\\tk: v for k, v in kwargs.items() if v and (k in FCM_TARGETS_KEYS or k in FCM_OPTIONS_KEYS)\\n\\t})\\n\\n\\t# Sort the keys for deterministic output (useful for tests)\\n\\tjson_payload = json.dumps(payload, separators=(\",\", \":\"), sort_keys=True).encode(\"utf-8\")\\n\\n\\t# Sends requests and handles the response\\n\\tif cloud_type == \"GCM\":\\n\\t\\tresponse = json.loads(_gcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telif cloud_type == \"FCM\":\\n\\t\\tresponse = json.loads(_fcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\treturn _cm_handle_response(registration_ids, response, cloud_type, application_id)\\n\\n\\ndef _cm_handle_canonical_id(canonical_id, current_id, cloud_type):\\n\\t\"\"\"\\n\\tHandle situation when FCM server response contains canonical ID\\n\\t\"\"\"\\n\\tdevices = GCMDevice.objects.filter(cloud_message_type=cloud_type)\\n\\tif devices.filter(registration_id=canonical_id, active=True).exists():\\n\\t\\tdevices.filter(registration_id=current_id).update(active=False)\\n\\telse:\\n\\t\\tdevices.filter(registration_id=current_id).update(registration_id=canonical_id)\\n\\n\\ndef send_message(registration_ids, data, cloud_type, application_id=None, **kwargs):\\n\\t\"\"\"\\n\\tSends a FCM (or GCM) notification to one or more registration_ids. The registration_ids\\n\\tcan be a list or a single string. This will send the notification as json data.\\n\\n\\tA reference of extra keyword arguments sent to the server is available here:\\n\\thttps://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\t\"\"\"\\n\\tif cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\tmax_recipients = get_manager().get_max_recipients(cloud_type, application_id)\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\n\\t# Checks for valid recipient\\n\\tif registration_ids is None and \"/topics/\" not in kwargs.get(\"to\", \"\"):\\n\\t\\treturn\\n\\n\\t# Bundles the registration_ids in an list if only one is sent\\n\\tif not isinstance(registration_ids, list):\\n\\t\\tregistration_ids = [registration_ids] if registration_ids else None\\n\\n\\t# FCM only allows up to 1000 reg ids per bulk message\\n\\t# https://firebase.google.com/docs/cloud-messaging/server#http-request\\n\\tif registration_ids:\\n\\t\\tret = []\\n\\t\\tfor chunk in _chunks(registration_ids, max_recipients):\\n\\t\\t\\tret.append(_cm_send_request(\\n\\t\\t\\t\\tchunk, data, cloud_type=cloud_type, application_id=application_id, **kwargs\\n\\t\\t\\t))\\n\\t\\treturn ret[0] if len(ret) == 1 else ret\\n\\telse:\\n\\t\\treturn _cm_send_request(None, data, cloud_type=cloud_type, **kwargs)\\n\\n\\nsend_bulk_message = send_message\\n'"}, {"func_args": {"source": "'\"\"\"\\nFirebase Cloud Messaging\\nPreviously known as GCM / C2DM\\nDocumentation is available on the Firebase Developer website:\\nhttps://firebase.google.com/docs/cloud-messaging/\\n\"\"\"\\n\\nimport json\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import Request, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import GCMError\\nfrom .models import GCMDevice\\n\\n\\n# Valid keys for FCM messages. Reference:\\n# https://firebase.google.com/docs/cloud-messaging/http-server-ref\\nFCM_TARGETS_KEYS = [\\n\\t\"to\", \"condition\", \"notification_key\"\\n]\\nFCM_OPTIONS_KEYS = [\\n\\t\"collapse_key\", \"priority\", \"content_available\", \"delay_while_idle\", \"time_to_live\",\\n\\t\"restricted_package_name\", \"dry_run\", \"mutable_content\"\\n]\\nFCM_NOTIFICATIONS_PAYLOAD_KEYS = [\\n\\t\"title\", \"body\", \"icon\", \"image\", \"sound\", \"badge\", \"color\", \"tag\", \"click_action\",\\n\\t\"body_loc_key\", \"body_loc_args\", \"title_loc_key\", \"title_loc_args\", \"android_channel_id\"\\n]\\n\\ndef _chunks(l, n):\\n\\t\"\"\"\\n\\tYield successive chunks from list \\\\a l with a minimum size \\\\a n\\n\\t\"\"\"\\n\\tfor i in range(0, len(l), n):\\n\\t\\tyield l[i:i + n]\\n\\n\\ndef _gcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_gcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"GCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"GCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _fcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_fcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"FCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"FCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _cm_handle_response(registration_ids, response_data, cloud_type, application_id=None):\\n\\tresponse = response_data\\n\\tif response.get(\"failure\") or response.get(\"canonical_ids\"):\\n\\t\\tids_to_remove, old_new_ids = [], []\\n\\t\\tthrow_error = False\\n\\t\\tfor index, result in enumerate(response[\"results\"]):\\n\\t\\t\\terror = result.get(\"error\")\\n\\t\\t\\tif error:\\n\\t\\t\\t\\t# https://firebase.google.com/docs/cloud-messaging/http-server-ref#error-codes\\n\\t\\t\\t\\t# If error is NotRegistered or InvalidRegistration, then we will deactivate devices\\n\\t\\t\\t\\t# because this registration ID is no more valid and can\\'t be used to send messages,\\n\\t\\t\\t\\t# otherwise raise error\\n\\t\\t\\t\\tif error in (\"NotRegistered\", \"InvalidRegistration\"):\\n\\t\\t\\t\\t\\tids_to_remove.append(registration_ids[index])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tthrow_error = True\\n\\t\\t\\tresult[\"original_registration_id\"] = registration_ids[index]\\n\\t\\t\\t# If registration_id is set, replace the original ID with the new value (canonical ID)\\n\\t\\t\\t# in your server database. Note that the original ID is not part of the result, you need\\n\\t\\t\\t# to obtain it from the list of registration_ids in the request (using the same index).\\n\\t\\t\\tnew_id = result.get(\"registration_id\")\\n\\t\\t\\tif new_id:\\n\\t\\t\\t\\told_new_ids.append((registration_ids[index], new_id))\\n\\n\\t\\tif ids_to_remove:\\n\\t\\t\\tremoved = GCMDevice.objects.filter(\\n\\t\\t\\t\\tregistration_id__in=ids_to_remove, cloud_message_type=cloud_type\\n\\t\\t\\t)\\n\\t\\t\\tremoved.update(active=False)\\n\\n\\t\\tfor old_id, new_id in old_new_ids:\\n\\t\\t\\t_cm_handle_canonical_id(new_id, old_id, cloud_type)\\n\\n\\t\\tif throw_error:\\n\\t\\t\\traise GCMError(response)\\n\\treturn response\\n\\n\\ndef _cm_send_request(\\n\\tregistration_ids, data, cloud_type=\"GCM\", application_id=None,\\n\\tuse_fcm_notifications=True, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a FCM or GCM notification to one or more registration_ids as json data.\\n\\tThe registration_ids needs to be a list.\\n\\t\"\"\"\\n\\n\\tpayload = {\"registration_ids\": registration_ids} if registration_ids else {}\\n\\n\\tdata = data.copy()\\n\\n\\t# If using FCM, optionally autodiscovers notification related keys\\n\\t# https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages\\n\\tif cloud_type == \"FCM\" and use_fcm_notifications:\\n\\t\\tnotification_payload = {}\\n\\t\\tif \"message\" in data:\\n\\t\\t\\tnotification_payload[\"body\"] = data.pop(\"message\", None)\\n\\n\\t\\tfor key in FCM_NOTIFICATIONS_PAYLOAD_KEYS:\\n\\t\\t\\tvalue_from_extra = data.pop(key, None)\\n\\t\\t\\tif value_from_extra:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_extra\\n\\t\\t\\tvalue_from_kwargs = kwargs.pop(key, None)\\n\\t\\t\\tif value_from_kwargs:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_kwargs\\n\\t\\tif notification_payload:\\n\\t\\t\\tpayload[\"notification\"] = notification_payload\\n\\n\\tif data:\\n\\t\\tpayload[\"data\"] = data\\n\\n\\t# Attach any additional non falsy keyword args (targets, options)\\n\\t# See ref : https://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\tpayload.update({\\n\\t\\tk: v for k, v in kwargs.items() if v and (k in FCM_TARGETS_KEYS or k in FCM_OPTIONS_KEYS)\\n\\t})\\n\\n\\t# Sort the keys for deterministic output (useful for tests)\\n\\tjson_payload = json.dumps(payload, separators=(\",\", \":\"), sort_keys=True).encode(\"utf-8\")\\n\\n\\t# Sends requests and handles the response\\n\\tif cloud_type == \"GCM\":\\n\\t\\tresponse = json.loads(_gcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telif cloud_type == \"FCM\":\\n\\t\\tresponse = json.loads(_fcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\treturn _cm_handle_response(registration_ids, response, cloud_type, application_id)\\n\\n\\ndef _cm_handle_canonical_id(canonical_id, current_id, cloud_type):\\n\\t\"\"\"\\n\\tHandle situation when FCM server response contains canonical ID\\n\\t\"\"\"\\n\\tdevices = GCMDevice.objects.filter(cloud_message_type=cloud_type)\\n\\tif devices.filter(registration_id=canonical_id, active=True).exists():\\n\\t\\tdevices.filter(registration_id=current_id).update(active=False)\\n\\telse:\\n\\t\\tdevices.filter(registration_id=current_id).update(registration_id=canonical_id)\\n\\n\\ndef send_message(registration_ids, data, cloud_type, application_id=None, **kwargs):\\n\\t\"\"\"\\n\\tSends a FCM (or GCM) notification to one or more registration_ids. The registration_ids\\n\\tcan be a list or a single string. This will send the notification as json data.\\n\\n\\tA reference of extra keyword arguments sent to the server is available here:\\n\\thttps://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\t\"\"\"\\n\\tif cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\tmax_recipients = get_manager().get_max_recipients(cloud_type, application_id)\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\n\\t# Checks for valid recipient\\n\\tif registration_ids is None and \"/topics/\" not in kwargs.get(\"to\", \"\"):\\n\\t\\treturn\\n\\n\\t# Bundles the registration_ids in an list if only one is sent\\n\\tif not isinstance(registration_ids, list):\\n\\t\\tregistration_ids = [registration_ids] if registration_ids else None\\n\\n\\t# FCM only allows up to 1000 reg ids per bulk message\\n\\t# https://firebase.google.com/docs/cloud-messaging/server#http-request\\n\\tif registration_ids:\\n\\t\\tret = []\\n\\t\\tfor chunk in _chunks(registration_ids, max_recipients):\\n\\t\\t\\tret.append(_cm_send_request(\\n\\t\\t\\t\\tchunk, data, cloud_type=cloud_type, application_id=application_id, **kwargs\\n\\t\\t\\t))\\n\\t\\treturn ret[0] if len(ret) == 1 else ret\\n\\telse:\\n\\t\\treturn _cm_send_request(None, data, cloud_type=cloud_type, **kwargs)\\n\\n\\nsend_bulk_message = send_message\\n'"}, "return_value": "'\"\"\"\\nFirebase Cloud Messaging\\nPreviously known as GCM / C2DM\\nDocumentation is available on the Firebase Developer website:\\nhttps://firebase.google.com/docs/cloud-messaging/\\n\"\"\"\\n\\nimport json\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import Request, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import GCMError\\nfrom .models import GCMDevice\\n\\n\\n# Valid keys for FCM messages. Reference:\\n# https://firebase.google.com/docs/cloud-messaging/http-server-ref\\nFCM_TARGETS_KEYS = [\\n\\t\"to\", \"condition\", \"notification_key\"\\n]\\nFCM_OPTIONS_KEYS = [\\n\\t\"collapse_key\", \"priority\", \"content_available\", \"delay_while_idle\", \"time_to_live\",\\n\\t\"restricted_package_name\", \"dry_run\", \"mutable_content\"\\n]\\nFCM_NOTIFICATIONS_PAYLOAD_KEYS = [\\n\\t\"title\", \"body\", \"icon\", \"image\", \"sound\", \"badge\", \"color\", \"tag\", \"click_action\",\\n\\t\"body_loc_key\", \"body_loc_args\", \"title_loc_key\", \"title_loc_args\", \"android_channel_id\"\\n]\\n\\ndef _chunks(l, n):\\n\\t\"\"\"\\n\\tYield successive chunks from list \\\\a l with a minimum size \\\\a n\\n\\t\"\"\"\\n\\tfor i in range(0, len(l), n):\\n\\t\\tyield l[i:i + n]\\n\\n\\ndef _gcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_gcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"GCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"GCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _fcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_fcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"FCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"FCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _cm_handle_response(registration_ids, response_data, cloud_type, application_id=None):\\n\\tresponse = response_data\\n\\tif response.get(\"failure\") or response.get(\"canonical_ids\"):\\n\\t\\tids_to_remove, old_new_ids = [], []\\n\\t\\tthrow_error = False\\n\\t\\tfor index, result in enumerate(response[\"results\"]):\\n\\t\\t\\terror = result.get(\"error\")\\n\\t\\t\\tif error:\\n\\t\\t\\t\\t# https://firebase.google.com/docs/cloud-messaging/http-server-ref#error-codes\\n\\t\\t\\t\\t# If error is NotRegistered or InvalidRegistration, then we will deactivate devices\\n\\t\\t\\t\\t# because this registration ID is no more valid and can\\'t be used to send messages,\\n\\t\\t\\t\\t# otherwise raise error\\n\\t\\t\\t\\tif error in (\"NotRegistered\", \"InvalidRegistration\"):\\n\\t\\t\\t\\t\\tids_to_remove.append(registration_ids[index])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tthrow_error = True\\n\\t\\t\\tresult[\"original_registration_id\"] = registration_ids[index]\\n\\t\\t\\t# If registration_id is set, replace the original ID with the new value (canonical ID)\\n\\t\\t\\t# in your server database. Note that the original ID is not part of the result, you need\\n\\t\\t\\t# to obtain it from the list of registration_ids in the request (using the same index).\\n\\t\\t\\tnew_id = result.get(\"registration_id\")\\n\\t\\t\\tif new_id:\\n\\t\\t\\t\\told_new_ids.append((registration_ids[index], new_id))\\n\\n\\t\\tif ids_to_remove:\\n\\t\\t\\tremoved = GCMDevice.objects.filter(\\n\\t\\t\\t\\tregistration_id__in=ids_to_remove, cloud_message_type=cloud_type\\n\\t\\t\\t)\\n\\t\\t\\tremoved.update(active=False)\\n\\n\\t\\tfor old_id, new_id in old_new_ids:\\n\\t\\t\\t_cm_handle_canonical_id(new_id, old_id, cloud_type)\\n\\n\\t\\tif throw_error:\\n\\t\\t\\traise GCMError(response)\\n\\treturn response\\n\\n\\ndef _cm_send_request(\\n\\tregistration_ids, data, cloud_type=\"GCM\", application_id=None,\\n\\tuse_fcm_notifications=True, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a FCM or GCM notification to one or more registration_ids as json data.\\n\\tThe registration_ids needs to be a list.\\n\\t\"\"\"\\n\\n\\tpayload = {\"registration_ids\": registration_ids} if registration_ids else {}\\n\\n\\tdata = data.copy()\\n\\n\\t# If using FCM, optionally autodiscovers notification related keys\\n\\t# https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages\\n\\tif cloud_type == \"FCM\" and use_fcm_notifications:\\n\\t\\tnotification_payload = {}\\n\\t\\tif \"message\" in data:\\n\\t\\t\\tnotification_payload[\"body\"] = data.pop(\"message\", None)\\n\\n\\t\\tfor key in FCM_NOTIFICATIONS_PAYLOAD_KEYS:\\n\\t\\t\\tvalue_from_extra = data.pop(key, None)\\n\\t\\t\\tif value_from_extra:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_extra\\n\\t\\t\\tvalue_from_kwargs = kwargs.pop(key, None)\\n\\t\\t\\tif value_from_kwargs:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_kwargs\\n\\t\\tif notification_payload:\\n\\t\\t\\tpayload[\"notification\"] = notification_payload\\n\\n\\tif data:\\n\\t\\tpayload[\"data\"] = data\\n\\n\\t# Attach any additional non falsy keyword args (targets, options)\\n\\t# See ref : https://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\tpayload.update({\\n\\t\\tk: v for k, v in kwargs.items() if v and (k in FCM_TARGETS_KEYS or k in FCM_OPTIONS_KEYS)\\n\\t})\\n\\n\\t# Sort the keys for deterministic output (useful for tests)\\n\\tjson_payload = json.dumps(payload, separators=(\",\", \":\"), sort_keys=True).encode(\"utf-8\")\\n\\n\\t# Sends requests and handles the response\\n\\tif cloud_type == \"GCM\":\\n\\t\\tresponse = json.loads(_gcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telif cloud_type == \"FCM\":\\n\\t\\tresponse = json.loads(_fcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\treturn _cm_handle_response(registration_ids, response, cloud_type, application_id)\\n\\n\\ndef _cm_handle_canonical_id(canonical_id, current_id, cloud_type):\\n\\t\"\"\"\\n\\tHandle situation when FCM server response contains canonical ID\\n\\t\"\"\"\\n\\tdevices = GCMDevice.objects.filter(cloud_message_type=cloud_type)\\n\\tif devices.filter(registration_id=canonical_id, active=True).exists():\\n\\t\\tdevices.filter(registration_id=current_id).update(active=False)\\n\\telse:\\n\\t\\tdevices.filter(registration_id=current_id).update(registration_id=canonical_id)\\n\\n\\ndef send_message(registration_ids, data, cloud_type, application_id=None, **kwargs):\\n\\t\"\"\"\\n\\tSends a FCM (or GCM) notification to one or more registration_ids. The registration_ids\\n\\tcan be a list or a single string. This will send the notification as json data.\\n\\n\\tA reference of extra keyword arguments sent to the server is available here:\\n\\thttps://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\t\"\"\"\\n\\tif cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\tmax_recipients = get_manager().get_max_recipients(cloud_type, application_id)\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\n\\t# Checks for valid recipient\\n\\tif registration_ids is None and \"/topics/\" not in kwargs.get(\"to\", \"\"):\\n\\t\\treturn\\n\\n\\t# Bundles the registration_ids in an list if only one is sent\\n\\tif not isinstance(registration_ids, list):\\n\\t\\tregistration_ids = [registration_ids] if registration_ids else None\\n\\n\\t# FCM only allows up to 1000 reg ids per bulk message\\n\\t# https://firebase.google.com/docs/cloud-messaging/server#http-request\\n\\tif registration_ids:\\n\\t\\tret = []\\n\\t\\tfor chunk in _chunks(registration_ids, max_recipients):\\n\\t\\t\\tret.append(_cm_send_request(\\n\\t\\t\\t\\tchunk, data, cloud_type=cloud_type, application_id=application_id, **kwargs\\n\\t\\t\\t))\\n\\t\\treturn ret[0] if len(ret) == 1 else ret\\n\\telse:\\n\\t\\treturn _cm_send_request(None, data, cloud_type=cloud_type, **kwargs)\\n\\n\\nsend_bulk_message = send_message\\n'"}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\nimport push_notifications.fields\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='APNSDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', models.UUIDField(help_text='UDID / UIDevice.identifierForVendor()', max_length=32, null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.CharField(unique=True, max_length=64, verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'APNS device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n        migrations.CreateModel(\\n            name='GCMDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', push_notifications.fields.HexIntegerField(help_text='ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)', null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'GCM device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\nimport push_notifications.fields\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='APNSDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', models.UUIDField(help_text='UDID / UIDevice.identifierForVendor()', max_length=32, null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.CharField(unique=True, max_length=64, verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'APNS device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n        migrations.CreateModel(\\n            name='GCMDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', push_notifications.fields.HexIntegerField(help_text='ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)', null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'GCM device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\nimport push_notifications.fields\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='APNSDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', models.UUIDField(help_text='UDID / UIDevice.identifierForVendor()', max_length=32, null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.CharField(unique=True, max_length=64, verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'APNS device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n        migrations.CreateModel(\\n            name='GCMDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', push_notifications.fields.HexIntegerField(help_text='ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)', null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'GCM device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\nimport push_notifications.fields\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='APNSDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', models.UUIDField(help_text='UDID / UIDevice.identifierForVendor()', max_length=32, null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.CharField(unique=True, max_length=64, verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'APNS device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n        migrations.CreateModel(\\n            name='GCMDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', push_notifications.fields.HexIntegerField(help_text='ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)', null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'GCM device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.1 on 2016-01-06 08:50\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0001_initial'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=True, verbose_name='Registration ID'),\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\n# Generated by Django 1.9.1 on 2016-01-06 08:50\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0001_initial'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=True, verbose_name='Registration ID'),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.1 on 2016-01-06 08:50\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0001_initial'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=True, verbose_name='Registration ID'),\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\n# Generated by Django 1.9.1 on 2016-01-06 08:50\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0001_initial'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=True, verbose_name='Registration ID'),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nimport django.db.models.deletion\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0002_auto_20160106_0850'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WNSDevice',\\n            fields=[\\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\\n                ('name', models.CharField(blank=True, max_length=255, null=True, verbose_name='Name')),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, null=True, verbose_name='Creation date')),\\n                ('device_id', models.UUIDField(blank=True, db_index=True, help_text='GUID()', null=True, verbose_name='Device ID')),\\n                ('registration_id', models.TextField(verbose_name='Notification URI')),\\n                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\\n            ],\\n            options={\\n                'verbose_name': 'WNS device',\\n            },\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nimport django.db.models.deletion\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0002_auto_20160106_0850'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WNSDevice',\\n            fields=[\\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\\n                ('name', models.CharField(blank=True, max_length=255, null=True, verbose_name='Name')),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, null=True, verbose_name='Creation date')),\\n                ('device_id', models.UUIDField(blank=True, db_index=True, help_text='GUID()', null=True, verbose_name='Device ID')),\\n                ('registration_id', models.TextField(verbose_name='Notification URI')),\\n                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\\n            ],\\n            options={\\n                'verbose_name': 'WNS device',\\n            },\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nimport django.db.models.deletion\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0002_auto_20160106_0850'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WNSDevice',\\n            fields=[\\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\\n                ('name', models.CharField(blank=True, max_length=255, null=True, verbose_name='Name')),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, null=True, verbose_name='Creation date')),\\n                ('device_id', models.UUIDField(blank=True, db_index=True, help_text='GUID()', null=True, verbose_name='Device ID')),\\n                ('registration_id', models.TextField(verbose_name='Notification URI')),\\n                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\\n            ],\\n            options={\\n                'verbose_name': 'WNS device',\\n            },\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nimport django.db.models.deletion\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0002_auto_20160106_0850'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WNSDevice',\\n            fields=[\\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\\n                ('name', models.CharField(blank=True, max_length=255, null=True, verbose_name='Name')),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, null=True, verbose_name='Creation date')),\\n                ('device_id', models.UUIDField(blank=True, db_index=True, help_text='GUID()', null=True, verbose_name='Device ID')),\\n                ('registration_id', models.TextField(verbose_name='Notification URI')),\\n                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\\n            ],\\n            options={\\n                'verbose_name': 'WNS device',\\n            },\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n\\tdependencies = [\\n\\t\\tmigrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n\\t\\t('push_notifications', '0003_wnsdevice'),\\n\\t]\\n\\n\\toperations = [\\n\\t\\tmigrations.AddField(\\n\\t\\t\\tmodel_name='gcmdevice',\\n\\t\\t\\tname='cloud_message_type',\\n\\t\\t\\tfield=models.CharField(choices=[('FCM', 'Firebase Cloud Message'), ('GCM', 'Google Cloud Message')], default='GCM', help_text='You should choose FCM or GCM', max_length=3, verbose_name='Cloud Message Type')\\n\\t\\t),\\n\\t]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n\\tdependencies = [\\n\\t\\tmigrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n\\t\\t('push_notifications', '0003_wnsdevice'),\\n\\t]\\n\\n\\toperations = [\\n\\t\\tmigrations.AddField(\\n\\t\\t\\tmodel_name='gcmdevice',\\n\\t\\t\\tname='cloud_message_type',\\n\\t\\t\\tfield=models.CharField(choices=[('FCM', 'Firebase Cloud Message'), ('GCM', 'Google Cloud Message')], default='GCM', help_text='You should choose FCM or GCM', max_length=3, verbose_name='Cloud Message Type')\\n\\t\\t),\\n\\t]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n\\tdependencies = [\\n\\t\\tmigrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n\\t\\t('push_notifications', '0003_wnsdevice'),\\n\\t]\\n\\n\\toperations = [\\n\\t\\tmigrations.AddField(\\n\\t\\t\\tmodel_name='gcmdevice',\\n\\t\\t\\tname='cloud_message_type',\\n\\t\\t\\tfield=models.CharField(choices=[('FCM', 'Firebase Cloud Message'), ('GCM', 'Google Cloud Message')], default='GCM', help_text='You should choose FCM or GCM', max_length=3, verbose_name='Cloud Message Type')\\n\\t\\t),\\n\\t]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n\\tdependencies = [\\n\\t\\tmigrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n\\t\\t('push_notifications', '0003_wnsdevice'),\\n\\t]\\n\\n\\toperations = [\\n\\t\\tmigrations.AddField(\\n\\t\\t\\tmodel_name='gcmdevice',\\n\\t\\t\\tname='cloud_message_type',\\n\\t\\t\\tfield=models.CharField(choices=[('FCM', 'Firebase Cloud Message'), ('GCM', 'Google Cloud Message')], default='GCM', help_text='You should choose FCM or GCM', max_length=3, verbose_name='Cloud Message Type')\\n\\t\\t),\\n\\t]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0004_fcm'),\\n    ]\\n\\n    operations = [\\n        migrations.AddField(\\n            model_name='apnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='gcmdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='wnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0004_fcm'),\\n    ]\\n\\n    operations = [\\n        migrations.AddField(\\n            model_name='apnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='gcmdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='wnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0004_fcm'),\\n    ]\\n\\n    operations = [\\n        migrations.AddField(\\n            model_name='apnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='gcmdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='wnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0004_fcm'),\\n    ]\\n\\n    operations = [\\n        migrations.AddField(\\n            model_name='apnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='gcmdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='wnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0005_applicationid'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WebPushDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('application_id', models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('p256dh', models.CharField(max_length=88, verbose_name='User public encryption key')),\\n                ('auth', models.CharField(max_length=24, verbose_name='User auth secret')),\\n                ('browser', models.CharField(default='CHROME', help_text='Currently only support to Chrome, Firefox and Opera browsers', max_length=10, verbose_name='Browser', choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera')])),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'WebPush device',\\n            },\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0005_applicationid'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WebPushDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('application_id', models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('p256dh', models.CharField(max_length=88, verbose_name='User public encryption key')),\\n                ('auth', models.CharField(max_length=24, verbose_name='User auth secret')),\\n                ('browser', models.CharField(default='CHROME', help_text='Currently only support to Chrome, Firefox and Opera browsers', max_length=10, verbose_name='Browser', choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera')])),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'WebPush device',\\n            },\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0005_applicationid'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WebPushDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('application_id', models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('p256dh', models.CharField(max_length=88, verbose_name='User public encryption key')),\\n                ('auth', models.CharField(max_length=24, verbose_name='User auth secret')),\\n                ('browser', models.CharField(default='CHROME', help_text='Currently only support to Chrome, Firefox and Opera browsers', max_length=10, verbose_name='Browser', choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera')])),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'WebPush device',\\n            },\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0005_applicationid'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WebPushDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('application_id', models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('p256dh', models.CharField(max_length=88, verbose_name='User public encryption key')),\\n                ('auth', models.CharField(max_length=24, verbose_name='User auth secret')),\\n                ('browser', models.CharField(default='CHROME', help_text='Currently only support to Chrome, Firefox and Opera browsers', max_length=10, verbose_name='Browser', choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera')])),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'WebPush device',\\n            },\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"from django.db import migrations, models\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0006_webpushdevice'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='gcmdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='wnsdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Notification URI'),\\n        ),\\n    ]\\n\""}, "return_value": "\"from django.db import migrations, models\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0006_webpushdevice'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='gcmdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='wnsdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Notification URI'),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"from django.db import migrations, models\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0006_webpushdevice'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='gcmdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='wnsdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Notification URI'),\\n        ),\\n    ]\\n\""}, "return_value": "\"from django.db import migrations, models\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0006_webpushdevice'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='gcmdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='wnsdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Notification URI'),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# Generated by Django 3.2.8 on 2021-11-12 09:49\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0007_uniquesetting'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='browser',\\n            field=models.CharField(choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera'), ('EDGE', 'Edge')], default='CHROME', help_text='Currently only support to Chrome, Firefox, Edge and Opera browsers', max_length=10, verbose_name='Browser'),\\n        ),\\n    ]\\n\""}, "return_value": "\"# Generated by Django 3.2.8 on 2021-11-12 09:49\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0007_uniquesetting'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='browser',\\n            field=models.CharField(choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera'), ('EDGE', 'Edge')], default='CHROME', help_text='Currently only support to Chrome, Firefox, Edge and Opera browsers', max_length=10, verbose_name='Browser'),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# Generated by Django 3.2.8 on 2021-11-12 09:49\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0007_uniquesetting'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='browser',\\n            field=models.CharField(choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera'), ('EDGE', 'Edge')], default='CHROME', help_text='Currently only support to Chrome, Firefox, Edge and Opera browsers', max_length=10, verbose_name='Browser'),\\n        ),\\n    ]\\n\""}, "return_value": "\"# Generated by Django 3.2.8 on 2021-11-12 09:49\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0007_uniquesetting'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='browser',\\n            field=models.CharField(choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera'), ('EDGE', 'Edge')], default='CHROME', help_text='Currently only support to Chrome, Firefox, Edge and Opera browsers', max_length=10, verbose_name='Browser'),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# Generated by Django 3.2.9 on 2022-01-10 09:03\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0008_webpush_add_edge'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='device_id',\\n            field=models.UUIDField(blank=True, db_index=True, help_text='UUID / UIDevice.identifierForVendor()', null=True, verbose_name='Device ID'),\\n        ),\\n    ]\\n\""}, "return_value": "\"# Generated by Django 3.2.9 on 2022-01-10 09:03\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0008_webpush_add_edge'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='device_id',\\n            field=models.UUIDField(blank=True, db_index=True, help_text='UUID / UIDevice.identifierForVendor()', null=True, verbose_name='Device ID'),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# Generated by Django 3.2.9 on 2022-01-10 09:03\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0008_webpush_add_edge'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='device_id',\\n            field=models.UUIDField(blank=True, db_index=True, help_text='UUID / UIDevice.identifierForVendor()', null=True, verbose_name='Device ID'),\\n        ),\\n    ]\\n\""}, "return_value": "\"# Generated by Django 3.2.9 on 2022-01-10 09:03\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0008_webpush_add_edge'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='device_id',\\n            field=models.UUIDField(blank=True, db_index=True, help_text='UUID / UIDevice.identifierForVendor()', null=True, verbose_name='Device ID'),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "''"}, "return_value": "''"}, {"func_args": {"source": "'from django.db import models\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .fields import HexIntegerField\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nCLOUD_MESSAGE_TYPES = (\\n\\t(\"FCM\", \"Firebase Cloud Message\"),\\n\\t(\"GCM\", \"Google Cloud Message\"),\\n)\\n\\nBROWSER_TYPES = (\\n\\t(\"CHROME\", \"Chrome\"),\\n\\t(\"FIREFOX\", \"Firefox\"),\\n\\t(\"OPERA\", \"Opera\"),\\n\\t(\"EDGE\", \"Edge\")\\n)\\n\\n\\nclass Device(models.Model):\\n\\tname = models.CharField(max_length=255, verbose_name=_(\"Name\"), blank=True, null=True)\\n\\tactive = models.BooleanField(\\n\\t\\tverbose_name=_(\"Is active\"), default=True,\\n\\t\\thelp_text=_(\"Inactive devices will not be sent notifications\")\\n\\t)\\n\\tuser = models.ForeignKey(\\n\\t\\tSETTINGS[\"USER_MODEL\"], blank=True, null=True, on_delete=models.CASCADE\\n\\t)\\n\\tdate_created = models.DateTimeField(\\n\\t\\tverbose_name=_(\"Creation date\"), auto_now_add=True, null=True\\n\\t)\\n\\tapplication_id = models.CharField(\\n\\t\\tmax_length=64, verbose_name=_(\"Application ID\"),\\n\\t\\thelp_text=_(\\n\\t\\t\\t\"Opaque application identity, should be filled in for multiple\"\\n\\t\\t\\t\" key/certificate access\"\\n\\t\\t),\\n\\t\\tblank=True, null=True\\n\\t)\\n\\n\\tclass Meta:\\n\\t\\tabstract = True\\n\\n\\tdef __str__(self):\\n\\t\\treturn (\\n\\t\\t\\tself.name or\\n\\t\\t\\tstr(self.device_id or \"\") or\\n\\t\\t\\t\"{} for {}\".format(self.__class__.__name__, self.user or \"unknown user\")\\n\\t\\t)\\n\\n\\nclass GCMDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn GCMDeviceQuerySet(self.model)\\n\\n\\nclass GCMDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\t\\tif message is not None:\\n\\t\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\\n\\t\\t\\t\\t\"application_id\"\\n\\t\\t\\t).values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tresponse = []\\n\\t\\t\\tfor cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\t\\treg_ids = list(\\n\\t\\t\\t\\t\\t\\tself.filter(\\n\\t\\t\\t\\t\\t\\t\\tactive=True, cloud_message_type=cloud_type, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\tif reg_ids:\\n\\t\\t\\t\\t\\t\\tr = gcm_send_message(reg_ids, data, cloud_type, application_id=app_id, **kwargs)\\n\\t\\t\\t\\t\\t\\tresponse.append(r)\\n\\n\\t\\t\\treturn response\\n\\n\\nclass GCMDevice(Device):\\n\\t# device_id cannot be a reliable primary key as fragmentation between different devices\\n\\t# can make it turn out to be null and such:\\n\\t# http://android-developers.blogspot.co.uk/2011/03/identifying-app-installations.html\\n\\tdevice_id = HexIntegerField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tcloud_message_type = models.CharField(\\n\\t\\tverbose_name=_(\"Cloud Message Type\"), max_length=3,\\n\\t\\tchoices=CLOUD_MESSAGE_TYPES, default=\"GCM\",\\n\\t\\thelp_text=_(\"You should choose FCM or GCM\")\\n\\t)\\n\\tobjects = GCMDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"GCM device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\tif message is not None:\\n\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\treturn gcm_send_message(\\n\\t\\t\\tself.registration_id, data, self.cloud_message_type,\\n\\t\\t\\tapplication_id=self.application_id, **kwargs\\n\\t\\t)\\n\\n\\nclass APNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn APNSDeviceQuerySet(self.model)\\n\\n\\nclass APNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .apns import apns_send_bulk_message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\")\\\\\\n\\t\\t\\t\\t.values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tres = []\\n\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\treg_ids = list(self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\"registration_id\", flat=True)\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tr = apns_send_bulk_message(\\n\\t\\t\\t\\t\\tregistration_ids=reg_ids, alert=message, application_id=app_id,\\n\\t\\t\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\t\\tres += [r]\\n\\t\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\t\\tres += r\\n\\t\\t\\treturn res\\n\\n\\nclass APNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"UUID / UIDevice.identifierForVendor()\")\\n\\t)\\n\\tregistration_id = models.CharField(\\n\\t\\tverbose_name=_(\"Registration ID\"), max_length=200, unique=SETTINGS[\"UNIQUE_REG_ID\"]\\n\\t)\\n\\n\\tobjects = APNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"APNS device\")\\n\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tfrom .apns import apns_send_message\\n\\n\\t\\treturn apns_send_message(\\n\\t\\t\\tregistration_id=self.registration_id,\\n\\t\\t\\talert=message,\\n\\t\\t\\tapplication_id=self.application_id, creds=creds,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WNSDeviceQuerySet(self.model)\\n\\n\\nclass WNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_bulk_message\\n\\n\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\").values_list(\\n\\t\\t\\t\"application_id\", flat=True\\n\\t\\t).distinct()\\n\\t\\tres = []\\n\\t\\tfor app_id in app_ids:\\n\\t\\t\\treg_ids = self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t)\\n\\t\\t\\tr = wns_send_bulk_message(uri_list=list(reg_ids), message=message, **kwargs)\\n\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\tres += [r]\\n\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\tres += r\\n\\n\\t\\treturn res\\n\\n\\nclass WNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"GUID()\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Notification URI\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\n\\tobjects = WNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WNS device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_message\\n\\n\\t\\treturn wns_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, application_id=self.application_id,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WebPushDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WebPushDeviceQuerySet(self.model)\\n\\n\\nclass WebPushDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tdevices = self.filter(active=True).order_by(\"application_id\").distinct()\\n\\t\\tres = []\\n\\t\\tfor device in devices:\\n\\t\\t\\tres.append(device.send_message(message))\\n\\n\\t\\treturn res\\n\\n\\nclass WebPushDevice(Device):\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tp256dh = models.CharField(\\n\\t\\tverbose_name=_(\"User public encryption key\"),\\n\\t\\tmax_length=88)\\n\\tauth = models.CharField(\\n\\t\\tverbose_name=_(\"User auth secret\"),\\n\\t\\tmax_length=24)\\n\\tbrowser = models.CharField(\\n\\t\\tverbose_name=_(\"Browser\"), max_length=10,\\n\\t\\tchoices=BROWSER_TYPES, default=BROWSER_TYPES[0][0],\\n\\t\\thelp_text=_(\"Currently only support to Chrome, Firefox, Edge and Opera browsers\")\\n\\t)\\n\\tobjects = WebPushDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WebPush device\")\\n\\n\\t@property\\n\\tdef device_id(self):\\n\\t\\treturn None\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .webpush import webpush_send_message\\n\\n\\t\\treturn webpush_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, browser=self.browser,\\n\\t\\t\\tauth=self.auth, p256dh=self.p256dh, application_id=self.application_id, **kwargs)\\n'"}, "return_value": "'from django.db import models\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .fields import HexIntegerField\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nCLOUD_MESSAGE_TYPES = (\\n\\t(\"FCM\", \"Firebase Cloud Message\"),\\n\\t(\"GCM\", \"Google Cloud Message\"),\\n)\\n\\nBROWSER_TYPES = (\\n\\t(\"CHROME\", \"Chrome\"),\\n\\t(\"FIREFOX\", \"Firefox\"),\\n\\t(\"OPERA\", \"Opera\"),\\n\\t(\"EDGE\", \"Edge\")\\n)\\n\\n\\nclass Device(models.Model):\\n\\tname = models.CharField(max_length=255, verbose_name=_(\"Name\"), blank=True, null=True)\\n\\tactive = models.BooleanField(\\n\\t\\tverbose_name=_(\"Is active\"), default=True,\\n\\t\\thelp_text=_(\"Inactive devices will not be sent notifications\")\\n\\t)\\n\\tuser = models.ForeignKey(\\n\\t\\tSETTINGS[\"USER_MODEL\"], blank=True, null=True, on_delete=models.CASCADE\\n\\t)\\n\\tdate_created = models.DateTimeField(\\n\\t\\tverbose_name=_(\"Creation date\"), auto_now_add=True, null=True\\n\\t)\\n\\tapplication_id = models.CharField(\\n\\t\\tmax_length=64, verbose_name=_(\"Application ID\"),\\n\\t\\thelp_text=_(\\n\\t\\t\\t\"Opaque application identity, should be filled in for multiple\"\\n\\t\\t\\t\" key/certificate access\"\\n\\t\\t),\\n\\t\\tblank=True, null=True\\n\\t)\\n\\n\\tclass Meta:\\n\\t\\tabstract = True\\n\\n\\tdef __str__(self):\\n\\t\\treturn (\\n\\t\\t\\tself.name or\\n\\t\\t\\tstr(self.device_id or \"\") or\\n\\t\\t\\t\"{} for {}\".format(self.__class__.__name__, self.user or \"unknown user\")\\n\\t\\t)\\n\\n\\nclass GCMDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn GCMDeviceQuerySet(self.model)\\n\\n\\nclass GCMDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\t\\tif message is not None:\\n\\t\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\\n\\t\\t\\t\\t\"application_id\"\\n\\t\\t\\t).values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tresponse = []\\n\\t\\t\\tfor cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\t\\treg_ids = list(\\n\\t\\t\\t\\t\\t\\tself.filter(\\n\\t\\t\\t\\t\\t\\t\\tactive=True, cloud_message_type=cloud_type, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\tif reg_ids:\\n\\t\\t\\t\\t\\t\\tr = gcm_send_message(reg_ids, data, cloud_type, application_id=app_id, **kwargs)\\n\\t\\t\\t\\t\\t\\tresponse.append(r)\\n\\n\\t\\t\\treturn response\\n\\n\\nclass GCMDevice(Device):\\n\\t# device_id cannot be a reliable primary key as fragmentation between different devices\\n\\t# can make it turn out to be null and such:\\n\\t# http://android-developers.blogspot.co.uk/2011/03/identifying-app-installations.html\\n\\tdevice_id = HexIntegerField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tcloud_message_type = models.CharField(\\n\\t\\tverbose_name=_(\"Cloud Message Type\"), max_length=3,\\n\\t\\tchoices=CLOUD_MESSAGE_TYPES, default=\"GCM\",\\n\\t\\thelp_text=_(\"You should choose FCM or GCM\")\\n\\t)\\n\\tobjects = GCMDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"GCM device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\tif message is not None:\\n\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\treturn gcm_send_message(\\n\\t\\t\\tself.registration_id, data, self.cloud_message_type,\\n\\t\\t\\tapplication_id=self.application_id, **kwargs\\n\\t\\t)\\n\\n\\nclass APNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn APNSDeviceQuerySet(self.model)\\n\\n\\nclass APNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .apns import apns_send_bulk_message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\")\\\\\\n\\t\\t\\t\\t.values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tres = []\\n\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\treg_ids = list(self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\"registration_id\", flat=True)\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tr = apns_send_bulk_message(\\n\\t\\t\\t\\t\\tregistration_ids=reg_ids, alert=message, application_id=app_id,\\n\\t\\t\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\t\\tres += [r]\\n\\t\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\t\\tres += r\\n\\t\\t\\treturn res\\n\\n\\nclass APNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"UUID / UIDevice.identifierForVendor()\")\\n\\t)\\n\\tregistration_id = models.CharField(\\n\\t\\tverbose_name=_(\"Registration ID\"), max_length=200, unique=SETTINGS[\"UNIQUE_REG_ID\"]\\n\\t)\\n\\n\\tobjects = APNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"APNS device\")\\n\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tfrom .apns import apns_send_message\\n\\n\\t\\treturn apns_send_message(\\n\\t\\t\\tregistration_id=self.registration_id,\\n\\t\\t\\talert=message,\\n\\t\\t\\tapplication_id=self.application_id, creds=creds,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WNSDeviceQuerySet(self.model)\\n\\n\\nclass WNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_bulk_message\\n\\n\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\").values_list(\\n\\t\\t\\t\"application_id\", flat=True\\n\\t\\t).distinct()\\n\\t\\tres = []\\n\\t\\tfor app_id in app_ids:\\n\\t\\t\\treg_ids = self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t)\\n\\t\\t\\tr = wns_send_bulk_message(uri_list=list(reg_ids), message=message, **kwargs)\\n\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\tres += [r]\\n\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\tres += r\\n\\n\\t\\treturn res\\n\\n\\nclass WNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"GUID()\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Notification URI\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\n\\tobjects = WNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WNS device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_message\\n\\n\\t\\treturn wns_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, application_id=self.application_id,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WebPushDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WebPushDeviceQuerySet(self.model)\\n\\n\\nclass WebPushDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tdevices = self.filter(active=True).order_by(\"application_id\").distinct()\\n\\t\\tres = []\\n\\t\\tfor device in devices:\\n\\t\\t\\tres.append(device.send_message(message))\\n\\n\\t\\treturn res\\n\\n\\nclass WebPushDevice(Device):\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tp256dh = models.CharField(\\n\\t\\tverbose_name=_(\"User public encryption key\"),\\n\\t\\tmax_length=88)\\n\\tauth = models.CharField(\\n\\t\\tverbose_name=_(\"User auth secret\"),\\n\\t\\tmax_length=24)\\n\\tbrowser = models.CharField(\\n\\t\\tverbose_name=_(\"Browser\"), max_length=10,\\n\\t\\tchoices=BROWSER_TYPES, default=BROWSER_TYPES[0][0],\\n\\t\\thelp_text=_(\"Currently only support to Chrome, Firefox, Edge and Opera browsers\")\\n\\t)\\n\\tobjects = WebPushDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WebPush device\")\\n\\n\\t@property\\n\\tdef device_id(self):\\n\\t\\treturn None\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .webpush import webpush_send_message\\n\\n\\t\\treturn webpush_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, browser=self.browser,\\n\\t\\t\\tauth=self.auth, p256dh=self.p256dh, application_id=self.application_id, **kwargs)\\n'"}, {"func_args": {"source": "'from django.db import models\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .fields import HexIntegerField\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nCLOUD_MESSAGE_TYPES = (\\n\\t(\"FCM\", \"Firebase Cloud Message\"),\\n\\t(\"GCM\", \"Google Cloud Message\"),\\n)\\n\\nBROWSER_TYPES = (\\n\\t(\"CHROME\", \"Chrome\"),\\n\\t(\"FIREFOX\", \"Firefox\"),\\n\\t(\"OPERA\", \"Opera\"),\\n\\t(\"EDGE\", \"Edge\")\\n)\\n\\n\\nclass Device(models.Model):\\n\\tname = models.CharField(max_length=255, verbose_name=_(\"Name\"), blank=True, null=True)\\n\\tactive = models.BooleanField(\\n\\t\\tverbose_name=_(\"Is active\"), default=True,\\n\\t\\thelp_text=_(\"Inactive devices will not be sent notifications\")\\n\\t)\\n\\tuser = models.ForeignKey(\\n\\t\\tSETTINGS[\"USER_MODEL\"], blank=True, null=True, on_delete=models.CASCADE\\n\\t)\\n\\tdate_created = models.DateTimeField(\\n\\t\\tverbose_name=_(\"Creation date\"), auto_now_add=True, null=True\\n\\t)\\n\\tapplication_id = models.CharField(\\n\\t\\tmax_length=64, verbose_name=_(\"Application ID\"),\\n\\t\\thelp_text=_(\\n\\t\\t\\t\"Opaque application identity, should be filled in for multiple\"\\n\\t\\t\\t\" key/certificate access\"\\n\\t\\t),\\n\\t\\tblank=True, null=True\\n\\t)\\n\\n\\tclass Meta:\\n\\t\\tabstract = True\\n\\n\\tdef __str__(self):\\n\\t\\treturn (\\n\\t\\t\\tself.name or\\n\\t\\t\\tstr(self.device_id or \"\") or\\n\\t\\t\\t\"{} for {}\".format(self.__class__.__name__, self.user or \"unknown user\")\\n\\t\\t)\\n\\n\\nclass GCMDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn GCMDeviceQuerySet(self.model)\\n\\n\\nclass GCMDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\t\\tif message is not None:\\n\\t\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\\n\\t\\t\\t\\t\"application_id\"\\n\\t\\t\\t).values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tresponse = []\\n\\t\\t\\tfor cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\t\\treg_ids = list(\\n\\t\\t\\t\\t\\t\\tself.filter(\\n\\t\\t\\t\\t\\t\\t\\tactive=True, cloud_message_type=cloud_type, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\tif reg_ids:\\n\\t\\t\\t\\t\\t\\tr = gcm_send_message(reg_ids, data, cloud_type, application_id=app_id, **kwargs)\\n\\t\\t\\t\\t\\t\\tresponse.append(r)\\n\\n\\t\\t\\treturn response\\n\\n\\nclass GCMDevice(Device):\\n\\t# device_id cannot be a reliable primary key as fragmentation between different devices\\n\\t# can make it turn out to be null and such:\\n\\t# http://android-developers.blogspot.co.uk/2011/03/identifying-app-installations.html\\n\\tdevice_id = HexIntegerField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tcloud_message_type = models.CharField(\\n\\t\\tverbose_name=_(\"Cloud Message Type\"), max_length=3,\\n\\t\\tchoices=CLOUD_MESSAGE_TYPES, default=\"GCM\",\\n\\t\\thelp_text=_(\"You should choose FCM or GCM\")\\n\\t)\\n\\tobjects = GCMDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"GCM device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\tif message is not None:\\n\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\treturn gcm_send_message(\\n\\t\\t\\tself.registration_id, data, self.cloud_message_type,\\n\\t\\t\\tapplication_id=self.application_id, **kwargs\\n\\t\\t)\\n\\n\\nclass APNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn APNSDeviceQuerySet(self.model)\\n\\n\\nclass APNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .apns import apns_send_bulk_message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\")\\\\\\n\\t\\t\\t\\t.values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tres = []\\n\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\treg_ids = list(self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\"registration_id\", flat=True)\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tr = apns_send_bulk_message(\\n\\t\\t\\t\\t\\tregistration_ids=reg_ids, alert=message, application_id=app_id,\\n\\t\\t\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\t\\tres += [r]\\n\\t\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\t\\tres += r\\n\\t\\t\\treturn res\\n\\n\\nclass APNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"UUID / UIDevice.identifierForVendor()\")\\n\\t)\\n\\tregistration_id = models.CharField(\\n\\t\\tverbose_name=_(\"Registration ID\"), max_length=200, unique=SETTINGS[\"UNIQUE_REG_ID\"]\\n\\t)\\n\\n\\tobjects = APNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"APNS device\")\\n\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tfrom .apns import apns_send_message\\n\\n\\t\\treturn apns_send_message(\\n\\t\\t\\tregistration_id=self.registration_id,\\n\\t\\t\\talert=message,\\n\\t\\t\\tapplication_id=self.application_id, creds=creds,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WNSDeviceQuerySet(self.model)\\n\\n\\nclass WNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_bulk_message\\n\\n\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\").values_list(\\n\\t\\t\\t\"application_id\", flat=True\\n\\t\\t).distinct()\\n\\t\\tres = []\\n\\t\\tfor app_id in app_ids:\\n\\t\\t\\treg_ids = self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t)\\n\\t\\t\\tr = wns_send_bulk_message(uri_list=list(reg_ids), message=message, **kwargs)\\n\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\tres += [r]\\n\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\tres += r\\n\\n\\t\\treturn res\\n\\n\\nclass WNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"GUID()\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Notification URI\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\n\\tobjects = WNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WNS device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_message\\n\\n\\t\\treturn wns_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, application_id=self.application_id,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WebPushDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WebPushDeviceQuerySet(self.model)\\n\\n\\nclass WebPushDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tdevices = self.filter(active=True).order_by(\"application_id\").distinct()\\n\\t\\tres = []\\n\\t\\tfor device in devices:\\n\\t\\t\\tres.append(device.send_message(message))\\n\\n\\t\\treturn res\\n\\n\\nclass WebPushDevice(Device):\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tp256dh = models.CharField(\\n\\t\\tverbose_name=_(\"User public encryption key\"),\\n\\t\\tmax_length=88)\\n\\tauth = models.CharField(\\n\\t\\tverbose_name=_(\"User auth secret\"),\\n\\t\\tmax_length=24)\\n\\tbrowser = models.CharField(\\n\\t\\tverbose_name=_(\"Browser\"), max_length=10,\\n\\t\\tchoices=BROWSER_TYPES, default=BROWSER_TYPES[0][0],\\n\\t\\thelp_text=_(\"Currently only support to Chrome, Firefox, Edge and Opera browsers\")\\n\\t)\\n\\tobjects = WebPushDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WebPush device\")\\n\\n\\t@property\\n\\tdef device_id(self):\\n\\t\\treturn None\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .webpush import webpush_send_message\\n\\n\\t\\treturn webpush_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, browser=self.browser,\\n\\t\\t\\tauth=self.auth, p256dh=self.p256dh, application_id=self.application_id, **kwargs)\\n'"}, "return_value": "'from django.db import models\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .fields import HexIntegerField\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nCLOUD_MESSAGE_TYPES = (\\n\\t(\"FCM\", \"Firebase Cloud Message\"),\\n\\t(\"GCM\", \"Google Cloud Message\"),\\n)\\n\\nBROWSER_TYPES = (\\n\\t(\"CHROME\", \"Chrome\"),\\n\\t(\"FIREFOX\", \"Firefox\"),\\n\\t(\"OPERA\", \"Opera\"),\\n\\t(\"EDGE\", \"Edge\")\\n)\\n\\n\\nclass Device(models.Model):\\n\\tname = models.CharField(max_length=255, verbose_name=_(\"Name\"), blank=True, null=True)\\n\\tactive = models.BooleanField(\\n\\t\\tverbose_name=_(\"Is active\"), default=True,\\n\\t\\thelp_text=_(\"Inactive devices will not be sent notifications\")\\n\\t)\\n\\tuser = models.ForeignKey(\\n\\t\\tSETTINGS[\"USER_MODEL\"], blank=True, null=True, on_delete=models.CASCADE\\n\\t)\\n\\tdate_created = models.DateTimeField(\\n\\t\\tverbose_name=_(\"Creation date\"), auto_now_add=True, null=True\\n\\t)\\n\\tapplication_id = models.CharField(\\n\\t\\tmax_length=64, verbose_name=_(\"Application ID\"),\\n\\t\\thelp_text=_(\\n\\t\\t\\t\"Opaque application identity, should be filled in for multiple\"\\n\\t\\t\\t\" key/certificate access\"\\n\\t\\t),\\n\\t\\tblank=True, null=True\\n\\t)\\n\\n\\tclass Meta:\\n\\t\\tabstract = True\\n\\n\\tdef __str__(self):\\n\\t\\treturn (\\n\\t\\t\\tself.name or\\n\\t\\t\\tstr(self.device_id or \"\") or\\n\\t\\t\\t\"{} for {}\".format(self.__class__.__name__, self.user or \"unknown user\")\\n\\t\\t)\\n\\n\\nclass GCMDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn GCMDeviceQuerySet(self.model)\\n\\n\\nclass GCMDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\t\\tif message is not None:\\n\\t\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\\n\\t\\t\\t\\t\"application_id\"\\n\\t\\t\\t).values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tresponse = []\\n\\t\\t\\tfor cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\t\\treg_ids = list(\\n\\t\\t\\t\\t\\t\\tself.filter(\\n\\t\\t\\t\\t\\t\\t\\tactive=True, cloud_message_type=cloud_type, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\tif reg_ids:\\n\\t\\t\\t\\t\\t\\tr = gcm_send_message(reg_ids, data, cloud_type, application_id=app_id, **kwargs)\\n\\t\\t\\t\\t\\t\\tresponse.append(r)\\n\\n\\t\\t\\treturn response\\n\\n\\nclass GCMDevice(Device):\\n\\t# device_id cannot be a reliable primary key as fragmentation between different devices\\n\\t# can make it turn out to be null and such:\\n\\t# http://android-developers.blogspot.co.uk/2011/03/identifying-app-installations.html\\n\\tdevice_id = HexIntegerField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tcloud_message_type = models.CharField(\\n\\t\\tverbose_name=_(\"Cloud Message Type\"), max_length=3,\\n\\t\\tchoices=CLOUD_MESSAGE_TYPES, default=\"GCM\",\\n\\t\\thelp_text=_(\"You should choose FCM or GCM\")\\n\\t)\\n\\tobjects = GCMDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"GCM device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\tif message is not None:\\n\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\treturn gcm_send_message(\\n\\t\\t\\tself.registration_id, data, self.cloud_message_type,\\n\\t\\t\\tapplication_id=self.application_id, **kwargs\\n\\t\\t)\\n\\n\\nclass APNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn APNSDeviceQuerySet(self.model)\\n\\n\\nclass APNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .apns import apns_send_bulk_message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\")\\\\\\n\\t\\t\\t\\t.values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tres = []\\n\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\treg_ids = list(self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\"registration_id\", flat=True)\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tr = apns_send_bulk_message(\\n\\t\\t\\t\\t\\tregistration_ids=reg_ids, alert=message, application_id=app_id,\\n\\t\\t\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\t\\tres += [r]\\n\\t\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\t\\tres += r\\n\\t\\t\\treturn res\\n\\n\\nclass APNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"UUID / UIDevice.identifierForVendor()\")\\n\\t)\\n\\tregistration_id = models.CharField(\\n\\t\\tverbose_name=_(\"Registration ID\"), max_length=200, unique=SETTINGS[\"UNIQUE_REG_ID\"]\\n\\t)\\n\\n\\tobjects = APNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"APNS device\")\\n\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tfrom .apns import apns_send_message\\n\\n\\t\\treturn apns_send_message(\\n\\t\\t\\tregistration_id=self.registration_id,\\n\\t\\t\\talert=message,\\n\\t\\t\\tapplication_id=self.application_id, creds=creds,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WNSDeviceQuerySet(self.model)\\n\\n\\nclass WNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_bulk_message\\n\\n\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\").values_list(\\n\\t\\t\\t\"application_id\", flat=True\\n\\t\\t).distinct()\\n\\t\\tres = []\\n\\t\\tfor app_id in app_ids:\\n\\t\\t\\treg_ids = self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t)\\n\\t\\t\\tr = wns_send_bulk_message(uri_list=list(reg_ids), message=message, **kwargs)\\n\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\tres += [r]\\n\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\tres += r\\n\\n\\t\\treturn res\\n\\n\\nclass WNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"GUID()\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Notification URI\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\n\\tobjects = WNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WNS device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_message\\n\\n\\t\\treturn wns_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, application_id=self.application_id,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WebPushDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WebPushDeviceQuerySet(self.model)\\n\\n\\nclass WebPushDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tdevices = self.filter(active=True).order_by(\"application_id\").distinct()\\n\\t\\tres = []\\n\\t\\tfor device in devices:\\n\\t\\t\\tres.append(device.send_message(message))\\n\\n\\t\\treturn res\\n\\n\\nclass WebPushDevice(Device):\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tp256dh = models.CharField(\\n\\t\\tverbose_name=_(\"User public encryption key\"),\\n\\t\\tmax_length=88)\\n\\tauth = models.CharField(\\n\\t\\tverbose_name=_(\"User auth secret\"),\\n\\t\\tmax_length=24)\\n\\tbrowser = models.CharField(\\n\\t\\tverbose_name=_(\"Browser\"), max_length=10,\\n\\t\\tchoices=BROWSER_TYPES, default=BROWSER_TYPES[0][0],\\n\\t\\thelp_text=_(\"Currently only support to Chrome, Firefox, Edge and Opera browsers\")\\n\\t)\\n\\tobjects = WebPushDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WebPush device\")\\n\\n\\t@property\\n\\tdef device_id(self):\\n\\t\\treturn None\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .webpush import webpush_send_message\\n\\n\\t\\treturn webpush_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, browser=self.browser,\\n\\t\\t\\tauth=self.auth, p256dh=self.p256dh, application_id=self.application_id, **kwargs)\\n'"}, {"func_args": {"source": "'from django.conf import settings\\n\\n\\nPUSH_NOTIFICATIONS_SETTINGS = getattr(settings, \"PUSH_NOTIFICATIONS_SETTINGS\", {})\\n\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"CONFIG\", \"push_notifications.conf.LegacyConfig\"\\n)\\n\\n# GCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"GCM_POST_URL\", \"https://android.googleapis.com/gcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_ERROR_TIMEOUT\", None)\\n\\n# FCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"FCM_POST_URL\", \"https://fcm.googleapis.com/fcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_ERROR_TIMEOUT\", None)\\n\\n# APNS\\nif settings.DEBUG:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", True)\\nelse:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_ALTERNATIVE_PORT\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_TOPIC\", None)\\n\\n# WNS\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_PACKAGE_SECURITY_ID\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_SECRET_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\"\\n)\\n\\n# WP (WebPush)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_POST_URL\", {\\n\\t\"CHROME\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"OPERA\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n})\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_PRIVATE_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_CLAIMS\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_ERROR_TIMEOUT\", None)\\n\\n# User model\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"USER_MODEL\", settings.AUTH_USER_MODEL)\\n\\n# Unique registration ID for all devices\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UNIQUE_REG_ID\", False)\\n\\n# API endpoint settings\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UPDATE_ON_DUPLICATE_REG_ID\", False)\\n'"}, "return_value": "'from django.conf import settings\\n\\n\\nPUSH_NOTIFICATIONS_SETTINGS = getattr(settings, \"PUSH_NOTIFICATIONS_SETTINGS\", {})\\n\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"CONFIG\", \"push_notifications.conf.LegacyConfig\"\\n)\\n\\n# GCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"GCM_POST_URL\", \"https://android.googleapis.com/gcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_ERROR_TIMEOUT\", None)\\n\\n# FCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"FCM_POST_URL\", \"https://fcm.googleapis.com/fcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_ERROR_TIMEOUT\", None)\\n\\n# APNS\\nif settings.DEBUG:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", True)\\nelse:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_ALTERNATIVE_PORT\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_TOPIC\", None)\\n\\n# WNS\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_PACKAGE_SECURITY_ID\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_SECRET_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\"\\n)\\n\\n# WP (WebPush)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_POST_URL\", {\\n\\t\"CHROME\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"OPERA\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n})\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_PRIVATE_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_CLAIMS\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_ERROR_TIMEOUT\", None)\\n\\n# User model\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"USER_MODEL\", settings.AUTH_USER_MODEL)\\n\\n# Unique registration ID for all devices\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UNIQUE_REG_ID\", False)\\n\\n# API endpoint settings\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UPDATE_ON_DUPLICATE_REG_ID\", False)\\n'"}, {"func_args": {"source": "'from django.conf import settings\\n\\n\\nPUSH_NOTIFICATIONS_SETTINGS = getattr(settings, \"PUSH_NOTIFICATIONS_SETTINGS\", {})\\n\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"CONFIG\", \"push_notifications.conf.LegacyConfig\"\\n)\\n\\n# GCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"GCM_POST_URL\", \"https://android.googleapis.com/gcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_ERROR_TIMEOUT\", None)\\n\\n# FCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"FCM_POST_URL\", \"https://fcm.googleapis.com/fcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_ERROR_TIMEOUT\", None)\\n\\n# APNS\\nif settings.DEBUG:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", True)\\nelse:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_ALTERNATIVE_PORT\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_TOPIC\", None)\\n\\n# WNS\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_PACKAGE_SECURITY_ID\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_SECRET_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\"\\n)\\n\\n# WP (WebPush)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_POST_URL\", {\\n\\t\"CHROME\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"OPERA\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n})\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_PRIVATE_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_CLAIMS\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_ERROR_TIMEOUT\", None)\\n\\n# User model\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"USER_MODEL\", settings.AUTH_USER_MODEL)\\n\\n# Unique registration ID for all devices\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UNIQUE_REG_ID\", False)\\n\\n# API endpoint settings\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UPDATE_ON_DUPLICATE_REG_ID\", False)\\n'"}, "return_value": "'from django.conf import settings\\n\\n\\nPUSH_NOTIFICATIONS_SETTINGS = getattr(settings, \"PUSH_NOTIFICATIONS_SETTINGS\", {})\\n\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"CONFIG\", \"push_notifications.conf.LegacyConfig\"\\n)\\n\\n# GCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"GCM_POST_URL\", \"https://android.googleapis.com/gcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_ERROR_TIMEOUT\", None)\\n\\n# FCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"FCM_POST_URL\", \"https://fcm.googleapis.com/fcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_ERROR_TIMEOUT\", None)\\n\\n# APNS\\nif settings.DEBUG:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", True)\\nelse:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_ALTERNATIVE_PORT\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_TOPIC\", None)\\n\\n# WNS\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_PACKAGE_SECURITY_ID\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_SECRET_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\"\\n)\\n\\n# WP (WebPush)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_POST_URL\", {\\n\\t\"CHROME\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"OPERA\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n})\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_PRIVATE_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_CLAIMS\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_ERROR_TIMEOUT\", None)\\n\\n# User model\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"USER_MODEL\", settings.AUTH_USER_MODEL)\\n\\n# Unique registration ID for all devices\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UNIQUE_REG_ID\", False)\\n\\n# API endpoint settings\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UPDATE_ON_DUPLICATE_REG_ID\", False)\\n'"}, {"func_args": {"source": "'from pywebpush import WebPushException, webpush\\n\\nfrom .conf import get_manager\\nfrom .exceptions import WebPushError\\n\\n\\ndef get_subscription_info(application_id, uri, browser, auth, p256dh):\\n\\turl = get_manager().get_wp_post_url(application_id, browser)\\n\\treturn {\\n\\t\\t\"endpoint\": \"{}/{}\".format(url, uri),\\n\\t\\t\"keys\": {\\n\\t\\t\\t\"auth\": auth,\\n\\t\\t\\t\"p256dh\": p256dh,\\n\\t\\t}\\n\\t}\\n\\n\\ndef webpush_send_message(\\n\\turi, message, browser, auth, p256dh, application_id=None, **kwargs\\n):\\n\\tsubscription_info = get_subscription_info(application_id, uri, browser, auth, p256dh)\\n\\n\\ttry:\\n\\t\\tresponse = webpush(\\n\\t\\t\\tsubscription_info=subscription_info,\\n\\t\\t\\tdata=message,\\n\\t\\t\\tvapid_private_key=get_manager().get_wp_private_key(application_id),\\n\\t\\t\\tvapid_claims=get_manager().get_wp_claims(application_id).copy(),\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\t\\tresults = {\"results\": [{}]}\\n\\t\\tif not response.ok:\\n\\t\\t\\tresults[\"results\"][0][\"error\"] = response.content\\n\\t\\t\\tresults[\"results\"][0][\"original_registration_id\"] = response.content\\n\\t\\telse:\\n\\t\\t\\tresults[\"success\"] = 1\\n\\t\\treturn results\\n\\texcept WebPushException as e:\\n\\t\\traise WebPushError(e.message)\\n'"}, "return_value": "'from pywebpush import WebPushException, webpush\\n\\nfrom .conf import get_manager\\nfrom .exceptions import WebPushError\\n\\n\\ndef get_subscription_info(application_id, uri, browser, auth, p256dh):\\n\\turl = get_manager().get_wp_post_url(application_id, browser)\\n\\treturn {\\n\\t\\t\"endpoint\": \"{}/{}\".format(url, uri),\\n\\t\\t\"keys\": {\\n\\t\\t\\t\"auth\": auth,\\n\\t\\t\\t\"p256dh\": p256dh,\\n\\t\\t}\\n\\t}\\n\\n\\ndef webpush_send_message(\\n\\turi, message, browser, auth, p256dh, application_id=None, **kwargs\\n):\\n\\tsubscription_info = get_subscription_info(application_id, uri, browser, auth, p256dh)\\n\\n\\ttry:\\n\\t\\tresponse = webpush(\\n\\t\\t\\tsubscription_info=subscription_info,\\n\\t\\t\\tdata=message,\\n\\t\\t\\tvapid_private_key=get_manager().get_wp_private_key(application_id),\\n\\t\\t\\tvapid_claims=get_manager().get_wp_claims(application_id).copy(),\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\t\\tresults = {\"results\": [{}]}\\n\\t\\tif not response.ok:\\n\\t\\t\\tresults[\"results\"][0][\"error\"] = response.content\\n\\t\\t\\tresults[\"results\"][0][\"original_registration_id\"] = response.content\\n\\t\\telse:\\n\\t\\t\\tresults[\"success\"] = 1\\n\\t\\treturn results\\n\\texcept WebPushException as e:\\n\\t\\traise WebPushError(e.message)\\n'"}, {"func_args": {"source": "'from pywebpush import WebPushException, webpush\\n\\nfrom .conf import get_manager\\nfrom .exceptions import WebPushError\\n\\n\\ndef get_subscription_info(application_id, uri, browser, auth, p256dh):\\n\\turl = get_manager().get_wp_post_url(application_id, browser)\\n\\treturn {\\n\\t\\t\"endpoint\": \"{}/{}\".format(url, uri),\\n\\t\\t\"keys\": {\\n\\t\\t\\t\"auth\": auth,\\n\\t\\t\\t\"p256dh\": p256dh,\\n\\t\\t}\\n\\t}\\n\\n\\ndef webpush_send_message(\\n\\turi, message, browser, auth, p256dh, application_id=None, **kwargs\\n):\\n\\tsubscription_info = get_subscription_info(application_id, uri, browser, auth, p256dh)\\n\\n\\ttry:\\n\\t\\tresponse = webpush(\\n\\t\\t\\tsubscription_info=subscription_info,\\n\\t\\t\\tdata=message,\\n\\t\\t\\tvapid_private_key=get_manager().get_wp_private_key(application_id),\\n\\t\\t\\tvapid_claims=get_manager().get_wp_claims(application_id).copy(),\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\t\\tresults = {\"results\": [{}]}\\n\\t\\tif not response.ok:\\n\\t\\t\\tresults[\"results\"][0][\"error\"] = response.content\\n\\t\\t\\tresults[\"results\"][0][\"original_registration_id\"] = response.content\\n\\t\\telse:\\n\\t\\t\\tresults[\"success\"] = 1\\n\\t\\treturn results\\n\\texcept WebPushException as e:\\n\\t\\traise WebPushError(e.message)\\n'"}, "return_value": "'from pywebpush import WebPushException, webpush\\n\\nfrom .conf import get_manager\\nfrom .exceptions import WebPushError\\n\\n\\ndef get_subscription_info(application_id, uri, browser, auth, p256dh):\\n\\turl = get_manager().get_wp_post_url(application_id, browser)\\n\\treturn {\\n\\t\\t\"endpoint\": \"{}/{}\".format(url, uri),\\n\\t\\t\"keys\": {\\n\\t\\t\\t\"auth\": auth,\\n\\t\\t\\t\"p256dh\": p256dh,\\n\\t\\t}\\n\\t}\\n\\n\\ndef webpush_send_message(\\n\\turi, message, browser, auth, p256dh, application_id=None, **kwargs\\n):\\n\\tsubscription_info = get_subscription_info(application_id, uri, browser, auth, p256dh)\\n\\n\\ttry:\\n\\t\\tresponse = webpush(\\n\\t\\t\\tsubscription_info=subscription_info,\\n\\t\\t\\tdata=message,\\n\\t\\t\\tvapid_private_key=get_manager().get_wp_private_key(application_id),\\n\\t\\t\\tvapid_claims=get_manager().get_wp_claims(application_id).copy(),\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\t\\tresults = {\"results\": [{}]}\\n\\t\\tif not response.ok:\\n\\t\\t\\tresults[\"results\"][0][\"error\"] = response.content\\n\\t\\t\\tresults[\"results\"][0][\"original_registration_id\"] = response.content\\n\\t\\telse:\\n\\t\\t\\tresults[\"success\"] = 1\\n\\t\\treturn results\\n\\texcept WebPushException as e:\\n\\t\\traise WebPushError(e.message)\\n'"}, {"func_args": {"source": "'\"\"\"\\nWindows Notification Service\\n\\nDocumentation is available on the Windows Dev Center:\\nhttps://msdn.microsoft.com/en-us/windows/uwp/controls-and-patterns/tiles-and-notifications-windows-push-notification-services--wns--overview\\n\"\"\"\\n\\nimport json\\nimport xml.etree.ElementTree as ET\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import HTTPError, Request, urlencode, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import NotificationError\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass WNSError(NotificationError):\\n\\tpass\\n\\n\\nclass WNSAuthenticationError(WNSError):\\n\\tpass\\n\\n\\nclass WNSNotificationResponseError(WNSError):\\n\\tpass\\n\\n\\ndef _wns_authenticate(scope=\"notify.windows.com\", application_id=None):\\n\\t\"\"\"\\n\\tRequests an Access token for WNS communication.\\n\\n\\t:return: dict: {\\'access_token\\': <str>, \\'expires_in\\': <int>, \\'token_type\\': \\'bearer\\'}\\n\\t\"\"\"\\n\\tclient_id = get_manager().get_wns_package_security_id(application_id)\\n\\tclient_secret = get_manager().get_wns_secret_key(application_id)\\n\\tif not client_id:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_PACKAGE_SECURITY_ID\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\tif not client_secret:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_SECRET_KEY\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": \"application/x-www-form-urlencoded\",\\n\\t}\\n\\tparams = {\\n\\t\\t\"grant_type\": \"client_credentials\",\\n\\t\\t\"client_id\": client_id,\\n\\t\\t\"client_secret\": client_secret,\\n\\t\\t\"scope\": scope,\\n\\t}\\n\\tdata = urlencode(params).encode(\"utf-8\")\\n\\n\\trequest = Request(SETTINGS[\"WNS_ACCESS_URL\"], data=data, headers=headers)\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\t# One of your settings is probably jacked up.\\n\\t\\t\\t# https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh868245\\n\\t\\t\\traise WNSAuthenticationError(\"Authentication failed, check your WNS settings.\")\\n\\t\\traise err\\n\\n\\toauth_data = response.read().decode(\"utf-8\")\\n\\ttry:\\n\\t\\toauth_data = json.loads(oauth_data)\\n\\texcept Exception:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Received invalid JSON data from WNS.\")\\n\\n\\taccess_token = oauth_data.get(\"access_token\")\\n\\tif not access_token:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Access token missing from WNS response.\")\\n\\n\\treturn access_token\\n\\n\\ndef _wns_send(uri, data, wns_type=\"wns/toast\", application_id=None):\\n\\t\"\"\"\\n\\tSends a notification data and authentication to WNS.\\n\\n\\t:param uri: str: The device\\'s unique notification URI\\n\\t:param data: dict: The notification data to be sent.\\n\\t:return:\\n\\t\"\"\"\\n\\taccess_token = _wns_authenticate(application_id=application_id)\\n\\n\\tcontent_type = \"text/xml\"\\n\\tif wns_type == \"wns/raw\":\\n\\t\\tcontent_type = \"application/octet-stream\"\\n\\n\\theaders = {\\n\\t\\t# content_type is \"text/xml\" (toast/badge/tile) | \"application/octet-stream\" (raw)\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"Bearer %s\" % (access_token),\\n\\t\\t\"X-WNS-Type\": wns_type,  # wns/toast | wns/badge | wns/tile | wns/raw\\n\\t}\\n\\n\\tif type(data) is str:\\n\\t\\tdata = data.encode(\"utf-8\")\\n\\n\\trequest = Request(uri, data, headers)\\n\\n\\t# A lot of things can happen, let them know which one.\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\tmsg = \"One or more headers were specified incorrectly or conflict with another header.\"\\n\\t\\telif err.code == 401:\\n\\t\\t\\tmsg = \"The cloud service did not present a valid authentication ticket.\"\\n\\t\\telif err.code == 403:\\n\\t\\t\\tmsg = \"The cloud service is not authorized to send a notification to this URI.\"\\n\\t\\telif err.code == 404:\\n\\t\\t\\tmsg = \"The channel URI is not valid or is not recognized by WNS.\"\\n\\t\\telif err.code == 405:\\n\\t\\t\\tmsg = \"Invalid method. Only POST or DELETE is allowed.\"\\n\\t\\telif err.code == 406:\\n\\t\\t\\tmsg = \"The cloud service exceeded its throttle limit\"\\n\\t\\telif err.code == 410:\\n\\t\\t\\tmsg = \"The channel expired.\"\\n\\t\\telif err.code == 413:\\n\\t\\t\\tmsg = \"The notification payload exceeds the 500 byte limit.\"\\n\\t\\telif err.code == 500:\\n\\t\\t\\tmsg = \"An internal failure caused notification delivery to fail.\"\\n\\t\\telif err.code == 503:\\n\\t\\t\\tmsg = \"The server is currently unavailable.\"\\n\\t\\telse:\\n\\t\\t\\traise err\\n\\t\\traise WNSNotificationResponseError(\"HTTP %i: %s\" % (err.code, msg))\\n\\n\\treturn response.read().decode(\"utf-8\")\\n\\n\\ndef _wns_prepare_toast(data, **kwargs):\\n\\t\"\"\"\\n\\tCreates the xml tree for a `toast` notification\\n\\n\\t:param data: dict: The notification data to be converted to an xml tree.\\n\\n\\t{\\n\\t\\t\"text\": [\"Title text\", \"Message Text\", \"Another message!\"],\\n\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t}\\n\\n\\t:return: str\\n\\t\"\"\"\\n\\troot = ET.Element(\"toast\")\\n\\tvisual = ET.SubElement(root, \"visual\")\\n\\tbinding = ET.SubElement(visual, \"binding\")\\n\\tbinding.attrib[\"template\"] = kwargs.pop(\"template\", \"ToastText01\")\\n\\tif \"text\" in data:\\n\\t\\tfor count, item in enumerate(data[\"text\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"text\")\\n\\t\\t\\telem.text = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\tif \"image\" in data:\\n\\t\\tfor count, item in enumerate(data[\"image\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"img\")\\n\\t\\t\\telem.attrib[\"src\"] = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\treturn ET.tostring(root)\\n\\n\\ndef wns_send_message(\\n\\turi, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a notification request to WNS.\\n\\tThere are four notification types that WNS can send: toast, tile, badge and raw.\\n\\tToast, tile, and badge can all be customized to use different\\n\\ttemplates/icons/sounds/launch params/etc.\\n\\tSee docs for more information:\\n\\thttps://msdn.microsoft.com/en-us/library/windows/apps/br212853.aspx\\n\\n\\tThere are multiple ways to input notification data:\\n\\n\\t1. The simplest and least custom notification to send is to just pass a string\\n\\tto `message`. This will create a toast notification with one text element. e.g.:\\n\\t\\t\"This is my notification title\"\\n\\n\\t2. You can also pass a dictionary to `message`: it can only contain one or both\\n\\tkeys: [\"text\", \"image\"]. The value of each key must be a list with the text and\\n\\tsrc respectively. e.g.:\\n\\t\\t{\\n\\t\\t\\t\"text\": [\"text1\", \"text2\"],\\n\\t\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t\\t}\\n\\n\\t3. Passing a dictionary to `xml_data` will create one of three types of\\n\\tnotifications depending on the dictionary data (toast, tile, badge).\\n\\tSee `dict_to_xml_schema` docs for more information on dictionary formatting.\\n\\n\\t4. Passing a value to `raw_data` will create a `raw` notification and send the\\n\\tinput data as is.\\n\\n\\t:param uri: str: The device\\'s unique notification uri.\\n\\t:param message: str|dict: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\t# Create a simple toast notification\\n\\tif message:\\n\\t\\twns_type = \"wns/toast\"\\n\\t\\tif isinstance(message, str):\\n\\t\\t\\tmessage = {\\n\\t\\t\\t\\t\"text\": [message, ],\\n\\t\\t\\t}\\n\\t\\tprepared_data = _wns_prepare_toast(data=message, **kwargs)\\n\\t# Create a toast/tile/badge notification from a dictionary\\n\\telif xml_data:\\n\\t\\txml = dict_to_xml_schema(xml_data)\\n\\t\\twns_type = \"wns/%s\" % xml.tag\\n\\t\\tprepared_data = ET.tostring(xml)\\n\\t# Create a raw notification\\n\\telif raw_data:\\n\\t\\twns_type = \"wns/raw\"\\n\\t\\tprepared_data = raw_data\\n\\telse:\\n\\t\\traise TypeError(\\n\\t\\t\\t\"At least one of the following parameters must be set:\"\\n\\t\\t\\t\"`message`, `xml_data`, `raw_data`\"\\n\\t\\t)\\n\\n\\treturn _wns_send(\\n\\t\\turi=uri, data=prepared_data, wns_type=wns_type, application_id=application_id\\n\\t)\\n\\n\\ndef wns_send_bulk_message(\\n\\turi_list, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tWNS doesn\\'t support bulk notification, so we loop through each uri.\\n\\n\\t:param uri_list: list: A list of uris the notification will be sent to.\\n\\t:param message: str: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\tres = []\\n\\tif uri_list:\\n\\t\\tfor uri in uri_list:\\n\\t\\t\\tr = wns_send_message(\\n\\t\\t\\t\\turi=uri, message=message, xml_data=xml_data,\\n\\t\\t\\t\\traw_data=raw_data, application_id=application_id, **kwargs\\n\\t\\t\\t)\\n\\t\\t\\tres.append(r)\\n\\treturn res\\n\\n\\ndef dict_to_xml_schema(data):\\n\\t\"\"\"\\n\\tInput a dictionary to be converted to xml. There should be only one key at\\n\\tthe top level. The value must be a dict with (required) `children` key and\\n\\t(optional) `attrs` key. This will be called the `sub-element dictionary`.\\n\\n\\tThe `attrs` value must be a dictionary; each value will be added to the\\n\\telement\\'s xml tag as attributes. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\n\\twould result in:\\n\\t\\t<example key1=\"value1\" key2=\"value2\"></example>\\n\\n\\tIf the value is a dict it must contain one or more keys which will be used\\n\\tas the sub-element names. Each sub-element must have a value of a sub-element\\n\\tdictionary(see above) or a list of sub-element dictionaries.\\n\\tIf the value is not a dict, it will be the value of the element.\\n\\tIf the value is a list, multiple elements of the same tag will be created\\n\\tfrom each sub-element dict in the list.\\n\\n\\t:param data: dict: Used to create an XML tree. e.g.:\\n\\t\\texample_data = {\\n\\t\\t\\t\"toast\": {\\n\\t\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\\t\"launch\": \"param\",\\n\\t\\t\\t\\t\\t\"duration\": \"short\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\"visual\": {\\n\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\"binding\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"template\": \"ToastText01\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"text\": [\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"1\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text1\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"2\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text2\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor key, value in data.items():\\n\\t\\troot = _add_element_attrs(ET.Element(key), value.get(\"attrs\", {}))\\n\\t\\tchildren = value.get(\"children\", None)\\n\\t\\tif isinstance(children, dict):\\n\\t\\t\\t_add_sub_elements_from_dict(root, children)\\n\\t\\treturn root\\n\\n\\ndef _add_sub_elements_from_dict(parent, sub_dict):\\n\\t\"\"\"\\n\\tAdd SubElements to the parent element.\\n\\n\\t:param parent: ElementTree.Element: The parent element for the newly created SubElement.\\n\\t:param sub_dict: dict: Used to create a new SubElement. See `dict_to_xml_schema`\\n\\tmethod docstring for more information. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\t\"\"\"\\n\\tfor key, value in sub_dict.items():\\n\\t\\tif isinstance(value, list):\\n\\t\\t\\tfor repeated_element in value:\\n\\t\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t\\t_add_element_attrs(sub_element, repeated_element.get(\"attrs\", {}))\\n\\t\\t\\t\\tchildren = repeated_element.get(\"children\", None)\\n\\t\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\t\\tsub_element.text = children\\n\\t\\telse:\\n\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t_add_element_attrs(sub_element, value.get(\"attrs\", {}))\\n\\t\\t\\tchildren = value.get(\"children\", None)\\n\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\tsub_element.text = children\\n\\n\\ndef _add_element_attrs(elem, attrs):\\n\\t\"\"\"\\n\\tAdd attributes to the given element.\\n\\n\\t:param elem: ElementTree.Element: The element the attributes are being added to.\\n\\t:param attrs: dict: A dictionary of attributes. e.g.:\\n\\t\\t{\"attribute1\": \"value\", \"attribute2\": \"another\"}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor attr, value in attrs.items():\\n\\t\\telem.attrib[attr] = value\\n\\treturn elem\\n'"}, "return_value": "'\"\"\"\\nWindows Notification Service\\n\\nDocumentation is available on the Windows Dev Center:\\nhttps://msdn.microsoft.com/en-us/windows/uwp/controls-and-patterns/tiles-and-notifications-windows-push-notification-services--wns--overview\\n\"\"\"\\n\\nimport json\\nimport xml.etree.ElementTree as ET\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import HTTPError, Request, urlencode, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import NotificationError\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass WNSError(NotificationError):\\n\\tpass\\n\\n\\nclass WNSAuthenticationError(WNSError):\\n\\tpass\\n\\n\\nclass WNSNotificationResponseError(WNSError):\\n\\tpass\\n\\n\\ndef _wns_authenticate(scope=\"notify.windows.com\", application_id=None):\\n\\t\"\"\"\\n\\tRequests an Access token for WNS communication.\\n\\n\\t:return: dict: {\\'access_token\\': <str>, \\'expires_in\\': <int>, \\'token_type\\': \\'bearer\\'}\\n\\t\"\"\"\\n\\tclient_id = get_manager().get_wns_package_security_id(application_id)\\n\\tclient_secret = get_manager().get_wns_secret_key(application_id)\\n\\tif not client_id:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_PACKAGE_SECURITY_ID\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\tif not client_secret:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_SECRET_KEY\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": \"application/x-www-form-urlencoded\",\\n\\t}\\n\\tparams = {\\n\\t\\t\"grant_type\": \"client_credentials\",\\n\\t\\t\"client_id\": client_id,\\n\\t\\t\"client_secret\": client_secret,\\n\\t\\t\"scope\": scope,\\n\\t}\\n\\tdata = urlencode(params).encode(\"utf-8\")\\n\\n\\trequest = Request(SETTINGS[\"WNS_ACCESS_URL\"], data=data, headers=headers)\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\t# One of your settings is probably jacked up.\\n\\t\\t\\t# https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh868245\\n\\t\\t\\traise WNSAuthenticationError(\"Authentication failed, check your WNS settings.\")\\n\\t\\traise err\\n\\n\\toauth_data = response.read().decode(\"utf-8\")\\n\\ttry:\\n\\t\\toauth_data = json.loads(oauth_data)\\n\\texcept Exception:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Received invalid JSON data from WNS.\")\\n\\n\\taccess_token = oauth_data.get(\"access_token\")\\n\\tif not access_token:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Access token missing from WNS response.\")\\n\\n\\treturn access_token\\n\\n\\ndef _wns_send(uri, data, wns_type=\"wns/toast\", application_id=None):\\n\\t\"\"\"\\n\\tSends a notification data and authentication to WNS.\\n\\n\\t:param uri: str: The device\\'s unique notification URI\\n\\t:param data: dict: The notification data to be sent.\\n\\t:return:\\n\\t\"\"\"\\n\\taccess_token = _wns_authenticate(application_id=application_id)\\n\\n\\tcontent_type = \"text/xml\"\\n\\tif wns_type == \"wns/raw\":\\n\\t\\tcontent_type = \"application/octet-stream\"\\n\\n\\theaders = {\\n\\t\\t# content_type is \"text/xml\" (toast/badge/tile) | \"application/octet-stream\" (raw)\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"Bearer %s\" % (access_token),\\n\\t\\t\"X-WNS-Type\": wns_type,  # wns/toast | wns/badge | wns/tile | wns/raw\\n\\t}\\n\\n\\tif type(data) is str:\\n\\t\\tdata = data.encode(\"utf-8\")\\n\\n\\trequest = Request(uri, data, headers)\\n\\n\\t# A lot of things can happen, let them know which one.\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\tmsg = \"One or more headers were specified incorrectly or conflict with another header.\"\\n\\t\\telif err.code == 401:\\n\\t\\t\\tmsg = \"The cloud service did not present a valid authentication ticket.\"\\n\\t\\telif err.code == 403:\\n\\t\\t\\tmsg = \"The cloud service is not authorized to send a notification to this URI.\"\\n\\t\\telif err.code == 404:\\n\\t\\t\\tmsg = \"The channel URI is not valid or is not recognized by WNS.\"\\n\\t\\telif err.code == 405:\\n\\t\\t\\tmsg = \"Invalid method. Only POST or DELETE is allowed.\"\\n\\t\\telif err.code == 406:\\n\\t\\t\\tmsg = \"The cloud service exceeded its throttle limit\"\\n\\t\\telif err.code == 410:\\n\\t\\t\\tmsg = \"The channel expired.\"\\n\\t\\telif err.code == 413:\\n\\t\\t\\tmsg = \"The notification payload exceeds the 500 byte limit.\"\\n\\t\\telif err.code == 500:\\n\\t\\t\\tmsg = \"An internal failure caused notification delivery to fail.\"\\n\\t\\telif err.code == 503:\\n\\t\\t\\tmsg = \"The server is currently unavailable.\"\\n\\t\\telse:\\n\\t\\t\\traise err\\n\\t\\traise WNSNotificationResponseError(\"HTTP %i: %s\" % (err.code, msg))\\n\\n\\treturn response.read().decode(\"utf-8\")\\n\\n\\ndef _wns_prepare_toast(data, **kwargs):\\n\\t\"\"\"\\n\\tCreates the xml tree for a `toast` notification\\n\\n\\t:param data: dict: The notification data to be converted to an xml tree.\\n\\n\\t{\\n\\t\\t\"text\": [\"Title text\", \"Message Text\", \"Another message!\"],\\n\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t}\\n\\n\\t:return: str\\n\\t\"\"\"\\n\\troot = ET.Element(\"toast\")\\n\\tvisual = ET.SubElement(root, \"visual\")\\n\\tbinding = ET.SubElement(visual, \"binding\")\\n\\tbinding.attrib[\"template\"] = kwargs.pop(\"template\", \"ToastText01\")\\n\\tif \"text\" in data:\\n\\t\\tfor count, item in enumerate(data[\"text\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"text\")\\n\\t\\t\\telem.text = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\tif \"image\" in data:\\n\\t\\tfor count, item in enumerate(data[\"image\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"img\")\\n\\t\\t\\telem.attrib[\"src\"] = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\treturn ET.tostring(root)\\n\\n\\ndef wns_send_message(\\n\\turi, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a notification request to WNS.\\n\\tThere are four notification types that WNS can send: toast, tile, badge and raw.\\n\\tToast, tile, and badge can all be customized to use different\\n\\ttemplates/icons/sounds/launch params/etc.\\n\\tSee docs for more information:\\n\\thttps://msdn.microsoft.com/en-us/library/windows/apps/br212853.aspx\\n\\n\\tThere are multiple ways to input notification data:\\n\\n\\t1. The simplest and least custom notification to send is to just pass a string\\n\\tto `message`. This will create a toast notification with one text element. e.g.:\\n\\t\\t\"This is my notification title\"\\n\\n\\t2. You can also pass a dictionary to `message`: it can only contain one or both\\n\\tkeys: [\"text\", \"image\"]. The value of each key must be a list with the text and\\n\\tsrc respectively. e.g.:\\n\\t\\t{\\n\\t\\t\\t\"text\": [\"text1\", \"text2\"],\\n\\t\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t\\t}\\n\\n\\t3. Passing a dictionary to `xml_data` will create one of three types of\\n\\tnotifications depending on the dictionary data (toast, tile, badge).\\n\\tSee `dict_to_xml_schema` docs for more information on dictionary formatting.\\n\\n\\t4. Passing a value to `raw_data` will create a `raw` notification and send the\\n\\tinput data as is.\\n\\n\\t:param uri: str: The device\\'s unique notification uri.\\n\\t:param message: str|dict: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\t# Create a simple toast notification\\n\\tif message:\\n\\t\\twns_type = \"wns/toast\"\\n\\t\\tif isinstance(message, str):\\n\\t\\t\\tmessage = {\\n\\t\\t\\t\\t\"text\": [message, ],\\n\\t\\t\\t}\\n\\t\\tprepared_data = _wns_prepare_toast(data=message, **kwargs)\\n\\t# Create a toast/tile/badge notification from a dictionary\\n\\telif xml_data:\\n\\t\\txml = dict_to_xml_schema(xml_data)\\n\\t\\twns_type = \"wns/%s\" % xml.tag\\n\\t\\tprepared_data = ET.tostring(xml)\\n\\t# Create a raw notification\\n\\telif raw_data:\\n\\t\\twns_type = \"wns/raw\"\\n\\t\\tprepared_data = raw_data\\n\\telse:\\n\\t\\traise TypeError(\\n\\t\\t\\t\"At least one of the following parameters must be set:\"\\n\\t\\t\\t\"`message`, `xml_data`, `raw_data`\"\\n\\t\\t)\\n\\n\\treturn _wns_send(\\n\\t\\turi=uri, data=prepared_data, wns_type=wns_type, application_id=application_id\\n\\t)\\n\\n\\ndef wns_send_bulk_message(\\n\\turi_list, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tWNS doesn\\'t support bulk notification, so we loop through each uri.\\n\\n\\t:param uri_list: list: A list of uris the notification will be sent to.\\n\\t:param message: str: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\tres = []\\n\\tif uri_list:\\n\\t\\tfor uri in uri_list:\\n\\t\\t\\tr = wns_send_message(\\n\\t\\t\\t\\turi=uri, message=message, xml_data=xml_data,\\n\\t\\t\\t\\traw_data=raw_data, application_id=application_id, **kwargs\\n\\t\\t\\t)\\n\\t\\t\\tres.append(r)\\n\\treturn res\\n\\n\\ndef dict_to_xml_schema(data):\\n\\t\"\"\"\\n\\tInput a dictionary to be converted to xml. There should be only one key at\\n\\tthe top level. The value must be a dict with (required) `children` key and\\n\\t(optional) `attrs` key. This will be called the `sub-element dictionary`.\\n\\n\\tThe `attrs` value must be a dictionary; each value will be added to the\\n\\telement\\'s xml tag as attributes. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\n\\twould result in:\\n\\t\\t<example key1=\"value1\" key2=\"value2\"></example>\\n\\n\\tIf the value is a dict it must contain one or more keys which will be used\\n\\tas the sub-element names. Each sub-element must have a value of a sub-element\\n\\tdictionary(see above) or a list of sub-element dictionaries.\\n\\tIf the value is not a dict, it will be the value of the element.\\n\\tIf the value is a list, multiple elements of the same tag will be created\\n\\tfrom each sub-element dict in the list.\\n\\n\\t:param data: dict: Used to create an XML tree. e.g.:\\n\\t\\texample_data = {\\n\\t\\t\\t\"toast\": {\\n\\t\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\\t\"launch\": \"param\",\\n\\t\\t\\t\\t\\t\"duration\": \"short\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\"visual\": {\\n\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\"binding\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"template\": \"ToastText01\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"text\": [\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"1\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text1\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"2\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text2\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor key, value in data.items():\\n\\t\\troot = _add_element_attrs(ET.Element(key), value.get(\"attrs\", {}))\\n\\t\\tchildren = value.get(\"children\", None)\\n\\t\\tif isinstance(children, dict):\\n\\t\\t\\t_add_sub_elements_from_dict(root, children)\\n\\t\\treturn root\\n\\n\\ndef _add_sub_elements_from_dict(parent, sub_dict):\\n\\t\"\"\"\\n\\tAdd SubElements to the parent element.\\n\\n\\t:param parent: ElementTree.Element: The parent element for the newly created SubElement.\\n\\t:param sub_dict: dict: Used to create a new SubElement. See `dict_to_xml_schema`\\n\\tmethod docstring for more information. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\t\"\"\"\\n\\tfor key, value in sub_dict.items():\\n\\t\\tif isinstance(value, list):\\n\\t\\t\\tfor repeated_element in value:\\n\\t\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t\\t_add_element_attrs(sub_element, repeated_element.get(\"attrs\", {}))\\n\\t\\t\\t\\tchildren = repeated_element.get(\"children\", None)\\n\\t\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\t\\tsub_element.text = children\\n\\t\\telse:\\n\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t_add_element_attrs(sub_element, value.get(\"attrs\", {}))\\n\\t\\t\\tchildren = value.get(\"children\", None)\\n\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\tsub_element.text = children\\n\\n\\ndef _add_element_attrs(elem, attrs):\\n\\t\"\"\"\\n\\tAdd attributes to the given element.\\n\\n\\t:param elem: ElementTree.Element: The element the attributes are being added to.\\n\\t:param attrs: dict: A dictionary of attributes. e.g.:\\n\\t\\t{\"attribute1\": \"value\", \"attribute2\": \"another\"}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor attr, value in attrs.items():\\n\\t\\telem.attrib[attr] = value\\n\\treturn elem\\n'"}, {"func_args": {"source": "'\"\"\"\\nWindows Notification Service\\n\\nDocumentation is available on the Windows Dev Center:\\nhttps://msdn.microsoft.com/en-us/windows/uwp/controls-and-patterns/tiles-and-notifications-windows-push-notification-services--wns--overview\\n\"\"\"\\n\\nimport json\\nimport xml.etree.ElementTree as ET\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import HTTPError, Request, urlencode, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import NotificationError\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass WNSError(NotificationError):\\n\\tpass\\n\\n\\nclass WNSAuthenticationError(WNSError):\\n\\tpass\\n\\n\\nclass WNSNotificationResponseError(WNSError):\\n\\tpass\\n\\n\\ndef _wns_authenticate(scope=\"notify.windows.com\", application_id=None):\\n\\t\"\"\"\\n\\tRequests an Access token for WNS communication.\\n\\n\\t:return: dict: {\\'access_token\\': <str>, \\'expires_in\\': <int>, \\'token_type\\': \\'bearer\\'}\\n\\t\"\"\"\\n\\tclient_id = get_manager().get_wns_package_security_id(application_id)\\n\\tclient_secret = get_manager().get_wns_secret_key(application_id)\\n\\tif not client_id:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_PACKAGE_SECURITY_ID\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\tif not client_secret:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_SECRET_KEY\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": \"application/x-www-form-urlencoded\",\\n\\t}\\n\\tparams = {\\n\\t\\t\"grant_type\": \"client_credentials\",\\n\\t\\t\"client_id\": client_id,\\n\\t\\t\"client_secret\": client_secret,\\n\\t\\t\"scope\": scope,\\n\\t}\\n\\tdata = urlencode(params).encode(\"utf-8\")\\n\\n\\trequest = Request(SETTINGS[\"WNS_ACCESS_URL\"], data=data, headers=headers)\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\t# One of your settings is probably jacked up.\\n\\t\\t\\t# https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh868245\\n\\t\\t\\traise WNSAuthenticationError(\"Authentication failed, check your WNS settings.\")\\n\\t\\traise err\\n\\n\\toauth_data = response.read().decode(\"utf-8\")\\n\\ttry:\\n\\t\\toauth_data = json.loads(oauth_data)\\n\\texcept Exception:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Received invalid JSON data from WNS.\")\\n\\n\\taccess_token = oauth_data.get(\"access_token\")\\n\\tif not access_token:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Access token missing from WNS response.\")\\n\\n\\treturn access_token\\n\\n\\ndef _wns_send(uri, data, wns_type=\"wns/toast\", application_id=None):\\n\\t\"\"\"\\n\\tSends a notification data and authentication to WNS.\\n\\n\\t:param uri: str: The device\\'s unique notification URI\\n\\t:param data: dict: The notification data to be sent.\\n\\t:return:\\n\\t\"\"\"\\n\\taccess_token = _wns_authenticate(application_id=application_id)\\n\\n\\tcontent_type = \"text/xml\"\\n\\tif wns_type == \"wns/raw\":\\n\\t\\tcontent_type = \"application/octet-stream\"\\n\\n\\theaders = {\\n\\t\\t# content_type is \"text/xml\" (toast/badge/tile) | \"application/octet-stream\" (raw)\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"Bearer %s\" % (access_token),\\n\\t\\t\"X-WNS-Type\": wns_type,  # wns/toast | wns/badge | wns/tile | wns/raw\\n\\t}\\n\\n\\tif type(data) is str:\\n\\t\\tdata = data.encode(\"utf-8\")\\n\\n\\trequest = Request(uri, data, headers)\\n\\n\\t# A lot of things can happen, let them know which one.\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\tmsg = \"One or more headers were specified incorrectly or conflict with another header.\"\\n\\t\\telif err.code == 401:\\n\\t\\t\\tmsg = \"The cloud service did not present a valid authentication ticket.\"\\n\\t\\telif err.code == 403:\\n\\t\\t\\tmsg = \"The cloud service is not authorized to send a notification to this URI.\"\\n\\t\\telif err.code == 404:\\n\\t\\t\\tmsg = \"The channel URI is not valid or is not recognized by WNS.\"\\n\\t\\telif err.code == 405:\\n\\t\\t\\tmsg = \"Invalid method. Only POST or DELETE is allowed.\"\\n\\t\\telif err.code == 406:\\n\\t\\t\\tmsg = \"The cloud service exceeded its throttle limit\"\\n\\t\\telif err.code == 410:\\n\\t\\t\\tmsg = \"The channel expired.\"\\n\\t\\telif err.code == 413:\\n\\t\\t\\tmsg = \"The notification payload exceeds the 500 byte limit.\"\\n\\t\\telif err.code == 500:\\n\\t\\t\\tmsg = \"An internal failure caused notification delivery to fail.\"\\n\\t\\telif err.code == 503:\\n\\t\\t\\tmsg = \"The server is currently unavailable.\"\\n\\t\\telse:\\n\\t\\t\\traise err\\n\\t\\traise WNSNotificationResponseError(\"HTTP %i: %s\" % (err.code, msg))\\n\\n\\treturn response.read().decode(\"utf-8\")\\n\\n\\ndef _wns_prepare_toast(data, **kwargs):\\n\\t\"\"\"\\n\\tCreates the xml tree for a `toast` notification\\n\\n\\t:param data: dict: The notification data to be converted to an xml tree.\\n\\n\\t{\\n\\t\\t\"text\": [\"Title text\", \"Message Text\", \"Another message!\"],\\n\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t}\\n\\n\\t:return: str\\n\\t\"\"\"\\n\\troot = ET.Element(\"toast\")\\n\\tvisual = ET.SubElement(root, \"visual\")\\n\\tbinding = ET.SubElement(visual, \"binding\")\\n\\tbinding.attrib[\"template\"] = kwargs.pop(\"template\", \"ToastText01\")\\n\\tif \"text\" in data:\\n\\t\\tfor count, item in enumerate(data[\"text\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"text\")\\n\\t\\t\\telem.text = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\tif \"image\" in data:\\n\\t\\tfor count, item in enumerate(data[\"image\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"img\")\\n\\t\\t\\telem.attrib[\"src\"] = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\treturn ET.tostring(root)\\n\\n\\ndef wns_send_message(\\n\\turi, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a notification request to WNS.\\n\\tThere are four notification types that WNS can send: toast, tile, badge and raw.\\n\\tToast, tile, and badge can all be customized to use different\\n\\ttemplates/icons/sounds/launch params/etc.\\n\\tSee docs for more information:\\n\\thttps://msdn.microsoft.com/en-us/library/windows/apps/br212853.aspx\\n\\n\\tThere are multiple ways to input notification data:\\n\\n\\t1. The simplest and least custom notification to send is to just pass a string\\n\\tto `message`. This will create a toast notification with one text element. e.g.:\\n\\t\\t\"This is my notification title\"\\n\\n\\t2. You can also pass a dictionary to `message`: it can only contain one or both\\n\\tkeys: [\"text\", \"image\"]. The value of each key must be a list with the text and\\n\\tsrc respectively. e.g.:\\n\\t\\t{\\n\\t\\t\\t\"text\": [\"text1\", \"text2\"],\\n\\t\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t\\t}\\n\\n\\t3. Passing a dictionary to `xml_data` will create one of three types of\\n\\tnotifications depending on the dictionary data (toast, tile, badge).\\n\\tSee `dict_to_xml_schema` docs for more information on dictionary formatting.\\n\\n\\t4. Passing a value to `raw_data` will create a `raw` notification and send the\\n\\tinput data as is.\\n\\n\\t:param uri: str: The device\\'s unique notification uri.\\n\\t:param message: str|dict: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\t# Create a simple toast notification\\n\\tif message:\\n\\t\\twns_type = \"wns/toast\"\\n\\t\\tif isinstance(message, str):\\n\\t\\t\\tmessage = {\\n\\t\\t\\t\\t\"text\": [message, ],\\n\\t\\t\\t}\\n\\t\\tprepared_data = _wns_prepare_toast(data=message, **kwargs)\\n\\t# Create a toast/tile/badge notification from a dictionary\\n\\telif xml_data:\\n\\t\\txml = dict_to_xml_schema(xml_data)\\n\\t\\twns_type = \"wns/%s\" % xml.tag\\n\\t\\tprepared_data = ET.tostring(xml)\\n\\t# Create a raw notification\\n\\telif raw_data:\\n\\t\\twns_type = \"wns/raw\"\\n\\t\\tprepared_data = raw_data\\n\\telse:\\n\\t\\traise TypeError(\\n\\t\\t\\t\"At least one of the following parameters must be set:\"\\n\\t\\t\\t\"`message`, `xml_data`, `raw_data`\"\\n\\t\\t)\\n\\n\\treturn _wns_send(\\n\\t\\turi=uri, data=prepared_data, wns_type=wns_type, application_id=application_id\\n\\t)\\n\\n\\ndef wns_send_bulk_message(\\n\\turi_list, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tWNS doesn\\'t support bulk notification, so we loop through each uri.\\n\\n\\t:param uri_list: list: A list of uris the notification will be sent to.\\n\\t:param message: str: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\tres = []\\n\\tif uri_list:\\n\\t\\tfor uri in uri_list:\\n\\t\\t\\tr = wns_send_message(\\n\\t\\t\\t\\turi=uri, message=message, xml_data=xml_data,\\n\\t\\t\\t\\traw_data=raw_data, application_id=application_id, **kwargs\\n\\t\\t\\t)\\n\\t\\t\\tres.append(r)\\n\\treturn res\\n\\n\\ndef dict_to_xml_schema(data):\\n\\t\"\"\"\\n\\tInput a dictionary to be converted to xml. There should be only one key at\\n\\tthe top level. The value must be a dict with (required) `children` key and\\n\\t(optional) `attrs` key. This will be called the `sub-element dictionary`.\\n\\n\\tThe `attrs` value must be a dictionary; each value will be added to the\\n\\telement\\'s xml tag as attributes. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\n\\twould result in:\\n\\t\\t<example key1=\"value1\" key2=\"value2\"></example>\\n\\n\\tIf the value is a dict it must contain one or more keys which will be used\\n\\tas the sub-element names. Each sub-element must have a value of a sub-element\\n\\tdictionary(see above) or a list of sub-element dictionaries.\\n\\tIf the value is not a dict, it will be the value of the element.\\n\\tIf the value is a list, multiple elements of the same tag will be created\\n\\tfrom each sub-element dict in the list.\\n\\n\\t:param data: dict: Used to create an XML tree. e.g.:\\n\\t\\texample_data = {\\n\\t\\t\\t\"toast\": {\\n\\t\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\\t\"launch\": \"param\",\\n\\t\\t\\t\\t\\t\"duration\": \"short\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\"visual\": {\\n\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\"binding\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"template\": \"ToastText01\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"text\": [\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"1\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text1\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"2\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text2\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor key, value in data.items():\\n\\t\\troot = _add_element_attrs(ET.Element(key), value.get(\"attrs\", {}))\\n\\t\\tchildren = value.get(\"children\", None)\\n\\t\\tif isinstance(children, dict):\\n\\t\\t\\t_add_sub_elements_from_dict(root, children)\\n\\t\\treturn root\\n\\n\\ndef _add_sub_elements_from_dict(parent, sub_dict):\\n\\t\"\"\"\\n\\tAdd SubElements to the parent element.\\n\\n\\t:param parent: ElementTree.Element: The parent element for the newly created SubElement.\\n\\t:param sub_dict: dict: Used to create a new SubElement. See `dict_to_xml_schema`\\n\\tmethod docstring for more information. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\t\"\"\"\\n\\tfor key, value in sub_dict.items():\\n\\t\\tif isinstance(value, list):\\n\\t\\t\\tfor repeated_element in value:\\n\\t\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t\\t_add_element_attrs(sub_element, repeated_element.get(\"attrs\", {}))\\n\\t\\t\\t\\tchildren = repeated_element.get(\"children\", None)\\n\\t\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\t\\tsub_element.text = children\\n\\t\\telse:\\n\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t_add_element_attrs(sub_element, value.get(\"attrs\", {}))\\n\\t\\t\\tchildren = value.get(\"children\", None)\\n\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\tsub_element.text = children\\n\\n\\ndef _add_element_attrs(elem, attrs):\\n\\t\"\"\"\\n\\tAdd attributes to the given element.\\n\\n\\t:param elem: ElementTree.Element: The element the attributes are being added to.\\n\\t:param attrs: dict: A dictionary of attributes. e.g.:\\n\\t\\t{\"attribute1\": \"value\", \"attribute2\": \"another\"}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor attr, value in attrs.items():\\n\\t\\telem.attrib[attr] = value\\n\\treturn elem\\n'"}, "return_value": "'\"\"\"\\nWindows Notification Service\\n\\nDocumentation is available on the Windows Dev Center:\\nhttps://msdn.microsoft.com/en-us/windows/uwp/controls-and-patterns/tiles-and-notifications-windows-push-notification-services--wns--overview\\n\"\"\"\\n\\nimport json\\nimport xml.etree.ElementTree as ET\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import HTTPError, Request, urlencode, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import NotificationError\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass WNSError(NotificationError):\\n\\tpass\\n\\n\\nclass WNSAuthenticationError(WNSError):\\n\\tpass\\n\\n\\nclass WNSNotificationResponseError(WNSError):\\n\\tpass\\n\\n\\ndef _wns_authenticate(scope=\"notify.windows.com\", application_id=None):\\n\\t\"\"\"\\n\\tRequests an Access token for WNS communication.\\n\\n\\t:return: dict: {\\'access_token\\': <str>, \\'expires_in\\': <int>, \\'token_type\\': \\'bearer\\'}\\n\\t\"\"\"\\n\\tclient_id = get_manager().get_wns_package_security_id(application_id)\\n\\tclient_secret = get_manager().get_wns_secret_key(application_id)\\n\\tif not client_id:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_PACKAGE_SECURITY_ID\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\tif not client_secret:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_SECRET_KEY\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": \"application/x-www-form-urlencoded\",\\n\\t}\\n\\tparams = {\\n\\t\\t\"grant_type\": \"client_credentials\",\\n\\t\\t\"client_id\": client_id,\\n\\t\\t\"client_secret\": client_secret,\\n\\t\\t\"scope\": scope,\\n\\t}\\n\\tdata = urlencode(params).encode(\"utf-8\")\\n\\n\\trequest = Request(SETTINGS[\"WNS_ACCESS_URL\"], data=data, headers=headers)\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\t# One of your settings is probably jacked up.\\n\\t\\t\\t# https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh868245\\n\\t\\t\\traise WNSAuthenticationError(\"Authentication failed, check your WNS settings.\")\\n\\t\\traise err\\n\\n\\toauth_data = response.read().decode(\"utf-8\")\\n\\ttry:\\n\\t\\toauth_data = json.loads(oauth_data)\\n\\texcept Exception:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Received invalid JSON data from WNS.\")\\n\\n\\taccess_token = oauth_data.get(\"access_token\")\\n\\tif not access_token:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Access token missing from WNS response.\")\\n\\n\\treturn access_token\\n\\n\\ndef _wns_send(uri, data, wns_type=\"wns/toast\", application_id=None):\\n\\t\"\"\"\\n\\tSends a notification data and authentication to WNS.\\n\\n\\t:param uri: str: The device\\'s unique notification URI\\n\\t:param data: dict: The notification data to be sent.\\n\\t:return:\\n\\t\"\"\"\\n\\taccess_token = _wns_authenticate(application_id=application_id)\\n\\n\\tcontent_type = \"text/xml\"\\n\\tif wns_type == \"wns/raw\":\\n\\t\\tcontent_type = \"application/octet-stream\"\\n\\n\\theaders = {\\n\\t\\t# content_type is \"text/xml\" (toast/badge/tile) | \"application/octet-stream\" (raw)\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"Bearer %s\" % (access_token),\\n\\t\\t\"X-WNS-Type\": wns_type,  # wns/toast | wns/badge | wns/tile | wns/raw\\n\\t}\\n\\n\\tif type(data) is str:\\n\\t\\tdata = data.encode(\"utf-8\")\\n\\n\\trequest = Request(uri, data, headers)\\n\\n\\t# A lot of things can happen, let them know which one.\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\tmsg = \"One or more headers were specified incorrectly or conflict with another header.\"\\n\\t\\telif err.code == 401:\\n\\t\\t\\tmsg = \"The cloud service did not present a valid authentication ticket.\"\\n\\t\\telif err.code == 403:\\n\\t\\t\\tmsg = \"The cloud service is not authorized to send a notification to this URI.\"\\n\\t\\telif err.code == 404:\\n\\t\\t\\tmsg = \"The channel URI is not valid or is not recognized by WNS.\"\\n\\t\\telif err.code == 405:\\n\\t\\t\\tmsg = \"Invalid method. Only POST or DELETE is allowed.\"\\n\\t\\telif err.code == 406:\\n\\t\\t\\tmsg = \"The cloud service exceeded its throttle limit\"\\n\\t\\telif err.code == 410:\\n\\t\\t\\tmsg = \"The channel expired.\"\\n\\t\\telif err.code == 413:\\n\\t\\t\\tmsg = \"The notification payload exceeds the 500 byte limit.\"\\n\\t\\telif err.code == 500:\\n\\t\\t\\tmsg = \"An internal failure caused notification delivery to fail.\"\\n\\t\\telif err.code == 503:\\n\\t\\t\\tmsg = \"The server is currently unavailable.\"\\n\\t\\telse:\\n\\t\\t\\traise err\\n\\t\\traise WNSNotificationResponseError(\"HTTP %i: %s\" % (err.code, msg))\\n\\n\\treturn response.read().decode(\"utf-8\")\\n\\n\\ndef _wns_prepare_toast(data, **kwargs):\\n\\t\"\"\"\\n\\tCreates the xml tree for a `toast` notification\\n\\n\\t:param data: dict: The notification data to be converted to an xml tree.\\n\\n\\t{\\n\\t\\t\"text\": [\"Title text\", \"Message Text\", \"Another message!\"],\\n\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t}\\n\\n\\t:return: str\\n\\t\"\"\"\\n\\troot = ET.Element(\"toast\")\\n\\tvisual = ET.SubElement(root, \"visual\")\\n\\tbinding = ET.SubElement(visual, \"binding\")\\n\\tbinding.attrib[\"template\"] = kwargs.pop(\"template\", \"ToastText01\")\\n\\tif \"text\" in data:\\n\\t\\tfor count, item in enumerate(data[\"text\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"text\")\\n\\t\\t\\telem.text = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\tif \"image\" in data:\\n\\t\\tfor count, item in enumerate(data[\"image\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"img\")\\n\\t\\t\\telem.attrib[\"src\"] = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\treturn ET.tostring(root)\\n\\n\\ndef wns_send_message(\\n\\turi, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a notification request to WNS.\\n\\tThere are four notification types that WNS can send: toast, tile, badge and raw.\\n\\tToast, tile, and badge can all be customized to use different\\n\\ttemplates/icons/sounds/launch params/etc.\\n\\tSee docs for more information:\\n\\thttps://msdn.microsoft.com/en-us/library/windows/apps/br212853.aspx\\n\\n\\tThere are multiple ways to input notification data:\\n\\n\\t1. The simplest and least custom notification to send is to just pass a string\\n\\tto `message`. This will create a toast notification with one text element. e.g.:\\n\\t\\t\"This is my notification title\"\\n\\n\\t2. You can also pass a dictionary to `message`: it can only contain one or both\\n\\tkeys: [\"text\", \"image\"]. The value of each key must be a list with the text and\\n\\tsrc respectively. e.g.:\\n\\t\\t{\\n\\t\\t\\t\"text\": [\"text1\", \"text2\"],\\n\\t\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t\\t}\\n\\n\\t3. Passing a dictionary to `xml_data` will create one of three types of\\n\\tnotifications depending on the dictionary data (toast, tile, badge).\\n\\tSee `dict_to_xml_schema` docs for more information on dictionary formatting.\\n\\n\\t4. Passing a value to `raw_data` will create a `raw` notification and send the\\n\\tinput data as is.\\n\\n\\t:param uri: str: The device\\'s unique notification uri.\\n\\t:param message: str|dict: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\t# Create a simple toast notification\\n\\tif message:\\n\\t\\twns_type = \"wns/toast\"\\n\\t\\tif isinstance(message, str):\\n\\t\\t\\tmessage = {\\n\\t\\t\\t\\t\"text\": [message, ],\\n\\t\\t\\t}\\n\\t\\tprepared_data = _wns_prepare_toast(data=message, **kwargs)\\n\\t# Create a toast/tile/badge notification from a dictionary\\n\\telif xml_data:\\n\\t\\txml = dict_to_xml_schema(xml_data)\\n\\t\\twns_type = \"wns/%s\" % xml.tag\\n\\t\\tprepared_data = ET.tostring(xml)\\n\\t# Create a raw notification\\n\\telif raw_data:\\n\\t\\twns_type = \"wns/raw\"\\n\\t\\tprepared_data = raw_data\\n\\telse:\\n\\t\\traise TypeError(\\n\\t\\t\\t\"At least one of the following parameters must be set:\"\\n\\t\\t\\t\"`message`, `xml_data`, `raw_data`\"\\n\\t\\t)\\n\\n\\treturn _wns_send(\\n\\t\\turi=uri, data=prepared_data, wns_type=wns_type, application_id=application_id\\n\\t)\\n\\n\\ndef wns_send_bulk_message(\\n\\turi_list, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tWNS doesn\\'t support bulk notification, so we loop through each uri.\\n\\n\\t:param uri_list: list: A list of uris the notification will be sent to.\\n\\t:param message: str: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\tres = []\\n\\tif uri_list:\\n\\t\\tfor uri in uri_list:\\n\\t\\t\\tr = wns_send_message(\\n\\t\\t\\t\\turi=uri, message=message, xml_data=xml_data,\\n\\t\\t\\t\\traw_data=raw_data, application_id=application_id, **kwargs\\n\\t\\t\\t)\\n\\t\\t\\tres.append(r)\\n\\treturn res\\n\\n\\ndef dict_to_xml_schema(data):\\n\\t\"\"\"\\n\\tInput a dictionary to be converted to xml. There should be only one key at\\n\\tthe top level. The value must be a dict with (required) `children` key and\\n\\t(optional) `attrs` key. This will be called the `sub-element dictionary`.\\n\\n\\tThe `attrs` value must be a dictionary; each value will be added to the\\n\\telement\\'s xml tag as attributes. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\n\\twould result in:\\n\\t\\t<example key1=\"value1\" key2=\"value2\"></example>\\n\\n\\tIf the value is a dict it must contain one or more keys which will be used\\n\\tas the sub-element names. Each sub-element must have a value of a sub-element\\n\\tdictionary(see above) or a list of sub-element dictionaries.\\n\\tIf the value is not a dict, it will be the value of the element.\\n\\tIf the value is a list, multiple elements of the same tag will be created\\n\\tfrom each sub-element dict in the list.\\n\\n\\t:param data: dict: Used to create an XML tree. e.g.:\\n\\t\\texample_data = {\\n\\t\\t\\t\"toast\": {\\n\\t\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\\t\"launch\": \"param\",\\n\\t\\t\\t\\t\\t\"duration\": \"short\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\"visual\": {\\n\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\"binding\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"template\": \"ToastText01\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"text\": [\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"1\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text1\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"2\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text2\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor key, value in data.items():\\n\\t\\troot = _add_element_attrs(ET.Element(key), value.get(\"attrs\", {}))\\n\\t\\tchildren = value.get(\"children\", None)\\n\\t\\tif isinstance(children, dict):\\n\\t\\t\\t_add_sub_elements_from_dict(root, children)\\n\\t\\treturn root\\n\\n\\ndef _add_sub_elements_from_dict(parent, sub_dict):\\n\\t\"\"\"\\n\\tAdd SubElements to the parent element.\\n\\n\\t:param parent: ElementTree.Element: The parent element for the newly created SubElement.\\n\\t:param sub_dict: dict: Used to create a new SubElement. See `dict_to_xml_schema`\\n\\tmethod docstring for more information. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\t\"\"\"\\n\\tfor key, value in sub_dict.items():\\n\\t\\tif isinstance(value, list):\\n\\t\\t\\tfor repeated_element in value:\\n\\t\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t\\t_add_element_attrs(sub_element, repeated_element.get(\"attrs\", {}))\\n\\t\\t\\t\\tchildren = repeated_element.get(\"children\", None)\\n\\t\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\t\\tsub_element.text = children\\n\\t\\telse:\\n\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t_add_element_attrs(sub_element, value.get(\"attrs\", {}))\\n\\t\\t\\tchildren = value.get(\"children\", None)\\n\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\tsub_element.text = children\\n\\n\\ndef _add_element_attrs(elem, attrs):\\n\\t\"\"\"\\n\\tAdd attributes to the given element.\\n\\n\\t:param elem: ElementTree.Element: The element the attributes are being added to.\\n\\t:param attrs: dict: A dictionary of attributes. e.g.:\\n\\t\\t{\"attribute1\": \"value\", \"attribute2\": \"another\"}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor attr, value in attrs.items():\\n\\t\\telem.attrib[attr] = value\\n\\treturn elem\\n'"}, {"func_args": {"source": "'try:\\n    # Python 3.8+\\n    import importlib.metadata as importlib_metadata\\nexcept ImportError:\\n    # <Python 3.7 and lower\\n    import importlib_metadata\\n\\n__version__ = importlib_metadata.version(\"django-push-notifications\")\\n'"}, "return_value": "'try:\\n    # Python 3.8+\\n    import importlib.metadata as importlib_metadata\\nexcept ImportError:\\n    # <Python 3.7 and lower\\n    import importlib_metadata\\n\\n__version__ = importlib_metadata.version(\"django-push-notifications\")\\n'"}, {"func_args": {"source": "'try:\\n    # Python 3.8+\\n    import importlib.metadata as importlib_metadata\\nexcept ImportError:\\n    # <Python 3.7 and lower\\n    import importlib_metadata\\n\\n__version__ = importlib_metadata.version(\"django-push-notifications\")\\n'"}, "return_value": "'try:\\n    # Python 3.8+\\n    import importlib.metadata as importlib_metadata\\nexcept ImportError:\\n    # <Python 3.7 and lower\\n    import importlib_metadata\\n\\n__version__ = importlib_metadata.version(\"django-push-notifications\")\\n'"}, {"func_args": {"source": "'from django.apps import apps\\nfrom django.contrib import admin, messages\\nfrom django.utils.encoding import force_str\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .exceptions import APNSServerError, GCMError, WebPushError\\nfrom .models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nUser = apps.get_model(*SETTINGS[\"USER_MODEL\"].split(\".\"))\\n\\n\\nclass DeviceAdmin(admin.ModelAdmin):\\n\\tlist_display = (\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\",)\\n\\tactions = (\"send_message\", \"send_bulk_message\", \"enable\", \"disable\")\\n\\traw_id_fields = (\"user\",)\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"device_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"device_id\")\\n\\n\\tdef send_messages(self, request, queryset, bulk=False):\\n\\t\\t\"\"\"\\n\\t\\tProvides error handling for DeviceAdmin send_message and send_bulk_message methods.\\n\\t\\t\"\"\"\\n\\t\\tret = []\\n\\t\\terrors = []\\n\\t\\tr = \"\"\\n\\n\\t\\tfor device in queryset:\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tif bulk:\\n\\t\\t\\t\\t\\tr = queryset.send_message(\"Test bulk notification\")\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = device.send_message(\"Test single notification\")\\n\\t\\t\\t\\tif r:\\n\\t\\t\\t\\t\\tret.append(r)\\n\\t\\t\\texcept GCMError as e:\\n\\t\\t\\t\\terrors.append(str(e))\\n\\t\\t\\texcept APNSServerError as e:\\n\\t\\t\\t\\terrors.append(e.status)\\n\\t\\t\\texcept WebPushError as e:\\n\\t\\t\\t\\terrors.append(force_str(e))\\n\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\t# Because NotRegistered and InvalidRegistration do not throw GCMError\\n\\t\\t# catch them here to display error msg.\\n\\t\\tif not bulk:\\n\\t\\t\\tfor r in ret:\\n\\t\\t\\t\\tif \"error\" in r[\"results\"][0]:\\n\\t\\t\\t\\t\\terrors.append(r[\"results\"][0][\"error\"])\\n\\t\\telse:\\n\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\terrors = [r[\"error\"] for r in ret[0][0][\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\terrors = errors + [r[\"error\"] for r in entry[\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept IndexError:\\n\\t\\t\\t\\t\\tpass\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\tif value.lower() != \"success\":\\n\\t\\t\\t\\t\\t\\terrors.append(value)\\n\\t\\tif errors:\\n\\t\\t\\tself.message_user(\\n\\t\\t\\t\\trequest, _(\"Some messages could not be processed: %r\" % (\", \".join(errors))),\\n\\t\\t\\t\\tlevel=messages.ERROR\\n\\t\\t\\t)\\n\\t\\tif ret:\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\t# When the queryset exceeds the max_recipients value, the\\n\\t\\t\\t\\t# send_message method returns a list of dicts, one per chunk\\n\\t\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\t\\tsuccess = ret[0][0][\"success\"]\\n\\t\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\t\\tsuccess = 0\\n\\t\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\t\\tsuccess = success + entry[\"success\"]\\n\\t\\t\\t\\t\\tif success == 0:\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\t\\tsuccess = []\\n\\t\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\t\\tif value.lower() == \"success\":\\n\\t\\t\\t\\t\\t\\t\\tsuccess.append(key)\\n\\n\\t\\t\\telif len(errors) == len(ret):\\n\\t\\t\\t\\treturn\\n\\t\\t\\tif errors:\\n\\t\\t\\t\\tmsg = _(\"Some messages were sent: %s\" % (ret))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = _(\"All messages were sent: %s\" % (ret))\\n\\t\\t\\tself.message_user(request, msg)\\n\\n\\tdef send_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset)\\n\\n\\tsend_message.short_description = _(\"Send test message\")\\n\\n\\tdef send_bulk_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset, True)\\n\\n\\tsend_bulk_message.short_description = _(\"Send test message in bulk\")\\n\\n\\tdef enable(self, request, queryset):\\n\\t\\tqueryset.update(active=True)\\n\\n\\tenable.short_description = _(\"Enable selected devices\")\\n\\n\\tdef disable(self, request, queryset):\\n\\t\\tqueryset.update(active=False)\\n\\n\\tdisable.short_description = _(\"Disable selected devices\")\\n\\n\\nclass GCMDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\\n\\t\\t\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\", \"cloud_message_type\"\\n\\t)\\n\\tlist_filter = (\"active\", \"cloud_message_type\")\\n\\n\\nclass WebPushDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\"__str__\", \"browser\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\", \"browser\")\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"registration_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"registration_id\")\\n\\n\\nadmin.site.register(APNSDevice, DeviceAdmin)\\nadmin.site.register(GCMDevice, GCMDeviceAdmin)\\nadmin.site.register(WNSDevice, DeviceAdmin)\\nadmin.site.register(WebPushDevice, WebPushDeviceAdmin)\\n'"}, "return_value": "'from django.apps import apps\\nfrom django.contrib import admin, messages\\nfrom django.utils.encoding import force_str\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .exceptions import APNSServerError, GCMError, WebPushError\\nfrom .models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nUser = apps.get_model(*SETTINGS[\"USER_MODEL\"].split(\".\"))\\n\\n\\nclass DeviceAdmin(admin.ModelAdmin):\\n\\tlist_display = (\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\",)\\n\\tactions = (\"send_message\", \"send_bulk_message\", \"enable\", \"disable\")\\n\\traw_id_fields = (\"user\",)\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"device_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"device_id\")\\n\\n\\tdef send_messages(self, request, queryset, bulk=False):\\n\\t\\t\"\"\"\\n\\t\\tProvides error handling for DeviceAdmin send_message and send_bulk_message methods.\\n\\t\\t\"\"\"\\n\\t\\tret = []\\n\\t\\terrors = []\\n\\t\\tr = \"\"\\n\\n\\t\\tfor device in queryset:\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tif bulk:\\n\\t\\t\\t\\t\\tr = queryset.send_message(\"Test bulk notification\")\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = device.send_message(\"Test single notification\")\\n\\t\\t\\t\\tif r:\\n\\t\\t\\t\\t\\tret.append(r)\\n\\t\\t\\texcept GCMError as e:\\n\\t\\t\\t\\terrors.append(str(e))\\n\\t\\t\\texcept APNSServerError as e:\\n\\t\\t\\t\\terrors.append(e.status)\\n\\t\\t\\texcept WebPushError as e:\\n\\t\\t\\t\\terrors.append(force_str(e))\\n\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\t# Because NotRegistered and InvalidRegistration do not throw GCMError\\n\\t\\t# catch them here to display error msg.\\n\\t\\tif not bulk:\\n\\t\\t\\tfor r in ret:\\n\\t\\t\\t\\tif \"error\" in r[\"results\"][0]:\\n\\t\\t\\t\\t\\terrors.append(r[\"results\"][0][\"error\"])\\n\\t\\telse:\\n\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\terrors = [r[\"error\"] for r in ret[0][0][\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\terrors = errors + [r[\"error\"] for r in entry[\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept IndexError:\\n\\t\\t\\t\\t\\tpass\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\tif value.lower() != \"success\":\\n\\t\\t\\t\\t\\t\\terrors.append(value)\\n\\t\\tif errors:\\n\\t\\t\\tself.message_user(\\n\\t\\t\\t\\trequest, _(\"Some messages could not be processed: %r\" % (\", \".join(errors))),\\n\\t\\t\\t\\tlevel=messages.ERROR\\n\\t\\t\\t)\\n\\t\\tif ret:\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\t# When the queryset exceeds the max_recipients value, the\\n\\t\\t\\t\\t# send_message method returns a list of dicts, one per chunk\\n\\t\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\t\\tsuccess = ret[0][0][\"success\"]\\n\\t\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\t\\tsuccess = 0\\n\\t\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\t\\tsuccess = success + entry[\"success\"]\\n\\t\\t\\t\\t\\tif success == 0:\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\t\\tsuccess = []\\n\\t\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\t\\tif value.lower() == \"success\":\\n\\t\\t\\t\\t\\t\\t\\tsuccess.append(key)\\n\\n\\t\\t\\telif len(errors) == len(ret):\\n\\t\\t\\t\\treturn\\n\\t\\t\\tif errors:\\n\\t\\t\\t\\tmsg = _(\"Some messages were sent: %s\" % (ret))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = _(\"All messages were sent: %s\" % (ret))\\n\\t\\t\\tself.message_user(request, msg)\\n\\n\\tdef send_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset)\\n\\n\\tsend_message.short_description = _(\"Send test message\")\\n\\n\\tdef send_bulk_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset, True)\\n\\n\\tsend_bulk_message.short_description = _(\"Send test message in bulk\")\\n\\n\\tdef enable(self, request, queryset):\\n\\t\\tqueryset.update(active=True)\\n\\n\\tenable.short_description = _(\"Enable selected devices\")\\n\\n\\tdef disable(self, request, queryset):\\n\\t\\tqueryset.update(active=False)\\n\\n\\tdisable.short_description = _(\"Disable selected devices\")\\n\\n\\nclass GCMDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\\n\\t\\t\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\", \"cloud_message_type\"\\n\\t)\\n\\tlist_filter = (\"active\", \"cloud_message_type\")\\n\\n\\nclass WebPushDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\"__str__\", \"browser\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\", \"browser\")\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"registration_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"registration_id\")\\n\\n\\nadmin.site.register(APNSDevice, DeviceAdmin)\\nadmin.site.register(GCMDevice, GCMDeviceAdmin)\\nadmin.site.register(WNSDevice, DeviceAdmin)\\nadmin.site.register(WebPushDevice, WebPushDeviceAdmin)\\n'"}, {"func_args": {"source": "'from django.apps import apps\\nfrom django.contrib import admin, messages\\nfrom django.utils.encoding import force_str\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .exceptions import APNSServerError, GCMError, WebPushError\\nfrom .models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nUser = apps.get_model(*SETTINGS[\"USER_MODEL\"].split(\".\"))\\n\\n\\nclass DeviceAdmin(admin.ModelAdmin):\\n\\tlist_display = (\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\",)\\n\\tactions = (\"send_message\", \"send_bulk_message\", \"enable\", \"disable\")\\n\\traw_id_fields = (\"user\",)\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"device_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"device_id\")\\n\\n\\tdef send_messages(self, request, queryset, bulk=False):\\n\\t\\t\"\"\"\\n\\t\\tProvides error handling for DeviceAdmin send_message and send_bulk_message methods.\\n\\t\\t\"\"\"\\n\\t\\tret = []\\n\\t\\terrors = []\\n\\t\\tr = \"\"\\n\\n\\t\\tfor device in queryset:\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tif bulk:\\n\\t\\t\\t\\t\\tr = queryset.send_message(\"Test bulk notification\")\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = device.send_message(\"Test single notification\")\\n\\t\\t\\t\\tif r:\\n\\t\\t\\t\\t\\tret.append(r)\\n\\t\\t\\texcept GCMError as e:\\n\\t\\t\\t\\terrors.append(str(e))\\n\\t\\t\\texcept APNSServerError as e:\\n\\t\\t\\t\\terrors.append(e.status)\\n\\t\\t\\texcept WebPushError as e:\\n\\t\\t\\t\\terrors.append(force_str(e))\\n\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\t# Because NotRegistered and InvalidRegistration do not throw GCMError\\n\\t\\t# catch them here to display error msg.\\n\\t\\tif not bulk:\\n\\t\\t\\tfor r in ret:\\n\\t\\t\\t\\tif \"error\" in r[\"results\"][0]:\\n\\t\\t\\t\\t\\terrors.append(r[\"results\"][0][\"error\"])\\n\\t\\telse:\\n\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\terrors = [r[\"error\"] for r in ret[0][0][\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\terrors = errors + [r[\"error\"] for r in entry[\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept IndexError:\\n\\t\\t\\t\\t\\tpass\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\tif value.lower() != \"success\":\\n\\t\\t\\t\\t\\t\\terrors.append(value)\\n\\t\\tif errors:\\n\\t\\t\\tself.message_user(\\n\\t\\t\\t\\trequest, _(\"Some messages could not be processed: %r\" % (\", \".join(errors))),\\n\\t\\t\\t\\tlevel=messages.ERROR\\n\\t\\t\\t)\\n\\t\\tif ret:\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\t# When the queryset exceeds the max_recipients value, the\\n\\t\\t\\t\\t# send_message method returns a list of dicts, one per chunk\\n\\t\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\t\\tsuccess = ret[0][0][\"success\"]\\n\\t\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\t\\tsuccess = 0\\n\\t\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\t\\tsuccess = success + entry[\"success\"]\\n\\t\\t\\t\\t\\tif success == 0:\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\t\\tsuccess = []\\n\\t\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\t\\tif value.lower() == \"success\":\\n\\t\\t\\t\\t\\t\\t\\tsuccess.append(key)\\n\\n\\t\\t\\telif len(errors) == len(ret):\\n\\t\\t\\t\\treturn\\n\\t\\t\\tif errors:\\n\\t\\t\\t\\tmsg = _(\"Some messages were sent: %s\" % (ret))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = _(\"All messages were sent: %s\" % (ret))\\n\\t\\t\\tself.message_user(request, msg)\\n\\n\\tdef send_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset)\\n\\n\\tsend_message.short_description = _(\"Send test message\")\\n\\n\\tdef send_bulk_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset, True)\\n\\n\\tsend_bulk_message.short_description = _(\"Send test message in bulk\")\\n\\n\\tdef enable(self, request, queryset):\\n\\t\\tqueryset.update(active=True)\\n\\n\\tenable.short_description = _(\"Enable selected devices\")\\n\\n\\tdef disable(self, request, queryset):\\n\\t\\tqueryset.update(active=False)\\n\\n\\tdisable.short_description = _(\"Disable selected devices\")\\n\\n\\nclass GCMDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\\n\\t\\t\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\", \"cloud_message_type\"\\n\\t)\\n\\tlist_filter = (\"active\", \"cloud_message_type\")\\n\\n\\nclass WebPushDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\"__str__\", \"browser\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\", \"browser\")\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"registration_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"registration_id\")\\n\\n\\nadmin.site.register(APNSDevice, DeviceAdmin)\\nadmin.site.register(GCMDevice, GCMDeviceAdmin)\\nadmin.site.register(WNSDevice, DeviceAdmin)\\nadmin.site.register(WebPushDevice, WebPushDeviceAdmin)\\n'"}, "return_value": "'from django.apps import apps\\nfrom django.contrib import admin, messages\\nfrom django.utils.encoding import force_str\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .exceptions import APNSServerError, GCMError, WebPushError\\nfrom .models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nUser = apps.get_model(*SETTINGS[\"USER_MODEL\"].split(\".\"))\\n\\n\\nclass DeviceAdmin(admin.ModelAdmin):\\n\\tlist_display = (\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\",)\\n\\tactions = (\"send_message\", \"send_bulk_message\", \"enable\", \"disable\")\\n\\traw_id_fields = (\"user\",)\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"device_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"device_id\")\\n\\n\\tdef send_messages(self, request, queryset, bulk=False):\\n\\t\\t\"\"\"\\n\\t\\tProvides error handling for DeviceAdmin send_message and send_bulk_message methods.\\n\\t\\t\"\"\"\\n\\t\\tret = []\\n\\t\\terrors = []\\n\\t\\tr = \"\"\\n\\n\\t\\tfor device in queryset:\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tif bulk:\\n\\t\\t\\t\\t\\tr = queryset.send_message(\"Test bulk notification\")\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = device.send_message(\"Test single notification\")\\n\\t\\t\\t\\tif r:\\n\\t\\t\\t\\t\\tret.append(r)\\n\\t\\t\\texcept GCMError as e:\\n\\t\\t\\t\\terrors.append(str(e))\\n\\t\\t\\texcept APNSServerError as e:\\n\\t\\t\\t\\terrors.append(e.status)\\n\\t\\t\\texcept WebPushError as e:\\n\\t\\t\\t\\terrors.append(force_str(e))\\n\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\t# Because NotRegistered and InvalidRegistration do not throw GCMError\\n\\t\\t# catch them here to display error msg.\\n\\t\\tif not bulk:\\n\\t\\t\\tfor r in ret:\\n\\t\\t\\t\\tif \"error\" in r[\"results\"][0]:\\n\\t\\t\\t\\t\\terrors.append(r[\"results\"][0][\"error\"])\\n\\t\\telse:\\n\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\terrors = [r[\"error\"] for r in ret[0][0][\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\terrors = errors + [r[\"error\"] for r in entry[\"results\"] if \"error\" in r]\\n\\t\\t\\t\\texcept IndexError:\\n\\t\\t\\t\\t\\tpass\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\tif value.lower() != \"success\":\\n\\t\\t\\t\\t\\t\\terrors.append(value)\\n\\t\\tif errors:\\n\\t\\t\\tself.message_user(\\n\\t\\t\\t\\trequest, _(\"Some messages could not be processed: %r\" % (\", \".join(errors))),\\n\\t\\t\\t\\tlevel=messages.ERROR\\n\\t\\t\\t)\\n\\t\\tif ret:\\n\\t\\t\\tif bulk:\\n\\t\\t\\t\\t# When the queryset exceeds the max_recipients value, the\\n\\t\\t\\t\\t# send_message method returns a list of dicts, one per chunk\\n\\t\\t\\t\\tif \"results\" in ret[0][0]:\\n\\t\\t\\t\\t\\ttry:\\n\\t\\t\\t\\t\\t\\tsuccess = ret[0][0][\"success\"]\\n\\t\\t\\t\\t\\texcept TypeError:\\n\\t\\t\\t\\t\\t\\tsuccess = 0\\n\\t\\t\\t\\t\\t\\tfor entry in ret[0][0]:\\n\\t\\t\\t\\t\\t\\t\\tsuccess = success + entry[\"success\"]\\n\\t\\t\\t\\t\\tif success == 0:\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# different format, e.g.:\\n\\t\\t\\t\\t\\t# [{\\'some_token1\\': \\'Success\\',\\n\\t\\t\\t\\t\\t#  \\'some_token2\\': \\'BadDeviceToken\\'}]\\n\\t\\t\\t\\t\\tsuccess = []\\n\\t\\t\\t\\t\\tfor key, value in ret[0][0].items():\\n\\t\\t\\t\\t\\t\\tif value.lower() == \"success\":\\n\\t\\t\\t\\t\\t\\t\\tsuccess.append(key)\\n\\n\\t\\t\\telif len(errors) == len(ret):\\n\\t\\t\\t\\treturn\\n\\t\\t\\tif errors:\\n\\t\\t\\t\\tmsg = _(\"Some messages were sent: %s\" % (ret))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = _(\"All messages were sent: %s\" % (ret))\\n\\t\\t\\tself.message_user(request, msg)\\n\\n\\tdef send_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset)\\n\\n\\tsend_message.short_description = _(\"Send test message\")\\n\\n\\tdef send_bulk_message(self, request, queryset):\\n\\t\\tself.send_messages(request, queryset, True)\\n\\n\\tsend_bulk_message.short_description = _(\"Send test message in bulk\")\\n\\n\\tdef enable(self, request, queryset):\\n\\t\\tqueryset.update(active=True)\\n\\n\\tenable.short_description = _(\"Enable selected devices\")\\n\\n\\tdef disable(self, request, queryset):\\n\\t\\tqueryset.update(active=False)\\n\\n\\tdisable.short_description = _(\"Disable selected devices\")\\n\\n\\nclass GCMDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\\n\\t\\t\"__str__\", \"device_id\", \"user\", \"active\", \"date_created\", \"cloud_message_type\"\\n\\t)\\n\\tlist_filter = (\"active\", \"cloud_message_type\")\\n\\n\\nclass WebPushDeviceAdmin(DeviceAdmin):\\n\\tlist_display = (\"__str__\", \"browser\", \"user\", \"active\", \"date_created\")\\n\\tlist_filter = (\"active\", \"browser\")\\n\\n\\tif hasattr(User, \"USERNAME_FIELD\"):\\n\\t\\tsearch_fields = (\"name\", \"registration_id\", \"user__%s\" % (User.USERNAME_FIELD))\\n\\telse:\\n\\t\\tsearch_fields = (\"name\", \"registration_id\")\\n\\n\\nadmin.site.register(APNSDevice, DeviceAdmin)\\nadmin.site.register(GCMDevice, GCMDeviceAdmin)\\nadmin.site.register(WNSDevice, DeviceAdmin)\\nadmin.site.register(WebPushDevice, WebPushDeviceAdmin)\\n'"}, {"func_args": {"source": "''"}, "return_value": "''"}, {"func_args": {"source": "'from rest_framework import permissions, status\\nfrom rest_framework.fields import IntegerField\\nfrom rest_framework.response import Response\\nfrom rest_framework.serializers import ModelSerializer, Serializer, ValidationError\\nfrom rest_framework.viewsets import ModelViewSet\\n\\nfrom ..fields import UNSIGNED_64BIT_INT_MAX_VALUE, hex_re\\nfrom ..models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\n# Fields\\nclass HexIntegerField(IntegerField):\\n\\t\"\"\"\\n\\tStore an integer represented as a hex string of form \"0x01\".\\n\\t\"\"\"\\n\\n\\tdef to_internal_value(self, data):\\n\\t\\t# validate hex string and convert it to the unsigned\\n\\t\\t# integer representation for internal use\\n\\t\\ttry:\\n\\t\\t\\tdata = int(data, 16) if type(data) != int else data\\n\\t\\texcept ValueError:\\n\\t\\t\\traise ValidationError(\"Device ID is not a valid hex number\")\\n\\t\\treturn super(HexIntegerField, self).to_internal_value(data)\\n\\n\\tdef to_representation(self, value):\\n\\t\\treturn value\\n\\n\\n# Serializers\\nclass DeviceSerializerMixin(ModelSerializer):\\n\\tclass Meta:\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"application_id\", \"registration_id\", \"device_id\",\\n\\t\\t\\t\"active\", \"date_created\"\\n\\t\\t)\\n\\t\\tread_only_fields = (\"date_created\",)\\n\\n\\t\\t# See https://github.com/tomchristie/django-rest-framework/issues/1101\\n\\t\\textra_kwargs = {\"active\": {\"default\": True}}\\n\\n\\nclass APNSDeviceSerializer(ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = APNSDevice\\n\\n\\tdef validate_registration_id(self, value):\\n\\t\\t# iOS device tokens are 256-bit hexadecimal (64 characters). In 2016 Apple is increasing\\n\\t\\t# iOS device tokens to 100 bytes hexadecimal (200 characters).\\n\\n\\t\\tif hex_re.match(value) is None or len(value) not in (64, 200):\\n\\t\\t\\traise ValidationError(\"Registration ID (device token) is invalid\")\\n\\n\\t\\treturn value\\n\\n\\nclass UniqueRegistrationSerializerMixin(Serializer):\\n\\tdef validate(self, attrs):\\n\\t\\tdevices = None\\n\\t\\tprimary_key = None\\n\\t\\trequest_method = None\\n\\n\\t\\tif self.initial_data.get(\"registration_id\", None):\\n\\t\\t\\tif self.instance:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telse:\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\t\\telse:\\n\\t\\t\\tif self.context[\"request\"].method in [\"PUT\", \"PATCH\"]:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telif self.context[\"request\"].method == \"POST\":\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\n\\t\\tDevice = self.Meta.model\\n\\t\\tif request_method == \"update\":\\n\\t\\t\\treg_id = attrs.get(\"registration_id\", self.instance.registration_id)\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=reg_id) \\\\\\n\\t\\t\\t\\t.exclude(id=primary_key)\\n\\t\\telif request_method == \"create\":\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=attrs[\"registration_id\"])\\n\\n\\t\\tif devices:\\n\\t\\t\\traise ValidationError({\"registration_id\": \"This field must be unique.\"})\\n\\t\\treturn attrs\\n\\n\\nclass GCMDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tdevice_id = HexIntegerField(\\n\\t\\thelp_text=\"ANDROID_ID / TelephonyManager.getDeviceId() (e.g: 0x01)\",\\n\\t\\tstyle={\"input_type\": \"text\"},\\n\\t\\trequired=False,\\n\\t\\tallow_null=True\\n\\t)\\n\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = GCMDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"device_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"cloud_message_type\", \"application_id\",\\n\\t\\t)\\n\\t\\textra_kwargs = {\"id\": {\"read_only\": False, \"required\": False}}\\n\\n\\tdef validate_device_id(self, value):\\n\\t\\t# device ids are 64 bit unsigned values\\n\\t\\tif value > UNSIGNED_64BIT_INT_MAX_VALUE:\\n\\t\\t\\traise ValidationError(\"Device ID is out of range\")\\n\\t\\treturn value\\n\\n\\nclass WNSDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WNSDevice\\n\\n\\nclass WebPushDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WebPushDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"p256dh\", \"auth\", \"browser\", \"application_id\",\\n\\t\\t)\\n\\n\\n# Permissions\\nclass IsOwner(permissions.BasePermission):\\n\\tdef has_object_permission(self, request, view, obj):\\n\\t\\t# must be the owner to view the object\\n\\t\\treturn obj.user == request.user\\n\\n\\n# Mixins\\nclass DeviceViewSetMixin:\\n\\tlookup_field = \"registration_id\"\\n\\n\\tdef create(self, request, *args, **kwargs):\\n\\t\\tserializer = None\\n\\t\\tis_update = False\\n\\t\\tif SETTINGS.get(\"UPDATE_ON_DUPLICATE_REG_ID\") and self.lookup_field in request.data:\\n\\t\\t\\tinstance = self.queryset.model.objects.filter(\\n\\t\\t\\t\\tregistration_id=request.data[self.lookup_field]\\n\\t\\t\\t).first()\\n\\t\\t\\tif instance:\\n\\t\\t\\t\\tserializer = self.get_serializer(instance, data=request.data)\\n\\t\\t\\t\\tis_update = True\\n\\t\\tif not serializer:\\n\\t\\t\\tserializer = self.get_serializer(data=request.data)\\n\\n\\t\\tserializer.is_valid(raise_exception=True)\\n\\t\\tif is_update:\\n\\t\\t\\tself.perform_update(serializer)\\n\\t\\t\\treturn Response(serializer.data)\\n\\t\\telse:\\n\\t\\t\\tself.perform_create(serializer)\\n\\t\\t\\theaders = self.get_success_headers(serializer.data)\\n\\t\\t\\treturn Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\\n\\n\\tdef perform_create(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_create(serializer)\\n\\n\\tdef perform_update(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_update(serializer)\\n\\n\\nclass AuthorizedMixin:\\n\\tpermission_classes = (permissions.IsAuthenticated, IsOwner)\\n\\n\\tdef get_queryset(self):\\n\\t\\t# filter all devices to only those belonging to the current user\\n\\t\\treturn self.queryset.filter(user=self.request.user)\\n\\n\\n# ViewSets\\nclass APNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = APNSDevice.objects.all()\\n\\tserializer_class = APNSDeviceSerializer\\n\\n\\nclass APNSDeviceAuthorizedViewSet(AuthorizedMixin, APNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass GCMDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = GCMDevice.objects.all()\\n\\tserializer_class = GCMDeviceSerializer\\n\\n\\nclass GCMDeviceAuthorizedViewSet(AuthorizedMixin, GCMDeviceViewSet):\\n\\tpass\\n\\n\\nclass WNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WNSDevice.objects.all()\\n\\tserializer_class = WNSDeviceSerializer\\n\\n\\nclass WNSDeviceAuthorizedViewSet(AuthorizedMixin, WNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass WebPushDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WebPushDevice.objects.all()\\n\\tserializer_class = WebPushDeviceSerializer\\n\\n\\nclass WebPushDeviceAuthorizedViewSet(AuthorizedMixin, WebPushDeviceViewSet):\\n\\tpass\\n'"}, "return_value": "'from rest_framework import permissions, status\\nfrom rest_framework.fields import IntegerField\\nfrom rest_framework.response import Response\\nfrom rest_framework.serializers import ModelSerializer, Serializer, ValidationError\\nfrom rest_framework.viewsets import ModelViewSet\\n\\nfrom ..fields import UNSIGNED_64BIT_INT_MAX_VALUE, hex_re\\nfrom ..models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\n# Fields\\nclass HexIntegerField(IntegerField):\\n\\t\"\"\"\\n\\tStore an integer represented as a hex string of form \"0x01\".\\n\\t\"\"\"\\n\\n\\tdef to_internal_value(self, data):\\n\\t\\t# validate hex string and convert it to the unsigned\\n\\t\\t# integer representation for internal use\\n\\t\\ttry:\\n\\t\\t\\tdata = int(data, 16) if type(data) != int else data\\n\\t\\texcept ValueError:\\n\\t\\t\\traise ValidationError(\"Device ID is not a valid hex number\")\\n\\t\\treturn super(HexIntegerField, self).to_internal_value(data)\\n\\n\\tdef to_representation(self, value):\\n\\t\\treturn value\\n\\n\\n# Serializers\\nclass DeviceSerializerMixin(ModelSerializer):\\n\\tclass Meta:\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"application_id\", \"registration_id\", \"device_id\",\\n\\t\\t\\t\"active\", \"date_created\"\\n\\t\\t)\\n\\t\\tread_only_fields = (\"date_created\",)\\n\\n\\t\\t# See https://github.com/tomchristie/django-rest-framework/issues/1101\\n\\t\\textra_kwargs = {\"active\": {\"default\": True}}\\n\\n\\nclass APNSDeviceSerializer(ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = APNSDevice\\n\\n\\tdef validate_registration_id(self, value):\\n\\t\\t# iOS device tokens are 256-bit hexadecimal (64 characters). In 2016 Apple is increasing\\n\\t\\t# iOS device tokens to 100 bytes hexadecimal (200 characters).\\n\\n\\t\\tif hex_re.match(value) is None or len(value) not in (64, 200):\\n\\t\\t\\traise ValidationError(\"Registration ID (device token) is invalid\")\\n\\n\\t\\treturn value\\n\\n\\nclass UniqueRegistrationSerializerMixin(Serializer):\\n\\tdef validate(self, attrs):\\n\\t\\tdevices = None\\n\\t\\tprimary_key = None\\n\\t\\trequest_method = None\\n\\n\\t\\tif self.initial_data.get(\"registration_id\", None):\\n\\t\\t\\tif self.instance:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telse:\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\t\\telse:\\n\\t\\t\\tif self.context[\"request\"].method in [\"PUT\", \"PATCH\"]:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telif self.context[\"request\"].method == \"POST\":\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\n\\t\\tDevice = self.Meta.model\\n\\t\\tif request_method == \"update\":\\n\\t\\t\\treg_id = attrs.get(\"registration_id\", self.instance.registration_id)\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=reg_id) \\\\\\n\\t\\t\\t\\t.exclude(id=primary_key)\\n\\t\\telif request_method == \"create\":\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=attrs[\"registration_id\"])\\n\\n\\t\\tif devices:\\n\\t\\t\\traise ValidationError({\"registration_id\": \"This field must be unique.\"})\\n\\t\\treturn attrs\\n\\n\\nclass GCMDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tdevice_id = HexIntegerField(\\n\\t\\thelp_text=\"ANDROID_ID / TelephonyManager.getDeviceId() (e.g: 0x01)\",\\n\\t\\tstyle={\"input_type\": \"text\"},\\n\\t\\trequired=False,\\n\\t\\tallow_null=True\\n\\t)\\n\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = GCMDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"device_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"cloud_message_type\", \"application_id\",\\n\\t\\t)\\n\\t\\textra_kwargs = {\"id\": {\"read_only\": False, \"required\": False}}\\n\\n\\tdef validate_device_id(self, value):\\n\\t\\t# device ids are 64 bit unsigned values\\n\\t\\tif value > UNSIGNED_64BIT_INT_MAX_VALUE:\\n\\t\\t\\traise ValidationError(\"Device ID is out of range\")\\n\\t\\treturn value\\n\\n\\nclass WNSDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WNSDevice\\n\\n\\nclass WebPushDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WebPushDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"p256dh\", \"auth\", \"browser\", \"application_id\",\\n\\t\\t)\\n\\n\\n# Permissions\\nclass IsOwner(permissions.BasePermission):\\n\\tdef has_object_permission(self, request, view, obj):\\n\\t\\t# must be the owner to view the object\\n\\t\\treturn obj.user == request.user\\n\\n\\n# Mixins\\nclass DeviceViewSetMixin:\\n\\tlookup_field = \"registration_id\"\\n\\n\\tdef create(self, request, *args, **kwargs):\\n\\t\\tserializer = None\\n\\t\\tis_update = False\\n\\t\\tif SETTINGS.get(\"UPDATE_ON_DUPLICATE_REG_ID\") and self.lookup_field in request.data:\\n\\t\\t\\tinstance = self.queryset.model.objects.filter(\\n\\t\\t\\t\\tregistration_id=request.data[self.lookup_field]\\n\\t\\t\\t).first()\\n\\t\\t\\tif instance:\\n\\t\\t\\t\\tserializer = self.get_serializer(instance, data=request.data)\\n\\t\\t\\t\\tis_update = True\\n\\t\\tif not serializer:\\n\\t\\t\\tserializer = self.get_serializer(data=request.data)\\n\\n\\t\\tserializer.is_valid(raise_exception=True)\\n\\t\\tif is_update:\\n\\t\\t\\tself.perform_update(serializer)\\n\\t\\t\\treturn Response(serializer.data)\\n\\t\\telse:\\n\\t\\t\\tself.perform_create(serializer)\\n\\t\\t\\theaders = self.get_success_headers(serializer.data)\\n\\t\\t\\treturn Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\\n\\n\\tdef perform_create(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_create(serializer)\\n\\n\\tdef perform_update(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_update(serializer)\\n\\n\\nclass AuthorizedMixin:\\n\\tpermission_classes = (permissions.IsAuthenticated, IsOwner)\\n\\n\\tdef get_queryset(self):\\n\\t\\t# filter all devices to only those belonging to the current user\\n\\t\\treturn self.queryset.filter(user=self.request.user)\\n\\n\\n# ViewSets\\nclass APNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = APNSDevice.objects.all()\\n\\tserializer_class = APNSDeviceSerializer\\n\\n\\nclass APNSDeviceAuthorizedViewSet(AuthorizedMixin, APNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass GCMDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = GCMDevice.objects.all()\\n\\tserializer_class = GCMDeviceSerializer\\n\\n\\nclass GCMDeviceAuthorizedViewSet(AuthorizedMixin, GCMDeviceViewSet):\\n\\tpass\\n\\n\\nclass WNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WNSDevice.objects.all()\\n\\tserializer_class = WNSDeviceSerializer\\n\\n\\nclass WNSDeviceAuthorizedViewSet(AuthorizedMixin, WNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass WebPushDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WebPushDevice.objects.all()\\n\\tserializer_class = WebPushDeviceSerializer\\n\\n\\nclass WebPushDeviceAuthorizedViewSet(AuthorizedMixin, WebPushDeviceViewSet):\\n\\tpass\\n'"}, {"func_args": {"source": "'from rest_framework import permissions, status\\nfrom rest_framework.fields import IntegerField\\nfrom rest_framework.response import Response\\nfrom rest_framework.serializers import ModelSerializer, Serializer, ValidationError\\nfrom rest_framework.viewsets import ModelViewSet\\n\\nfrom ..fields import UNSIGNED_64BIT_INT_MAX_VALUE, hex_re\\nfrom ..models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\n# Fields\\nclass HexIntegerField(IntegerField):\\n\\t\"\"\"\\n\\tStore an integer represented as a hex string of form \"0x01\".\\n\\t\"\"\"\\n\\n\\tdef to_internal_value(self, data):\\n\\t\\t# validate hex string and convert it to the unsigned\\n\\t\\t# integer representation for internal use\\n\\t\\ttry:\\n\\t\\t\\tdata = int(data, 16) if type(data) != int else data\\n\\t\\texcept ValueError:\\n\\t\\t\\traise ValidationError(\"Device ID is not a valid hex number\")\\n\\t\\treturn super(HexIntegerField, self).to_internal_value(data)\\n\\n\\tdef to_representation(self, value):\\n\\t\\treturn value\\n\\n\\n# Serializers\\nclass DeviceSerializerMixin(ModelSerializer):\\n\\tclass Meta:\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"application_id\", \"registration_id\", \"device_id\",\\n\\t\\t\\t\"active\", \"date_created\"\\n\\t\\t)\\n\\t\\tread_only_fields = (\"date_created\",)\\n\\n\\t\\t# See https://github.com/tomchristie/django-rest-framework/issues/1101\\n\\t\\textra_kwargs = {\"active\": {\"default\": True}}\\n\\n\\nclass APNSDeviceSerializer(ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = APNSDevice\\n\\n\\tdef validate_registration_id(self, value):\\n\\t\\t# iOS device tokens are 256-bit hexadecimal (64 characters). In 2016 Apple is increasing\\n\\t\\t# iOS device tokens to 100 bytes hexadecimal (200 characters).\\n\\n\\t\\tif hex_re.match(value) is None or len(value) not in (64, 200):\\n\\t\\t\\traise ValidationError(\"Registration ID (device token) is invalid\")\\n\\n\\t\\treturn value\\n\\n\\nclass UniqueRegistrationSerializerMixin(Serializer):\\n\\tdef validate(self, attrs):\\n\\t\\tdevices = None\\n\\t\\tprimary_key = None\\n\\t\\trequest_method = None\\n\\n\\t\\tif self.initial_data.get(\"registration_id\", None):\\n\\t\\t\\tif self.instance:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telse:\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\t\\telse:\\n\\t\\t\\tif self.context[\"request\"].method in [\"PUT\", \"PATCH\"]:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telif self.context[\"request\"].method == \"POST\":\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\n\\t\\tDevice = self.Meta.model\\n\\t\\tif request_method == \"update\":\\n\\t\\t\\treg_id = attrs.get(\"registration_id\", self.instance.registration_id)\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=reg_id) \\\\\\n\\t\\t\\t\\t.exclude(id=primary_key)\\n\\t\\telif request_method == \"create\":\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=attrs[\"registration_id\"])\\n\\n\\t\\tif devices:\\n\\t\\t\\traise ValidationError({\"registration_id\": \"This field must be unique.\"})\\n\\t\\treturn attrs\\n\\n\\nclass GCMDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tdevice_id = HexIntegerField(\\n\\t\\thelp_text=\"ANDROID_ID / TelephonyManager.getDeviceId() (e.g: 0x01)\",\\n\\t\\tstyle={\"input_type\": \"text\"},\\n\\t\\trequired=False,\\n\\t\\tallow_null=True\\n\\t)\\n\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = GCMDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"device_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"cloud_message_type\", \"application_id\",\\n\\t\\t)\\n\\t\\textra_kwargs = {\"id\": {\"read_only\": False, \"required\": False}}\\n\\n\\tdef validate_device_id(self, value):\\n\\t\\t# device ids are 64 bit unsigned values\\n\\t\\tif value > UNSIGNED_64BIT_INT_MAX_VALUE:\\n\\t\\t\\traise ValidationError(\"Device ID is out of range\")\\n\\t\\treturn value\\n\\n\\nclass WNSDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WNSDevice\\n\\n\\nclass WebPushDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WebPushDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"p256dh\", \"auth\", \"browser\", \"application_id\",\\n\\t\\t)\\n\\n\\n# Permissions\\nclass IsOwner(permissions.BasePermission):\\n\\tdef has_object_permission(self, request, view, obj):\\n\\t\\t# must be the owner to view the object\\n\\t\\treturn obj.user == request.user\\n\\n\\n# Mixins\\nclass DeviceViewSetMixin:\\n\\tlookup_field = \"registration_id\"\\n\\n\\tdef create(self, request, *args, **kwargs):\\n\\t\\tserializer = None\\n\\t\\tis_update = False\\n\\t\\tif SETTINGS.get(\"UPDATE_ON_DUPLICATE_REG_ID\") and self.lookup_field in request.data:\\n\\t\\t\\tinstance = self.queryset.model.objects.filter(\\n\\t\\t\\t\\tregistration_id=request.data[self.lookup_field]\\n\\t\\t\\t).first()\\n\\t\\t\\tif instance:\\n\\t\\t\\t\\tserializer = self.get_serializer(instance, data=request.data)\\n\\t\\t\\t\\tis_update = True\\n\\t\\tif not serializer:\\n\\t\\t\\tserializer = self.get_serializer(data=request.data)\\n\\n\\t\\tserializer.is_valid(raise_exception=True)\\n\\t\\tif is_update:\\n\\t\\t\\tself.perform_update(serializer)\\n\\t\\t\\treturn Response(serializer.data)\\n\\t\\telse:\\n\\t\\t\\tself.perform_create(serializer)\\n\\t\\t\\theaders = self.get_success_headers(serializer.data)\\n\\t\\t\\treturn Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\\n\\n\\tdef perform_create(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_create(serializer)\\n\\n\\tdef perform_update(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_update(serializer)\\n\\n\\nclass AuthorizedMixin:\\n\\tpermission_classes = (permissions.IsAuthenticated, IsOwner)\\n\\n\\tdef get_queryset(self):\\n\\t\\t# filter all devices to only those belonging to the current user\\n\\t\\treturn self.queryset.filter(user=self.request.user)\\n\\n\\n# ViewSets\\nclass APNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = APNSDevice.objects.all()\\n\\tserializer_class = APNSDeviceSerializer\\n\\n\\nclass APNSDeviceAuthorizedViewSet(AuthorizedMixin, APNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass GCMDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = GCMDevice.objects.all()\\n\\tserializer_class = GCMDeviceSerializer\\n\\n\\nclass GCMDeviceAuthorizedViewSet(AuthorizedMixin, GCMDeviceViewSet):\\n\\tpass\\n\\n\\nclass WNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WNSDevice.objects.all()\\n\\tserializer_class = WNSDeviceSerializer\\n\\n\\nclass WNSDeviceAuthorizedViewSet(AuthorizedMixin, WNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass WebPushDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WebPushDevice.objects.all()\\n\\tserializer_class = WebPushDeviceSerializer\\n\\n\\nclass WebPushDeviceAuthorizedViewSet(AuthorizedMixin, WebPushDeviceViewSet):\\n\\tpass\\n'"}, "return_value": "'from rest_framework import permissions, status\\nfrom rest_framework.fields import IntegerField\\nfrom rest_framework.response import Response\\nfrom rest_framework.serializers import ModelSerializer, Serializer, ValidationError\\nfrom rest_framework.viewsets import ModelViewSet\\n\\nfrom ..fields import UNSIGNED_64BIT_INT_MAX_VALUE, hex_re\\nfrom ..models import APNSDevice, GCMDevice, WebPushDevice, WNSDevice\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\n# Fields\\nclass HexIntegerField(IntegerField):\\n\\t\"\"\"\\n\\tStore an integer represented as a hex string of form \"0x01\".\\n\\t\"\"\"\\n\\n\\tdef to_internal_value(self, data):\\n\\t\\t# validate hex string and convert it to the unsigned\\n\\t\\t# integer representation for internal use\\n\\t\\ttry:\\n\\t\\t\\tdata = int(data, 16) if type(data) != int else data\\n\\t\\texcept ValueError:\\n\\t\\t\\traise ValidationError(\"Device ID is not a valid hex number\")\\n\\t\\treturn super(HexIntegerField, self).to_internal_value(data)\\n\\n\\tdef to_representation(self, value):\\n\\t\\treturn value\\n\\n\\n# Serializers\\nclass DeviceSerializerMixin(ModelSerializer):\\n\\tclass Meta:\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"application_id\", \"registration_id\", \"device_id\",\\n\\t\\t\\t\"active\", \"date_created\"\\n\\t\\t)\\n\\t\\tread_only_fields = (\"date_created\",)\\n\\n\\t\\t# See https://github.com/tomchristie/django-rest-framework/issues/1101\\n\\t\\textra_kwargs = {\"active\": {\"default\": True}}\\n\\n\\nclass APNSDeviceSerializer(ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = APNSDevice\\n\\n\\tdef validate_registration_id(self, value):\\n\\t\\t# iOS device tokens are 256-bit hexadecimal (64 characters). In 2016 Apple is increasing\\n\\t\\t# iOS device tokens to 100 bytes hexadecimal (200 characters).\\n\\n\\t\\tif hex_re.match(value) is None or len(value) not in (64, 200):\\n\\t\\t\\traise ValidationError(\"Registration ID (device token) is invalid\")\\n\\n\\t\\treturn value\\n\\n\\nclass UniqueRegistrationSerializerMixin(Serializer):\\n\\tdef validate(self, attrs):\\n\\t\\tdevices = None\\n\\t\\tprimary_key = None\\n\\t\\trequest_method = None\\n\\n\\t\\tif self.initial_data.get(\"registration_id\", None):\\n\\t\\t\\tif self.instance:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telse:\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\t\\telse:\\n\\t\\t\\tif self.context[\"request\"].method in [\"PUT\", \"PATCH\"]:\\n\\t\\t\\t\\trequest_method = \"update\"\\n\\t\\t\\t\\tprimary_key = self.instance.id\\n\\t\\t\\telif self.context[\"request\"].method == \"POST\":\\n\\t\\t\\t\\trequest_method = \"create\"\\n\\n\\t\\tDevice = self.Meta.model\\n\\t\\tif request_method == \"update\":\\n\\t\\t\\treg_id = attrs.get(\"registration_id\", self.instance.registration_id)\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=reg_id) \\\\\\n\\t\\t\\t\\t.exclude(id=primary_key)\\n\\t\\telif request_method == \"create\":\\n\\t\\t\\tdevices = Device.objects.filter(registration_id=attrs[\"registration_id\"])\\n\\n\\t\\tif devices:\\n\\t\\t\\traise ValidationError({\"registration_id\": \"This field must be unique.\"})\\n\\t\\treturn attrs\\n\\n\\nclass GCMDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tdevice_id = HexIntegerField(\\n\\t\\thelp_text=\"ANDROID_ID / TelephonyManager.getDeviceId() (e.g: 0x01)\",\\n\\t\\tstyle={\"input_type\": \"text\"},\\n\\t\\trequired=False,\\n\\t\\tallow_null=True\\n\\t)\\n\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = GCMDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"device_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"cloud_message_type\", \"application_id\",\\n\\t\\t)\\n\\t\\textra_kwargs = {\"id\": {\"read_only\": False, \"required\": False}}\\n\\n\\tdef validate_device_id(self, value):\\n\\t\\t# device ids are 64 bit unsigned values\\n\\t\\tif value > UNSIGNED_64BIT_INT_MAX_VALUE:\\n\\t\\t\\traise ValidationError(\"Device ID is out of range\")\\n\\t\\treturn value\\n\\n\\nclass WNSDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WNSDevice\\n\\n\\nclass WebPushDeviceSerializer(UniqueRegistrationSerializerMixin, ModelSerializer):\\n\\tclass Meta(DeviceSerializerMixin.Meta):\\n\\t\\tmodel = WebPushDevice\\n\\t\\tfields = (\\n\\t\\t\\t\"id\", \"name\", \"registration_id\", \"active\", \"date_created\",\\n\\t\\t\\t\"p256dh\", \"auth\", \"browser\", \"application_id\",\\n\\t\\t)\\n\\n\\n# Permissions\\nclass IsOwner(permissions.BasePermission):\\n\\tdef has_object_permission(self, request, view, obj):\\n\\t\\t# must be the owner to view the object\\n\\t\\treturn obj.user == request.user\\n\\n\\n# Mixins\\nclass DeviceViewSetMixin:\\n\\tlookup_field = \"registration_id\"\\n\\n\\tdef create(self, request, *args, **kwargs):\\n\\t\\tserializer = None\\n\\t\\tis_update = False\\n\\t\\tif SETTINGS.get(\"UPDATE_ON_DUPLICATE_REG_ID\") and self.lookup_field in request.data:\\n\\t\\t\\tinstance = self.queryset.model.objects.filter(\\n\\t\\t\\t\\tregistration_id=request.data[self.lookup_field]\\n\\t\\t\\t).first()\\n\\t\\t\\tif instance:\\n\\t\\t\\t\\tserializer = self.get_serializer(instance, data=request.data)\\n\\t\\t\\t\\tis_update = True\\n\\t\\tif not serializer:\\n\\t\\t\\tserializer = self.get_serializer(data=request.data)\\n\\n\\t\\tserializer.is_valid(raise_exception=True)\\n\\t\\tif is_update:\\n\\t\\t\\tself.perform_update(serializer)\\n\\t\\t\\treturn Response(serializer.data)\\n\\t\\telse:\\n\\t\\t\\tself.perform_create(serializer)\\n\\t\\t\\theaders = self.get_success_headers(serializer.data)\\n\\t\\t\\treturn Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\\n\\n\\tdef perform_create(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_create(serializer)\\n\\n\\tdef perform_update(self, serializer):\\n\\t\\tif self.request.user.is_authenticated:\\n\\t\\t\\tserializer.save(user=self.request.user)\\n\\t\\treturn super(DeviceViewSetMixin, self).perform_update(serializer)\\n\\n\\nclass AuthorizedMixin:\\n\\tpermission_classes = (permissions.IsAuthenticated, IsOwner)\\n\\n\\tdef get_queryset(self):\\n\\t\\t# filter all devices to only those belonging to the current user\\n\\t\\treturn self.queryset.filter(user=self.request.user)\\n\\n\\n# ViewSets\\nclass APNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = APNSDevice.objects.all()\\n\\tserializer_class = APNSDeviceSerializer\\n\\n\\nclass APNSDeviceAuthorizedViewSet(AuthorizedMixin, APNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass GCMDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = GCMDevice.objects.all()\\n\\tserializer_class = GCMDeviceSerializer\\n\\n\\nclass GCMDeviceAuthorizedViewSet(AuthorizedMixin, GCMDeviceViewSet):\\n\\tpass\\n\\n\\nclass WNSDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WNSDevice.objects.all()\\n\\tserializer_class = WNSDeviceSerializer\\n\\n\\nclass WNSDeviceAuthorizedViewSet(AuthorizedMixin, WNSDeviceViewSet):\\n\\tpass\\n\\n\\nclass WebPushDeviceViewSet(DeviceViewSetMixin, ModelViewSet):\\n\\tqueryset = WebPushDevice.objects.all()\\n\\tserializer_class = WebPushDeviceSerializer\\n\\n\\nclass WebPushDeviceAuthorizedViewSet(AuthorizedMixin, WebPushDeviceViewSet):\\n\\tpass\\n'"}, {"func_args": {"source": "'\"\"\"\\nApple Push Notification Service\\nDocumentation is available on the iOS Developer Library:\\nhttps://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html\\n\"\"\"\\n\\nimport time\\n\\nfrom apns2 import client as apns2_client\\nfrom apns2 import credentials as apns2_credentials\\nfrom apns2 import errors as apns2_errors\\nfrom apns2 import payload as apns2_payload\\n\\nfrom . import models\\nfrom .conf import get_manager\\nfrom .exceptions import APNSError, APNSUnsupportedPriority, APNSServerError\\n\\n\\ndef _apns_create_socket(creds=None, application_id=None):\\n\\tif creds is None:\\n\\t\\tif not get_manager().has_auth_token_creds(application_id):\\n\\t\\t\\tcert = get_manager().get_apns_certificate(application_id)\\n\\t\\t\\tcreds = apns2_credentials.CertificateCredentials(cert)\\n\\t\\telse:\\n\\t\\t\\tkeyPath, keyId, teamId = get_manager().get_apns_auth_creds(application_id)\\n\\t\\t\\t# No use getting a lifetime because this credential is\\n\\t\\t\\t# ephemeral, but if you\\'re looking at this to see how to\\n\\t\\t\\t# create a credential, you could also pass the lifetime and\\n\\t\\t\\t# algorithm. Neither of those settings are exposed in the\\n\\t\\t\\t# settings API at the moment.\\n\\t\\t\\tcreds = creds or apns2_credentials.TokenCredentials(keyPath, keyId, teamId)\\n\\tclient = apns2_client.APNsClient(\\n\\t\\tcreds,\\n\\t\\tuse_sandbox=get_manager().get_apns_use_sandbox(application_id),\\n\\t\\tuse_alternative_port=get_manager().get_apns_use_alternative_port(application_id)\\n\\t)\\n\\tclient.connect()\\n\\treturn client\\n\\n\\ndef _apns_prepare(\\n\\ttoken, alert, application_id=None, badge=None, sound=None, category=None,\\n\\tcontent_available=False, action_loc_key=None, loc_key=None, loc_args=[],\\n\\textra={}, mutable_content=False, thread_id=None, url_args=None):\\n\\t\\tif action_loc_key or loc_key or loc_args:\\n\\t\\t\\tapns2_alert = apns2_payload.PayloadAlert(\\n\\t\\t\\t\\tbody=alert if alert else {}, body_localized_key=loc_key,\\n\\t\\t\\t\\tbody_localized_args=loc_args, action_localized_key=action_loc_key)\\n\\t\\telse:\\n\\t\\t\\tapns2_alert = alert\\n\\n\\t\\tif callable(badge):\\n\\t\\t\\tbadge = badge(token)\\n\\n\\t\\treturn apns2_payload.Payload(\\n\\t\\t\\talert=apns2_alert, badge=badge, sound=sound, category=category,\\n\\t\\t\\turl_args=url_args, custom=extra, thread_id=thread_id,\\n\\t\\t\\tcontent_available=content_available, mutable_content=mutable_content)\\n\\n\\ndef _apns_send(\\n\\tregistration_id, alert, batch=False, application_id=None, creds=None, **kwargs\\n):\\n\\tclient = _apns_create_socket(creds=creds, application_id=application_id)\\n\\n\\tnotification_kwargs = {}\\n\\n\\t# if expiration isn\"t specified use 1 month from now\\n\\tnotification_kwargs[\"expiration\"] = kwargs.pop(\"expiration\", None)\\n\\tif not notification_kwargs[\"expiration\"]:\\n\\t\\tnotification_kwargs[\"expiration\"] = int(time.time()) + 2592000\\n\\n\\tpriority = kwargs.pop(\"priority\", None)\\n\\tif priority:\\n\\t\\ttry:\\n\\t\\t\\tnotification_kwargs[\"priority\"] = apns2_client.NotificationPriority(str(priority))\\n\\t\\texcept ValueError:\\n\\t\\t\\traise APNSUnsupportedPriority(\"Unsupported priority %d\" % (priority))\\n\\n\\tnotification_kwargs[\"collapse_id\"] = kwargs.pop(\"collapse_id\", None)\\n\\n\\tif batch:\\n\\t\\tdata = [apns2_client.Notification(\\n\\t\\t\\ttoken=rid, payload=_apns_prepare(rid, alert, **kwargs)) for rid in registration_id]\\n\\t\\t# returns a dictionary mapping each token to its result. That\\n\\t\\t# result is either \"Success\" or the reason for the failure.\\n\\t\\treturn client.send_notification_batch(\\n\\t\\t\\tdata, get_manager().get_apns_topic(application_id=application_id),\\n\\t\\t\\t**notification_kwargs\\n\\t\\t)\\n\\n\\tdata = _apns_prepare(registration_id, alert, **kwargs)\\n\\tclient.send_notification(\\n\\t\\tregistration_id, data,\\n\\t\\tget_manager().get_apns_topic(application_id=application_id),\\n\\t\\t**notification_kwargs\\n\\t)\\n\\n\\ndef apns_send_message(registration_id, alert, application_id=None, creds=None, **kwargs):\\n\\t\"\"\"\\n\\tSends an APNS notification to a single registration_id.\\n\\tThis will send the notification as form data.\\n\\tIf sending multiple notifications, it is more efficient to use\\n\\tapns_send_bulk_message()\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\ttry:\\n\\t\\t_apns_send(\\n\\t\\t\\tregistration_id, alert, application_id=application_id,\\n\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t)\\n\\texcept apns2_errors.APNsException as apns2_exception:\\n\\t\\tif isinstance(apns2_exception, apns2_errors.Unregistered):\\n\\t\\t\\tdevice = models.APNSDevice.objects.get(registration_id=registration_id)\\n\\t\\t\\tdevice.active = False\\n\\t\\t\\tdevice.save()\\n\\n\\t\\traise APNSServerError(status=apns2_exception.__class__.__name__)\\n\\n\\ndef apns_send_bulk_message(\\n\\tregistration_ids, alert, application_id=None, creds=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends an APNS notification to one or more registration_ids.\\n\\tThe registration_ids argument needs to be a list.\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\tresults = _apns_send(\\n\\t\\tregistration_ids, alert, batch=True, application_id=application_id,\\n\\t\\tcreds=creds, **kwargs\\n\\t)\\n\\tinactive_tokens = [token for token, result in results.items() if result == \"Unregistered\"]\\n\\tmodels.APNSDevice.objects.filter(registration_id__in=inactive_tokens).update(active=False)\\n\\treturn results\\n'"}, "return_value": "'\"\"\"\\nApple Push Notification Service\\nDocumentation is available on the iOS Developer Library:\\nhttps://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html\\n\"\"\"\\n\\nimport time\\n\\nfrom apns2 import client as apns2_client\\nfrom apns2 import credentials as apns2_credentials\\nfrom apns2 import errors as apns2_errors\\nfrom apns2 import payload as apns2_payload\\n\\nfrom . import models\\nfrom .conf import get_manager\\nfrom .exceptions import APNSError, APNSUnsupportedPriority, APNSServerError\\n\\n\\ndef _apns_create_socket(creds=None, application_id=None):\\n\\tif creds is None:\\n\\t\\tif not get_manager().has_auth_token_creds(application_id):\\n\\t\\t\\tcert = get_manager().get_apns_certificate(application_id)\\n\\t\\t\\tcreds = apns2_credentials.CertificateCredentials(cert)\\n\\t\\telse:\\n\\t\\t\\tkeyPath, keyId, teamId = get_manager().get_apns_auth_creds(application_id)\\n\\t\\t\\t# No use getting a lifetime because this credential is\\n\\t\\t\\t# ephemeral, but if you\\'re looking at this to see how to\\n\\t\\t\\t# create a credential, you could also pass the lifetime and\\n\\t\\t\\t# algorithm. Neither of those settings are exposed in the\\n\\t\\t\\t# settings API at the moment.\\n\\t\\t\\tcreds = creds or apns2_credentials.TokenCredentials(keyPath, keyId, teamId)\\n\\tclient = apns2_client.APNsClient(\\n\\t\\tcreds,\\n\\t\\tuse_sandbox=get_manager().get_apns_use_sandbox(application_id),\\n\\t\\tuse_alternative_port=get_manager().get_apns_use_alternative_port(application_id)\\n\\t)\\n\\tclient.connect()\\n\\treturn client\\n\\n\\ndef _apns_prepare(\\n\\ttoken, alert, application_id=None, badge=None, sound=None, category=None,\\n\\tcontent_available=False, action_loc_key=None, loc_key=None, loc_args=[],\\n\\textra={}, mutable_content=False, thread_id=None, url_args=None):\\n\\t\\tif action_loc_key or loc_key or loc_args:\\n\\t\\t\\tapns2_alert = apns2_payload.PayloadAlert(\\n\\t\\t\\t\\tbody=alert if alert else {}, body_localized_key=loc_key,\\n\\t\\t\\t\\tbody_localized_args=loc_args, action_localized_key=action_loc_key)\\n\\t\\telse:\\n\\t\\t\\tapns2_alert = alert\\n\\n\\t\\tif callable(badge):\\n\\t\\t\\tbadge = badge(token)\\n\\n\\t\\treturn apns2_payload.Payload(\\n\\t\\t\\talert=apns2_alert, badge=badge, sound=sound, category=category,\\n\\t\\t\\turl_args=url_args, custom=extra, thread_id=thread_id,\\n\\t\\t\\tcontent_available=content_available, mutable_content=mutable_content)\\n\\n\\ndef _apns_send(\\n\\tregistration_id, alert, batch=False, application_id=None, creds=None, **kwargs\\n):\\n\\tclient = _apns_create_socket(creds=creds, application_id=application_id)\\n\\n\\tnotification_kwargs = {}\\n\\n\\t# if expiration isn\"t specified use 1 month from now\\n\\tnotification_kwargs[\"expiration\"] = kwargs.pop(\"expiration\", None)\\n\\tif not notification_kwargs[\"expiration\"]:\\n\\t\\tnotification_kwargs[\"expiration\"] = int(time.time()) + 2592000\\n\\n\\tpriority = kwargs.pop(\"priority\", None)\\n\\tif priority:\\n\\t\\ttry:\\n\\t\\t\\tnotification_kwargs[\"priority\"] = apns2_client.NotificationPriority(str(priority))\\n\\t\\texcept ValueError:\\n\\t\\t\\traise APNSUnsupportedPriority(\"Unsupported priority %d\" % (priority))\\n\\n\\tnotification_kwargs[\"collapse_id\"] = kwargs.pop(\"collapse_id\", None)\\n\\n\\tif batch:\\n\\t\\tdata = [apns2_client.Notification(\\n\\t\\t\\ttoken=rid, payload=_apns_prepare(rid, alert, **kwargs)) for rid in registration_id]\\n\\t\\t# returns a dictionary mapping each token to its result. That\\n\\t\\t# result is either \"Success\" or the reason for the failure.\\n\\t\\treturn client.send_notification_batch(\\n\\t\\t\\tdata, get_manager().get_apns_topic(application_id=application_id),\\n\\t\\t\\t**notification_kwargs\\n\\t\\t)\\n\\n\\tdata = _apns_prepare(registration_id, alert, **kwargs)\\n\\tclient.send_notification(\\n\\t\\tregistration_id, data,\\n\\t\\tget_manager().get_apns_topic(application_id=application_id),\\n\\t\\t**notification_kwargs\\n\\t)\\n\\n\\ndef apns_send_message(registration_id, alert, application_id=None, creds=None, **kwargs):\\n\\t\"\"\"\\n\\tSends an APNS notification to a single registration_id.\\n\\tThis will send the notification as form data.\\n\\tIf sending multiple notifications, it is more efficient to use\\n\\tapns_send_bulk_message()\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\ttry:\\n\\t\\t_apns_send(\\n\\t\\t\\tregistration_id, alert, application_id=application_id,\\n\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t)\\n\\texcept apns2_errors.APNsException as apns2_exception:\\n\\t\\tif isinstance(apns2_exception, apns2_errors.Unregistered):\\n\\t\\t\\tdevice = models.APNSDevice.objects.get(registration_id=registration_id)\\n\\t\\t\\tdevice.active = False\\n\\t\\t\\tdevice.save()\\n\\n\\t\\traise APNSServerError(status=apns2_exception.__class__.__name__)\\n\\n\\ndef apns_send_bulk_message(\\n\\tregistration_ids, alert, application_id=None, creds=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends an APNS notification to one or more registration_ids.\\n\\tThe registration_ids argument needs to be a list.\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\tresults = _apns_send(\\n\\t\\tregistration_ids, alert, batch=True, application_id=application_id,\\n\\t\\tcreds=creds, **kwargs\\n\\t)\\n\\tinactive_tokens = [token for token, result in results.items() if result == \"Unregistered\"]\\n\\tmodels.APNSDevice.objects.filter(registration_id__in=inactive_tokens).update(active=False)\\n\\treturn results\\n'"}, {"func_args": {"source": "'\"\"\"\\nApple Push Notification Service\\nDocumentation is available on the iOS Developer Library:\\nhttps://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html\\n\"\"\"\\n\\nimport time\\n\\nfrom apns2 import client as apns2_client\\nfrom apns2 import credentials as apns2_credentials\\nfrom apns2 import errors as apns2_errors\\nfrom apns2 import payload as apns2_payload\\n\\nfrom . import models\\nfrom .conf import get_manager\\nfrom .exceptions import APNSError, APNSUnsupportedPriority, APNSServerError\\n\\n\\ndef _apns_create_socket(creds=None, application_id=None):\\n\\tif creds is None:\\n\\t\\tif not get_manager().has_auth_token_creds(application_id):\\n\\t\\t\\tcert = get_manager().get_apns_certificate(application_id)\\n\\t\\t\\tcreds = apns2_credentials.CertificateCredentials(cert)\\n\\t\\telse:\\n\\t\\t\\tkeyPath, keyId, teamId = get_manager().get_apns_auth_creds(application_id)\\n\\t\\t\\t# No use getting a lifetime because this credential is\\n\\t\\t\\t# ephemeral, but if you\\'re looking at this to see how to\\n\\t\\t\\t# create a credential, you could also pass the lifetime and\\n\\t\\t\\t# algorithm. Neither of those settings are exposed in the\\n\\t\\t\\t# settings API at the moment.\\n\\t\\t\\tcreds = creds or apns2_credentials.TokenCredentials(keyPath, keyId, teamId)\\n\\tclient = apns2_client.APNsClient(\\n\\t\\tcreds,\\n\\t\\tuse_sandbox=get_manager().get_apns_use_sandbox(application_id),\\n\\t\\tuse_alternative_port=get_manager().get_apns_use_alternative_port(application_id)\\n\\t)\\n\\tclient.connect()\\n\\treturn client\\n\\n\\ndef _apns_prepare(\\n\\ttoken, alert, application_id=None, badge=None, sound=None, category=None,\\n\\tcontent_available=False, action_loc_key=None, loc_key=None, loc_args=[],\\n\\textra={}, mutable_content=False, thread_id=None, url_args=None):\\n\\t\\tif action_loc_key or loc_key or loc_args:\\n\\t\\t\\tapns2_alert = apns2_payload.PayloadAlert(\\n\\t\\t\\t\\tbody=alert if alert else {}, body_localized_key=loc_key,\\n\\t\\t\\t\\tbody_localized_args=loc_args, action_localized_key=action_loc_key)\\n\\t\\telse:\\n\\t\\t\\tapns2_alert = alert\\n\\n\\t\\tif callable(badge):\\n\\t\\t\\tbadge = badge(token)\\n\\n\\t\\treturn apns2_payload.Payload(\\n\\t\\t\\talert=apns2_alert, badge=badge, sound=sound, category=category,\\n\\t\\t\\turl_args=url_args, custom=extra, thread_id=thread_id,\\n\\t\\t\\tcontent_available=content_available, mutable_content=mutable_content)\\n\\n\\ndef _apns_send(\\n\\tregistration_id, alert, batch=False, application_id=None, creds=None, **kwargs\\n):\\n\\tclient = _apns_create_socket(creds=creds, application_id=application_id)\\n\\n\\tnotification_kwargs = {}\\n\\n\\t# if expiration isn\"t specified use 1 month from now\\n\\tnotification_kwargs[\"expiration\"] = kwargs.pop(\"expiration\", None)\\n\\tif not notification_kwargs[\"expiration\"]:\\n\\t\\tnotification_kwargs[\"expiration\"] = int(time.time()) + 2592000\\n\\n\\tpriority = kwargs.pop(\"priority\", None)\\n\\tif priority:\\n\\t\\ttry:\\n\\t\\t\\tnotification_kwargs[\"priority\"] = apns2_client.NotificationPriority(str(priority))\\n\\t\\texcept ValueError:\\n\\t\\t\\traise APNSUnsupportedPriority(\"Unsupported priority %d\" % (priority))\\n\\n\\tnotification_kwargs[\"collapse_id\"] = kwargs.pop(\"collapse_id\", None)\\n\\n\\tif batch:\\n\\t\\tdata = [apns2_client.Notification(\\n\\t\\t\\ttoken=rid, payload=_apns_prepare(rid, alert, **kwargs)) for rid in registration_id]\\n\\t\\t# returns a dictionary mapping each token to its result. That\\n\\t\\t# result is either \"Success\" or the reason for the failure.\\n\\t\\treturn client.send_notification_batch(\\n\\t\\t\\tdata, get_manager().get_apns_topic(application_id=application_id),\\n\\t\\t\\t**notification_kwargs\\n\\t\\t)\\n\\n\\tdata = _apns_prepare(registration_id, alert, **kwargs)\\n\\tclient.send_notification(\\n\\t\\tregistration_id, data,\\n\\t\\tget_manager().get_apns_topic(application_id=application_id),\\n\\t\\t**notification_kwargs\\n\\t)\\n\\n\\ndef apns_send_message(registration_id, alert, application_id=None, creds=None, **kwargs):\\n\\t\"\"\"\\n\\tSends an APNS notification to a single registration_id.\\n\\tThis will send the notification as form data.\\n\\tIf sending multiple notifications, it is more efficient to use\\n\\tapns_send_bulk_message()\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\ttry:\\n\\t\\t_apns_send(\\n\\t\\t\\tregistration_id, alert, application_id=application_id,\\n\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t)\\n\\texcept apns2_errors.APNsException as apns2_exception:\\n\\t\\tif isinstance(apns2_exception, apns2_errors.Unregistered):\\n\\t\\t\\tdevice = models.APNSDevice.objects.get(registration_id=registration_id)\\n\\t\\t\\tdevice.active = False\\n\\t\\t\\tdevice.save()\\n\\n\\t\\traise APNSServerError(status=apns2_exception.__class__.__name__)\\n\\n\\ndef apns_send_bulk_message(\\n\\tregistration_ids, alert, application_id=None, creds=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends an APNS notification to one or more registration_ids.\\n\\tThe registration_ids argument needs to be a list.\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\tresults = _apns_send(\\n\\t\\tregistration_ids, alert, batch=True, application_id=application_id,\\n\\t\\tcreds=creds, **kwargs\\n\\t)\\n\\tinactive_tokens = [token for token, result in results.items() if result == \"Unregistered\"]\\n\\tmodels.APNSDevice.objects.filter(registration_id__in=inactive_tokens).update(active=False)\\n\\treturn results\\n'"}, "return_value": "'\"\"\"\\nApple Push Notification Service\\nDocumentation is available on the iOS Developer Library:\\nhttps://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html\\n\"\"\"\\n\\nimport time\\n\\nfrom apns2 import client as apns2_client\\nfrom apns2 import credentials as apns2_credentials\\nfrom apns2 import errors as apns2_errors\\nfrom apns2 import payload as apns2_payload\\n\\nfrom . import models\\nfrom .conf import get_manager\\nfrom .exceptions import APNSError, APNSUnsupportedPriority, APNSServerError\\n\\n\\ndef _apns_create_socket(creds=None, application_id=None):\\n\\tif creds is None:\\n\\t\\tif not get_manager().has_auth_token_creds(application_id):\\n\\t\\t\\tcert = get_manager().get_apns_certificate(application_id)\\n\\t\\t\\tcreds = apns2_credentials.CertificateCredentials(cert)\\n\\t\\telse:\\n\\t\\t\\tkeyPath, keyId, teamId = get_manager().get_apns_auth_creds(application_id)\\n\\t\\t\\t# No use getting a lifetime because this credential is\\n\\t\\t\\t# ephemeral, but if you\\'re looking at this to see how to\\n\\t\\t\\t# create a credential, you could also pass the lifetime and\\n\\t\\t\\t# algorithm. Neither of those settings are exposed in the\\n\\t\\t\\t# settings API at the moment.\\n\\t\\t\\tcreds = creds or apns2_credentials.TokenCredentials(keyPath, keyId, teamId)\\n\\tclient = apns2_client.APNsClient(\\n\\t\\tcreds,\\n\\t\\tuse_sandbox=get_manager().get_apns_use_sandbox(application_id),\\n\\t\\tuse_alternative_port=get_manager().get_apns_use_alternative_port(application_id)\\n\\t)\\n\\tclient.connect()\\n\\treturn client\\n\\n\\ndef _apns_prepare(\\n\\ttoken, alert, application_id=None, badge=None, sound=None, category=None,\\n\\tcontent_available=False, action_loc_key=None, loc_key=None, loc_args=[],\\n\\textra={}, mutable_content=False, thread_id=None, url_args=None):\\n\\t\\tif action_loc_key or loc_key or loc_args:\\n\\t\\t\\tapns2_alert = apns2_payload.PayloadAlert(\\n\\t\\t\\t\\tbody=alert if alert else {}, body_localized_key=loc_key,\\n\\t\\t\\t\\tbody_localized_args=loc_args, action_localized_key=action_loc_key)\\n\\t\\telse:\\n\\t\\t\\tapns2_alert = alert\\n\\n\\t\\tif callable(badge):\\n\\t\\t\\tbadge = badge(token)\\n\\n\\t\\treturn apns2_payload.Payload(\\n\\t\\t\\talert=apns2_alert, badge=badge, sound=sound, category=category,\\n\\t\\t\\turl_args=url_args, custom=extra, thread_id=thread_id,\\n\\t\\t\\tcontent_available=content_available, mutable_content=mutable_content)\\n\\n\\ndef _apns_send(\\n\\tregistration_id, alert, batch=False, application_id=None, creds=None, **kwargs\\n):\\n\\tclient = _apns_create_socket(creds=creds, application_id=application_id)\\n\\n\\tnotification_kwargs = {}\\n\\n\\t# if expiration isn\"t specified use 1 month from now\\n\\tnotification_kwargs[\"expiration\"] = kwargs.pop(\"expiration\", None)\\n\\tif not notification_kwargs[\"expiration\"]:\\n\\t\\tnotification_kwargs[\"expiration\"] = int(time.time()) + 2592000\\n\\n\\tpriority = kwargs.pop(\"priority\", None)\\n\\tif priority:\\n\\t\\ttry:\\n\\t\\t\\tnotification_kwargs[\"priority\"] = apns2_client.NotificationPriority(str(priority))\\n\\t\\texcept ValueError:\\n\\t\\t\\traise APNSUnsupportedPriority(\"Unsupported priority %d\" % (priority))\\n\\n\\tnotification_kwargs[\"collapse_id\"] = kwargs.pop(\"collapse_id\", None)\\n\\n\\tif batch:\\n\\t\\tdata = [apns2_client.Notification(\\n\\t\\t\\ttoken=rid, payload=_apns_prepare(rid, alert, **kwargs)) for rid in registration_id]\\n\\t\\t# returns a dictionary mapping each token to its result. That\\n\\t\\t# result is either \"Success\" or the reason for the failure.\\n\\t\\treturn client.send_notification_batch(\\n\\t\\t\\tdata, get_manager().get_apns_topic(application_id=application_id),\\n\\t\\t\\t**notification_kwargs\\n\\t\\t)\\n\\n\\tdata = _apns_prepare(registration_id, alert, **kwargs)\\n\\tclient.send_notification(\\n\\t\\tregistration_id, data,\\n\\t\\tget_manager().get_apns_topic(application_id=application_id),\\n\\t\\t**notification_kwargs\\n\\t)\\n\\n\\ndef apns_send_message(registration_id, alert, application_id=None, creds=None, **kwargs):\\n\\t\"\"\"\\n\\tSends an APNS notification to a single registration_id.\\n\\tThis will send the notification as form data.\\n\\tIf sending multiple notifications, it is more efficient to use\\n\\tapns_send_bulk_message()\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\ttry:\\n\\t\\t_apns_send(\\n\\t\\t\\tregistration_id, alert, application_id=application_id,\\n\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t)\\n\\texcept apns2_errors.APNsException as apns2_exception:\\n\\t\\tif isinstance(apns2_exception, apns2_errors.Unregistered):\\n\\t\\t\\tdevice = models.APNSDevice.objects.get(registration_id=registration_id)\\n\\t\\t\\tdevice.active = False\\n\\t\\t\\tdevice.save()\\n\\n\\t\\traise APNSServerError(status=apns2_exception.__class__.__name__)\\n\\n\\ndef apns_send_bulk_message(\\n\\tregistration_ids, alert, application_id=None, creds=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends an APNS notification to one or more registration_ids.\\n\\tThe registration_ids argument needs to be a list.\\n\\n\\tNote that if set alert should always be a string. If it is not set,\\n\\tit won\"t be included in the notification. You will need to pass None\\n\\tto this for silent notifications.\\n\\t\"\"\"\\n\\n\\tresults = _apns_send(\\n\\t\\tregistration_ids, alert, batch=True, application_id=application_id,\\n\\t\\tcreds=creds, **kwargs\\n\\t)\\n\\tinactive_tokens = [token for token, result in results.items() if result == \"Unregistered\"]\\n\\tmodels.APNSDevice.objects.filter(registration_id__in=inactive_tokens).update(active=False)\\n\\treturn results\\n'"}, {"func_args": {"source": "'# flake8:noqa\\nfrom urllib.error import HTTPError\\nfrom urllib.parse import urlencode\\nfrom urllib.request import Request, urlopen\\n'"}, "return_value": "'# flake8:noqa\\nfrom urllib.error import HTTPError\\nfrom urllib.parse import urlencode\\nfrom urllib.request import Request, urlopen\\n'"}, {"func_args": {"source": "'# flake8:noqa\\nfrom urllib.error import HTTPError\\nfrom urllib.parse import urlencode\\nfrom urllib.request import Request, urlopen\\n'"}, "return_value": "'# flake8:noqa\\nfrom urllib.error import HTTPError\\nfrom urllib.parse import urlencode\\nfrom urllib.request import Request, urlopen\\n'"}, {"func_args": {"source": "'from django.utils.module_loading import import_string\\n\\nfrom .app import AppConfig  # noqa: F401\\nfrom .appmodel import AppModelConfig  # noqa: F401\\nfrom .legacy import LegacyConfig  # noqa: F401\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS  # noqa: I001\\n\\n\\nmanager = None\\n\\n\\ndef get_manager(reload=False):\\n\\tglobal manager\\n\\n\\tif not manager or reload is True:\\n\\t\\tmanager = import_string(SETTINGS[\"CONFIG\"])()\\n\\n\\treturn manager\\n\\n\\n# implementing get_manager as a function allows tests to reload settings\\nget_manager()\\n'"}, "return_value": "'from django.utils.module_loading import import_string\\n\\nfrom .app import AppConfig  # noqa: F401\\nfrom .appmodel import AppModelConfig  # noqa: F401\\nfrom .legacy import LegacyConfig  # noqa: F401\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS  # noqa: I001\\n\\n\\nmanager = None\\n\\n\\ndef get_manager(reload=False):\\n\\tglobal manager\\n\\n\\tif not manager or reload is True:\\n\\t\\tmanager = import_string(SETTINGS[\"CONFIG\"])()\\n\\n\\treturn manager\\n\\n\\n# implementing get_manager as a function allows tests to reload settings\\nget_manager()\\n'"}, {"func_args": {"source": "'from django.utils.module_loading import import_string\\n\\nfrom .app import AppConfig  # noqa: F401\\nfrom .appmodel import AppModelConfig  # noqa: F401\\nfrom .legacy import LegacyConfig  # noqa: F401\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS  # noqa: I001\\n\\n\\nmanager = None\\n\\n\\ndef get_manager(reload=False):\\n\\tglobal manager\\n\\n\\tif not manager or reload is True:\\n\\t\\tmanager = import_string(SETTINGS[\"CONFIG\"])()\\n\\n\\treturn manager\\n\\n\\n# implementing get_manager as a function allows tests to reload settings\\nget_manager()\\n'"}, "return_value": "'from django.utils.module_loading import import_string\\n\\nfrom .app import AppConfig  # noqa: F401\\nfrom .appmodel import AppModelConfig  # noqa: F401\\nfrom .legacy import LegacyConfig  # noqa: F401\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS  # noqa: I001\\n\\n\\nmanager = None\\n\\n\\ndef get_manager(reload=False):\\n\\tglobal manager\\n\\n\\tif not manager or reload is True:\\n\\t\\tmanager = import_string(SETTINGS[\"CONFIG\"])()\\n\\n\\treturn manager\\n\\n\\n# implementing get_manager as a function allows tests to reload settings\\nget_manager()\\n'"}, {"func_args": {"source": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig, check_apns_certificate\\n\\n\\nSETTING_MISMATCH = (\\n\\t\"Application \\'{application_id}\\' ({platform}) does not support the setting \\'{setting}\\'.\"\\n)\\n\\n# code can be \"missing\" or \"invalid\"\\nBAD_PLATFORM = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"PLATFORM\"] is {code}. \\'\\n\\t\"Must be one of: {platforms}.\"\\n)\\n\\nUNKNOWN_PLATFORM = (\\n\\t\"Unknown Platform: {platform}. Must be one of: {platforms}.\"\\n)\\n\\nMISSING_SETTING = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"{setting}\"] is missing.\\'\\n)\\n\\nPLATFORMS = [\\n\\t\"APNS\",\\n\\t\"FCM\",\\n\\t\"GCM\",\\n\\t\"WNS\",\\n\\t\"WP\",\\n]\\n\\n# Settings that all applications must have\\nREQUIRED_SETTINGS = [\\n\\t\"PLATFORM\",\\n]\\n\\n# Settings that an application may have to enable optional features\\n# these settings are stubs for registry support and have no effect on the operation\\n# of the application at this time.\\nOPTIONAL_SETTINGS = [\\n\\t\"APPLICATION_GROUP\", \"APPLICATION_SECRET\"\\n]\\n\\n# Since we can have an auth key, combined with a auth key id and team id *or*\\n# a certificate, we make these all optional, and then make sure we have one or\\n# the other (group) of settings.\\nAPNS_SETTINGS_CERT_CREDS = \"CERTIFICATE\"\\n\\n# Subkeys for APNS_SETTINGS_AUTH_CREDS\\nAPNS_AUTH_CREDS_REQUIRED = [\"AUTH_KEY_PATH\", \"AUTH_KEY_ID\", \"TEAM_ID\"]\\nAPNS_AUTH_CREDS_OPTIONAL = [\"CERTIFICATE\", \"ENCRYPTION_ALGORITHM\", \"TOKEN_LIFETIME\"]\\n\\nAPNS_OPTIONAL_SETTINGS = [\\n\\t\"USE_SANDBOX\", \"USE_ALTERNATIVE_PORT\", \"TOPIC\"\\n]\\n\\nFCM_REQUIRED_SETTINGS = GCM_REQUIRED_SETTINGS = [\"API_KEY\"]\\nFCM_OPTIONAL_SETTINGS = GCM_OPTIONAL_SETTINGS = [\\n\\t\"POST_URL\", \"MAX_RECIPIENTS\", \"ERROR_TIMEOUT\"\\n]\\n\\nWNS_REQUIRED_SETTINGS = [\"PACKAGE_SECURITY_ID\", \"SECRET_KEY\"]\\nWNS_OPTIONAL_SETTINGS = [\"WNS_ACCESS_URL\"]\\n\\nWP_REQUIRED_SETTINGS = [\"PRIVATE_KEY\", \"CLAIMS\"]\\nWP_OPTIONAL_SETTINGS = [\"ERROR_TIMEOUT\", \"POST_URL\"]\\n\\n\\nclass AppConfig(BaseConfig):\\n\\t\"\"\"\\n\\tSupports any number of push notification enabled applications.\\n\\t\"\"\"\\n\\n\\tdef __init__(self, settings=None):\\n\\t\\t# supports overriding the settings to be loaded. Will load from ..settings by default.\\n\\t\\tself._settings = settings or SETTINGS\\n\\n\\t\\t# initialize APPLICATIONS to an empty collection\\n\\t\\tself._settings.setdefault(\"APPLICATIONS\", {})\\n\\n\\t\\t# validate application configurations\\n\\t\\tself._validate_applications(self._settings[\"APPLICATIONS\"])\\n\\n\\tdef _validate_applications(self, apps):\\n\\t\\t\"\"\"Validate the application collection\"\"\"\\n\\t\\tfor application_id, application_config in apps.items():\\n\\t\\t\\tself._validate_config(application_id, application_config)\\n\\n\\t\\t\\tapplication_config[\"APPLICATION_ID\"] = application_id\\n\\n\\tdef _validate_config(self, application_id, application_config):\\n\\t\\tplatform = application_config.get(\"PLATFORM\", None)\\n\\n\\t\\t# platform is not present\\n\\t\\tif platform is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"required\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# platform is not a valid choice from PLATFORMS\\n\\t\\tif platform not in PLATFORMS:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"invalid\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\tvalidate_fn = \"_validate_{platform}_config\".format(platform=platform).lower()\\n\\n\\t\\tif hasattr(self, validate_fn):\\n\\t\\t\\tgetattr(self, validate_fn)(application_id, application_config)\\n\\t\\telse:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tUNKNOWN_PLATFORM.format(\\n\\t\\t\\t\\t\\tplatform=platform,\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\tdef _validate_apns_config(self, application_id, application_config):\\n\\t\\tallowed = REQUIRED_SETTINGS + OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\tAPNS_OPTIONAL_SETTINGS\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\t# We have two sets of settings, certificate and JWT auth key.\\n\\t\\t# Auth Key requires 3 values, so if that is set, that will take\\n\\t\\t# precedence. If None are set, we will throw an error.\\n\\t\\thas_cert_creds = APNS_SETTINGS_CERT_CREDS in \\\\\\n\\t\\t\\tapplication_config.keys()\\n\\t\\tself.has_token_creds = True\\n\\t\\tfor token_setting in APNS_AUTH_CREDS_REQUIRED:\\n\\t\\t\\tif token_setting not in application_config.keys():\\n\\t\\t\\t\\tself.has_token_creds = False\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif not has_cert_creds and not self.has_token_creds:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tsetting=(APNS_SETTINGS_CERT_CREDS, APNS_AUTH_CREDS_REQUIRED)))\\n\\t\\tcert_path = None\\n\\t\\tif has_cert_creds:\\n\\t\\t\\tcert_path = \"CERTIFICATE\"\\n\\t\\telif self.has_token_creds:\\n\\t\\t\\tcert_path = \"AUTH_KEY_PATH\"\\n\\t\\t\\tallowed_tokens = APNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\t\\tAPNS_OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\t\\tREQUIRED_SETTINGS\\n\\t\\t\\tself._validate_allowed_settings(application_id, application_config, allowed_tokens)\\n\\t\\t\\tself._validate_required_settings(\\n\\t\\t\\t\\tapplication_id, application_config, APNS_AUTH_CREDS_REQUIRED\\n\\t\\t\\t)\\n\\t\\tself._validate_apns_certificate(application_config[cert_path])\\n\\n\\t\\t# determine/set optional values\\n\\t\\tapplication_config.setdefault(\"USE_SANDBOX\", False)\\n\\t\\tapplication_config.setdefault(\"USE_ALTERNATIVE_PORT\", False)\\n\\t\\tapplication_config.setdefault(\"TOPIC\", None)\\n\\n\\tdef _validate_apns_certificate(self, certfile):\\n\\t\\t\"\"\"Validate the APNS certificate at startup.\"\"\"\\n\\n\\t\\ttry:\\n\\t\\t\\twith open(certfile, \"r\") as f:\\n\\t\\t\\t\\tcontent = f.read()\\n\\t\\t\\t\\tcheck_apns_certificate(content)\\n\\t\\texcept Exception as e:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"The APNS certificate file at {!r} is not readable: {}\".format(certfile, e)\\n\\t\\t\\t)\\n\\n\\tdef _validate_fcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + FCM_REQUIRED_SETTINGS + FCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, FCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://fcm.googleapis.com/fcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_gcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + GCM_REQUIRED_SETTINGS + GCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, GCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://android.googleapis.com/gcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_wns_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WNS_REQUIRED_SETTINGS + WNS_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WNS_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\")\\n\\n\\tdef _validate_wp_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WP_REQUIRED_SETTINGS + WP_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WP_REQUIRED_SETTINGS\\n\\t\\t)\\n\\t\\tapplication_config.setdefault(\"POST_URL\", {\\n\\t\\t\\t\"CHROME\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"OPERA\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n\\t\\t\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\\t})\\n\\n\\tdef _validate_allowed_settings(self, application_id, application_config, allowed_settings):\\n\\t\\t\"\"\"Confirm only allowed settings are present.\"\"\"\\n\\n\\t\\tfor setting_key in application_config.keys():\\n\\t\\t\\tif setting_key not in allowed_settings:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"Platform {}, app {} does not support the setting: {}.\".format(\\n\\t\\t\\t\\t\\t\\tapplication_config[\"PLATFORM\"], application_id, setting_key\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\n\\tdef _validate_required_settings(\\n\\t\\tself, application_id, application_config, required_settings,\\n\\t\\tshould_throw=True\\n\\t):\\n\\t\\t\"\"\"All required keys must be present\"\"\"\\n\\n\\t\\tfor setting_key in required_settings:\\n\\t\\t\\tif setting_key not in application_config.keys():\\n\\t\\t\\t\\tif should_throw:\\n\\t\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\t\\t\\tapplication_id=application_id, setting=setting_key\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tdef _get_application_settings(self, application_id, platform, settings_key):\\n\\t\\t\"\"\"\\n\\t\\tWalks through PUSH_NOTIFICATIONS_SETTINGS to find the correct setting value\\n\\t\\tor raises ImproperlyConfigured.\\n\\t\\t\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tconf_cls = \"push_notifications.conf.AppConfig\"\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"{} requires the application_id be specified at all times.\".format(conf_cls)\\n\\t\\t\\t)\\n\\n\\t\\t# verify that the application config exists\\n\\t\\tapp_config = self._settings.get(\"APPLICATIONS\").get(application_id, None)\\n\\t\\tif app_config is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"No application configured with application_id: {}.\".format(application_id)\\n\\t\\t\\t)\\n\\n\\t\\t# fetch a setting for the incorrect type of platform\\n\\t\\tif app_config.get(\"PLATFORM\") != platform:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tSETTING_MISMATCH.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tplatform=app_config.get(\"PLATFORM\"),\\n\\t\\t\\t\\t\\tsetting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# finally, try to fetch the setting\\n\\t\\tif settings_key not in app_config:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id, setting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\treturn app_config.get(settings_key)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\treturn self.has_token_creds\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"GCM\", \"API_KEY\")\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"FCM\", \"API_KEY\")\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"POST_URL\")\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"ERROR_TIMEOUT\")\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"MAX_RECIPIENTS\")\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(application_id, \"APNS\", \"CERTIFICATE\")\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn \\\\\\n\\t\\t(self._get_apns_auth_key_path(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key_path(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_PATH\")\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_ID\")\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TEAM_ID\")\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_SANDBOX\")\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_ALTERNATIVE_PORT\")\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TOPIC\")\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"PACKAGE_SECURITY_ID\")\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"SECRET_KEY\")\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"POST_URL\")[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"PRIVATE_KEY\")\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"CLAIMS\")\\n'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig, check_apns_certificate\\n\\n\\nSETTING_MISMATCH = (\\n\\t\"Application \\'{application_id}\\' ({platform}) does not support the setting \\'{setting}\\'.\"\\n)\\n\\n# code can be \"missing\" or \"invalid\"\\nBAD_PLATFORM = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"PLATFORM\"] is {code}. \\'\\n\\t\"Must be one of: {platforms}.\"\\n)\\n\\nUNKNOWN_PLATFORM = (\\n\\t\"Unknown Platform: {platform}. Must be one of: {platforms}.\"\\n)\\n\\nMISSING_SETTING = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"{setting}\"] is missing.\\'\\n)\\n\\nPLATFORMS = [\\n\\t\"APNS\",\\n\\t\"FCM\",\\n\\t\"GCM\",\\n\\t\"WNS\",\\n\\t\"WP\",\\n]\\n\\n# Settings that all applications must have\\nREQUIRED_SETTINGS = [\\n\\t\"PLATFORM\",\\n]\\n\\n# Settings that an application may have to enable optional features\\n# these settings are stubs for registry support and have no effect on the operation\\n# of the application at this time.\\nOPTIONAL_SETTINGS = [\\n\\t\"APPLICATION_GROUP\", \"APPLICATION_SECRET\"\\n]\\n\\n# Since we can have an auth key, combined with a auth key id and team id *or*\\n# a certificate, we make these all optional, and then make sure we have one or\\n# the other (group) of settings.\\nAPNS_SETTINGS_CERT_CREDS = \"CERTIFICATE\"\\n\\n# Subkeys for APNS_SETTINGS_AUTH_CREDS\\nAPNS_AUTH_CREDS_REQUIRED = [\"AUTH_KEY_PATH\", \"AUTH_KEY_ID\", \"TEAM_ID\"]\\nAPNS_AUTH_CREDS_OPTIONAL = [\"CERTIFICATE\", \"ENCRYPTION_ALGORITHM\", \"TOKEN_LIFETIME\"]\\n\\nAPNS_OPTIONAL_SETTINGS = [\\n\\t\"USE_SANDBOX\", \"USE_ALTERNATIVE_PORT\", \"TOPIC\"\\n]\\n\\nFCM_REQUIRED_SETTINGS = GCM_REQUIRED_SETTINGS = [\"API_KEY\"]\\nFCM_OPTIONAL_SETTINGS = GCM_OPTIONAL_SETTINGS = [\\n\\t\"POST_URL\", \"MAX_RECIPIENTS\", \"ERROR_TIMEOUT\"\\n]\\n\\nWNS_REQUIRED_SETTINGS = [\"PACKAGE_SECURITY_ID\", \"SECRET_KEY\"]\\nWNS_OPTIONAL_SETTINGS = [\"WNS_ACCESS_URL\"]\\n\\nWP_REQUIRED_SETTINGS = [\"PRIVATE_KEY\", \"CLAIMS\"]\\nWP_OPTIONAL_SETTINGS = [\"ERROR_TIMEOUT\", \"POST_URL\"]\\n\\n\\nclass AppConfig(BaseConfig):\\n\\t\"\"\"\\n\\tSupports any number of push notification enabled applications.\\n\\t\"\"\"\\n\\n\\tdef __init__(self, settings=None):\\n\\t\\t# supports overriding the settings to be loaded. Will load from ..settings by default.\\n\\t\\tself._settings = settings or SETTINGS\\n\\n\\t\\t# initialize APPLICATIONS to an empty collection\\n\\t\\tself._settings.setdefault(\"APPLICATIONS\", {})\\n\\n\\t\\t# validate application configurations\\n\\t\\tself._validate_applications(self._settings[\"APPLICATIONS\"])\\n\\n\\tdef _validate_applications(self, apps):\\n\\t\\t\"\"\"Validate the application collection\"\"\"\\n\\t\\tfor application_id, application_config in apps.items():\\n\\t\\t\\tself._validate_config(application_id, application_config)\\n\\n\\t\\t\\tapplication_config[\"APPLICATION_ID\"] = application_id\\n\\n\\tdef _validate_config(self, application_id, application_config):\\n\\t\\tplatform = application_config.get(\"PLATFORM\", None)\\n\\n\\t\\t# platform is not present\\n\\t\\tif platform is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"required\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# platform is not a valid choice from PLATFORMS\\n\\t\\tif platform not in PLATFORMS:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"invalid\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\tvalidate_fn = \"_validate_{platform}_config\".format(platform=platform).lower()\\n\\n\\t\\tif hasattr(self, validate_fn):\\n\\t\\t\\tgetattr(self, validate_fn)(application_id, application_config)\\n\\t\\telse:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tUNKNOWN_PLATFORM.format(\\n\\t\\t\\t\\t\\tplatform=platform,\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\tdef _validate_apns_config(self, application_id, application_config):\\n\\t\\tallowed = REQUIRED_SETTINGS + OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\tAPNS_OPTIONAL_SETTINGS\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\t# We have two sets of settings, certificate and JWT auth key.\\n\\t\\t# Auth Key requires 3 values, so if that is set, that will take\\n\\t\\t# precedence. If None are set, we will throw an error.\\n\\t\\thas_cert_creds = APNS_SETTINGS_CERT_CREDS in \\\\\\n\\t\\t\\tapplication_config.keys()\\n\\t\\tself.has_token_creds = True\\n\\t\\tfor token_setting in APNS_AUTH_CREDS_REQUIRED:\\n\\t\\t\\tif token_setting not in application_config.keys():\\n\\t\\t\\t\\tself.has_token_creds = False\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif not has_cert_creds and not self.has_token_creds:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tsetting=(APNS_SETTINGS_CERT_CREDS, APNS_AUTH_CREDS_REQUIRED)))\\n\\t\\tcert_path = None\\n\\t\\tif has_cert_creds:\\n\\t\\t\\tcert_path = \"CERTIFICATE\"\\n\\t\\telif self.has_token_creds:\\n\\t\\t\\tcert_path = \"AUTH_KEY_PATH\"\\n\\t\\t\\tallowed_tokens = APNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\t\\tAPNS_OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\t\\tREQUIRED_SETTINGS\\n\\t\\t\\tself._validate_allowed_settings(application_id, application_config, allowed_tokens)\\n\\t\\t\\tself._validate_required_settings(\\n\\t\\t\\t\\tapplication_id, application_config, APNS_AUTH_CREDS_REQUIRED\\n\\t\\t\\t)\\n\\t\\tself._validate_apns_certificate(application_config[cert_path])\\n\\n\\t\\t# determine/set optional values\\n\\t\\tapplication_config.setdefault(\"USE_SANDBOX\", False)\\n\\t\\tapplication_config.setdefault(\"USE_ALTERNATIVE_PORT\", False)\\n\\t\\tapplication_config.setdefault(\"TOPIC\", None)\\n\\n\\tdef _validate_apns_certificate(self, certfile):\\n\\t\\t\"\"\"Validate the APNS certificate at startup.\"\"\"\\n\\n\\t\\ttry:\\n\\t\\t\\twith open(certfile, \"r\") as f:\\n\\t\\t\\t\\tcontent = f.read()\\n\\t\\t\\t\\tcheck_apns_certificate(content)\\n\\t\\texcept Exception as e:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"The APNS certificate file at {!r} is not readable: {}\".format(certfile, e)\\n\\t\\t\\t)\\n\\n\\tdef _validate_fcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + FCM_REQUIRED_SETTINGS + FCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, FCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://fcm.googleapis.com/fcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_gcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + GCM_REQUIRED_SETTINGS + GCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, GCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://android.googleapis.com/gcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_wns_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WNS_REQUIRED_SETTINGS + WNS_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WNS_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\")\\n\\n\\tdef _validate_wp_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WP_REQUIRED_SETTINGS + WP_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WP_REQUIRED_SETTINGS\\n\\t\\t)\\n\\t\\tapplication_config.setdefault(\"POST_URL\", {\\n\\t\\t\\t\"CHROME\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"OPERA\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n\\t\\t\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\\t})\\n\\n\\tdef _validate_allowed_settings(self, application_id, application_config, allowed_settings):\\n\\t\\t\"\"\"Confirm only allowed settings are present.\"\"\"\\n\\n\\t\\tfor setting_key in application_config.keys():\\n\\t\\t\\tif setting_key not in allowed_settings:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"Platform {}, app {} does not support the setting: {}.\".format(\\n\\t\\t\\t\\t\\t\\tapplication_config[\"PLATFORM\"], application_id, setting_key\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\n\\tdef _validate_required_settings(\\n\\t\\tself, application_id, application_config, required_settings,\\n\\t\\tshould_throw=True\\n\\t):\\n\\t\\t\"\"\"All required keys must be present\"\"\"\\n\\n\\t\\tfor setting_key in required_settings:\\n\\t\\t\\tif setting_key not in application_config.keys():\\n\\t\\t\\t\\tif should_throw:\\n\\t\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\t\\t\\tapplication_id=application_id, setting=setting_key\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tdef _get_application_settings(self, application_id, platform, settings_key):\\n\\t\\t\"\"\"\\n\\t\\tWalks through PUSH_NOTIFICATIONS_SETTINGS to find the correct setting value\\n\\t\\tor raises ImproperlyConfigured.\\n\\t\\t\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tconf_cls = \"push_notifications.conf.AppConfig\"\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"{} requires the application_id be specified at all times.\".format(conf_cls)\\n\\t\\t\\t)\\n\\n\\t\\t# verify that the application config exists\\n\\t\\tapp_config = self._settings.get(\"APPLICATIONS\").get(application_id, None)\\n\\t\\tif app_config is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"No application configured with application_id: {}.\".format(application_id)\\n\\t\\t\\t)\\n\\n\\t\\t# fetch a setting for the incorrect type of platform\\n\\t\\tif app_config.get(\"PLATFORM\") != platform:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tSETTING_MISMATCH.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tplatform=app_config.get(\"PLATFORM\"),\\n\\t\\t\\t\\t\\tsetting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# finally, try to fetch the setting\\n\\t\\tif settings_key not in app_config:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id, setting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\treturn app_config.get(settings_key)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\treturn self.has_token_creds\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"GCM\", \"API_KEY\")\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"FCM\", \"API_KEY\")\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"POST_URL\")\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"ERROR_TIMEOUT\")\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"MAX_RECIPIENTS\")\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(application_id, \"APNS\", \"CERTIFICATE\")\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn \\\\\\n\\t\\t(self._get_apns_auth_key_path(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key_path(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_PATH\")\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_ID\")\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TEAM_ID\")\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_SANDBOX\")\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_ALTERNATIVE_PORT\")\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TOPIC\")\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"PACKAGE_SECURITY_ID\")\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"SECRET_KEY\")\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"POST_URL\")[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"PRIVATE_KEY\")\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"CLAIMS\")\\n'"}, {"func_args": {"source": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig, check_apns_certificate\\n\\n\\nSETTING_MISMATCH = (\\n\\t\"Application \\'{application_id}\\' ({platform}) does not support the setting \\'{setting}\\'.\"\\n)\\n\\n# code can be \"missing\" or \"invalid\"\\nBAD_PLATFORM = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"PLATFORM\"] is {code}. \\'\\n\\t\"Must be one of: {platforms}.\"\\n)\\n\\nUNKNOWN_PLATFORM = (\\n\\t\"Unknown Platform: {platform}. Must be one of: {platforms}.\"\\n)\\n\\nMISSING_SETTING = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"{setting}\"] is missing.\\'\\n)\\n\\nPLATFORMS = [\\n\\t\"APNS\",\\n\\t\"FCM\",\\n\\t\"GCM\",\\n\\t\"WNS\",\\n\\t\"WP\",\\n]\\n\\n# Settings that all applications must have\\nREQUIRED_SETTINGS = [\\n\\t\"PLATFORM\",\\n]\\n\\n# Settings that an application may have to enable optional features\\n# these settings are stubs for registry support and have no effect on the operation\\n# of the application at this time.\\nOPTIONAL_SETTINGS = [\\n\\t\"APPLICATION_GROUP\", \"APPLICATION_SECRET\"\\n]\\n\\n# Since we can have an auth key, combined with a auth key id and team id *or*\\n# a certificate, we make these all optional, and then make sure we have one or\\n# the other (group) of settings.\\nAPNS_SETTINGS_CERT_CREDS = \"CERTIFICATE\"\\n\\n# Subkeys for APNS_SETTINGS_AUTH_CREDS\\nAPNS_AUTH_CREDS_REQUIRED = [\"AUTH_KEY_PATH\", \"AUTH_KEY_ID\", \"TEAM_ID\"]\\nAPNS_AUTH_CREDS_OPTIONAL = [\"CERTIFICATE\", \"ENCRYPTION_ALGORITHM\", \"TOKEN_LIFETIME\"]\\n\\nAPNS_OPTIONAL_SETTINGS = [\\n\\t\"USE_SANDBOX\", \"USE_ALTERNATIVE_PORT\", \"TOPIC\"\\n]\\n\\nFCM_REQUIRED_SETTINGS = GCM_REQUIRED_SETTINGS = [\"API_KEY\"]\\nFCM_OPTIONAL_SETTINGS = GCM_OPTIONAL_SETTINGS = [\\n\\t\"POST_URL\", \"MAX_RECIPIENTS\", \"ERROR_TIMEOUT\"\\n]\\n\\nWNS_REQUIRED_SETTINGS = [\"PACKAGE_SECURITY_ID\", \"SECRET_KEY\"]\\nWNS_OPTIONAL_SETTINGS = [\"WNS_ACCESS_URL\"]\\n\\nWP_REQUIRED_SETTINGS = [\"PRIVATE_KEY\", \"CLAIMS\"]\\nWP_OPTIONAL_SETTINGS = [\"ERROR_TIMEOUT\", \"POST_URL\"]\\n\\n\\nclass AppConfig(BaseConfig):\\n\\t\"\"\"\\n\\tSupports any number of push notification enabled applications.\\n\\t\"\"\"\\n\\n\\tdef __init__(self, settings=None):\\n\\t\\t# supports overriding the settings to be loaded. Will load from ..settings by default.\\n\\t\\tself._settings = settings or SETTINGS\\n\\n\\t\\t# initialize APPLICATIONS to an empty collection\\n\\t\\tself._settings.setdefault(\"APPLICATIONS\", {})\\n\\n\\t\\t# validate application configurations\\n\\t\\tself._validate_applications(self._settings[\"APPLICATIONS\"])\\n\\n\\tdef _validate_applications(self, apps):\\n\\t\\t\"\"\"Validate the application collection\"\"\"\\n\\t\\tfor application_id, application_config in apps.items():\\n\\t\\t\\tself._validate_config(application_id, application_config)\\n\\n\\t\\t\\tapplication_config[\"APPLICATION_ID\"] = application_id\\n\\n\\tdef _validate_config(self, application_id, application_config):\\n\\t\\tplatform = application_config.get(\"PLATFORM\", None)\\n\\n\\t\\t# platform is not present\\n\\t\\tif platform is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"required\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# platform is not a valid choice from PLATFORMS\\n\\t\\tif platform not in PLATFORMS:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"invalid\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\tvalidate_fn = \"_validate_{platform}_config\".format(platform=platform).lower()\\n\\n\\t\\tif hasattr(self, validate_fn):\\n\\t\\t\\tgetattr(self, validate_fn)(application_id, application_config)\\n\\t\\telse:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tUNKNOWN_PLATFORM.format(\\n\\t\\t\\t\\t\\tplatform=platform,\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\tdef _validate_apns_config(self, application_id, application_config):\\n\\t\\tallowed = REQUIRED_SETTINGS + OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\tAPNS_OPTIONAL_SETTINGS\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\t# We have two sets of settings, certificate and JWT auth key.\\n\\t\\t# Auth Key requires 3 values, so if that is set, that will take\\n\\t\\t# precedence. If None are set, we will throw an error.\\n\\t\\thas_cert_creds = APNS_SETTINGS_CERT_CREDS in \\\\\\n\\t\\t\\tapplication_config.keys()\\n\\t\\tself.has_token_creds = True\\n\\t\\tfor token_setting in APNS_AUTH_CREDS_REQUIRED:\\n\\t\\t\\tif token_setting not in application_config.keys():\\n\\t\\t\\t\\tself.has_token_creds = False\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif not has_cert_creds and not self.has_token_creds:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tsetting=(APNS_SETTINGS_CERT_CREDS, APNS_AUTH_CREDS_REQUIRED)))\\n\\t\\tcert_path = None\\n\\t\\tif has_cert_creds:\\n\\t\\t\\tcert_path = \"CERTIFICATE\"\\n\\t\\telif self.has_token_creds:\\n\\t\\t\\tcert_path = \"AUTH_KEY_PATH\"\\n\\t\\t\\tallowed_tokens = APNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\t\\tAPNS_OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\t\\tREQUIRED_SETTINGS\\n\\t\\t\\tself._validate_allowed_settings(application_id, application_config, allowed_tokens)\\n\\t\\t\\tself._validate_required_settings(\\n\\t\\t\\t\\tapplication_id, application_config, APNS_AUTH_CREDS_REQUIRED\\n\\t\\t\\t)\\n\\t\\tself._validate_apns_certificate(application_config[cert_path])\\n\\n\\t\\t# determine/set optional values\\n\\t\\tapplication_config.setdefault(\"USE_SANDBOX\", False)\\n\\t\\tapplication_config.setdefault(\"USE_ALTERNATIVE_PORT\", False)\\n\\t\\tapplication_config.setdefault(\"TOPIC\", None)\\n\\n\\tdef _validate_apns_certificate(self, certfile):\\n\\t\\t\"\"\"Validate the APNS certificate at startup.\"\"\"\\n\\n\\t\\ttry:\\n\\t\\t\\twith open(certfile, \"r\") as f:\\n\\t\\t\\t\\tcontent = f.read()\\n\\t\\t\\t\\tcheck_apns_certificate(content)\\n\\t\\texcept Exception as e:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"The APNS certificate file at {!r} is not readable: {}\".format(certfile, e)\\n\\t\\t\\t)\\n\\n\\tdef _validate_fcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + FCM_REQUIRED_SETTINGS + FCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, FCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://fcm.googleapis.com/fcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_gcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + GCM_REQUIRED_SETTINGS + GCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, GCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://android.googleapis.com/gcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_wns_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WNS_REQUIRED_SETTINGS + WNS_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WNS_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\")\\n\\n\\tdef _validate_wp_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WP_REQUIRED_SETTINGS + WP_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WP_REQUIRED_SETTINGS\\n\\t\\t)\\n\\t\\tapplication_config.setdefault(\"POST_URL\", {\\n\\t\\t\\t\"CHROME\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"OPERA\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n\\t\\t\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\\t})\\n\\n\\tdef _validate_allowed_settings(self, application_id, application_config, allowed_settings):\\n\\t\\t\"\"\"Confirm only allowed settings are present.\"\"\"\\n\\n\\t\\tfor setting_key in application_config.keys():\\n\\t\\t\\tif setting_key not in allowed_settings:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"Platform {}, app {} does not support the setting: {}.\".format(\\n\\t\\t\\t\\t\\t\\tapplication_config[\"PLATFORM\"], application_id, setting_key\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\n\\tdef _validate_required_settings(\\n\\t\\tself, application_id, application_config, required_settings,\\n\\t\\tshould_throw=True\\n\\t):\\n\\t\\t\"\"\"All required keys must be present\"\"\"\\n\\n\\t\\tfor setting_key in required_settings:\\n\\t\\t\\tif setting_key not in application_config.keys():\\n\\t\\t\\t\\tif should_throw:\\n\\t\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\t\\t\\tapplication_id=application_id, setting=setting_key\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tdef _get_application_settings(self, application_id, platform, settings_key):\\n\\t\\t\"\"\"\\n\\t\\tWalks through PUSH_NOTIFICATIONS_SETTINGS to find the correct setting value\\n\\t\\tor raises ImproperlyConfigured.\\n\\t\\t\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tconf_cls = \"push_notifications.conf.AppConfig\"\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"{} requires the application_id be specified at all times.\".format(conf_cls)\\n\\t\\t\\t)\\n\\n\\t\\t# verify that the application config exists\\n\\t\\tapp_config = self._settings.get(\"APPLICATIONS\").get(application_id, None)\\n\\t\\tif app_config is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"No application configured with application_id: {}.\".format(application_id)\\n\\t\\t\\t)\\n\\n\\t\\t# fetch a setting for the incorrect type of platform\\n\\t\\tif app_config.get(\"PLATFORM\") != platform:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tSETTING_MISMATCH.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tplatform=app_config.get(\"PLATFORM\"),\\n\\t\\t\\t\\t\\tsetting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# finally, try to fetch the setting\\n\\t\\tif settings_key not in app_config:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id, setting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\treturn app_config.get(settings_key)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\treturn self.has_token_creds\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"GCM\", \"API_KEY\")\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"FCM\", \"API_KEY\")\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"POST_URL\")\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"ERROR_TIMEOUT\")\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"MAX_RECIPIENTS\")\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(application_id, \"APNS\", \"CERTIFICATE\")\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn \\\\\\n\\t\\t(self._get_apns_auth_key_path(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key_path(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_PATH\")\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_ID\")\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TEAM_ID\")\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_SANDBOX\")\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_ALTERNATIVE_PORT\")\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TOPIC\")\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"PACKAGE_SECURITY_ID\")\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"SECRET_KEY\")\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"POST_URL\")[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"PRIVATE_KEY\")\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"CLAIMS\")\\n'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig, check_apns_certificate\\n\\n\\nSETTING_MISMATCH = (\\n\\t\"Application \\'{application_id}\\' ({platform}) does not support the setting \\'{setting}\\'.\"\\n)\\n\\n# code can be \"missing\" or \"invalid\"\\nBAD_PLATFORM = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"PLATFORM\"] is {code}. \\'\\n\\t\"Must be one of: {platforms}.\"\\n)\\n\\nUNKNOWN_PLATFORM = (\\n\\t\"Unknown Platform: {platform}. Must be one of: {platforms}.\"\\n)\\n\\nMISSING_SETTING = (\\n\\t\\'PUSH_NOTIFICATIONS_SETTINGS.APPLICATIONS[\"{application_id}\"][\"{setting}\"] is missing.\\'\\n)\\n\\nPLATFORMS = [\\n\\t\"APNS\",\\n\\t\"FCM\",\\n\\t\"GCM\",\\n\\t\"WNS\",\\n\\t\"WP\",\\n]\\n\\n# Settings that all applications must have\\nREQUIRED_SETTINGS = [\\n\\t\"PLATFORM\",\\n]\\n\\n# Settings that an application may have to enable optional features\\n# these settings are stubs for registry support and have no effect on the operation\\n# of the application at this time.\\nOPTIONAL_SETTINGS = [\\n\\t\"APPLICATION_GROUP\", \"APPLICATION_SECRET\"\\n]\\n\\n# Since we can have an auth key, combined with a auth key id and team id *or*\\n# a certificate, we make these all optional, and then make sure we have one or\\n# the other (group) of settings.\\nAPNS_SETTINGS_CERT_CREDS = \"CERTIFICATE\"\\n\\n# Subkeys for APNS_SETTINGS_AUTH_CREDS\\nAPNS_AUTH_CREDS_REQUIRED = [\"AUTH_KEY_PATH\", \"AUTH_KEY_ID\", \"TEAM_ID\"]\\nAPNS_AUTH_CREDS_OPTIONAL = [\"CERTIFICATE\", \"ENCRYPTION_ALGORITHM\", \"TOKEN_LIFETIME\"]\\n\\nAPNS_OPTIONAL_SETTINGS = [\\n\\t\"USE_SANDBOX\", \"USE_ALTERNATIVE_PORT\", \"TOPIC\"\\n]\\n\\nFCM_REQUIRED_SETTINGS = GCM_REQUIRED_SETTINGS = [\"API_KEY\"]\\nFCM_OPTIONAL_SETTINGS = GCM_OPTIONAL_SETTINGS = [\\n\\t\"POST_URL\", \"MAX_RECIPIENTS\", \"ERROR_TIMEOUT\"\\n]\\n\\nWNS_REQUIRED_SETTINGS = [\"PACKAGE_SECURITY_ID\", \"SECRET_KEY\"]\\nWNS_OPTIONAL_SETTINGS = [\"WNS_ACCESS_URL\"]\\n\\nWP_REQUIRED_SETTINGS = [\"PRIVATE_KEY\", \"CLAIMS\"]\\nWP_OPTIONAL_SETTINGS = [\"ERROR_TIMEOUT\", \"POST_URL\"]\\n\\n\\nclass AppConfig(BaseConfig):\\n\\t\"\"\"\\n\\tSupports any number of push notification enabled applications.\\n\\t\"\"\"\\n\\n\\tdef __init__(self, settings=None):\\n\\t\\t# supports overriding the settings to be loaded. Will load from ..settings by default.\\n\\t\\tself._settings = settings or SETTINGS\\n\\n\\t\\t# initialize APPLICATIONS to an empty collection\\n\\t\\tself._settings.setdefault(\"APPLICATIONS\", {})\\n\\n\\t\\t# validate application configurations\\n\\t\\tself._validate_applications(self._settings[\"APPLICATIONS\"])\\n\\n\\tdef _validate_applications(self, apps):\\n\\t\\t\"\"\"Validate the application collection\"\"\"\\n\\t\\tfor application_id, application_config in apps.items():\\n\\t\\t\\tself._validate_config(application_id, application_config)\\n\\n\\t\\t\\tapplication_config[\"APPLICATION_ID\"] = application_id\\n\\n\\tdef _validate_config(self, application_id, application_config):\\n\\t\\tplatform = application_config.get(\"PLATFORM\", None)\\n\\n\\t\\t# platform is not present\\n\\t\\tif platform is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"required\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# platform is not a valid choice from PLATFORMS\\n\\t\\tif platform not in PLATFORMS:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tBAD_PLATFORM.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tcode=\"invalid\",\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\tvalidate_fn = \"_validate_{platform}_config\".format(platform=platform).lower()\\n\\n\\t\\tif hasattr(self, validate_fn):\\n\\t\\t\\tgetattr(self, validate_fn)(application_id, application_config)\\n\\t\\telse:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tUNKNOWN_PLATFORM.format(\\n\\t\\t\\t\\t\\tplatform=platform,\\n\\t\\t\\t\\t\\tplatforms=\", \".join(PLATFORMS)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\tdef _validate_apns_config(self, application_id, application_config):\\n\\t\\tallowed = REQUIRED_SETTINGS + OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\tAPNS_OPTIONAL_SETTINGS\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\t# We have two sets of settings, certificate and JWT auth key.\\n\\t\\t# Auth Key requires 3 values, so if that is set, that will take\\n\\t\\t# precedence. If None are set, we will throw an error.\\n\\t\\thas_cert_creds = APNS_SETTINGS_CERT_CREDS in \\\\\\n\\t\\t\\tapplication_config.keys()\\n\\t\\tself.has_token_creds = True\\n\\t\\tfor token_setting in APNS_AUTH_CREDS_REQUIRED:\\n\\t\\t\\tif token_setting not in application_config.keys():\\n\\t\\t\\t\\tself.has_token_creds = False\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif not has_cert_creds and not self.has_token_creds:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tsetting=(APNS_SETTINGS_CERT_CREDS, APNS_AUTH_CREDS_REQUIRED)))\\n\\t\\tcert_path = None\\n\\t\\tif has_cert_creds:\\n\\t\\t\\tcert_path = \"CERTIFICATE\"\\n\\t\\telif self.has_token_creds:\\n\\t\\t\\tcert_path = \"AUTH_KEY_PATH\"\\n\\t\\t\\tallowed_tokens = APNS_AUTH_CREDS_REQUIRED + \\\\\\n\\t\\t\\t\\tAPNS_AUTH_CREDS_OPTIONAL + \\\\\\n\\t\\t\\t\\tAPNS_OPTIONAL_SETTINGS + \\\\\\n\\t\\t\\t\\tREQUIRED_SETTINGS\\n\\t\\t\\tself._validate_allowed_settings(application_id, application_config, allowed_tokens)\\n\\t\\t\\tself._validate_required_settings(\\n\\t\\t\\t\\tapplication_id, application_config, APNS_AUTH_CREDS_REQUIRED\\n\\t\\t\\t)\\n\\t\\tself._validate_apns_certificate(application_config[cert_path])\\n\\n\\t\\t# determine/set optional values\\n\\t\\tapplication_config.setdefault(\"USE_SANDBOX\", False)\\n\\t\\tapplication_config.setdefault(\"USE_ALTERNATIVE_PORT\", False)\\n\\t\\tapplication_config.setdefault(\"TOPIC\", None)\\n\\n\\tdef _validate_apns_certificate(self, certfile):\\n\\t\\t\"\"\"Validate the APNS certificate at startup.\"\"\"\\n\\n\\t\\ttry:\\n\\t\\t\\twith open(certfile, \"r\") as f:\\n\\t\\t\\t\\tcontent = f.read()\\n\\t\\t\\t\\tcheck_apns_certificate(content)\\n\\t\\texcept Exception as e:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"The APNS certificate file at {!r} is not readable: {}\".format(certfile, e)\\n\\t\\t\\t)\\n\\n\\tdef _validate_fcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + FCM_REQUIRED_SETTINGS + FCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, FCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://fcm.googleapis.com/fcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_gcm_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + GCM_REQUIRED_SETTINGS + GCM_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, GCM_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"POST_URL\", \"https://android.googleapis.com/gcm/send\")\\n\\t\\tapplication_config.setdefault(\"MAX_RECIPIENTS\", 1000)\\n\\t\\tapplication_config.setdefault(\"ERROR_TIMEOUT\", None)\\n\\n\\tdef _validate_wns_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WNS_REQUIRED_SETTINGS + WNS_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WNS_REQUIRED_SETTINGS\\n\\t\\t)\\n\\n\\t\\tapplication_config.setdefault(\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\")\\n\\n\\tdef _validate_wp_config(self, application_id, application_config):\\n\\t\\tallowed = (\\n\\t\\t\\tREQUIRED_SETTINGS + OPTIONAL_SETTINGS + WP_REQUIRED_SETTINGS + WP_OPTIONAL_SETTINGS\\n\\t\\t)\\n\\n\\t\\tself._validate_allowed_settings(application_id, application_config, allowed)\\n\\t\\tself._validate_required_settings(\\n\\t\\t\\tapplication_id, application_config, WP_REQUIRED_SETTINGS\\n\\t\\t)\\n\\t\\tapplication_config.setdefault(\"POST_URL\", {\\n\\t\\t\\t\"CHROME\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"OPERA\": \"https://fcm.googleapis.com/fcm/send\",\\n\\t\\t\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n\\t\\t\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\\t})\\n\\n\\tdef _validate_allowed_settings(self, application_id, application_config, allowed_settings):\\n\\t\\t\"\"\"Confirm only allowed settings are present.\"\"\"\\n\\n\\t\\tfor setting_key in application_config.keys():\\n\\t\\t\\tif setting_key not in allowed_settings:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"Platform {}, app {} does not support the setting: {}.\".format(\\n\\t\\t\\t\\t\\t\\tapplication_config[\"PLATFORM\"], application_id, setting_key\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\n\\tdef _validate_required_settings(\\n\\t\\tself, application_id, application_config, required_settings,\\n\\t\\tshould_throw=True\\n\\t):\\n\\t\\t\"\"\"All required keys must be present\"\"\"\\n\\n\\t\\tfor setting_key in required_settings:\\n\\t\\t\\tif setting_key not in application_config.keys():\\n\\t\\t\\t\\tif should_throw:\\n\\t\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\t\\t\\tapplication_id=application_id, setting=setting_key\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tdef _get_application_settings(self, application_id, platform, settings_key):\\n\\t\\t\"\"\"\\n\\t\\tWalks through PUSH_NOTIFICATIONS_SETTINGS to find the correct setting value\\n\\t\\tor raises ImproperlyConfigured.\\n\\t\\t\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tconf_cls = \"push_notifications.conf.AppConfig\"\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"{} requires the application_id be specified at all times.\".format(conf_cls)\\n\\t\\t\\t)\\n\\n\\t\\t# verify that the application config exists\\n\\t\\tapp_config = self._settings.get(\"APPLICATIONS\").get(application_id, None)\\n\\t\\tif app_config is None:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\"No application configured with application_id: {}.\".format(application_id)\\n\\t\\t\\t)\\n\\n\\t\\t# fetch a setting for the incorrect type of platform\\n\\t\\tif app_config.get(\"PLATFORM\") != platform:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tSETTING_MISMATCH.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id,\\n\\t\\t\\t\\t\\tplatform=app_config.get(\"PLATFORM\"),\\n\\t\\t\\t\\t\\tsetting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\t# finally, try to fetch the setting\\n\\t\\tif settings_key not in app_config:\\n\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\tMISSING_SETTING.format(\\n\\t\\t\\t\\t\\tapplication_id=application_id, setting=settings_key\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\n\\t\\treturn app_config.get(settings_key)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\treturn self.has_token_creds\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"GCM\", \"API_KEY\")\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"FCM\", \"API_KEY\")\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"POST_URL\")\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"ERROR_TIMEOUT\")\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, cloud_type, \"MAX_RECIPIENTS\")\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(application_id, \"APNS\", \"CERTIFICATE\")\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn \\\\\\n\\t\\t(self._get_apns_auth_key_path(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key_path(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_PATH\")\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"AUTH_KEY_ID\")\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TEAM_ID\")\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_SANDBOX\")\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"USE_ALTERNATIVE_PORT\")\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS\", \"TOPIC\")\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"PACKAGE_SECURITY_ID\")\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS\", \"SECRET_KEY\")\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"POST_URL\")[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"PRIVATE_KEY\")\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WP\", \"CLAIMS\")\\n'"}, {"func_args": {"source": "'from .base import BaseConfig\\n\\n\\nclass AppModelConfig(BaseConfig):\\n\\t\"\"\"Future home of the Application Model conf adapter\\n\\n\\tSupports multiple applications in the database.\\n\\t\"\"\"\\n\\n\\tpass\\n'"}, "return_value": "'from .base import BaseConfig\\n\\n\\nclass AppModelConfig(BaseConfig):\\n\\t\"\"\"Future home of the Application Model conf adapter\\n\\n\\tSupports multiple applications in the database.\\n\\t\"\"\"\\n\\n\\tpass\\n'"}, {"func_args": {"source": "'from .base import BaseConfig\\n\\n\\nclass AppModelConfig(BaseConfig):\\n\\t\"\"\"Future home of the Application Model conf adapter\\n\\n\\tSupports multiple applications in the database.\\n\\t\"\"\"\\n\\n\\tpass\\n'"}, "return_value": "'from .base import BaseConfig\\n\\n\\nclass AppModelConfig(BaseConfig):\\n\\t\"\"\"Future home of the Application Model conf adapter\\n\\n\\tSupports multiple applications in the database.\\n\\t\"\"\"\\n\\n\\tpass\\n'"}, {"func_args": {"source": "'from django.core.exceptions import ImproperlyConfigured\\n\\n\\nclass BaseConfig:\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_applications(self):\\n\\t\\t\"\"\"Returns a collection containing the configured applications.\"\"\"\\n\\n\\t\\traise NotImplementedError\\n\\n\\n# This works for both the certificate and the auth key (since that\\'s just\\n# a certificate).\\ndef check_apns_certificate(ss):\\n\\tmode = \"start\"\\n\\tfor s in ss.split(\"\\\\n\"):\\n\\t\\tif mode == \"start\":\\n\\t\\t\\tif \"BEGIN RSA PRIVATE KEY\" in s or \"BEGIN PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"key\"\\n\\t\\telif mode == \"key\":\\n\\t\\t\\tif \"END RSA PRIVATE KEY\" in s or \"END PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"end\"\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif s.startswith(\"Proc-Type\") and \"ENCRYPTED\" in s:\\n\\t\\t\\t\\traise ImproperlyConfigured(\"Encrypted APNS private keys are not supported\")\\n\\n\\tif mode != \"end\":\\n\\t\\traise ImproperlyConfigured(\"The APNS certificate doesn\\'t contain a private key\")\\n'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\n\\nclass BaseConfig:\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_applications(self):\\n\\t\\t\"\"\"Returns a collection containing the configured applications.\"\"\"\\n\\n\\t\\traise NotImplementedError\\n\\n\\n# This works for both the certificate and the auth key (since that\\'s just\\n# a certificate).\\ndef check_apns_certificate(ss):\\n\\tmode = \"start\"\\n\\tfor s in ss.split(\"\\\\n\"):\\n\\t\\tif mode == \"start\":\\n\\t\\t\\tif \"BEGIN RSA PRIVATE KEY\" in s or \"BEGIN PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"key\"\\n\\t\\telif mode == \"key\":\\n\\t\\t\\tif \"END RSA PRIVATE KEY\" in s or \"END PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"end\"\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif s.startswith(\"Proc-Type\") and \"ENCRYPTED\" in s:\\n\\t\\t\\t\\traise ImproperlyConfigured(\"Encrypted APNS private keys are not supported\")\\n\\n\\tif mode != \"end\":\\n\\t\\traise ImproperlyConfigured(\"The APNS certificate doesn\\'t contain a private key\")\\n'"}, {"func_args": {"source": "'from django.core.exceptions import ImproperlyConfigured\\n\\n\\nclass BaseConfig:\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_applications(self):\\n\\t\\t\"\"\"Returns a collection containing the configured applications.\"\"\"\\n\\n\\t\\traise NotImplementedError\\n\\n\\n# This works for both the certificate and the auth key (since that\\'s just\\n# a certificate).\\ndef check_apns_certificate(ss):\\n\\tmode = \"start\"\\n\\tfor s in ss.split(\"\\\\n\"):\\n\\t\\tif mode == \"start\":\\n\\t\\t\\tif \"BEGIN RSA PRIVATE KEY\" in s or \"BEGIN PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"key\"\\n\\t\\telif mode == \"key\":\\n\\t\\t\\tif \"END RSA PRIVATE KEY\" in s or \"END PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"end\"\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif s.startswith(\"Proc-Type\") and \"ENCRYPTED\" in s:\\n\\t\\t\\t\\traise ImproperlyConfigured(\"Encrypted APNS private keys are not supported\")\\n\\n\\tif mode != \"end\":\\n\\t\\traise ImproperlyConfigured(\"The APNS certificate doesn\\'t contain a private key\")\\n'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\n\\nclass BaseConfig:\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\traise NotImplementedError\\n\\n\\tdef get_applications(self):\\n\\t\\t\"\"\"Returns a collection containing the configured applications.\"\"\"\\n\\n\\t\\traise NotImplementedError\\n\\n\\n# This works for both the certificate and the auth key (since that\\'s just\\n# a certificate).\\ndef check_apns_certificate(ss):\\n\\tmode = \"start\"\\n\\tfor s in ss.split(\"\\\\n\"):\\n\\t\\tif mode == \"start\":\\n\\t\\t\\tif \"BEGIN RSA PRIVATE KEY\" in s or \"BEGIN PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"key\"\\n\\t\\telif mode == \"key\":\\n\\t\\t\\tif \"END RSA PRIVATE KEY\" in s or \"END PRIVATE KEY\" in s:\\n\\t\\t\\t\\tmode = \"end\"\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif s.startswith(\"Proc-Type\") and \"ENCRYPTED\" in s:\\n\\t\\t\\t\\traise ImproperlyConfigured(\"Encrypted APNS private keys are not supported\")\\n\\n\\tif mode != \"end\":\\n\\t\\traise ImproperlyConfigured(\"The APNS certificate doesn\\'t contain a private key\")\\n'"}, {"func_args": {"source": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig\\n\\n\\n__all__ = [\\n\\t\"LegacyConfig\"\\n]\\n\\n\\nclass empty:\\n\\tpass\\n\\n\\nclass LegacyConfig(BaseConfig):\\n\\n\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\n\\tdef _get_application_settings(self, application_id, settings_key, error_message):\\n\\t\\t\"\"\"Legacy behaviour\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tvalue = SETTINGS.get(settings_key, empty)\\n\\t\\t\\tif value is empty:\\n\\t\\t\\t\\traise ImproperlyConfigured(error_message)\\n\\t\\t\\treturn value\\n\\t\\telse:\\n\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\"LegacySettings does not support application_id. To enable \"\\n\\t\\t\\t\\t\"multiple application support, use push_notifications.conf.AppSettings.\"\\n\\t\\t\\t)\\n\\t\\t\\traise ImproperlyConfigured(msg)\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"GCM_API_KEY\"] to send messages through GCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"GCM_API_KEY\", msg)\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"FCM_API_KEY\"] to send messages through FCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"FCM_API_KEY\", msg)\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_POST_URL\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_ERROR_TIMEOUT\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_MAX_RECIPIENTS\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\ttry:\\n\\t\\t\\tself._get_apns_auth_key(application_id)\\n\\t\\t\\tself._get_apns_auth_key_id(application_id)\\n\\t\\t\\tself._get_apns_team_id(application_id)\\n\\t\\texcept ImproperlyConfigured:\\n\\t\\t\\treturn False\\n\\n\\t\\treturn True\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(\\n\\t\\t\\tapplication_id, \"APNS_CERTIFICATE\",\\n\\t\\t\\t\"You need to setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\t)\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\traise ImproperlyConfigured(msg)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn (\\n\\t\\t\\tself._get_apns_auth_key(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_PATH\", self.msg)\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TEAM_ID\", self.msg)\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_ID\", self.msg)\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_USE_SANDBOX\", self.msg)\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn\\n\\t\\tself._get_application_settings(application_id, \"APNS_USE_ALTERNATIVE_PORT\", self.msg)\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TOPIC\", self.msg)\\n\\n\\tdef get_apns_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_HOST\", self.msg)\\n\\n\\tdef get_apns_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_PORT\", self.msg)\\n\\n\\tdef get_apns_feedback_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_HOST\", self.msg)\\n\\n\\tdef get_apns_feedback_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_PORT\", self.msg)\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_PACKAGE_SECURITY_ID\", self.msg)\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_SECRET_KEY\", msg)\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_POST_URL\", msg)[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_PRIVATE_KEY\", msg)\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_CLAIMS\", msg)\\n'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig\\n\\n\\n__all__ = [\\n\\t\"LegacyConfig\"\\n]\\n\\n\\nclass empty:\\n\\tpass\\n\\n\\nclass LegacyConfig(BaseConfig):\\n\\n\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\n\\tdef _get_application_settings(self, application_id, settings_key, error_message):\\n\\t\\t\"\"\"Legacy behaviour\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tvalue = SETTINGS.get(settings_key, empty)\\n\\t\\t\\tif value is empty:\\n\\t\\t\\t\\traise ImproperlyConfigured(error_message)\\n\\t\\t\\treturn value\\n\\t\\telse:\\n\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\"LegacySettings does not support application_id. To enable \"\\n\\t\\t\\t\\t\"multiple application support, use push_notifications.conf.AppSettings.\"\\n\\t\\t\\t)\\n\\t\\t\\traise ImproperlyConfigured(msg)\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"GCM_API_KEY\"] to send messages through GCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"GCM_API_KEY\", msg)\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"FCM_API_KEY\"] to send messages through FCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"FCM_API_KEY\", msg)\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_POST_URL\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_ERROR_TIMEOUT\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_MAX_RECIPIENTS\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\ttry:\\n\\t\\t\\tself._get_apns_auth_key(application_id)\\n\\t\\t\\tself._get_apns_auth_key_id(application_id)\\n\\t\\t\\tself._get_apns_team_id(application_id)\\n\\t\\texcept ImproperlyConfigured:\\n\\t\\t\\treturn False\\n\\n\\t\\treturn True\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(\\n\\t\\t\\tapplication_id, \"APNS_CERTIFICATE\",\\n\\t\\t\\t\"You need to setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\t)\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\traise ImproperlyConfigured(msg)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn (\\n\\t\\t\\tself._get_apns_auth_key(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_PATH\", self.msg)\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TEAM_ID\", self.msg)\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_ID\", self.msg)\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_USE_SANDBOX\", self.msg)\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn\\n\\t\\tself._get_application_settings(application_id, \"APNS_USE_ALTERNATIVE_PORT\", self.msg)\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TOPIC\", self.msg)\\n\\n\\tdef get_apns_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_HOST\", self.msg)\\n\\n\\tdef get_apns_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_PORT\", self.msg)\\n\\n\\tdef get_apns_feedback_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_HOST\", self.msg)\\n\\n\\tdef get_apns_feedback_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_PORT\", self.msg)\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_PACKAGE_SECURITY_ID\", self.msg)\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_SECRET_KEY\", msg)\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_POST_URL\", msg)[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_PRIVATE_KEY\", msg)\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_CLAIMS\", msg)\\n'"}, {"func_args": {"source": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig\\n\\n\\n__all__ = [\\n\\t\"LegacyConfig\"\\n]\\n\\n\\nclass empty:\\n\\tpass\\n\\n\\nclass LegacyConfig(BaseConfig):\\n\\n\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\n\\tdef _get_application_settings(self, application_id, settings_key, error_message):\\n\\t\\t\"\"\"Legacy behaviour\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tvalue = SETTINGS.get(settings_key, empty)\\n\\t\\t\\tif value is empty:\\n\\t\\t\\t\\traise ImproperlyConfigured(error_message)\\n\\t\\t\\treturn value\\n\\t\\telse:\\n\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\"LegacySettings does not support application_id. To enable \"\\n\\t\\t\\t\\t\"multiple application support, use push_notifications.conf.AppSettings.\"\\n\\t\\t\\t)\\n\\t\\t\\traise ImproperlyConfigured(msg)\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"GCM_API_KEY\"] to send messages through GCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"GCM_API_KEY\", msg)\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"FCM_API_KEY\"] to send messages through FCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"FCM_API_KEY\", msg)\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_POST_URL\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_ERROR_TIMEOUT\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_MAX_RECIPIENTS\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\ttry:\\n\\t\\t\\tself._get_apns_auth_key(application_id)\\n\\t\\t\\tself._get_apns_auth_key_id(application_id)\\n\\t\\t\\tself._get_apns_team_id(application_id)\\n\\t\\texcept ImproperlyConfigured:\\n\\t\\t\\treturn False\\n\\n\\t\\treturn True\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(\\n\\t\\t\\tapplication_id, \"APNS_CERTIFICATE\",\\n\\t\\t\\t\"You need to setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\t)\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\traise ImproperlyConfigured(msg)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn (\\n\\t\\t\\tself._get_apns_auth_key(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_PATH\", self.msg)\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TEAM_ID\", self.msg)\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_ID\", self.msg)\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_USE_SANDBOX\", self.msg)\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn\\n\\t\\tself._get_application_settings(application_id, \"APNS_USE_ALTERNATIVE_PORT\", self.msg)\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TOPIC\", self.msg)\\n\\n\\tdef get_apns_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_HOST\", self.msg)\\n\\n\\tdef get_apns_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_PORT\", self.msg)\\n\\n\\tdef get_apns_feedback_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_HOST\", self.msg)\\n\\n\\tdef get_apns_feedback_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_PORT\", self.msg)\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_PACKAGE_SECURITY_ID\", self.msg)\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_SECRET_KEY\", msg)\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_POST_URL\", msg)[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_PRIVATE_KEY\", msg)\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_CLAIMS\", msg)\\n'"}, "return_value": "'from django.core.exceptions import ImproperlyConfigured\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\nfrom .base import BaseConfig\\n\\n\\n__all__ = [\\n\\t\"LegacyConfig\"\\n]\\n\\n\\nclass empty:\\n\\tpass\\n\\n\\nclass LegacyConfig(BaseConfig):\\n\\n\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\n\\tdef _get_application_settings(self, application_id, settings_key, error_message):\\n\\t\\t\"\"\"Legacy behaviour\"\"\"\\n\\n\\t\\tif not application_id:\\n\\t\\t\\tvalue = SETTINGS.get(settings_key, empty)\\n\\t\\t\\tif value is empty:\\n\\t\\t\\t\\traise ImproperlyConfigured(error_message)\\n\\t\\t\\treturn value\\n\\t\\telse:\\n\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\"LegacySettings does not support application_id. To enable \"\\n\\t\\t\\t\\t\"multiple application support, use push_notifications.conf.AppSettings.\"\\n\\t\\t\\t)\\n\\t\\t\\traise ImproperlyConfigured(msg)\\n\\n\\tdef get_gcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"GCM_API_KEY\"] to send messages through GCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"GCM_API_KEY\", msg)\\n\\n\\tdef get_fcm_api_key(self, application_id=None):\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"FCM_API_KEY\"] to send messages through FCM.\\'\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, \"FCM_API_KEY\", msg)\\n\\n\\tdef get_post_url(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_POST_URL\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_error_timeout(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_ERROR_TIMEOUT\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef get_max_recipients(self, cloud_type, application_id=None):\\n\\t\\tkey = \"{}_MAX_RECIPIENTS\".format(cloud_type)\\n\\t\\tmsg = (\\n\\t\\t\\t\\'Set PUSH_NOTIFICATIONS_SETTINGS[\"{}\"] to send messages through {}.\\'.format(\\n\\t\\t\\t\\tkey, cloud_type\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\treturn self._get_application_settings(application_id, key, msg)\\n\\n\\tdef has_auth_token_creds(self, application_id=None):\\n\\t\\ttry:\\n\\t\\t\\tself._get_apns_auth_key(application_id)\\n\\t\\t\\tself._get_apns_auth_key_id(application_id)\\n\\t\\t\\tself._get_apns_team_id(application_id)\\n\\t\\texcept ImproperlyConfigured:\\n\\t\\t\\treturn False\\n\\n\\t\\treturn True\\n\\n\\tdef get_apns_certificate(self, application_id=None):\\n\\t\\tr = self._get_application_settings(\\n\\t\\t\\tapplication_id, \"APNS_CERTIFICATE\",\\n\\t\\t\\t\"You need to setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\t)\\n\\t\\tif not isinstance(r, str):\\n\\t\\t\\t# probably the (Django) file, and file path should be got\\n\\t\\t\\tif hasattr(r, \"path\"):\\n\\t\\t\\t\\treturn r.path\\n\\t\\t\\telif (hasattr(r, \"has_key\") or hasattr(r, \"__contains__\")) and \"path\" in r:\\n\\t\\t\\t\\treturn r[\"path\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmsg = (\\n\\t\\t\\t\\t\\t\"The APNS certificate settings value should be a string, or \"\\n\\t\\t\\t\\t\\t\"should have a \\'path\\' attribute or key\"\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\traise ImproperlyConfigured(msg)\\n\\t\\treturn r\\n\\n\\tdef get_apns_auth_creds(self, application_id=None):\\n\\t\\treturn (\\n\\t\\t\\tself._get_apns_auth_key(application_id),\\n\\t\\t\\tself._get_apns_auth_key_id(application_id),\\n\\t\\t\\tself._get_apns_team_id(application_id))\\n\\n\\tdef _get_apns_auth_key(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_PATH\", self.msg)\\n\\n\\tdef _get_apns_team_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TEAM_ID\", self.msg)\\n\\n\\tdef _get_apns_auth_key_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_AUTH_KEY_ID\", self.msg)\\n\\n\\tdef get_apns_use_sandbox(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_USE_SANDBOX\", self.msg)\\n\\n\\tdef get_apns_use_alternative_port(self, application_id=None):\\n\\t\\treturn\\n\\t\\tself._get_application_settings(application_id, \"APNS_USE_ALTERNATIVE_PORT\", self.msg)\\n\\n\\tdef get_apns_topic(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_TOPIC\", self.msg)\\n\\n\\tdef get_apns_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_HOST\", self.msg)\\n\\n\\tdef get_apns_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_PORT\", self.msg)\\n\\n\\tdef get_apns_feedback_host(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_HOST\", self.msg)\\n\\n\\tdef get_apns_feedback_port(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"APNS_FEEDBACK_PORT\", self.msg)\\n\\n\\tdef get_wns_package_security_id(self, application_id=None):\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_PACKAGE_SECURITY_ID\", self.msg)\\n\\n\\tdef get_wns_secret_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WNS_SECRET_KEY\", msg)\\n\\n\\tdef get_wp_post_url(self, application_id, browser):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_POST_URL\", msg)[browser]\\n\\n\\tdef get_wp_private_key(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_PRIVATE_KEY\", msg)\\n\\n\\tdef get_wp_claims(self, application_id=None):\\n\\t\\tmsg = \"Setup PUSH_NOTIFICATIONS_SETTINGS properly to send messages\"\\n\\t\\treturn self._get_application_settings(application_id, \"WP_CLAIMS\", msg)\\n'"}, {"func_args": {"source": "'class NotificationError(Exception):\\n\\tpass\\n\\n\\n# APNS\\nclass APNSError(NotificationError):\\n\\tpass\\n\\n\\nclass APNSUnsupportedPriority(APNSError):\\n\\tpass\\n\\n\\nclass APNSServerError(APNSError):\\n\\tdef __init__(self, status):\\n\\t\\tsuper().__init__(status)\\n\\t\\tself.status = status\\n\\n\\n# GCM\\nclass GCMError(NotificationError):\\n\\tpass\\n\\n\\n# Web Push\\nclass WebPushError(NotificationError):\\n\\tpass\\n'"}, "return_value": "'class NotificationError(Exception):\\n\\tpass\\n\\n\\n# APNS\\nclass APNSError(NotificationError):\\n\\tpass\\n\\n\\nclass APNSUnsupportedPriority(APNSError):\\n\\tpass\\n\\n\\nclass APNSServerError(APNSError):\\n\\tdef __init__(self, status):\\n\\t\\tsuper().__init__(status)\\n\\t\\tself.status = status\\n\\n\\n# GCM\\nclass GCMError(NotificationError):\\n\\tpass\\n\\n\\n# Web Push\\nclass WebPushError(NotificationError):\\n\\tpass\\n'"}, {"func_args": {"source": "'class NotificationError(Exception):\\n\\tpass\\n\\n\\n# APNS\\nclass APNSError(NotificationError):\\n\\tpass\\n\\n\\nclass APNSUnsupportedPriority(APNSError):\\n\\tpass\\n\\n\\nclass APNSServerError(APNSError):\\n\\tdef __init__(self, status):\\n\\t\\tsuper().__init__(status)\\n\\t\\tself.status = status\\n\\n\\n# GCM\\nclass GCMError(NotificationError):\\n\\tpass\\n\\n\\n# Web Push\\nclass WebPushError(NotificationError):\\n\\tpass\\n'"}, "return_value": "'class NotificationError(Exception):\\n\\tpass\\n\\n\\n# APNS\\nclass APNSError(NotificationError):\\n\\tpass\\n\\n\\nclass APNSUnsupportedPriority(APNSError):\\n\\tpass\\n\\n\\nclass APNSServerError(APNSError):\\n\\tdef __init__(self, status):\\n\\t\\tsuper().__init__(status)\\n\\t\\tself.status = status\\n\\n\\n# GCM\\nclass GCMError(NotificationError):\\n\\tpass\\n\\n\\n# Web Push\\nclass WebPushError(NotificationError):\\n\\tpass\\n'"}, {"func_args": {"source": "'import re\\nimport struct\\n\\nfrom django import forms\\nfrom django.core.validators import MaxValueValidator, MinValueValidator, RegexValidator\\nfrom django.db import connection, models\\nfrom django.utils.translation import gettext_lazy as _\\n\\n\\n__all__ = [\"HexadecimalField\", \"HexIntegerField\"]\\n\\nUNSIGNED_64BIT_INT_MIN_VALUE = 0\\nUNSIGNED_64BIT_INT_MAX_VALUE = 2 ** 64 - 1\\n\\n\\nhex_re = re.compile(r\"^(([0-9A-f])|(0x[0-9A-f]))+$\")\\nsigned_integer_vendors = [\\n\\t\"postgresql\",\\n\\t\"sqlite\",\\n]\\n\\n\\ndef _using_signed_storage():\\n\\treturn connection.vendor in signed_integer_vendors\\n\\n\\ndef _signed_to_unsigned_integer(value):\\n\\treturn struct.unpack(\"Q\", struct.pack(\"q\", value))[0]\\n\\n\\ndef _unsigned_to_signed_integer(value):\\n\\treturn struct.unpack(\"q\", struct.pack(\"Q\", value))[0]\\n\\n\\ndef _hex_string_to_unsigned_integer(value):\\n\\treturn int(value, 16)\\n\\n\\ndef _unsigned_integer_to_hex_string(value):\\n\\treturn hex(value).rstrip(\"L\")\\n\\n\\nclass HexadecimalField(forms.CharField):\\n\\t\"\"\"\\n\\tA form field that accepts only hexadecimal numbers\\n\\t\"\"\"\\n\\tdef __init__(self, *args, **kwargs):\\n\\t\\tself.default_validators = [\\n\\t\\t\\tRegexValidator(hex_re, _(\"Enter a valid hexadecimal number\"), \"invalid\")\\n\\t\\t]\\n\\t\\tsuper(HexadecimalField, self).__init__(*args, **kwargs)\\n\\n\\tdef prepare_value(self, value):\\n\\t\\t# converts bigint from db to hex before it is displayed in admin\\n\\t\\tif value and not isinstance(value, str) \\\\\\n\\t\\t\\tand connection.vendor in (\"mysql\", \"sqlite\"):\\n\\t\\t\\tvalue = _unsigned_integer_to_hex_string(value)\\n\\t\\treturn super(forms.CharField, self).prepare_value(value)\\n\\n\\nclass HexIntegerField(models.BigIntegerField):\\n\\t\"\"\"\\n\\tThis field stores a hexadecimal *string* of up to 64 bits as an unsigned integer\\n\\ton *all* backends including postgres.\\n\\n\\tReasoning: Postgres only supports signed bigints. Since we don\\'t care about\\n\\tsignedness, we store it as signed, and cast it to unsigned when we deal with\\n\\tthe actual value (with struct)\\n\\n\\tOn sqlite and mysql, native unsigned bigint types are used. In all cases, the\\n\\tvalue we deal with in python is always in hex.\\n\\t\"\"\"\\n\\n\\tvalidators = [\\n\\t\\tMinValueValidator(UNSIGNED_64BIT_INT_MIN_VALUE),\\n\\t\\tMaxValueValidator(UNSIGNED_64BIT_INT_MAX_VALUE)\\n\\t]\\n\\n\\tdef db_type(self, connection):\\n\\t\\tif \"mysql\" == connection.vendor:\\n\\t\\t\\treturn \"bigint unsigned\"\\n\\t\\telif \"sqlite\" == connection.vendor:\\n\\t\\t\\treturn \"UNSIGNED BIG INT\"\\n\\t\\telse:\\n\\t\\t\\treturn super(HexIntegerField, self).db_type(connection=connection)\\n\\n\\tdef get_prep_value(self, value):\\n\\t\\t\"\"\" Return the integer value to be stored from the hex string \"\"\"\\n\\t\\tif value is None or value == \"\":\\n\\t\\t\\treturn None\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _unsigned_to_signed_integer(value)\\n\\t\\treturn value\\n\\n\\tdef from_db_value(self, value, *args):\\n\\t\\t\"\"\" Return an unsigned int representation from all db backends \"\"\"\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _signed_to_unsigned_integer(value)\\n\\t\\treturn value\\n\\n\\tdef to_python(self, value):\\n\\t\\t\"\"\" Return a str representation of the hexadecimal \"\"\"\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\treturn value\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\treturn _unsigned_integer_to_hex_string(value)\\n\\n\\tdef formfield(self, **kwargs):\\n\\t\\tdefaults = {\"form_class\": HexadecimalField}\\n\\t\\tdefaults.update(kwargs)\\n\\t\\t# yes, that super call is right\\n\\t\\treturn super(models.IntegerField, self).formfield(**defaults)\\n\\n\\tdef run_validators(self, value):\\n\\t\\t# make sure validation is performed on integer value not string value\\n\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\treturn super(models.BigIntegerField, self).run_validators(value)\\n'"}, "return_value": "'import re\\nimport struct\\n\\nfrom django import forms\\nfrom django.core.validators import MaxValueValidator, MinValueValidator, RegexValidator\\nfrom django.db import connection, models\\nfrom django.utils.translation import gettext_lazy as _\\n\\n\\n__all__ = [\"HexadecimalField\", \"HexIntegerField\"]\\n\\nUNSIGNED_64BIT_INT_MIN_VALUE = 0\\nUNSIGNED_64BIT_INT_MAX_VALUE = 2 ** 64 - 1\\n\\n\\nhex_re = re.compile(r\"^(([0-9A-f])|(0x[0-9A-f]))+$\")\\nsigned_integer_vendors = [\\n\\t\"postgresql\",\\n\\t\"sqlite\",\\n]\\n\\n\\ndef _using_signed_storage():\\n\\treturn connection.vendor in signed_integer_vendors\\n\\n\\ndef _signed_to_unsigned_integer(value):\\n\\treturn struct.unpack(\"Q\", struct.pack(\"q\", value))[0]\\n\\n\\ndef _unsigned_to_signed_integer(value):\\n\\treturn struct.unpack(\"q\", struct.pack(\"Q\", value))[0]\\n\\n\\ndef _hex_string_to_unsigned_integer(value):\\n\\treturn int(value, 16)\\n\\n\\ndef _unsigned_integer_to_hex_string(value):\\n\\treturn hex(value).rstrip(\"L\")\\n\\n\\nclass HexadecimalField(forms.CharField):\\n\\t\"\"\"\\n\\tA form field that accepts only hexadecimal numbers\\n\\t\"\"\"\\n\\tdef __init__(self, *args, **kwargs):\\n\\t\\tself.default_validators = [\\n\\t\\t\\tRegexValidator(hex_re, _(\"Enter a valid hexadecimal number\"), \"invalid\")\\n\\t\\t]\\n\\t\\tsuper(HexadecimalField, self).__init__(*args, **kwargs)\\n\\n\\tdef prepare_value(self, value):\\n\\t\\t# converts bigint from db to hex before it is displayed in admin\\n\\t\\tif value and not isinstance(value, str) \\\\\\n\\t\\t\\tand connection.vendor in (\"mysql\", \"sqlite\"):\\n\\t\\t\\tvalue = _unsigned_integer_to_hex_string(value)\\n\\t\\treturn super(forms.CharField, self).prepare_value(value)\\n\\n\\nclass HexIntegerField(models.BigIntegerField):\\n\\t\"\"\"\\n\\tThis field stores a hexadecimal *string* of up to 64 bits as an unsigned integer\\n\\ton *all* backends including postgres.\\n\\n\\tReasoning: Postgres only supports signed bigints. Since we don\\'t care about\\n\\tsignedness, we store it as signed, and cast it to unsigned when we deal with\\n\\tthe actual value (with struct)\\n\\n\\tOn sqlite and mysql, native unsigned bigint types are used. In all cases, the\\n\\tvalue we deal with in python is always in hex.\\n\\t\"\"\"\\n\\n\\tvalidators = [\\n\\t\\tMinValueValidator(UNSIGNED_64BIT_INT_MIN_VALUE),\\n\\t\\tMaxValueValidator(UNSIGNED_64BIT_INT_MAX_VALUE)\\n\\t]\\n\\n\\tdef db_type(self, connection):\\n\\t\\tif \"mysql\" == connection.vendor:\\n\\t\\t\\treturn \"bigint unsigned\"\\n\\t\\telif \"sqlite\" == connection.vendor:\\n\\t\\t\\treturn \"UNSIGNED BIG INT\"\\n\\t\\telse:\\n\\t\\t\\treturn super(HexIntegerField, self).db_type(connection=connection)\\n\\n\\tdef get_prep_value(self, value):\\n\\t\\t\"\"\" Return the integer value to be stored from the hex string \"\"\"\\n\\t\\tif value is None or value == \"\":\\n\\t\\t\\treturn None\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _unsigned_to_signed_integer(value)\\n\\t\\treturn value\\n\\n\\tdef from_db_value(self, value, *args):\\n\\t\\t\"\"\" Return an unsigned int representation from all db backends \"\"\"\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _signed_to_unsigned_integer(value)\\n\\t\\treturn value\\n\\n\\tdef to_python(self, value):\\n\\t\\t\"\"\" Return a str representation of the hexadecimal \"\"\"\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\treturn value\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\treturn _unsigned_integer_to_hex_string(value)\\n\\n\\tdef formfield(self, **kwargs):\\n\\t\\tdefaults = {\"form_class\": HexadecimalField}\\n\\t\\tdefaults.update(kwargs)\\n\\t\\t# yes, that super call is right\\n\\t\\treturn super(models.IntegerField, self).formfield(**defaults)\\n\\n\\tdef run_validators(self, value):\\n\\t\\t# make sure validation is performed on integer value not string value\\n\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\treturn super(models.BigIntegerField, self).run_validators(value)\\n'"}, {"func_args": {"source": "'import re\\nimport struct\\n\\nfrom django import forms\\nfrom django.core.validators import MaxValueValidator, MinValueValidator, RegexValidator\\nfrom django.db import connection, models\\nfrom django.utils.translation import gettext_lazy as _\\n\\n\\n__all__ = [\"HexadecimalField\", \"HexIntegerField\"]\\n\\nUNSIGNED_64BIT_INT_MIN_VALUE = 0\\nUNSIGNED_64BIT_INT_MAX_VALUE = 2 ** 64 - 1\\n\\n\\nhex_re = re.compile(r\"^(([0-9A-f])|(0x[0-9A-f]))+$\")\\nsigned_integer_vendors = [\\n\\t\"postgresql\",\\n\\t\"sqlite\",\\n]\\n\\n\\ndef _using_signed_storage():\\n\\treturn connection.vendor in signed_integer_vendors\\n\\n\\ndef _signed_to_unsigned_integer(value):\\n\\treturn struct.unpack(\"Q\", struct.pack(\"q\", value))[0]\\n\\n\\ndef _unsigned_to_signed_integer(value):\\n\\treturn struct.unpack(\"q\", struct.pack(\"Q\", value))[0]\\n\\n\\ndef _hex_string_to_unsigned_integer(value):\\n\\treturn int(value, 16)\\n\\n\\ndef _unsigned_integer_to_hex_string(value):\\n\\treturn hex(value).rstrip(\"L\")\\n\\n\\nclass HexadecimalField(forms.CharField):\\n\\t\"\"\"\\n\\tA form field that accepts only hexadecimal numbers\\n\\t\"\"\"\\n\\tdef __init__(self, *args, **kwargs):\\n\\t\\tself.default_validators = [\\n\\t\\t\\tRegexValidator(hex_re, _(\"Enter a valid hexadecimal number\"), \"invalid\")\\n\\t\\t]\\n\\t\\tsuper(HexadecimalField, self).__init__(*args, **kwargs)\\n\\n\\tdef prepare_value(self, value):\\n\\t\\t# converts bigint from db to hex before it is displayed in admin\\n\\t\\tif value and not isinstance(value, str) \\\\\\n\\t\\t\\tand connection.vendor in (\"mysql\", \"sqlite\"):\\n\\t\\t\\tvalue = _unsigned_integer_to_hex_string(value)\\n\\t\\treturn super(forms.CharField, self).prepare_value(value)\\n\\n\\nclass HexIntegerField(models.BigIntegerField):\\n\\t\"\"\"\\n\\tThis field stores a hexadecimal *string* of up to 64 bits as an unsigned integer\\n\\ton *all* backends including postgres.\\n\\n\\tReasoning: Postgres only supports signed bigints. Since we don\\'t care about\\n\\tsignedness, we store it as signed, and cast it to unsigned when we deal with\\n\\tthe actual value (with struct)\\n\\n\\tOn sqlite and mysql, native unsigned bigint types are used. In all cases, the\\n\\tvalue we deal with in python is always in hex.\\n\\t\"\"\"\\n\\n\\tvalidators = [\\n\\t\\tMinValueValidator(UNSIGNED_64BIT_INT_MIN_VALUE),\\n\\t\\tMaxValueValidator(UNSIGNED_64BIT_INT_MAX_VALUE)\\n\\t]\\n\\n\\tdef db_type(self, connection):\\n\\t\\tif \"mysql\" == connection.vendor:\\n\\t\\t\\treturn \"bigint unsigned\"\\n\\t\\telif \"sqlite\" == connection.vendor:\\n\\t\\t\\treturn \"UNSIGNED BIG INT\"\\n\\t\\telse:\\n\\t\\t\\treturn super(HexIntegerField, self).db_type(connection=connection)\\n\\n\\tdef get_prep_value(self, value):\\n\\t\\t\"\"\" Return the integer value to be stored from the hex string \"\"\"\\n\\t\\tif value is None or value == \"\":\\n\\t\\t\\treturn None\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _unsigned_to_signed_integer(value)\\n\\t\\treturn value\\n\\n\\tdef from_db_value(self, value, *args):\\n\\t\\t\"\"\" Return an unsigned int representation from all db backends \"\"\"\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _signed_to_unsigned_integer(value)\\n\\t\\treturn value\\n\\n\\tdef to_python(self, value):\\n\\t\\t\"\"\" Return a str representation of the hexadecimal \"\"\"\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\treturn value\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\treturn _unsigned_integer_to_hex_string(value)\\n\\n\\tdef formfield(self, **kwargs):\\n\\t\\tdefaults = {\"form_class\": HexadecimalField}\\n\\t\\tdefaults.update(kwargs)\\n\\t\\t# yes, that super call is right\\n\\t\\treturn super(models.IntegerField, self).formfield(**defaults)\\n\\n\\tdef run_validators(self, value):\\n\\t\\t# make sure validation is performed on integer value not string value\\n\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\treturn super(models.BigIntegerField, self).run_validators(value)\\n'"}, "return_value": "'import re\\nimport struct\\n\\nfrom django import forms\\nfrom django.core.validators import MaxValueValidator, MinValueValidator, RegexValidator\\nfrom django.db import connection, models\\nfrom django.utils.translation import gettext_lazy as _\\n\\n\\n__all__ = [\"HexadecimalField\", \"HexIntegerField\"]\\n\\nUNSIGNED_64BIT_INT_MIN_VALUE = 0\\nUNSIGNED_64BIT_INT_MAX_VALUE = 2 ** 64 - 1\\n\\n\\nhex_re = re.compile(r\"^(([0-9A-f])|(0x[0-9A-f]))+$\")\\nsigned_integer_vendors = [\\n\\t\"postgresql\",\\n\\t\"sqlite\",\\n]\\n\\n\\ndef _using_signed_storage():\\n\\treturn connection.vendor in signed_integer_vendors\\n\\n\\ndef _signed_to_unsigned_integer(value):\\n\\treturn struct.unpack(\"Q\", struct.pack(\"q\", value))[0]\\n\\n\\ndef _unsigned_to_signed_integer(value):\\n\\treturn struct.unpack(\"q\", struct.pack(\"Q\", value))[0]\\n\\n\\ndef _hex_string_to_unsigned_integer(value):\\n\\treturn int(value, 16)\\n\\n\\ndef _unsigned_integer_to_hex_string(value):\\n\\treturn hex(value).rstrip(\"L\")\\n\\n\\nclass HexadecimalField(forms.CharField):\\n\\t\"\"\"\\n\\tA form field that accepts only hexadecimal numbers\\n\\t\"\"\"\\n\\tdef __init__(self, *args, **kwargs):\\n\\t\\tself.default_validators = [\\n\\t\\t\\tRegexValidator(hex_re, _(\"Enter a valid hexadecimal number\"), \"invalid\")\\n\\t\\t]\\n\\t\\tsuper(HexadecimalField, self).__init__(*args, **kwargs)\\n\\n\\tdef prepare_value(self, value):\\n\\t\\t# converts bigint from db to hex before it is displayed in admin\\n\\t\\tif value and not isinstance(value, str) \\\\\\n\\t\\t\\tand connection.vendor in (\"mysql\", \"sqlite\"):\\n\\t\\t\\tvalue = _unsigned_integer_to_hex_string(value)\\n\\t\\treturn super(forms.CharField, self).prepare_value(value)\\n\\n\\nclass HexIntegerField(models.BigIntegerField):\\n\\t\"\"\"\\n\\tThis field stores a hexadecimal *string* of up to 64 bits as an unsigned integer\\n\\ton *all* backends including postgres.\\n\\n\\tReasoning: Postgres only supports signed bigints. Since we don\\'t care about\\n\\tsignedness, we store it as signed, and cast it to unsigned when we deal with\\n\\tthe actual value (with struct)\\n\\n\\tOn sqlite and mysql, native unsigned bigint types are used. In all cases, the\\n\\tvalue we deal with in python is always in hex.\\n\\t\"\"\"\\n\\n\\tvalidators = [\\n\\t\\tMinValueValidator(UNSIGNED_64BIT_INT_MIN_VALUE),\\n\\t\\tMaxValueValidator(UNSIGNED_64BIT_INT_MAX_VALUE)\\n\\t]\\n\\n\\tdef db_type(self, connection):\\n\\t\\tif \"mysql\" == connection.vendor:\\n\\t\\t\\treturn \"bigint unsigned\"\\n\\t\\telif \"sqlite\" == connection.vendor:\\n\\t\\t\\treturn \"UNSIGNED BIG INT\"\\n\\t\\telse:\\n\\t\\t\\treturn super(HexIntegerField, self).db_type(connection=connection)\\n\\n\\tdef get_prep_value(self, value):\\n\\t\\t\"\"\" Return the integer value to be stored from the hex string \"\"\"\\n\\t\\tif value is None or value == \"\":\\n\\t\\t\\treturn None\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _unsigned_to_signed_integer(value)\\n\\t\\treturn value\\n\\n\\tdef from_db_value(self, value, *args):\\n\\t\\t\"\"\" Return an unsigned int representation from all db backends \"\"\"\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\tif _using_signed_storage():\\n\\t\\t\\tvalue = _signed_to_unsigned_integer(value)\\n\\t\\treturn value\\n\\n\\tdef to_python(self, value):\\n\\t\\t\"\"\" Return a str representation of the hexadecimal \"\"\"\\n\\t\\tif isinstance(value, str):\\n\\t\\t\\treturn value\\n\\t\\tif value is None:\\n\\t\\t\\treturn value\\n\\t\\treturn _unsigned_integer_to_hex_string(value)\\n\\n\\tdef formfield(self, **kwargs):\\n\\t\\tdefaults = {\"form_class\": HexadecimalField}\\n\\t\\tdefaults.update(kwargs)\\n\\t\\t# yes, that super call is right\\n\\t\\treturn super(models.IntegerField, self).formfield(**defaults)\\n\\n\\tdef run_validators(self, value):\\n\\t\\t# make sure validation is performed on integer value not string value\\n\\t\\tvalue = _hex_string_to_unsigned_integer(value)\\n\\t\\treturn super(models.BigIntegerField, self).run_validators(value)\\n'"}, {"func_args": {"source": "'\"\"\"\\nFirebase Cloud Messaging\\nPreviously known as GCM / C2DM\\nDocumentation is available on the Firebase Developer website:\\nhttps://firebase.google.com/docs/cloud-messaging/\\n\"\"\"\\n\\nimport json\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import Request, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import GCMError\\nfrom .models import GCMDevice\\n\\n\\n# Valid keys for FCM messages. Reference:\\n# https://firebase.google.com/docs/cloud-messaging/http-server-ref\\nFCM_TARGETS_KEYS = [\\n\\t\"to\", \"condition\", \"notification_key\"\\n]\\nFCM_OPTIONS_KEYS = [\\n\\t\"collapse_key\", \"priority\", \"content_available\", \"delay_while_idle\", \"time_to_live\",\\n\\t\"restricted_package_name\", \"dry_run\", \"mutable_content\"\\n]\\nFCM_NOTIFICATIONS_PAYLOAD_KEYS = [\\n\\t\"title\", \"body\", \"icon\", \"image\", \"sound\", \"badge\", \"color\", \"tag\", \"click_action\",\\n\\t\"body_loc_key\", \"body_loc_args\", \"title_loc_key\", \"title_loc_args\", \"android_channel_id\"\\n]\\n\\ndef _chunks(l, n):\\n\\t\"\"\"\\n\\tYield successive chunks from list \\\\a l with a minimum size \\\\a n\\n\\t\"\"\"\\n\\tfor i in range(0, len(l), n):\\n\\t\\tyield l[i:i + n]\\n\\n\\ndef _gcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_gcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"GCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"GCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _fcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_fcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"FCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"FCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _cm_handle_response(registration_ids, response_data, cloud_type, application_id=None):\\n\\tresponse = response_data\\n\\tif response.get(\"failure\") or response.get(\"canonical_ids\"):\\n\\t\\tids_to_remove, old_new_ids = [], []\\n\\t\\tthrow_error = False\\n\\t\\tfor index, result in enumerate(response[\"results\"]):\\n\\t\\t\\terror = result.get(\"error\")\\n\\t\\t\\tif error:\\n\\t\\t\\t\\t# https://firebase.google.com/docs/cloud-messaging/http-server-ref#error-codes\\n\\t\\t\\t\\t# If error is NotRegistered or InvalidRegistration, then we will deactivate devices\\n\\t\\t\\t\\t# because this registration ID is no more valid and can\\'t be used to send messages,\\n\\t\\t\\t\\t# otherwise raise error\\n\\t\\t\\t\\tif error in (\"NotRegistered\", \"InvalidRegistration\"):\\n\\t\\t\\t\\t\\tids_to_remove.append(registration_ids[index])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tthrow_error = True\\n\\t\\t\\tresult[\"original_registration_id\"] = registration_ids[index]\\n\\t\\t\\t# If registration_id is set, replace the original ID with the new value (canonical ID)\\n\\t\\t\\t# in your server database. Note that the original ID is not part of the result, you need\\n\\t\\t\\t# to obtain it from the list of registration_ids in the request (using the same index).\\n\\t\\t\\tnew_id = result.get(\"registration_id\")\\n\\t\\t\\tif new_id:\\n\\t\\t\\t\\told_new_ids.append((registration_ids[index], new_id))\\n\\n\\t\\tif ids_to_remove:\\n\\t\\t\\tremoved = GCMDevice.objects.filter(\\n\\t\\t\\t\\tregistration_id__in=ids_to_remove, cloud_message_type=cloud_type\\n\\t\\t\\t)\\n\\t\\t\\tremoved.update(active=False)\\n\\n\\t\\tfor old_id, new_id in old_new_ids:\\n\\t\\t\\t_cm_handle_canonical_id(new_id, old_id, cloud_type)\\n\\n\\t\\tif throw_error:\\n\\t\\t\\traise GCMError(response)\\n\\treturn response\\n\\n\\ndef _cm_send_request(\\n\\tregistration_ids, data, cloud_type=\"GCM\", application_id=None,\\n\\tuse_fcm_notifications=True, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a FCM or GCM notification to one or more registration_ids as json data.\\n\\tThe registration_ids needs to be a list.\\n\\t\"\"\"\\n\\n\\tpayload = {\"registration_ids\": registration_ids} if registration_ids else {}\\n\\n\\tdata = data.copy()\\n\\n\\t# If using FCM, optionally autodiscovers notification related keys\\n\\t# https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages\\n\\tif cloud_type == \"FCM\" and use_fcm_notifications:\\n\\t\\tnotification_payload = {}\\n\\t\\tif \"message\" in data:\\n\\t\\t\\tnotification_payload[\"body\"] = data.pop(\"message\", None)\\n\\n\\t\\tfor key in FCM_NOTIFICATIONS_PAYLOAD_KEYS:\\n\\t\\t\\tvalue_from_extra = data.pop(key, None)\\n\\t\\t\\tif value_from_extra:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_extra\\n\\t\\t\\tvalue_from_kwargs = kwargs.pop(key, None)\\n\\t\\t\\tif value_from_kwargs:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_kwargs\\n\\t\\tif notification_payload:\\n\\t\\t\\tpayload[\"notification\"] = notification_payload\\n\\n\\tif data:\\n\\t\\tpayload[\"data\"] = data\\n\\n\\t# Attach any additional non falsy keyword args (targets, options)\\n\\t# See ref : https://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\tpayload.update({\\n\\t\\tk: v for k, v in kwargs.items() if v and (k in FCM_TARGETS_KEYS or k in FCM_OPTIONS_KEYS)\\n\\t})\\n\\n\\t# Sort the keys for deterministic output (useful for tests)\\n\\tjson_payload = json.dumps(payload, separators=(\",\", \":\"), sort_keys=True).encode(\"utf-8\")\\n\\n\\t# Sends requests and handles the response\\n\\tif cloud_type == \"GCM\":\\n\\t\\tresponse = json.loads(_gcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telif cloud_type == \"FCM\":\\n\\t\\tresponse = json.loads(_fcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\treturn _cm_handle_response(registration_ids, response, cloud_type, application_id)\\n\\n\\ndef _cm_handle_canonical_id(canonical_id, current_id, cloud_type):\\n\\t\"\"\"\\n\\tHandle situation when FCM server response contains canonical ID\\n\\t\"\"\"\\n\\tdevices = GCMDevice.objects.filter(cloud_message_type=cloud_type)\\n\\tif devices.filter(registration_id=canonical_id, active=True).exists():\\n\\t\\tdevices.filter(registration_id=current_id).update(active=False)\\n\\telse:\\n\\t\\tdevices.filter(registration_id=current_id).update(registration_id=canonical_id)\\n\\n\\ndef send_message(registration_ids, data, cloud_type, application_id=None, **kwargs):\\n\\t\"\"\"\\n\\tSends a FCM (or GCM) notification to one or more registration_ids. The registration_ids\\n\\tcan be a list or a single string. This will send the notification as json data.\\n\\n\\tA reference of extra keyword arguments sent to the server is available here:\\n\\thttps://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\t\"\"\"\\n\\tif cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\tmax_recipients = get_manager().get_max_recipients(cloud_type, application_id)\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\n\\t# Checks for valid recipient\\n\\tif registration_ids is None and \"/topics/\" not in kwargs.get(\"to\", \"\"):\\n\\t\\treturn\\n\\n\\t# Bundles the registration_ids in an list if only one is sent\\n\\tif not isinstance(registration_ids, list):\\n\\t\\tregistration_ids = [registration_ids] if registration_ids else None\\n\\n\\t# FCM only allows up to 1000 reg ids per bulk message\\n\\t# https://firebase.google.com/docs/cloud-messaging/server#http-request\\n\\tif registration_ids:\\n\\t\\tret = []\\n\\t\\tfor chunk in _chunks(registration_ids, max_recipients):\\n\\t\\t\\tret.append(_cm_send_request(\\n\\t\\t\\t\\tchunk, data, cloud_type=cloud_type, application_id=application_id, **kwargs\\n\\t\\t\\t))\\n\\t\\treturn ret[0] if len(ret) == 1 else ret\\n\\telse:\\n\\t\\treturn _cm_send_request(None, data, cloud_type=cloud_type, **kwargs)\\n\\n\\nsend_bulk_message = send_message\\n'"}, "return_value": "'\"\"\"\\nFirebase Cloud Messaging\\nPreviously known as GCM / C2DM\\nDocumentation is available on the Firebase Developer website:\\nhttps://firebase.google.com/docs/cloud-messaging/\\n\"\"\"\\n\\nimport json\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import Request, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import GCMError\\nfrom .models import GCMDevice\\n\\n\\n# Valid keys for FCM messages. Reference:\\n# https://firebase.google.com/docs/cloud-messaging/http-server-ref\\nFCM_TARGETS_KEYS = [\\n\\t\"to\", \"condition\", \"notification_key\"\\n]\\nFCM_OPTIONS_KEYS = [\\n\\t\"collapse_key\", \"priority\", \"content_available\", \"delay_while_idle\", \"time_to_live\",\\n\\t\"restricted_package_name\", \"dry_run\", \"mutable_content\"\\n]\\nFCM_NOTIFICATIONS_PAYLOAD_KEYS = [\\n\\t\"title\", \"body\", \"icon\", \"image\", \"sound\", \"badge\", \"color\", \"tag\", \"click_action\",\\n\\t\"body_loc_key\", \"body_loc_args\", \"title_loc_key\", \"title_loc_args\", \"android_channel_id\"\\n]\\n\\ndef _chunks(l, n):\\n\\t\"\"\"\\n\\tYield successive chunks from list \\\\a l with a minimum size \\\\a n\\n\\t\"\"\"\\n\\tfor i in range(0, len(l), n):\\n\\t\\tyield l[i:i + n]\\n\\n\\ndef _gcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_gcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"GCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"GCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _fcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_fcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"FCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"FCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _cm_handle_response(registration_ids, response_data, cloud_type, application_id=None):\\n\\tresponse = response_data\\n\\tif response.get(\"failure\") or response.get(\"canonical_ids\"):\\n\\t\\tids_to_remove, old_new_ids = [], []\\n\\t\\tthrow_error = False\\n\\t\\tfor index, result in enumerate(response[\"results\"]):\\n\\t\\t\\terror = result.get(\"error\")\\n\\t\\t\\tif error:\\n\\t\\t\\t\\t# https://firebase.google.com/docs/cloud-messaging/http-server-ref#error-codes\\n\\t\\t\\t\\t# If error is NotRegistered or InvalidRegistration, then we will deactivate devices\\n\\t\\t\\t\\t# because this registration ID is no more valid and can\\'t be used to send messages,\\n\\t\\t\\t\\t# otherwise raise error\\n\\t\\t\\t\\tif error in (\"NotRegistered\", \"InvalidRegistration\"):\\n\\t\\t\\t\\t\\tids_to_remove.append(registration_ids[index])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tthrow_error = True\\n\\t\\t\\tresult[\"original_registration_id\"] = registration_ids[index]\\n\\t\\t\\t# If registration_id is set, replace the original ID with the new value (canonical ID)\\n\\t\\t\\t# in your server database. Note that the original ID is not part of the result, you need\\n\\t\\t\\t# to obtain it from the list of registration_ids in the request (using the same index).\\n\\t\\t\\tnew_id = result.get(\"registration_id\")\\n\\t\\t\\tif new_id:\\n\\t\\t\\t\\told_new_ids.append((registration_ids[index], new_id))\\n\\n\\t\\tif ids_to_remove:\\n\\t\\t\\tremoved = GCMDevice.objects.filter(\\n\\t\\t\\t\\tregistration_id__in=ids_to_remove, cloud_message_type=cloud_type\\n\\t\\t\\t)\\n\\t\\t\\tremoved.update(active=False)\\n\\n\\t\\tfor old_id, new_id in old_new_ids:\\n\\t\\t\\t_cm_handle_canonical_id(new_id, old_id, cloud_type)\\n\\n\\t\\tif throw_error:\\n\\t\\t\\traise GCMError(response)\\n\\treturn response\\n\\n\\ndef _cm_send_request(\\n\\tregistration_ids, data, cloud_type=\"GCM\", application_id=None,\\n\\tuse_fcm_notifications=True, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a FCM or GCM notification to one or more registration_ids as json data.\\n\\tThe registration_ids needs to be a list.\\n\\t\"\"\"\\n\\n\\tpayload = {\"registration_ids\": registration_ids} if registration_ids else {}\\n\\n\\tdata = data.copy()\\n\\n\\t# If using FCM, optionally autodiscovers notification related keys\\n\\t# https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages\\n\\tif cloud_type == \"FCM\" and use_fcm_notifications:\\n\\t\\tnotification_payload = {}\\n\\t\\tif \"message\" in data:\\n\\t\\t\\tnotification_payload[\"body\"] = data.pop(\"message\", None)\\n\\n\\t\\tfor key in FCM_NOTIFICATIONS_PAYLOAD_KEYS:\\n\\t\\t\\tvalue_from_extra = data.pop(key, None)\\n\\t\\t\\tif value_from_extra:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_extra\\n\\t\\t\\tvalue_from_kwargs = kwargs.pop(key, None)\\n\\t\\t\\tif value_from_kwargs:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_kwargs\\n\\t\\tif notification_payload:\\n\\t\\t\\tpayload[\"notification\"] = notification_payload\\n\\n\\tif data:\\n\\t\\tpayload[\"data\"] = data\\n\\n\\t# Attach any additional non falsy keyword args (targets, options)\\n\\t# See ref : https://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\tpayload.update({\\n\\t\\tk: v for k, v in kwargs.items() if v and (k in FCM_TARGETS_KEYS or k in FCM_OPTIONS_KEYS)\\n\\t})\\n\\n\\t# Sort the keys for deterministic output (useful for tests)\\n\\tjson_payload = json.dumps(payload, separators=(\",\", \":\"), sort_keys=True).encode(\"utf-8\")\\n\\n\\t# Sends requests and handles the response\\n\\tif cloud_type == \"GCM\":\\n\\t\\tresponse = json.loads(_gcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telif cloud_type == \"FCM\":\\n\\t\\tresponse = json.loads(_fcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\treturn _cm_handle_response(registration_ids, response, cloud_type, application_id)\\n\\n\\ndef _cm_handle_canonical_id(canonical_id, current_id, cloud_type):\\n\\t\"\"\"\\n\\tHandle situation when FCM server response contains canonical ID\\n\\t\"\"\"\\n\\tdevices = GCMDevice.objects.filter(cloud_message_type=cloud_type)\\n\\tif devices.filter(registration_id=canonical_id, active=True).exists():\\n\\t\\tdevices.filter(registration_id=current_id).update(active=False)\\n\\telse:\\n\\t\\tdevices.filter(registration_id=current_id).update(registration_id=canonical_id)\\n\\n\\ndef send_message(registration_ids, data, cloud_type, application_id=None, **kwargs):\\n\\t\"\"\"\\n\\tSends a FCM (or GCM) notification to one or more registration_ids. The registration_ids\\n\\tcan be a list or a single string. This will send the notification as json data.\\n\\n\\tA reference of extra keyword arguments sent to the server is available here:\\n\\thttps://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\t\"\"\"\\n\\tif cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\tmax_recipients = get_manager().get_max_recipients(cloud_type, application_id)\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\n\\t# Checks for valid recipient\\n\\tif registration_ids is None and \"/topics/\" not in kwargs.get(\"to\", \"\"):\\n\\t\\treturn\\n\\n\\t# Bundles the registration_ids in an list if only one is sent\\n\\tif not isinstance(registration_ids, list):\\n\\t\\tregistration_ids = [registration_ids] if registration_ids else None\\n\\n\\t# FCM only allows up to 1000 reg ids per bulk message\\n\\t# https://firebase.google.com/docs/cloud-messaging/server#http-request\\n\\tif registration_ids:\\n\\t\\tret = []\\n\\t\\tfor chunk in _chunks(registration_ids, max_recipients):\\n\\t\\t\\tret.append(_cm_send_request(\\n\\t\\t\\t\\tchunk, data, cloud_type=cloud_type, application_id=application_id, **kwargs\\n\\t\\t\\t))\\n\\t\\treturn ret[0] if len(ret) == 1 else ret\\n\\telse:\\n\\t\\treturn _cm_send_request(None, data, cloud_type=cloud_type, **kwargs)\\n\\n\\nsend_bulk_message = send_message\\n'"}, {"func_args": {"source": "'\"\"\"\\nFirebase Cloud Messaging\\nPreviously known as GCM / C2DM\\nDocumentation is available on the Firebase Developer website:\\nhttps://firebase.google.com/docs/cloud-messaging/\\n\"\"\"\\n\\nimport json\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import Request, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import GCMError\\nfrom .models import GCMDevice\\n\\n\\n# Valid keys for FCM messages. Reference:\\n# https://firebase.google.com/docs/cloud-messaging/http-server-ref\\nFCM_TARGETS_KEYS = [\\n\\t\"to\", \"condition\", \"notification_key\"\\n]\\nFCM_OPTIONS_KEYS = [\\n\\t\"collapse_key\", \"priority\", \"content_available\", \"delay_while_idle\", \"time_to_live\",\\n\\t\"restricted_package_name\", \"dry_run\", \"mutable_content\"\\n]\\nFCM_NOTIFICATIONS_PAYLOAD_KEYS = [\\n\\t\"title\", \"body\", \"icon\", \"image\", \"sound\", \"badge\", \"color\", \"tag\", \"click_action\",\\n\\t\"body_loc_key\", \"body_loc_args\", \"title_loc_key\", \"title_loc_args\", \"android_channel_id\"\\n]\\n\\ndef _chunks(l, n):\\n\\t\"\"\"\\n\\tYield successive chunks from list \\\\a l with a minimum size \\\\a n\\n\\t\"\"\"\\n\\tfor i in range(0, len(l), n):\\n\\t\\tyield l[i:i + n]\\n\\n\\ndef _gcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_gcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"GCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"GCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _fcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_fcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"FCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"FCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _cm_handle_response(registration_ids, response_data, cloud_type, application_id=None):\\n\\tresponse = response_data\\n\\tif response.get(\"failure\") or response.get(\"canonical_ids\"):\\n\\t\\tids_to_remove, old_new_ids = [], []\\n\\t\\tthrow_error = False\\n\\t\\tfor index, result in enumerate(response[\"results\"]):\\n\\t\\t\\terror = result.get(\"error\")\\n\\t\\t\\tif error:\\n\\t\\t\\t\\t# https://firebase.google.com/docs/cloud-messaging/http-server-ref#error-codes\\n\\t\\t\\t\\t# If error is NotRegistered or InvalidRegistration, then we will deactivate devices\\n\\t\\t\\t\\t# because this registration ID is no more valid and can\\'t be used to send messages,\\n\\t\\t\\t\\t# otherwise raise error\\n\\t\\t\\t\\tif error in (\"NotRegistered\", \"InvalidRegistration\"):\\n\\t\\t\\t\\t\\tids_to_remove.append(registration_ids[index])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tthrow_error = True\\n\\t\\t\\tresult[\"original_registration_id\"] = registration_ids[index]\\n\\t\\t\\t# If registration_id is set, replace the original ID with the new value (canonical ID)\\n\\t\\t\\t# in your server database. Note that the original ID is not part of the result, you need\\n\\t\\t\\t# to obtain it from the list of registration_ids in the request (using the same index).\\n\\t\\t\\tnew_id = result.get(\"registration_id\")\\n\\t\\t\\tif new_id:\\n\\t\\t\\t\\told_new_ids.append((registration_ids[index], new_id))\\n\\n\\t\\tif ids_to_remove:\\n\\t\\t\\tremoved = GCMDevice.objects.filter(\\n\\t\\t\\t\\tregistration_id__in=ids_to_remove, cloud_message_type=cloud_type\\n\\t\\t\\t)\\n\\t\\t\\tremoved.update(active=False)\\n\\n\\t\\tfor old_id, new_id in old_new_ids:\\n\\t\\t\\t_cm_handle_canonical_id(new_id, old_id, cloud_type)\\n\\n\\t\\tif throw_error:\\n\\t\\t\\traise GCMError(response)\\n\\treturn response\\n\\n\\ndef _cm_send_request(\\n\\tregistration_ids, data, cloud_type=\"GCM\", application_id=None,\\n\\tuse_fcm_notifications=True, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a FCM or GCM notification to one or more registration_ids as json data.\\n\\tThe registration_ids needs to be a list.\\n\\t\"\"\"\\n\\n\\tpayload = {\"registration_ids\": registration_ids} if registration_ids else {}\\n\\n\\tdata = data.copy()\\n\\n\\t# If using FCM, optionally autodiscovers notification related keys\\n\\t# https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages\\n\\tif cloud_type == \"FCM\" and use_fcm_notifications:\\n\\t\\tnotification_payload = {}\\n\\t\\tif \"message\" in data:\\n\\t\\t\\tnotification_payload[\"body\"] = data.pop(\"message\", None)\\n\\n\\t\\tfor key in FCM_NOTIFICATIONS_PAYLOAD_KEYS:\\n\\t\\t\\tvalue_from_extra = data.pop(key, None)\\n\\t\\t\\tif value_from_extra:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_extra\\n\\t\\t\\tvalue_from_kwargs = kwargs.pop(key, None)\\n\\t\\t\\tif value_from_kwargs:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_kwargs\\n\\t\\tif notification_payload:\\n\\t\\t\\tpayload[\"notification\"] = notification_payload\\n\\n\\tif data:\\n\\t\\tpayload[\"data\"] = data\\n\\n\\t# Attach any additional non falsy keyword args (targets, options)\\n\\t# See ref : https://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\tpayload.update({\\n\\t\\tk: v for k, v in kwargs.items() if v and (k in FCM_TARGETS_KEYS or k in FCM_OPTIONS_KEYS)\\n\\t})\\n\\n\\t# Sort the keys for deterministic output (useful for tests)\\n\\tjson_payload = json.dumps(payload, separators=(\",\", \":\"), sort_keys=True).encode(\"utf-8\")\\n\\n\\t# Sends requests and handles the response\\n\\tif cloud_type == \"GCM\":\\n\\t\\tresponse = json.loads(_gcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telif cloud_type == \"FCM\":\\n\\t\\tresponse = json.loads(_fcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\treturn _cm_handle_response(registration_ids, response, cloud_type, application_id)\\n\\n\\ndef _cm_handle_canonical_id(canonical_id, current_id, cloud_type):\\n\\t\"\"\"\\n\\tHandle situation when FCM server response contains canonical ID\\n\\t\"\"\"\\n\\tdevices = GCMDevice.objects.filter(cloud_message_type=cloud_type)\\n\\tif devices.filter(registration_id=canonical_id, active=True).exists():\\n\\t\\tdevices.filter(registration_id=current_id).update(active=False)\\n\\telse:\\n\\t\\tdevices.filter(registration_id=current_id).update(registration_id=canonical_id)\\n\\n\\ndef send_message(registration_ids, data, cloud_type, application_id=None, **kwargs):\\n\\t\"\"\"\\n\\tSends a FCM (or GCM) notification to one or more registration_ids. The registration_ids\\n\\tcan be a list or a single string. This will send the notification as json data.\\n\\n\\tA reference of extra keyword arguments sent to the server is available here:\\n\\thttps://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\t\"\"\"\\n\\tif cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\tmax_recipients = get_manager().get_max_recipients(cloud_type, application_id)\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\n\\t# Checks for valid recipient\\n\\tif registration_ids is None and \"/topics/\" not in kwargs.get(\"to\", \"\"):\\n\\t\\treturn\\n\\n\\t# Bundles the registration_ids in an list if only one is sent\\n\\tif not isinstance(registration_ids, list):\\n\\t\\tregistration_ids = [registration_ids] if registration_ids else None\\n\\n\\t# FCM only allows up to 1000 reg ids per bulk message\\n\\t# https://firebase.google.com/docs/cloud-messaging/server#http-request\\n\\tif registration_ids:\\n\\t\\tret = []\\n\\t\\tfor chunk in _chunks(registration_ids, max_recipients):\\n\\t\\t\\tret.append(_cm_send_request(\\n\\t\\t\\t\\tchunk, data, cloud_type=cloud_type, application_id=application_id, **kwargs\\n\\t\\t\\t))\\n\\t\\treturn ret[0] if len(ret) == 1 else ret\\n\\telse:\\n\\t\\treturn _cm_send_request(None, data, cloud_type=cloud_type, **kwargs)\\n\\n\\nsend_bulk_message = send_message\\n'"}, "return_value": "'\"\"\"\\nFirebase Cloud Messaging\\nPreviously known as GCM / C2DM\\nDocumentation is available on the Firebase Developer website:\\nhttps://firebase.google.com/docs/cloud-messaging/\\n\"\"\"\\n\\nimport json\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import Request, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import GCMError\\nfrom .models import GCMDevice\\n\\n\\n# Valid keys for FCM messages. Reference:\\n# https://firebase.google.com/docs/cloud-messaging/http-server-ref\\nFCM_TARGETS_KEYS = [\\n\\t\"to\", \"condition\", \"notification_key\"\\n]\\nFCM_OPTIONS_KEYS = [\\n\\t\"collapse_key\", \"priority\", \"content_available\", \"delay_while_idle\", \"time_to_live\",\\n\\t\"restricted_package_name\", \"dry_run\", \"mutable_content\"\\n]\\nFCM_NOTIFICATIONS_PAYLOAD_KEYS = [\\n\\t\"title\", \"body\", \"icon\", \"image\", \"sound\", \"badge\", \"color\", \"tag\", \"click_action\",\\n\\t\"body_loc_key\", \"body_loc_args\", \"title_loc_key\", \"title_loc_args\", \"android_channel_id\"\\n]\\n\\ndef _chunks(l, n):\\n\\t\"\"\"\\n\\tYield successive chunks from list \\\\a l with a minimum size \\\\a n\\n\\t\"\"\"\\n\\tfor i in range(0, len(l), n):\\n\\t\\tyield l[i:i + n]\\n\\n\\ndef _gcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_gcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"GCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"GCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _fcm_send(data, content_type, application_id):\\n\\tkey = get_manager().get_fcm_api_key(application_id)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"key=%s\" % (key),\\n\\t\\t\"Content-Length\": str(len(data)),\\n\\t}\\n\\trequest = Request(get_manager().get_post_url(\"FCM\", application_id), data, headers)\\n\\treturn urlopen(\\n\\t\\trequest, timeout=get_manager().get_error_timeout(\"FCM\", application_id)\\n\\t).read().decode(\"utf-8\")\\n\\n\\ndef _cm_handle_response(registration_ids, response_data, cloud_type, application_id=None):\\n\\tresponse = response_data\\n\\tif response.get(\"failure\") or response.get(\"canonical_ids\"):\\n\\t\\tids_to_remove, old_new_ids = [], []\\n\\t\\tthrow_error = False\\n\\t\\tfor index, result in enumerate(response[\"results\"]):\\n\\t\\t\\terror = result.get(\"error\")\\n\\t\\t\\tif error:\\n\\t\\t\\t\\t# https://firebase.google.com/docs/cloud-messaging/http-server-ref#error-codes\\n\\t\\t\\t\\t# If error is NotRegistered or InvalidRegistration, then we will deactivate devices\\n\\t\\t\\t\\t# because this registration ID is no more valid and can\\'t be used to send messages,\\n\\t\\t\\t\\t# otherwise raise error\\n\\t\\t\\t\\tif error in (\"NotRegistered\", \"InvalidRegistration\"):\\n\\t\\t\\t\\t\\tids_to_remove.append(registration_ids[index])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tthrow_error = True\\n\\t\\t\\tresult[\"original_registration_id\"] = registration_ids[index]\\n\\t\\t\\t# If registration_id is set, replace the original ID with the new value (canonical ID)\\n\\t\\t\\t# in your server database. Note that the original ID is not part of the result, you need\\n\\t\\t\\t# to obtain it from the list of registration_ids in the request (using the same index).\\n\\t\\t\\tnew_id = result.get(\"registration_id\")\\n\\t\\t\\tif new_id:\\n\\t\\t\\t\\told_new_ids.append((registration_ids[index], new_id))\\n\\n\\t\\tif ids_to_remove:\\n\\t\\t\\tremoved = GCMDevice.objects.filter(\\n\\t\\t\\t\\tregistration_id__in=ids_to_remove, cloud_message_type=cloud_type\\n\\t\\t\\t)\\n\\t\\t\\tremoved.update(active=False)\\n\\n\\t\\tfor old_id, new_id in old_new_ids:\\n\\t\\t\\t_cm_handle_canonical_id(new_id, old_id, cloud_type)\\n\\n\\t\\tif throw_error:\\n\\t\\t\\traise GCMError(response)\\n\\treturn response\\n\\n\\ndef _cm_send_request(\\n\\tregistration_ids, data, cloud_type=\"GCM\", application_id=None,\\n\\tuse_fcm_notifications=True, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a FCM or GCM notification to one or more registration_ids as json data.\\n\\tThe registration_ids needs to be a list.\\n\\t\"\"\"\\n\\n\\tpayload = {\"registration_ids\": registration_ids} if registration_ids else {}\\n\\n\\tdata = data.copy()\\n\\n\\t# If using FCM, optionally autodiscovers notification related keys\\n\\t# https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages\\n\\tif cloud_type == \"FCM\" and use_fcm_notifications:\\n\\t\\tnotification_payload = {}\\n\\t\\tif \"message\" in data:\\n\\t\\t\\tnotification_payload[\"body\"] = data.pop(\"message\", None)\\n\\n\\t\\tfor key in FCM_NOTIFICATIONS_PAYLOAD_KEYS:\\n\\t\\t\\tvalue_from_extra = data.pop(key, None)\\n\\t\\t\\tif value_from_extra:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_extra\\n\\t\\t\\tvalue_from_kwargs = kwargs.pop(key, None)\\n\\t\\t\\tif value_from_kwargs:\\n\\t\\t\\t\\tnotification_payload[key] = value_from_kwargs\\n\\t\\tif notification_payload:\\n\\t\\t\\tpayload[\"notification\"] = notification_payload\\n\\n\\tif data:\\n\\t\\tpayload[\"data\"] = data\\n\\n\\t# Attach any additional non falsy keyword args (targets, options)\\n\\t# See ref : https://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\tpayload.update({\\n\\t\\tk: v for k, v in kwargs.items() if v and (k in FCM_TARGETS_KEYS or k in FCM_OPTIONS_KEYS)\\n\\t})\\n\\n\\t# Sort the keys for deterministic output (useful for tests)\\n\\tjson_payload = json.dumps(payload, separators=(\",\", \":\"), sort_keys=True).encode(\"utf-8\")\\n\\n\\t# Sends requests and handles the response\\n\\tif cloud_type == \"GCM\":\\n\\t\\tresponse = json.loads(_gcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telif cloud_type == \"FCM\":\\n\\t\\tresponse = json.loads(_fcm_send(\\n\\t\\t\\tjson_payload, \"application/json\", application_id=application_id\\n\\t\\t))\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\treturn _cm_handle_response(registration_ids, response, cloud_type, application_id)\\n\\n\\ndef _cm_handle_canonical_id(canonical_id, current_id, cloud_type):\\n\\t\"\"\"\\n\\tHandle situation when FCM server response contains canonical ID\\n\\t\"\"\"\\n\\tdevices = GCMDevice.objects.filter(cloud_message_type=cloud_type)\\n\\tif devices.filter(registration_id=canonical_id, active=True).exists():\\n\\t\\tdevices.filter(registration_id=current_id).update(active=False)\\n\\telse:\\n\\t\\tdevices.filter(registration_id=current_id).update(registration_id=canonical_id)\\n\\n\\ndef send_message(registration_ids, data, cloud_type, application_id=None, **kwargs):\\n\\t\"\"\"\\n\\tSends a FCM (or GCM) notification to one or more registration_ids. The registration_ids\\n\\tcan be a list or a single string. This will send the notification as json data.\\n\\n\\tA reference of extra keyword arguments sent to the server is available here:\\n\\thttps://firebase.google.com/docs/cloud-messaging/http-server-ref#table1\\n\\t\"\"\"\\n\\tif cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\tmax_recipients = get_manager().get_max_recipients(cloud_type, application_id)\\n\\telse:\\n\\t\\traise ImproperlyConfigured(\"cloud_type must be FCM or GCM not %s\" % str(cloud_type))\\n\\n\\t# Checks for valid recipient\\n\\tif registration_ids is None and \"/topics/\" not in kwargs.get(\"to\", \"\"):\\n\\t\\treturn\\n\\n\\t# Bundles the registration_ids in an list if only one is sent\\n\\tif not isinstance(registration_ids, list):\\n\\t\\tregistration_ids = [registration_ids] if registration_ids else None\\n\\n\\t# FCM only allows up to 1000 reg ids per bulk message\\n\\t# https://firebase.google.com/docs/cloud-messaging/server#http-request\\n\\tif registration_ids:\\n\\t\\tret = []\\n\\t\\tfor chunk in _chunks(registration_ids, max_recipients):\\n\\t\\t\\tret.append(_cm_send_request(\\n\\t\\t\\t\\tchunk, data, cloud_type=cloud_type, application_id=application_id, **kwargs\\n\\t\\t\\t))\\n\\t\\treturn ret[0] if len(ret) == 1 else ret\\n\\telse:\\n\\t\\treturn _cm_send_request(None, data, cloud_type=cloud_type, **kwargs)\\n\\n\\nsend_bulk_message = send_message\\n'"}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\nimport push_notifications.fields\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='APNSDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', models.UUIDField(help_text='UDID / UIDevice.identifierForVendor()', max_length=32, null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.CharField(unique=True, max_length=64, verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'APNS device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n        migrations.CreateModel(\\n            name='GCMDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', push_notifications.fields.HexIntegerField(help_text='ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)', null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'GCM device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\nimport push_notifications.fields\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='APNSDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', models.UUIDField(help_text='UDID / UIDevice.identifierForVendor()', max_length=32, null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.CharField(unique=True, max_length=64, verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'APNS device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n        migrations.CreateModel(\\n            name='GCMDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', push_notifications.fields.HexIntegerField(help_text='ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)', null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'GCM device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\nimport push_notifications.fields\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='APNSDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', models.UUIDField(help_text='UDID / UIDevice.identifierForVendor()', max_length=32, null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.CharField(unique=True, max_length=64, verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'APNS device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n        migrations.CreateModel(\\n            name='GCMDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', push_notifications.fields.HexIntegerField(help_text='ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)', null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'GCM device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\nimport push_notifications.fields\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='APNSDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', models.UUIDField(help_text='UDID / UIDevice.identifierForVendor()', max_length=32, null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.CharField(unique=True, max_length=64, verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'APNS device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n        migrations.CreateModel(\\n            name='GCMDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('device_id', push_notifications.fields.HexIntegerField(help_text='ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)', null=True, verbose_name='Device ID', blank=True, db_index=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'GCM device',\\n            },\\n            bases=(models.Model,),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.1 on 2016-01-06 08:50\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0001_initial'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=True, verbose_name='Registration ID'),\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\n# Generated by Django 1.9.1 on 2016-01-06 08:50\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0001_initial'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=True, verbose_name='Registration ID'),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.1 on 2016-01-06 08:50\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0001_initial'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=True, verbose_name='Registration ID'),\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\n# Generated by Django 1.9.1 on 2016-01-06 08:50\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0001_initial'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=True, verbose_name='Registration ID'),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nimport django.db.models.deletion\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0002_auto_20160106_0850'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WNSDevice',\\n            fields=[\\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\\n                ('name', models.CharField(blank=True, max_length=255, null=True, verbose_name='Name')),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, null=True, verbose_name='Creation date')),\\n                ('device_id', models.UUIDField(blank=True, db_index=True, help_text='GUID()', null=True, verbose_name='Device ID')),\\n                ('registration_id', models.TextField(verbose_name='Notification URI')),\\n                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\\n            ],\\n            options={\\n                'verbose_name': 'WNS device',\\n            },\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nimport django.db.models.deletion\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0002_auto_20160106_0850'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WNSDevice',\\n            fields=[\\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\\n                ('name', models.CharField(blank=True, max_length=255, null=True, verbose_name='Name')),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, null=True, verbose_name='Creation date')),\\n                ('device_id', models.UUIDField(blank=True, db_index=True, help_text='GUID()', null=True, verbose_name='Device ID')),\\n                ('registration_id', models.TextField(verbose_name='Notification URI')),\\n                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\\n            ],\\n            options={\\n                'verbose_name': 'WNS device',\\n            },\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nimport django.db.models.deletion\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0002_auto_20160106_0850'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WNSDevice',\\n            fields=[\\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\\n                ('name', models.CharField(blank=True, max_length=255, null=True, verbose_name='Name')),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, null=True, verbose_name='Creation date')),\\n                ('device_id', models.UUIDField(blank=True, db_index=True, help_text='GUID()', null=True, verbose_name='Device ID')),\\n                ('registration_id', models.TextField(verbose_name='Notification URI')),\\n                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\\n            ],\\n            options={\\n                'verbose_name': 'WNS device',\\n            },\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nimport django.db.models.deletion\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0002_auto_20160106_0850'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WNSDevice',\\n            fields=[\\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\\n                ('name', models.CharField(blank=True, max_length=255, null=True, verbose_name='Name')),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, null=True, verbose_name='Creation date')),\\n                ('device_id', models.UUIDField(blank=True, db_index=True, help_text='GUID()', null=True, verbose_name='Device ID')),\\n                ('registration_id', models.TextField(verbose_name='Notification URI')),\\n                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\\n            ],\\n            options={\\n                'verbose_name': 'WNS device',\\n            },\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n\\tdependencies = [\\n\\t\\tmigrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n\\t\\t('push_notifications', '0003_wnsdevice'),\\n\\t]\\n\\n\\toperations = [\\n\\t\\tmigrations.AddField(\\n\\t\\t\\tmodel_name='gcmdevice',\\n\\t\\t\\tname='cloud_message_type',\\n\\t\\t\\tfield=models.CharField(choices=[('FCM', 'Firebase Cloud Message'), ('GCM', 'Google Cloud Message')], default='GCM', help_text='You should choose FCM or GCM', max_length=3, verbose_name='Cloud Message Type')\\n\\t\\t),\\n\\t]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n\\tdependencies = [\\n\\t\\tmigrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n\\t\\t('push_notifications', '0003_wnsdevice'),\\n\\t]\\n\\n\\toperations = [\\n\\t\\tmigrations.AddField(\\n\\t\\t\\tmodel_name='gcmdevice',\\n\\t\\t\\tname='cloud_message_type',\\n\\t\\t\\tfield=models.CharField(choices=[('FCM', 'Firebase Cloud Message'), ('GCM', 'Google Cloud Message')], default='GCM', help_text='You should choose FCM or GCM', max_length=3, verbose_name='Cloud Message Type')\\n\\t\\t),\\n\\t]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n\\tdependencies = [\\n\\t\\tmigrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n\\t\\t('push_notifications', '0003_wnsdevice'),\\n\\t]\\n\\n\\toperations = [\\n\\t\\tmigrations.AddField(\\n\\t\\t\\tmodel_name='gcmdevice',\\n\\t\\t\\tname='cloud_message_type',\\n\\t\\t\\tfield=models.CharField(choices=[('FCM', 'Firebase Cloud Message'), ('GCM', 'Google Cloud Message')], default='GCM', help_text='You should choose FCM or GCM', max_length=3, verbose_name='Cloud Message Type')\\n\\t\\t),\\n\\t]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\n# Generated by Django 1.9.6 on 2016-06-13 20:46\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n\\tdependencies = [\\n\\t\\tmigrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n\\t\\t('push_notifications', '0003_wnsdevice'),\\n\\t]\\n\\n\\toperations = [\\n\\t\\tmigrations.AddField(\\n\\t\\t\\tmodel_name='gcmdevice',\\n\\t\\t\\tname='cloud_message_type',\\n\\t\\t\\tfield=models.CharField(choices=[('FCM', 'Firebase Cloud Message'), ('GCM', 'Google Cloud Message')], default='GCM', help_text='You should choose FCM or GCM', max_length=3, verbose_name='Cloud Message Type')\\n\\t\\t),\\n\\t]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0004_fcm'),\\n    ]\\n\\n    operations = [\\n        migrations.AddField(\\n            model_name='apnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='gcmdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='wnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0004_fcm'),\\n    ]\\n\\n    operations = [\\n        migrations.AddField(\\n            model_name='apnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='gcmdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='wnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0004_fcm'),\\n    ]\\n\\n    operations = [\\n        migrations.AddField(\\n            model_name='apnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='gcmdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='wnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0004_fcm'),\\n    ]\\n\\n    operations = [\\n        migrations.AddField(\\n            model_name='apnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='gcmdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n        migrations.AddField(\\n            model_name='wnsdevice',\\n            name='application_id',\\n            field=models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True),\\n            preserve_default=True,\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0005_applicationid'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WebPushDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('application_id', models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('p256dh', models.CharField(max_length=88, verbose_name='User public encryption key')),\\n                ('auth', models.CharField(max_length=24, verbose_name='User auth secret')),\\n                ('browser', models.CharField(default='CHROME', help_text='Currently only support to Chrome, Firefox and Opera browsers', max_length=10, verbose_name='Browser', choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera')])),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'WebPush device',\\n            },\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0005_applicationid'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WebPushDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('application_id', models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('p256dh', models.CharField(max_length=88, verbose_name='User public encryption key')),\\n                ('auth', models.CharField(max_length=24, verbose_name='User auth secret')),\\n                ('browser', models.CharField(default='CHROME', help_text='Currently only support to Chrome, Firefox and Opera browsers', max_length=10, verbose_name='Browser', choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera')])),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'WebPush device',\\n            },\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# -*- coding: utf-8 -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0005_applicationid'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WebPushDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('application_id', models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('p256dh', models.CharField(max_length=88, verbose_name='User public encryption key')),\\n                ('auth', models.CharField(max_length=24, verbose_name='User auth secret')),\\n                ('browser', models.CharField(default='CHROME', help_text='Currently only support to Chrome, Firefox and Opera browsers', max_length=10, verbose_name='Browser', choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera')])),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'WebPush device',\\n            },\\n        ),\\n    ]\\n\""}, "return_value": "\"# (deleted declaration) -*-\\nfrom django.conf import settings\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\\n        ('push_notifications', '0005_applicationid'),\\n    ]\\n\\n    operations = [\\n        migrations.CreateModel(\\n            name='WebPushDevice',\\n            fields=[\\n                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),\\n                ('name', models.CharField(max_length=255, null=True, verbose_name='Name', blank=True)),\\n                ('active', models.BooleanField(default=True, help_text='Inactive devices will not be sent notifications', verbose_name='Is active')),\\n                ('date_created', models.DateTimeField(auto_now_add=True, verbose_name='Creation date', null=True)),\\n                ('application_id', models.CharField(help_text='Opaque application identity, should be filled in for multiple key/certificate access', max_length=64, null=True, verbose_name='Application ID', blank=True)),\\n                ('registration_id', models.TextField(verbose_name='Registration ID')),\\n                ('p256dh', models.CharField(max_length=88, verbose_name='User public encryption key')),\\n                ('auth', models.CharField(max_length=24, verbose_name='User auth secret')),\\n                ('browser', models.CharField(default='CHROME', help_text='Currently only support to Chrome, Firefox and Opera browsers', max_length=10, verbose_name='Browser', choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera')])),\\n                ('user', models.ForeignKey(blank=True, to=settings.AUTH_USER_MODEL, null=True, on_delete=models.CASCADE)),\\n            ],\\n            options={\\n                'verbose_name': 'WebPush device',\\n            },\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"from django.db import migrations, models\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0006_webpushdevice'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='gcmdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='wnsdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Notification URI'),\\n        ),\\n    ]\\n\""}, "return_value": "\"from django.db import migrations, models\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0006_webpushdevice'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='gcmdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='wnsdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Notification URI'),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"from django.db import migrations, models\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0006_webpushdevice'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='gcmdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='wnsdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Notification URI'),\\n        ),\\n    ]\\n\""}, "return_value": "\"from django.db import migrations, models\\n\\nfrom ..settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0006_webpushdevice'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='registration_id',\\n            field=models.CharField(max_length=200, unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='gcmdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Registration ID'),\\n        ),\\n        migrations.AlterField(\\n            model_name='wnsdevice',\\n            name='registration_id',\\n            field=models.TextField(unique=SETTINGS['UNIQUE_REG_ID'], verbose_name='Notification URI'),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# Generated by Django 3.2.8 on 2021-11-12 09:49\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0007_uniquesetting'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='browser',\\n            field=models.CharField(choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera'), ('EDGE', 'Edge')], default='CHROME', help_text='Currently only support to Chrome, Firefox, Edge and Opera browsers', max_length=10, verbose_name='Browser'),\\n        ),\\n    ]\\n\""}, "return_value": "\"# Generated by Django 3.2.8 on 2021-11-12 09:49\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0007_uniquesetting'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='browser',\\n            field=models.CharField(choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera'), ('EDGE', 'Edge')], default='CHROME', help_text='Currently only support to Chrome, Firefox, Edge and Opera browsers', max_length=10, verbose_name='Browser'),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# Generated by Django 3.2.8 on 2021-11-12 09:49\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0007_uniquesetting'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='browser',\\n            field=models.CharField(choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera'), ('EDGE', 'Edge')], default='CHROME', help_text='Currently only support to Chrome, Firefox, Edge and Opera browsers', max_length=10, verbose_name='Browser'),\\n        ),\\n    ]\\n\""}, "return_value": "\"# Generated by Django 3.2.8 on 2021-11-12 09:49\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0007_uniquesetting'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='webpushdevice',\\n            name='browser',\\n            field=models.CharField(choices=[('CHROME', 'Chrome'), ('FIREFOX', 'Firefox'), ('OPERA', 'Opera'), ('EDGE', 'Edge')], default='CHROME', help_text='Currently only support to Chrome, Firefox, Edge and Opera browsers', max_length=10, verbose_name='Browser'),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# Generated by Django 3.2.9 on 2022-01-10 09:03\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0008_webpush_add_edge'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='device_id',\\n            field=models.UUIDField(blank=True, db_index=True, help_text='UUID / UIDevice.identifierForVendor()', null=True, verbose_name='Device ID'),\\n        ),\\n    ]\\n\""}, "return_value": "\"# Generated by Django 3.2.9 on 2022-01-10 09:03\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0008_webpush_add_edge'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='device_id',\\n            field=models.UUIDField(blank=True, db_index=True, help_text='UUID / UIDevice.identifierForVendor()', null=True, verbose_name='Device ID'),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "\"# Generated by Django 3.2.9 on 2022-01-10 09:03\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0008_webpush_add_edge'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='device_id',\\n            field=models.UUIDField(blank=True, db_index=True, help_text='UUID / UIDevice.identifierForVendor()', null=True, verbose_name='Device ID'),\\n        ),\\n    ]\\n\""}, "return_value": "\"# Generated by Django 3.2.9 on 2022-01-10 09:03\\n\\nfrom django.db import migrations, models\\n\\n\\nclass Migration(migrations.Migration):\\n\\n    dependencies = [\\n        ('push_notifications', '0008_webpush_add_edge'),\\n    ]\\n\\n    operations = [\\n        migrations.AlterField(\\n            model_name='apnsdevice',\\n            name='device_id',\\n            field=models.UUIDField(blank=True, db_index=True, help_text='UUID / UIDevice.identifierForVendor()', null=True, verbose_name='Device ID'),\\n        ),\\n    ]\\n\""}, {"func_args": {"source": "''"}, "return_value": "''"}, {"func_args": {"source": "'from django.db import models\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .fields import HexIntegerField\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nCLOUD_MESSAGE_TYPES = (\\n\\t(\"FCM\", \"Firebase Cloud Message\"),\\n\\t(\"GCM\", \"Google Cloud Message\"),\\n)\\n\\nBROWSER_TYPES = (\\n\\t(\"CHROME\", \"Chrome\"),\\n\\t(\"FIREFOX\", \"Firefox\"),\\n\\t(\"OPERA\", \"Opera\"),\\n\\t(\"EDGE\", \"Edge\")\\n)\\n\\n\\nclass Device(models.Model):\\n\\tname = models.CharField(max_length=255, verbose_name=_(\"Name\"), blank=True, null=True)\\n\\tactive = models.BooleanField(\\n\\t\\tverbose_name=_(\"Is active\"), default=True,\\n\\t\\thelp_text=_(\"Inactive devices will not be sent notifications\")\\n\\t)\\n\\tuser = models.ForeignKey(\\n\\t\\tSETTINGS[\"USER_MODEL\"], blank=True, null=True, on_delete=models.CASCADE\\n\\t)\\n\\tdate_created = models.DateTimeField(\\n\\t\\tverbose_name=_(\"Creation date\"), auto_now_add=True, null=True\\n\\t)\\n\\tapplication_id = models.CharField(\\n\\t\\tmax_length=64, verbose_name=_(\"Application ID\"),\\n\\t\\thelp_text=_(\\n\\t\\t\\t\"Opaque application identity, should be filled in for multiple\"\\n\\t\\t\\t\" key/certificate access\"\\n\\t\\t),\\n\\t\\tblank=True, null=True\\n\\t)\\n\\n\\tclass Meta:\\n\\t\\tabstract = True\\n\\n\\tdef __str__(self):\\n\\t\\treturn (\\n\\t\\t\\tself.name or\\n\\t\\t\\tstr(self.device_id or \"\") or\\n\\t\\t\\t\"{} for {}\".format(self.__class__.__name__, self.user or \"unknown user\")\\n\\t\\t)\\n\\n\\nclass GCMDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn GCMDeviceQuerySet(self.model)\\n\\n\\nclass GCMDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\t\\tif message is not None:\\n\\t\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\\n\\t\\t\\t\\t\"application_id\"\\n\\t\\t\\t).values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tresponse = []\\n\\t\\t\\tfor cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\t\\treg_ids = list(\\n\\t\\t\\t\\t\\t\\tself.filter(\\n\\t\\t\\t\\t\\t\\t\\tactive=True, cloud_message_type=cloud_type, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\tif reg_ids:\\n\\t\\t\\t\\t\\t\\tr = gcm_send_message(reg_ids, data, cloud_type, application_id=app_id, **kwargs)\\n\\t\\t\\t\\t\\t\\tresponse.append(r)\\n\\n\\t\\t\\treturn response\\n\\n\\nclass GCMDevice(Device):\\n\\t# device_id cannot be a reliable primary key as fragmentation between different devices\\n\\t# can make it turn out to be null and such:\\n\\t# http://android-developers.blogspot.co.uk/2011/03/identifying-app-installations.html\\n\\tdevice_id = HexIntegerField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tcloud_message_type = models.CharField(\\n\\t\\tverbose_name=_(\"Cloud Message Type\"), max_length=3,\\n\\t\\tchoices=CLOUD_MESSAGE_TYPES, default=\"GCM\",\\n\\t\\thelp_text=_(\"You should choose FCM or GCM\")\\n\\t)\\n\\tobjects = GCMDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"GCM device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\tif message is not None:\\n\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\treturn gcm_send_message(\\n\\t\\t\\tself.registration_id, data, self.cloud_message_type,\\n\\t\\t\\tapplication_id=self.application_id, **kwargs\\n\\t\\t)\\n\\n\\nclass APNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn APNSDeviceQuerySet(self.model)\\n\\n\\nclass APNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .apns import apns_send_bulk_message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\")\\\\\\n\\t\\t\\t\\t.values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tres = []\\n\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\treg_ids = list(self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\"registration_id\", flat=True)\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tr = apns_send_bulk_message(\\n\\t\\t\\t\\t\\tregistration_ids=reg_ids, alert=message, application_id=app_id,\\n\\t\\t\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\t\\tres += [r]\\n\\t\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\t\\tres += r\\n\\t\\t\\treturn res\\n\\n\\nclass APNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"UUID / UIDevice.identifierForVendor()\")\\n\\t)\\n\\tregistration_id = models.CharField(\\n\\t\\tverbose_name=_(\"Registration ID\"), max_length=200, unique=SETTINGS[\"UNIQUE_REG_ID\"]\\n\\t)\\n\\n\\tobjects = APNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"APNS device\")\\n\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tfrom .apns import apns_send_message\\n\\n\\t\\treturn apns_send_message(\\n\\t\\t\\tregistration_id=self.registration_id,\\n\\t\\t\\talert=message,\\n\\t\\t\\tapplication_id=self.application_id, creds=creds,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WNSDeviceQuerySet(self.model)\\n\\n\\nclass WNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_bulk_message\\n\\n\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\").values_list(\\n\\t\\t\\t\"application_id\", flat=True\\n\\t\\t).distinct()\\n\\t\\tres = []\\n\\t\\tfor app_id in app_ids:\\n\\t\\t\\treg_ids = self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t)\\n\\t\\t\\tr = wns_send_bulk_message(uri_list=list(reg_ids), message=message, **kwargs)\\n\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\tres += [r]\\n\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\tres += r\\n\\n\\t\\treturn res\\n\\n\\nclass WNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"GUID()\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Notification URI\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\n\\tobjects = WNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WNS device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_message\\n\\n\\t\\treturn wns_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, application_id=self.application_id,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WebPushDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WebPushDeviceQuerySet(self.model)\\n\\n\\nclass WebPushDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tdevices = self.filter(active=True).order_by(\"application_id\").distinct()\\n\\t\\tres = []\\n\\t\\tfor device in devices:\\n\\t\\t\\tres.append(device.send_message(message))\\n\\n\\t\\treturn res\\n\\n\\nclass WebPushDevice(Device):\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tp256dh = models.CharField(\\n\\t\\tverbose_name=_(\"User public encryption key\"),\\n\\t\\tmax_length=88)\\n\\tauth = models.CharField(\\n\\t\\tverbose_name=_(\"User auth secret\"),\\n\\t\\tmax_length=24)\\n\\tbrowser = models.CharField(\\n\\t\\tverbose_name=_(\"Browser\"), max_length=10,\\n\\t\\tchoices=BROWSER_TYPES, default=BROWSER_TYPES[0][0],\\n\\t\\thelp_text=_(\"Currently only support to Chrome, Firefox, Edge and Opera browsers\")\\n\\t)\\n\\tobjects = WebPushDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WebPush device\")\\n\\n\\t@property\\n\\tdef device_id(self):\\n\\t\\treturn None\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .webpush import webpush_send_message\\n\\n\\t\\treturn webpush_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, browser=self.browser,\\n\\t\\t\\tauth=self.auth, p256dh=self.p256dh, application_id=self.application_id, **kwargs)\\n'"}, "return_value": "'from django.db import models\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .fields import HexIntegerField\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nCLOUD_MESSAGE_TYPES = (\\n\\t(\"FCM\", \"Firebase Cloud Message\"),\\n\\t(\"GCM\", \"Google Cloud Message\"),\\n)\\n\\nBROWSER_TYPES = (\\n\\t(\"CHROME\", \"Chrome\"),\\n\\t(\"FIREFOX\", \"Firefox\"),\\n\\t(\"OPERA\", \"Opera\"),\\n\\t(\"EDGE\", \"Edge\")\\n)\\n\\n\\nclass Device(models.Model):\\n\\tname = models.CharField(max_length=255, verbose_name=_(\"Name\"), blank=True, null=True)\\n\\tactive = models.BooleanField(\\n\\t\\tverbose_name=_(\"Is active\"), default=True,\\n\\t\\thelp_text=_(\"Inactive devices will not be sent notifications\")\\n\\t)\\n\\tuser = models.ForeignKey(\\n\\t\\tSETTINGS[\"USER_MODEL\"], blank=True, null=True, on_delete=models.CASCADE\\n\\t)\\n\\tdate_created = models.DateTimeField(\\n\\t\\tverbose_name=_(\"Creation date\"), auto_now_add=True, null=True\\n\\t)\\n\\tapplication_id = models.CharField(\\n\\t\\tmax_length=64, verbose_name=_(\"Application ID\"),\\n\\t\\thelp_text=_(\\n\\t\\t\\t\"Opaque application identity, should be filled in for multiple\"\\n\\t\\t\\t\" key/certificate access\"\\n\\t\\t),\\n\\t\\tblank=True, null=True\\n\\t)\\n\\n\\tclass Meta:\\n\\t\\tabstract = True\\n\\n\\tdef __str__(self):\\n\\t\\treturn (\\n\\t\\t\\tself.name or\\n\\t\\t\\tstr(self.device_id or \"\") or\\n\\t\\t\\t\"{} for {}\".format(self.__class__.__name__, self.user or \"unknown user\")\\n\\t\\t)\\n\\n\\nclass GCMDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn GCMDeviceQuerySet(self.model)\\n\\n\\nclass GCMDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\t\\tif message is not None:\\n\\t\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\\n\\t\\t\\t\\t\"application_id\"\\n\\t\\t\\t).values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tresponse = []\\n\\t\\t\\tfor cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\t\\treg_ids = list(\\n\\t\\t\\t\\t\\t\\tself.filter(\\n\\t\\t\\t\\t\\t\\t\\tactive=True, cloud_message_type=cloud_type, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\tif reg_ids:\\n\\t\\t\\t\\t\\t\\tr = gcm_send_message(reg_ids, data, cloud_type, application_id=app_id, **kwargs)\\n\\t\\t\\t\\t\\t\\tresponse.append(r)\\n\\n\\t\\t\\treturn response\\n\\n\\nclass GCMDevice(Device):\\n\\t# device_id cannot be a reliable primary key as fragmentation between different devices\\n\\t# can make it turn out to be null and such:\\n\\t# http://android-developers.blogspot.co.uk/2011/03/identifying-app-installations.html\\n\\tdevice_id = HexIntegerField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tcloud_message_type = models.CharField(\\n\\t\\tverbose_name=_(\"Cloud Message Type\"), max_length=3,\\n\\t\\tchoices=CLOUD_MESSAGE_TYPES, default=\"GCM\",\\n\\t\\thelp_text=_(\"You should choose FCM or GCM\")\\n\\t)\\n\\tobjects = GCMDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"GCM device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\tif message is not None:\\n\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\treturn gcm_send_message(\\n\\t\\t\\tself.registration_id, data, self.cloud_message_type,\\n\\t\\t\\tapplication_id=self.application_id, **kwargs\\n\\t\\t)\\n\\n\\nclass APNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn APNSDeviceQuerySet(self.model)\\n\\n\\nclass APNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .apns import apns_send_bulk_message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\")\\\\\\n\\t\\t\\t\\t.values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tres = []\\n\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\treg_ids = list(self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\"registration_id\", flat=True)\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tr = apns_send_bulk_message(\\n\\t\\t\\t\\t\\tregistration_ids=reg_ids, alert=message, application_id=app_id,\\n\\t\\t\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\t\\tres += [r]\\n\\t\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\t\\tres += r\\n\\t\\t\\treturn res\\n\\n\\nclass APNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"UUID / UIDevice.identifierForVendor()\")\\n\\t)\\n\\tregistration_id = models.CharField(\\n\\t\\tverbose_name=_(\"Registration ID\"), max_length=200, unique=SETTINGS[\"UNIQUE_REG_ID\"]\\n\\t)\\n\\n\\tobjects = APNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"APNS device\")\\n\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tfrom .apns import apns_send_message\\n\\n\\t\\treturn apns_send_message(\\n\\t\\t\\tregistration_id=self.registration_id,\\n\\t\\t\\talert=message,\\n\\t\\t\\tapplication_id=self.application_id, creds=creds,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WNSDeviceQuerySet(self.model)\\n\\n\\nclass WNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_bulk_message\\n\\n\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\").values_list(\\n\\t\\t\\t\"application_id\", flat=True\\n\\t\\t).distinct()\\n\\t\\tres = []\\n\\t\\tfor app_id in app_ids:\\n\\t\\t\\treg_ids = self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t)\\n\\t\\t\\tr = wns_send_bulk_message(uri_list=list(reg_ids), message=message, **kwargs)\\n\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\tres += [r]\\n\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\tres += r\\n\\n\\t\\treturn res\\n\\n\\nclass WNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"GUID()\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Notification URI\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\n\\tobjects = WNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WNS device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_message\\n\\n\\t\\treturn wns_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, application_id=self.application_id,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WebPushDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WebPushDeviceQuerySet(self.model)\\n\\n\\nclass WebPushDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tdevices = self.filter(active=True).order_by(\"application_id\").distinct()\\n\\t\\tres = []\\n\\t\\tfor device in devices:\\n\\t\\t\\tres.append(device.send_message(message))\\n\\n\\t\\treturn res\\n\\n\\nclass WebPushDevice(Device):\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tp256dh = models.CharField(\\n\\t\\tverbose_name=_(\"User public encryption key\"),\\n\\t\\tmax_length=88)\\n\\tauth = models.CharField(\\n\\t\\tverbose_name=_(\"User auth secret\"),\\n\\t\\tmax_length=24)\\n\\tbrowser = models.CharField(\\n\\t\\tverbose_name=_(\"Browser\"), max_length=10,\\n\\t\\tchoices=BROWSER_TYPES, default=BROWSER_TYPES[0][0],\\n\\t\\thelp_text=_(\"Currently only support to Chrome, Firefox, Edge and Opera browsers\")\\n\\t)\\n\\tobjects = WebPushDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WebPush device\")\\n\\n\\t@property\\n\\tdef device_id(self):\\n\\t\\treturn None\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .webpush import webpush_send_message\\n\\n\\t\\treturn webpush_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, browser=self.browser,\\n\\t\\t\\tauth=self.auth, p256dh=self.p256dh, application_id=self.application_id, **kwargs)\\n'"}, {"func_args": {"source": "'from django.db import models\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .fields import HexIntegerField\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nCLOUD_MESSAGE_TYPES = (\\n\\t(\"FCM\", \"Firebase Cloud Message\"),\\n\\t(\"GCM\", \"Google Cloud Message\"),\\n)\\n\\nBROWSER_TYPES = (\\n\\t(\"CHROME\", \"Chrome\"),\\n\\t(\"FIREFOX\", \"Firefox\"),\\n\\t(\"OPERA\", \"Opera\"),\\n\\t(\"EDGE\", \"Edge\")\\n)\\n\\n\\nclass Device(models.Model):\\n\\tname = models.CharField(max_length=255, verbose_name=_(\"Name\"), blank=True, null=True)\\n\\tactive = models.BooleanField(\\n\\t\\tverbose_name=_(\"Is active\"), default=True,\\n\\t\\thelp_text=_(\"Inactive devices will not be sent notifications\")\\n\\t)\\n\\tuser = models.ForeignKey(\\n\\t\\tSETTINGS[\"USER_MODEL\"], blank=True, null=True, on_delete=models.CASCADE\\n\\t)\\n\\tdate_created = models.DateTimeField(\\n\\t\\tverbose_name=_(\"Creation date\"), auto_now_add=True, null=True\\n\\t)\\n\\tapplication_id = models.CharField(\\n\\t\\tmax_length=64, verbose_name=_(\"Application ID\"),\\n\\t\\thelp_text=_(\\n\\t\\t\\t\"Opaque application identity, should be filled in for multiple\"\\n\\t\\t\\t\" key/certificate access\"\\n\\t\\t),\\n\\t\\tblank=True, null=True\\n\\t)\\n\\n\\tclass Meta:\\n\\t\\tabstract = True\\n\\n\\tdef __str__(self):\\n\\t\\treturn (\\n\\t\\t\\tself.name or\\n\\t\\t\\tstr(self.device_id or \"\") or\\n\\t\\t\\t\"{} for {}\".format(self.__class__.__name__, self.user or \"unknown user\")\\n\\t\\t)\\n\\n\\nclass GCMDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn GCMDeviceQuerySet(self.model)\\n\\n\\nclass GCMDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\t\\tif message is not None:\\n\\t\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\\n\\t\\t\\t\\t\"application_id\"\\n\\t\\t\\t).values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tresponse = []\\n\\t\\t\\tfor cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\t\\treg_ids = list(\\n\\t\\t\\t\\t\\t\\tself.filter(\\n\\t\\t\\t\\t\\t\\t\\tactive=True, cloud_message_type=cloud_type, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\tif reg_ids:\\n\\t\\t\\t\\t\\t\\tr = gcm_send_message(reg_ids, data, cloud_type, application_id=app_id, **kwargs)\\n\\t\\t\\t\\t\\t\\tresponse.append(r)\\n\\n\\t\\t\\treturn response\\n\\n\\nclass GCMDevice(Device):\\n\\t# device_id cannot be a reliable primary key as fragmentation between different devices\\n\\t# can make it turn out to be null and such:\\n\\t# http://android-developers.blogspot.co.uk/2011/03/identifying-app-installations.html\\n\\tdevice_id = HexIntegerField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tcloud_message_type = models.CharField(\\n\\t\\tverbose_name=_(\"Cloud Message Type\"), max_length=3,\\n\\t\\tchoices=CLOUD_MESSAGE_TYPES, default=\"GCM\",\\n\\t\\thelp_text=_(\"You should choose FCM or GCM\")\\n\\t)\\n\\tobjects = GCMDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"GCM device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\tif message is not None:\\n\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\treturn gcm_send_message(\\n\\t\\t\\tself.registration_id, data, self.cloud_message_type,\\n\\t\\t\\tapplication_id=self.application_id, **kwargs\\n\\t\\t)\\n\\n\\nclass APNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn APNSDeviceQuerySet(self.model)\\n\\n\\nclass APNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .apns import apns_send_bulk_message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\")\\\\\\n\\t\\t\\t\\t.values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tres = []\\n\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\treg_ids = list(self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\"registration_id\", flat=True)\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tr = apns_send_bulk_message(\\n\\t\\t\\t\\t\\tregistration_ids=reg_ids, alert=message, application_id=app_id,\\n\\t\\t\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\t\\tres += [r]\\n\\t\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\t\\tres += r\\n\\t\\t\\treturn res\\n\\n\\nclass APNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"UUID / UIDevice.identifierForVendor()\")\\n\\t)\\n\\tregistration_id = models.CharField(\\n\\t\\tverbose_name=_(\"Registration ID\"), max_length=200, unique=SETTINGS[\"UNIQUE_REG_ID\"]\\n\\t)\\n\\n\\tobjects = APNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"APNS device\")\\n\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tfrom .apns import apns_send_message\\n\\n\\t\\treturn apns_send_message(\\n\\t\\t\\tregistration_id=self.registration_id,\\n\\t\\t\\talert=message,\\n\\t\\t\\tapplication_id=self.application_id, creds=creds,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WNSDeviceQuerySet(self.model)\\n\\n\\nclass WNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_bulk_message\\n\\n\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\").values_list(\\n\\t\\t\\t\"application_id\", flat=True\\n\\t\\t).distinct()\\n\\t\\tres = []\\n\\t\\tfor app_id in app_ids:\\n\\t\\t\\treg_ids = self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t)\\n\\t\\t\\tr = wns_send_bulk_message(uri_list=list(reg_ids), message=message, **kwargs)\\n\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\tres += [r]\\n\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\tres += r\\n\\n\\t\\treturn res\\n\\n\\nclass WNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"GUID()\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Notification URI\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\n\\tobjects = WNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WNS device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_message\\n\\n\\t\\treturn wns_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, application_id=self.application_id,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WebPushDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WebPushDeviceQuerySet(self.model)\\n\\n\\nclass WebPushDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tdevices = self.filter(active=True).order_by(\"application_id\").distinct()\\n\\t\\tres = []\\n\\t\\tfor device in devices:\\n\\t\\t\\tres.append(device.send_message(message))\\n\\n\\t\\treturn res\\n\\n\\nclass WebPushDevice(Device):\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tp256dh = models.CharField(\\n\\t\\tverbose_name=_(\"User public encryption key\"),\\n\\t\\tmax_length=88)\\n\\tauth = models.CharField(\\n\\t\\tverbose_name=_(\"User auth secret\"),\\n\\t\\tmax_length=24)\\n\\tbrowser = models.CharField(\\n\\t\\tverbose_name=_(\"Browser\"), max_length=10,\\n\\t\\tchoices=BROWSER_TYPES, default=BROWSER_TYPES[0][0],\\n\\t\\thelp_text=_(\"Currently only support to Chrome, Firefox, Edge and Opera browsers\")\\n\\t)\\n\\tobjects = WebPushDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WebPush device\")\\n\\n\\t@property\\n\\tdef device_id(self):\\n\\t\\treturn None\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .webpush import webpush_send_message\\n\\n\\t\\treturn webpush_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, browser=self.browser,\\n\\t\\t\\tauth=self.auth, p256dh=self.p256dh, application_id=self.application_id, **kwargs)\\n'"}, "return_value": "'from django.db import models\\nfrom django.utils.translation import gettext_lazy as _\\n\\nfrom .fields import HexIntegerField\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nCLOUD_MESSAGE_TYPES = (\\n\\t(\"FCM\", \"Firebase Cloud Message\"),\\n\\t(\"GCM\", \"Google Cloud Message\"),\\n)\\n\\nBROWSER_TYPES = (\\n\\t(\"CHROME\", \"Chrome\"),\\n\\t(\"FIREFOX\", \"Firefox\"),\\n\\t(\"OPERA\", \"Opera\"),\\n\\t(\"EDGE\", \"Edge\")\\n)\\n\\n\\nclass Device(models.Model):\\n\\tname = models.CharField(max_length=255, verbose_name=_(\"Name\"), blank=True, null=True)\\n\\tactive = models.BooleanField(\\n\\t\\tverbose_name=_(\"Is active\"), default=True,\\n\\t\\thelp_text=_(\"Inactive devices will not be sent notifications\")\\n\\t)\\n\\tuser = models.ForeignKey(\\n\\t\\tSETTINGS[\"USER_MODEL\"], blank=True, null=True, on_delete=models.CASCADE\\n\\t)\\n\\tdate_created = models.DateTimeField(\\n\\t\\tverbose_name=_(\"Creation date\"), auto_now_add=True, null=True\\n\\t)\\n\\tapplication_id = models.CharField(\\n\\t\\tmax_length=64, verbose_name=_(\"Application ID\"),\\n\\t\\thelp_text=_(\\n\\t\\t\\t\"Opaque application identity, should be filled in for multiple\"\\n\\t\\t\\t\" key/certificate access\"\\n\\t\\t),\\n\\t\\tblank=True, null=True\\n\\t)\\n\\n\\tclass Meta:\\n\\t\\tabstract = True\\n\\n\\tdef __str__(self):\\n\\t\\treturn (\\n\\t\\t\\tself.name or\\n\\t\\t\\tstr(self.device_id or \"\") or\\n\\t\\t\\t\"{} for {}\".format(self.__class__.__name__, self.user or \"unknown user\")\\n\\t\\t)\\n\\n\\nclass GCMDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn GCMDeviceQuerySet(self.model)\\n\\n\\nclass GCMDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\t\\tif message is not None:\\n\\t\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\\n\\t\\t\\t\\t\"application_id\"\\n\\t\\t\\t).values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tresponse = []\\n\\t\\t\\tfor cloud_type in (\"FCM\", \"GCM\"):\\n\\t\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\t\\treg_ids = list(\\n\\t\\t\\t\\t\\t\\tself.filter(\\n\\t\\t\\t\\t\\t\\t\\tactive=True, cloud_message_type=cloud_type, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\tif reg_ids:\\n\\t\\t\\t\\t\\t\\tr = gcm_send_message(reg_ids, data, cloud_type, application_id=app_id, **kwargs)\\n\\t\\t\\t\\t\\t\\tresponse.append(r)\\n\\n\\t\\t\\treturn response\\n\\n\\nclass GCMDevice(Device):\\n\\t# device_id cannot be a reliable primary key as fragmentation between different devices\\n\\t# can make it turn out to be null and such:\\n\\t# http://android-developers.blogspot.co.uk/2011/03/identifying-app-installations.html\\n\\tdevice_id = HexIntegerField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"ANDROID_ID / TelephonyManager.getDeviceId() (always as hex)\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tcloud_message_type = models.CharField(\\n\\t\\tverbose_name=_(\"Cloud Message Type\"), max_length=3,\\n\\t\\tchoices=CLOUD_MESSAGE_TYPES, default=\"GCM\",\\n\\t\\thelp_text=_(\"You should choose FCM or GCM\")\\n\\t)\\n\\tobjects = GCMDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"GCM device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .gcm import send_message as gcm_send_message\\n\\n\\t\\tdata = kwargs.pop(\"extra\", {})\\n\\t\\tif message is not None:\\n\\t\\t\\tdata[\"message\"] = message\\n\\n\\t\\treturn gcm_send_message(\\n\\t\\t\\tself.registration_id, data, self.cloud_message_type,\\n\\t\\t\\tapplication_id=self.application_id, **kwargs\\n\\t\\t)\\n\\n\\nclass APNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn APNSDeviceQuerySet(self.model)\\n\\n\\nclass APNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tif self.exists():\\n\\t\\t\\tfrom .apns import apns_send_bulk_message\\n\\n\\t\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\")\\\\\\n\\t\\t\\t\\t.values_list(\"application_id\", flat=True).distinct()\\n\\t\\t\\tres = []\\n\\t\\t\\tfor app_id in app_ids:\\n\\t\\t\\t\\treg_ids = list(self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\\t\"registration_id\", flat=True)\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tr = apns_send_bulk_message(\\n\\t\\t\\t\\t\\tregistration_ids=reg_ids, alert=message, application_id=app_id,\\n\\t\\t\\t\\t\\tcreds=creds, **kwargs\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\t\\tres += [r]\\n\\t\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\t\\tres += r\\n\\t\\t\\treturn res\\n\\n\\nclass APNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"UUID / UIDevice.identifierForVendor()\")\\n\\t)\\n\\tregistration_id = models.CharField(\\n\\t\\tverbose_name=_(\"Registration ID\"), max_length=200, unique=SETTINGS[\"UNIQUE_REG_ID\"]\\n\\t)\\n\\n\\tobjects = APNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"APNS device\")\\n\\n\\tdef send_message(self, message, creds=None, **kwargs):\\n\\t\\tfrom .apns import apns_send_message\\n\\n\\t\\treturn apns_send_message(\\n\\t\\t\\tregistration_id=self.registration_id,\\n\\t\\t\\talert=message,\\n\\t\\t\\tapplication_id=self.application_id, creds=creds,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WNSDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WNSDeviceQuerySet(self.model)\\n\\n\\nclass WNSDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_bulk_message\\n\\n\\t\\tapp_ids = self.filter(active=True).order_by(\"application_id\").values_list(\\n\\t\\t\\t\"application_id\", flat=True\\n\\t\\t).distinct()\\n\\t\\tres = []\\n\\t\\tfor app_id in app_ids:\\n\\t\\t\\treg_ids = self.filter(active=True, application_id=app_id).values_list(\\n\\t\\t\\t\\t\"registration_id\", flat=True\\n\\t\\t\\t)\\n\\t\\t\\tr = wns_send_bulk_message(uri_list=list(reg_ids), message=message, **kwargs)\\n\\t\\t\\tif hasattr(r, \"keys\"):\\n\\t\\t\\t\\tres += [r]\\n\\t\\t\\telif hasattr(r, \"__getitem__\"):\\n\\t\\t\\t\\tres += r\\n\\n\\t\\treturn res\\n\\n\\nclass WNSDevice(Device):\\n\\tdevice_id = models.UUIDField(\\n\\t\\tverbose_name=_(\"Device ID\"), blank=True, null=True, db_index=True,\\n\\t\\thelp_text=_(\"GUID()\")\\n\\t)\\n\\tregistration_id = models.TextField(verbose_name=_(\"Notification URI\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\n\\tobjects = WNSDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WNS device\")\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .wns import wns_send_message\\n\\n\\t\\treturn wns_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, application_id=self.application_id,\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\n\\nclass WebPushDeviceManager(models.Manager):\\n\\tdef get_queryset(self):\\n\\t\\treturn WebPushDeviceQuerySet(self.model)\\n\\n\\nclass WebPushDeviceQuerySet(models.query.QuerySet):\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tdevices = self.filter(active=True).order_by(\"application_id\").distinct()\\n\\t\\tres = []\\n\\t\\tfor device in devices:\\n\\t\\t\\tres.append(device.send_message(message))\\n\\n\\t\\treturn res\\n\\n\\nclass WebPushDevice(Device):\\n\\tregistration_id = models.TextField(verbose_name=_(\"Registration ID\"), unique=SETTINGS[\"UNIQUE_REG_ID\"])\\n\\tp256dh = models.CharField(\\n\\t\\tverbose_name=_(\"User public encryption key\"),\\n\\t\\tmax_length=88)\\n\\tauth = models.CharField(\\n\\t\\tverbose_name=_(\"User auth secret\"),\\n\\t\\tmax_length=24)\\n\\tbrowser = models.CharField(\\n\\t\\tverbose_name=_(\"Browser\"), max_length=10,\\n\\t\\tchoices=BROWSER_TYPES, default=BROWSER_TYPES[0][0],\\n\\t\\thelp_text=_(\"Currently only support to Chrome, Firefox, Edge and Opera browsers\")\\n\\t)\\n\\tobjects = WebPushDeviceManager()\\n\\n\\tclass Meta:\\n\\t\\tverbose_name = _(\"WebPush device\")\\n\\n\\t@property\\n\\tdef device_id(self):\\n\\t\\treturn None\\n\\n\\tdef send_message(self, message, **kwargs):\\n\\t\\tfrom .webpush import webpush_send_message\\n\\n\\t\\treturn webpush_send_message(\\n\\t\\t\\turi=self.registration_id, message=message, browser=self.browser,\\n\\t\\t\\tauth=self.auth, p256dh=self.p256dh, application_id=self.application_id, **kwargs)\\n'"}, {"func_args": {"source": "'from django.conf import settings\\n\\n\\nPUSH_NOTIFICATIONS_SETTINGS = getattr(settings, \"PUSH_NOTIFICATIONS_SETTINGS\", {})\\n\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"CONFIG\", \"push_notifications.conf.LegacyConfig\"\\n)\\n\\n# GCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"GCM_POST_URL\", \"https://android.googleapis.com/gcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_ERROR_TIMEOUT\", None)\\n\\n# FCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"FCM_POST_URL\", \"https://fcm.googleapis.com/fcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_ERROR_TIMEOUT\", None)\\n\\n# APNS\\nif settings.DEBUG:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", True)\\nelse:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_ALTERNATIVE_PORT\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_TOPIC\", None)\\n\\n# WNS\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_PACKAGE_SECURITY_ID\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_SECRET_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\"\\n)\\n\\n# WP (WebPush)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_POST_URL\", {\\n\\t\"CHROME\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"OPERA\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n})\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_PRIVATE_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_CLAIMS\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_ERROR_TIMEOUT\", None)\\n\\n# User model\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"USER_MODEL\", settings.AUTH_USER_MODEL)\\n\\n# Unique registration ID for all devices\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UNIQUE_REG_ID\", False)\\n\\n# API endpoint settings\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UPDATE_ON_DUPLICATE_REG_ID\", False)\\n'"}, "return_value": "'from django.conf import settings\\n\\n\\nPUSH_NOTIFICATIONS_SETTINGS = getattr(settings, \"PUSH_NOTIFICATIONS_SETTINGS\", {})\\n\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"CONFIG\", \"push_notifications.conf.LegacyConfig\"\\n)\\n\\n# GCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"GCM_POST_URL\", \"https://android.googleapis.com/gcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_ERROR_TIMEOUT\", None)\\n\\n# FCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"FCM_POST_URL\", \"https://fcm.googleapis.com/fcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_ERROR_TIMEOUT\", None)\\n\\n# APNS\\nif settings.DEBUG:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", True)\\nelse:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_ALTERNATIVE_PORT\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_TOPIC\", None)\\n\\n# WNS\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_PACKAGE_SECURITY_ID\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_SECRET_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\"\\n)\\n\\n# WP (WebPush)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_POST_URL\", {\\n\\t\"CHROME\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"OPERA\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n})\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_PRIVATE_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_CLAIMS\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_ERROR_TIMEOUT\", None)\\n\\n# User model\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"USER_MODEL\", settings.AUTH_USER_MODEL)\\n\\n# Unique registration ID for all devices\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UNIQUE_REG_ID\", False)\\n\\n# API endpoint settings\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UPDATE_ON_DUPLICATE_REG_ID\", False)\\n'"}, {"func_args": {"source": "'from django.conf import settings\\n\\n\\nPUSH_NOTIFICATIONS_SETTINGS = getattr(settings, \"PUSH_NOTIFICATIONS_SETTINGS\", {})\\n\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"CONFIG\", \"push_notifications.conf.LegacyConfig\"\\n)\\n\\n# GCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"GCM_POST_URL\", \"https://android.googleapis.com/gcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_ERROR_TIMEOUT\", None)\\n\\n# FCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"FCM_POST_URL\", \"https://fcm.googleapis.com/fcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_ERROR_TIMEOUT\", None)\\n\\n# APNS\\nif settings.DEBUG:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", True)\\nelse:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_ALTERNATIVE_PORT\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_TOPIC\", None)\\n\\n# WNS\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_PACKAGE_SECURITY_ID\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_SECRET_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\"\\n)\\n\\n# WP (WebPush)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_POST_URL\", {\\n\\t\"CHROME\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"OPERA\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n})\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_PRIVATE_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_CLAIMS\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_ERROR_TIMEOUT\", None)\\n\\n# User model\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"USER_MODEL\", settings.AUTH_USER_MODEL)\\n\\n# Unique registration ID for all devices\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UNIQUE_REG_ID\", False)\\n\\n# API endpoint settings\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UPDATE_ON_DUPLICATE_REG_ID\", False)\\n'"}, "return_value": "'from django.conf import settings\\n\\n\\nPUSH_NOTIFICATIONS_SETTINGS = getattr(settings, \"PUSH_NOTIFICATIONS_SETTINGS\", {})\\n\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"CONFIG\", \"push_notifications.conf.LegacyConfig\"\\n)\\n\\n# GCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"GCM_POST_URL\", \"https://android.googleapis.com/gcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"GCM_ERROR_TIMEOUT\", None)\\n\\n# FCM\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"FCM_POST_URL\", \"https://fcm.googleapis.com/fcm/send\"\\n)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_MAX_RECIPIENTS\", 1000)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"FCM_ERROR_TIMEOUT\", None)\\n\\n# APNS\\nif settings.DEBUG:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", True)\\nelse:\\n\\tPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_SANDBOX\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_USE_ALTERNATIVE_PORT\", False)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"APNS_TOPIC\", None)\\n\\n# WNS\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_PACKAGE_SECURITY_ID\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WNS_SECRET_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\\n\\t\"WNS_ACCESS_URL\", \"https://login.live.com/accesstoken.srf\"\\n)\\n\\n# WP (WebPush)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_POST_URL\", {\\n\\t\"CHROME\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"OPERA\": PUSH_NOTIFICATIONS_SETTINGS[\"FCM_POST_URL\"],\\n\\t\"FIREFOX\": \"https://updates.push.services.mozilla.com/wpush/v2\",\\n\\t\"EDGE\": \"https://wns2-par02p.notify.windows.com/w\",\\n})\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_PRIVATE_KEY\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_CLAIMS\", None)\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"WP_ERROR_TIMEOUT\", None)\\n\\n# User model\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"USER_MODEL\", settings.AUTH_USER_MODEL)\\n\\n# Unique registration ID for all devices\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UNIQUE_REG_ID\", False)\\n\\n# API endpoint settings\\nPUSH_NOTIFICATIONS_SETTINGS.setdefault(\"UPDATE_ON_DUPLICATE_REG_ID\", False)\\n'"}, {"func_args": {"source": "'from pywebpush import WebPushException, webpush\\n\\nfrom .conf import get_manager\\nfrom .exceptions import WebPushError\\n\\n\\ndef get_subscription_info(application_id, uri, browser, auth, p256dh):\\n\\turl = get_manager().get_wp_post_url(application_id, browser)\\n\\treturn {\\n\\t\\t\"endpoint\": \"{}/{}\".format(url, uri),\\n\\t\\t\"keys\": {\\n\\t\\t\\t\"auth\": auth,\\n\\t\\t\\t\"p256dh\": p256dh,\\n\\t\\t}\\n\\t}\\n\\n\\ndef webpush_send_message(\\n\\turi, message, browser, auth, p256dh, application_id=None, **kwargs\\n):\\n\\tsubscription_info = get_subscription_info(application_id, uri, browser, auth, p256dh)\\n\\n\\ttry:\\n\\t\\tresponse = webpush(\\n\\t\\t\\tsubscription_info=subscription_info,\\n\\t\\t\\tdata=message,\\n\\t\\t\\tvapid_private_key=get_manager().get_wp_private_key(application_id),\\n\\t\\t\\tvapid_claims=get_manager().get_wp_claims(application_id).copy(),\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\t\\tresults = {\"results\": [{}]}\\n\\t\\tif not response.ok:\\n\\t\\t\\tresults[\"results\"][0][\"error\"] = response.content\\n\\t\\t\\tresults[\"results\"][0][\"original_registration_id\"] = response.content\\n\\t\\telse:\\n\\t\\t\\tresults[\"success\"] = 1\\n\\t\\treturn results\\n\\texcept WebPushException as e:\\n\\t\\traise WebPushError(e.message)\\n'"}, "return_value": "'from pywebpush import WebPushException, webpush\\n\\nfrom .conf import get_manager\\nfrom .exceptions import WebPushError\\n\\n\\ndef get_subscription_info(application_id, uri, browser, auth, p256dh):\\n\\turl = get_manager().get_wp_post_url(application_id, browser)\\n\\treturn {\\n\\t\\t\"endpoint\": \"{}/{}\".format(url, uri),\\n\\t\\t\"keys\": {\\n\\t\\t\\t\"auth\": auth,\\n\\t\\t\\t\"p256dh\": p256dh,\\n\\t\\t}\\n\\t}\\n\\n\\ndef webpush_send_message(\\n\\turi, message, browser, auth, p256dh, application_id=None, **kwargs\\n):\\n\\tsubscription_info = get_subscription_info(application_id, uri, browser, auth, p256dh)\\n\\n\\ttry:\\n\\t\\tresponse = webpush(\\n\\t\\t\\tsubscription_info=subscription_info,\\n\\t\\t\\tdata=message,\\n\\t\\t\\tvapid_private_key=get_manager().get_wp_private_key(application_id),\\n\\t\\t\\tvapid_claims=get_manager().get_wp_claims(application_id).copy(),\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\t\\tresults = {\"results\": [{}]}\\n\\t\\tif not response.ok:\\n\\t\\t\\tresults[\"results\"][0][\"error\"] = response.content\\n\\t\\t\\tresults[\"results\"][0][\"original_registration_id\"] = response.content\\n\\t\\telse:\\n\\t\\t\\tresults[\"success\"] = 1\\n\\t\\treturn results\\n\\texcept WebPushException as e:\\n\\t\\traise WebPushError(e.message)\\n'"}, {"func_args": {"source": "'from pywebpush import WebPushException, webpush\\n\\nfrom .conf import get_manager\\nfrom .exceptions import WebPushError\\n\\n\\ndef get_subscription_info(application_id, uri, browser, auth, p256dh):\\n\\turl = get_manager().get_wp_post_url(application_id, browser)\\n\\treturn {\\n\\t\\t\"endpoint\": \"{}/{}\".format(url, uri),\\n\\t\\t\"keys\": {\\n\\t\\t\\t\"auth\": auth,\\n\\t\\t\\t\"p256dh\": p256dh,\\n\\t\\t}\\n\\t}\\n\\n\\ndef webpush_send_message(\\n\\turi, message, browser, auth, p256dh, application_id=None, **kwargs\\n):\\n\\tsubscription_info = get_subscription_info(application_id, uri, browser, auth, p256dh)\\n\\n\\ttry:\\n\\t\\tresponse = webpush(\\n\\t\\t\\tsubscription_info=subscription_info,\\n\\t\\t\\tdata=message,\\n\\t\\t\\tvapid_private_key=get_manager().get_wp_private_key(application_id),\\n\\t\\t\\tvapid_claims=get_manager().get_wp_claims(application_id).copy(),\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\t\\tresults = {\"results\": [{}]}\\n\\t\\tif not response.ok:\\n\\t\\t\\tresults[\"results\"][0][\"error\"] = response.content\\n\\t\\t\\tresults[\"results\"][0][\"original_registration_id\"] = response.content\\n\\t\\telse:\\n\\t\\t\\tresults[\"success\"] = 1\\n\\t\\treturn results\\n\\texcept WebPushException as e:\\n\\t\\traise WebPushError(e.message)\\n'"}, "return_value": "'from pywebpush import WebPushException, webpush\\n\\nfrom .conf import get_manager\\nfrom .exceptions import WebPushError\\n\\n\\ndef get_subscription_info(application_id, uri, browser, auth, p256dh):\\n\\turl = get_manager().get_wp_post_url(application_id, browser)\\n\\treturn {\\n\\t\\t\"endpoint\": \"{}/{}\".format(url, uri),\\n\\t\\t\"keys\": {\\n\\t\\t\\t\"auth\": auth,\\n\\t\\t\\t\"p256dh\": p256dh,\\n\\t\\t}\\n\\t}\\n\\n\\ndef webpush_send_message(\\n\\turi, message, browser, auth, p256dh, application_id=None, **kwargs\\n):\\n\\tsubscription_info = get_subscription_info(application_id, uri, browser, auth, p256dh)\\n\\n\\ttry:\\n\\t\\tresponse = webpush(\\n\\t\\t\\tsubscription_info=subscription_info,\\n\\t\\t\\tdata=message,\\n\\t\\t\\tvapid_private_key=get_manager().get_wp_private_key(application_id),\\n\\t\\t\\tvapid_claims=get_manager().get_wp_claims(application_id).copy(),\\n\\t\\t\\t**kwargs\\n\\t\\t)\\n\\t\\tresults = {\"results\": [{}]}\\n\\t\\tif not response.ok:\\n\\t\\t\\tresults[\"results\"][0][\"error\"] = response.content\\n\\t\\t\\tresults[\"results\"][0][\"original_registration_id\"] = response.content\\n\\t\\telse:\\n\\t\\t\\tresults[\"success\"] = 1\\n\\t\\treturn results\\n\\texcept WebPushException as e:\\n\\t\\traise WebPushError(e.message)\\n'"}, {"func_args": {"source": "'\"\"\"\\nWindows Notification Service\\n\\nDocumentation is available on the Windows Dev Center:\\nhttps://msdn.microsoft.com/en-us/windows/uwp/controls-and-patterns/tiles-and-notifications-windows-push-notification-services--wns--overview\\n\"\"\"\\n\\nimport json\\nimport xml.etree.ElementTree as ET\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import HTTPError, Request, urlencode, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import NotificationError\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass WNSError(NotificationError):\\n\\tpass\\n\\n\\nclass WNSAuthenticationError(WNSError):\\n\\tpass\\n\\n\\nclass WNSNotificationResponseError(WNSError):\\n\\tpass\\n\\n\\ndef _wns_authenticate(scope=\"notify.windows.com\", application_id=None):\\n\\t\"\"\"\\n\\tRequests an Access token for WNS communication.\\n\\n\\t:return: dict: {\\'access_token\\': <str>, \\'expires_in\\': <int>, \\'token_type\\': \\'bearer\\'}\\n\\t\"\"\"\\n\\tclient_id = get_manager().get_wns_package_security_id(application_id)\\n\\tclient_secret = get_manager().get_wns_secret_key(application_id)\\n\\tif not client_id:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_PACKAGE_SECURITY_ID\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\tif not client_secret:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_SECRET_KEY\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": \"application/x-www-form-urlencoded\",\\n\\t}\\n\\tparams = {\\n\\t\\t\"grant_type\": \"client_credentials\",\\n\\t\\t\"client_id\": client_id,\\n\\t\\t\"client_secret\": client_secret,\\n\\t\\t\"scope\": scope,\\n\\t}\\n\\tdata = urlencode(params).encode(\"utf-8\")\\n\\n\\trequest = Request(SETTINGS[\"WNS_ACCESS_URL\"], data=data, headers=headers)\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\t# One of your settings is probably jacked up.\\n\\t\\t\\t# https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh868245\\n\\t\\t\\traise WNSAuthenticationError(\"Authentication failed, check your WNS settings.\")\\n\\t\\traise err\\n\\n\\toauth_data = response.read().decode(\"utf-8\")\\n\\ttry:\\n\\t\\toauth_data = json.loads(oauth_data)\\n\\texcept Exception:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Received invalid JSON data from WNS.\")\\n\\n\\taccess_token = oauth_data.get(\"access_token\")\\n\\tif not access_token:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Access token missing from WNS response.\")\\n\\n\\treturn access_token\\n\\n\\ndef _wns_send(uri, data, wns_type=\"wns/toast\", application_id=None):\\n\\t\"\"\"\\n\\tSends a notification data and authentication to WNS.\\n\\n\\t:param uri: str: The device\\'s unique notification URI\\n\\t:param data: dict: The notification data to be sent.\\n\\t:return:\\n\\t\"\"\"\\n\\taccess_token = _wns_authenticate(application_id=application_id)\\n\\n\\tcontent_type = \"text/xml\"\\n\\tif wns_type == \"wns/raw\":\\n\\t\\tcontent_type = \"application/octet-stream\"\\n\\n\\theaders = {\\n\\t\\t# content_type is \"text/xml\" (toast/badge/tile) | \"application/octet-stream\" (raw)\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"Bearer %s\" % (access_token),\\n\\t\\t\"X-WNS-Type\": wns_type,  # wns/toast | wns/badge | wns/tile | wns/raw\\n\\t}\\n\\n\\tif type(data) is str:\\n\\t\\tdata = data.encode(\"utf-8\")\\n\\n\\trequest = Request(uri, data, headers)\\n\\n\\t# A lot of things can happen, let them know which one.\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\tmsg = \"One or more headers were specified incorrectly or conflict with another header.\"\\n\\t\\telif err.code == 401:\\n\\t\\t\\tmsg = \"The cloud service did not present a valid authentication ticket.\"\\n\\t\\telif err.code == 403:\\n\\t\\t\\tmsg = \"The cloud service is not authorized to send a notification to this URI.\"\\n\\t\\telif err.code == 404:\\n\\t\\t\\tmsg = \"The channel URI is not valid or is not recognized by WNS.\"\\n\\t\\telif err.code == 405:\\n\\t\\t\\tmsg = \"Invalid method. Only POST or DELETE is allowed.\"\\n\\t\\telif err.code == 406:\\n\\t\\t\\tmsg = \"The cloud service exceeded its throttle limit\"\\n\\t\\telif err.code == 410:\\n\\t\\t\\tmsg = \"The channel expired.\"\\n\\t\\telif err.code == 413:\\n\\t\\t\\tmsg = \"The notification payload exceeds the 500 byte limit.\"\\n\\t\\telif err.code == 500:\\n\\t\\t\\tmsg = \"An internal failure caused notification delivery to fail.\"\\n\\t\\telif err.code == 503:\\n\\t\\t\\tmsg = \"The server is currently unavailable.\"\\n\\t\\telse:\\n\\t\\t\\traise err\\n\\t\\traise WNSNotificationResponseError(\"HTTP %i: %s\" % (err.code, msg))\\n\\n\\treturn response.read().decode(\"utf-8\")\\n\\n\\ndef _wns_prepare_toast(data, **kwargs):\\n\\t\"\"\"\\n\\tCreates the xml tree for a `toast` notification\\n\\n\\t:param data: dict: The notification data to be converted to an xml tree.\\n\\n\\t{\\n\\t\\t\"text\": [\"Title text\", \"Message Text\", \"Another message!\"],\\n\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t}\\n\\n\\t:return: str\\n\\t\"\"\"\\n\\troot = ET.Element(\"toast\")\\n\\tvisual = ET.SubElement(root, \"visual\")\\n\\tbinding = ET.SubElement(visual, \"binding\")\\n\\tbinding.attrib[\"template\"] = kwargs.pop(\"template\", \"ToastText01\")\\n\\tif \"text\" in data:\\n\\t\\tfor count, item in enumerate(data[\"text\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"text\")\\n\\t\\t\\telem.text = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\tif \"image\" in data:\\n\\t\\tfor count, item in enumerate(data[\"image\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"img\")\\n\\t\\t\\telem.attrib[\"src\"] = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\treturn ET.tostring(root)\\n\\n\\ndef wns_send_message(\\n\\turi, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a notification request to WNS.\\n\\tThere are four notification types that WNS can send: toast, tile, badge and raw.\\n\\tToast, tile, and badge can all be customized to use different\\n\\ttemplates/icons/sounds/launch params/etc.\\n\\tSee docs for more information:\\n\\thttps://msdn.microsoft.com/en-us/library/windows/apps/br212853.aspx\\n\\n\\tThere are multiple ways to input notification data:\\n\\n\\t1. The simplest and least custom notification to send is to just pass a string\\n\\tto `message`. This will create a toast notification with one text element. e.g.:\\n\\t\\t\"This is my notification title\"\\n\\n\\t2. You can also pass a dictionary to `message`: it can only contain one or both\\n\\tkeys: [\"text\", \"image\"]. The value of each key must be a list with the text and\\n\\tsrc respectively. e.g.:\\n\\t\\t{\\n\\t\\t\\t\"text\": [\"text1\", \"text2\"],\\n\\t\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t\\t}\\n\\n\\t3. Passing a dictionary to `xml_data` will create one of three types of\\n\\tnotifications depending on the dictionary data (toast, tile, badge).\\n\\tSee `dict_to_xml_schema` docs for more information on dictionary formatting.\\n\\n\\t4. Passing a value to `raw_data` will create a `raw` notification and send the\\n\\tinput data as is.\\n\\n\\t:param uri: str: The device\\'s unique notification uri.\\n\\t:param message: str|dict: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\t# Create a simple toast notification\\n\\tif message:\\n\\t\\twns_type = \"wns/toast\"\\n\\t\\tif isinstance(message, str):\\n\\t\\t\\tmessage = {\\n\\t\\t\\t\\t\"text\": [message, ],\\n\\t\\t\\t}\\n\\t\\tprepared_data = _wns_prepare_toast(data=message, **kwargs)\\n\\t# Create a toast/tile/badge notification from a dictionary\\n\\telif xml_data:\\n\\t\\txml = dict_to_xml_schema(xml_data)\\n\\t\\twns_type = \"wns/%s\" % xml.tag\\n\\t\\tprepared_data = ET.tostring(xml)\\n\\t# Create a raw notification\\n\\telif raw_data:\\n\\t\\twns_type = \"wns/raw\"\\n\\t\\tprepared_data = raw_data\\n\\telse:\\n\\t\\traise TypeError(\\n\\t\\t\\t\"At least one of the following parameters must be set:\"\\n\\t\\t\\t\"`message`, `xml_data`, `raw_data`\"\\n\\t\\t)\\n\\n\\treturn _wns_send(\\n\\t\\turi=uri, data=prepared_data, wns_type=wns_type, application_id=application_id\\n\\t)\\n\\n\\ndef wns_send_bulk_message(\\n\\turi_list, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tWNS doesn\\'t support bulk notification, so we loop through each uri.\\n\\n\\t:param uri_list: list: A list of uris the notification will be sent to.\\n\\t:param message: str: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\tres = []\\n\\tif uri_list:\\n\\t\\tfor uri in uri_list:\\n\\t\\t\\tr = wns_send_message(\\n\\t\\t\\t\\turi=uri, message=message, xml_data=xml_data,\\n\\t\\t\\t\\traw_data=raw_data, application_id=application_id, **kwargs\\n\\t\\t\\t)\\n\\t\\t\\tres.append(r)\\n\\treturn res\\n\\n\\ndef dict_to_xml_schema(data):\\n\\t\"\"\"\\n\\tInput a dictionary to be converted to xml. There should be only one key at\\n\\tthe top level. The value must be a dict with (required) `children` key and\\n\\t(optional) `attrs` key. This will be called the `sub-element dictionary`.\\n\\n\\tThe `attrs` value must be a dictionary; each value will be added to the\\n\\telement\\'s xml tag as attributes. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\n\\twould result in:\\n\\t\\t<example key1=\"value1\" key2=\"value2\"></example>\\n\\n\\tIf the value is a dict it must contain one or more keys which will be used\\n\\tas the sub-element names. Each sub-element must have a value of a sub-element\\n\\tdictionary(see above) or a list of sub-element dictionaries.\\n\\tIf the value is not a dict, it will be the value of the element.\\n\\tIf the value is a list, multiple elements of the same tag will be created\\n\\tfrom each sub-element dict in the list.\\n\\n\\t:param data: dict: Used to create an XML tree. e.g.:\\n\\t\\texample_data = {\\n\\t\\t\\t\"toast\": {\\n\\t\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\\t\"launch\": \"param\",\\n\\t\\t\\t\\t\\t\"duration\": \"short\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\"visual\": {\\n\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\"binding\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"template\": \"ToastText01\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"text\": [\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"1\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text1\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"2\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text2\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor key, value in data.items():\\n\\t\\troot = _add_element_attrs(ET.Element(key), value.get(\"attrs\", {}))\\n\\t\\tchildren = value.get(\"children\", None)\\n\\t\\tif isinstance(children, dict):\\n\\t\\t\\t_add_sub_elements_from_dict(root, children)\\n\\t\\treturn root\\n\\n\\ndef _add_sub_elements_from_dict(parent, sub_dict):\\n\\t\"\"\"\\n\\tAdd SubElements to the parent element.\\n\\n\\t:param parent: ElementTree.Element: The parent element for the newly created SubElement.\\n\\t:param sub_dict: dict: Used to create a new SubElement. See `dict_to_xml_schema`\\n\\tmethod docstring for more information. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\t\"\"\"\\n\\tfor key, value in sub_dict.items():\\n\\t\\tif isinstance(value, list):\\n\\t\\t\\tfor repeated_element in value:\\n\\t\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t\\t_add_element_attrs(sub_element, repeated_element.get(\"attrs\", {}))\\n\\t\\t\\t\\tchildren = repeated_element.get(\"children\", None)\\n\\t\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\t\\tsub_element.text = children\\n\\t\\telse:\\n\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t_add_element_attrs(sub_element, value.get(\"attrs\", {}))\\n\\t\\t\\tchildren = value.get(\"children\", None)\\n\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\tsub_element.text = children\\n\\n\\ndef _add_element_attrs(elem, attrs):\\n\\t\"\"\"\\n\\tAdd attributes to the given element.\\n\\n\\t:param elem: ElementTree.Element: The element the attributes are being added to.\\n\\t:param attrs: dict: A dictionary of attributes. e.g.:\\n\\t\\t{\"attribute1\": \"value\", \"attribute2\": \"another\"}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor attr, value in attrs.items():\\n\\t\\telem.attrib[attr] = value\\n\\treturn elem\\n'"}, "return_value": "'\"\"\"\\nWindows Notification Service\\n\\nDocumentation is available on the Windows Dev Center:\\nhttps://msdn.microsoft.com/en-us/windows/uwp/controls-and-patterns/tiles-and-notifications-windows-push-notification-services--wns--overview\\n\"\"\"\\n\\nimport json\\nimport xml.etree.ElementTree as ET\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import HTTPError, Request, urlencode, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import NotificationError\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass WNSError(NotificationError):\\n\\tpass\\n\\n\\nclass WNSAuthenticationError(WNSError):\\n\\tpass\\n\\n\\nclass WNSNotificationResponseError(WNSError):\\n\\tpass\\n\\n\\ndef _wns_authenticate(scope=\"notify.windows.com\", application_id=None):\\n\\t\"\"\"\\n\\tRequests an Access token for WNS communication.\\n\\n\\t:return: dict: {\\'access_token\\': <str>, \\'expires_in\\': <int>, \\'token_type\\': \\'bearer\\'}\\n\\t\"\"\"\\n\\tclient_id = get_manager().get_wns_package_security_id(application_id)\\n\\tclient_secret = get_manager().get_wns_secret_key(application_id)\\n\\tif not client_id:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_PACKAGE_SECURITY_ID\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\tif not client_secret:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_SECRET_KEY\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": \"application/x-www-form-urlencoded\",\\n\\t}\\n\\tparams = {\\n\\t\\t\"grant_type\": \"client_credentials\",\\n\\t\\t\"client_id\": client_id,\\n\\t\\t\"client_secret\": client_secret,\\n\\t\\t\"scope\": scope,\\n\\t}\\n\\tdata = urlencode(params).encode(\"utf-8\")\\n\\n\\trequest = Request(SETTINGS[\"WNS_ACCESS_URL\"], data=data, headers=headers)\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\t# One of your settings is probably jacked up.\\n\\t\\t\\t# https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh868245\\n\\t\\t\\traise WNSAuthenticationError(\"Authentication failed, check your WNS settings.\")\\n\\t\\traise err\\n\\n\\toauth_data = response.read().decode(\"utf-8\")\\n\\ttry:\\n\\t\\toauth_data = json.loads(oauth_data)\\n\\texcept Exception:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Received invalid JSON data from WNS.\")\\n\\n\\taccess_token = oauth_data.get(\"access_token\")\\n\\tif not access_token:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Access token missing from WNS response.\")\\n\\n\\treturn access_token\\n\\n\\ndef _wns_send(uri, data, wns_type=\"wns/toast\", application_id=None):\\n\\t\"\"\"\\n\\tSends a notification data and authentication to WNS.\\n\\n\\t:param uri: str: The device\\'s unique notification URI\\n\\t:param data: dict: The notification data to be sent.\\n\\t:return:\\n\\t\"\"\"\\n\\taccess_token = _wns_authenticate(application_id=application_id)\\n\\n\\tcontent_type = \"text/xml\"\\n\\tif wns_type == \"wns/raw\":\\n\\t\\tcontent_type = \"application/octet-stream\"\\n\\n\\theaders = {\\n\\t\\t# content_type is \"text/xml\" (toast/badge/tile) | \"application/octet-stream\" (raw)\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"Bearer %s\" % (access_token),\\n\\t\\t\"X-WNS-Type\": wns_type,  # wns/toast | wns/badge | wns/tile | wns/raw\\n\\t}\\n\\n\\tif type(data) is str:\\n\\t\\tdata = data.encode(\"utf-8\")\\n\\n\\trequest = Request(uri, data, headers)\\n\\n\\t# A lot of things can happen, let them know which one.\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\tmsg = \"One or more headers were specified incorrectly or conflict with another header.\"\\n\\t\\telif err.code == 401:\\n\\t\\t\\tmsg = \"The cloud service did not present a valid authentication ticket.\"\\n\\t\\telif err.code == 403:\\n\\t\\t\\tmsg = \"The cloud service is not authorized to send a notification to this URI.\"\\n\\t\\telif err.code == 404:\\n\\t\\t\\tmsg = \"The channel URI is not valid or is not recognized by WNS.\"\\n\\t\\telif err.code == 405:\\n\\t\\t\\tmsg = \"Invalid method. Only POST or DELETE is allowed.\"\\n\\t\\telif err.code == 406:\\n\\t\\t\\tmsg = \"The cloud service exceeded its throttle limit\"\\n\\t\\telif err.code == 410:\\n\\t\\t\\tmsg = \"The channel expired.\"\\n\\t\\telif err.code == 413:\\n\\t\\t\\tmsg = \"The notification payload exceeds the 500 byte limit.\"\\n\\t\\telif err.code == 500:\\n\\t\\t\\tmsg = \"An internal failure caused notification delivery to fail.\"\\n\\t\\telif err.code == 503:\\n\\t\\t\\tmsg = \"The server is currently unavailable.\"\\n\\t\\telse:\\n\\t\\t\\traise err\\n\\t\\traise WNSNotificationResponseError(\"HTTP %i: %s\" % (err.code, msg))\\n\\n\\treturn response.read().decode(\"utf-8\")\\n\\n\\ndef _wns_prepare_toast(data, **kwargs):\\n\\t\"\"\"\\n\\tCreates the xml tree for a `toast` notification\\n\\n\\t:param data: dict: The notification data to be converted to an xml tree.\\n\\n\\t{\\n\\t\\t\"text\": [\"Title text\", \"Message Text\", \"Another message!\"],\\n\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t}\\n\\n\\t:return: str\\n\\t\"\"\"\\n\\troot = ET.Element(\"toast\")\\n\\tvisual = ET.SubElement(root, \"visual\")\\n\\tbinding = ET.SubElement(visual, \"binding\")\\n\\tbinding.attrib[\"template\"] = kwargs.pop(\"template\", \"ToastText01\")\\n\\tif \"text\" in data:\\n\\t\\tfor count, item in enumerate(data[\"text\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"text\")\\n\\t\\t\\telem.text = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\tif \"image\" in data:\\n\\t\\tfor count, item in enumerate(data[\"image\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"img\")\\n\\t\\t\\telem.attrib[\"src\"] = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\treturn ET.tostring(root)\\n\\n\\ndef wns_send_message(\\n\\turi, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a notification request to WNS.\\n\\tThere are four notification types that WNS can send: toast, tile, badge and raw.\\n\\tToast, tile, and badge can all be customized to use different\\n\\ttemplates/icons/sounds/launch params/etc.\\n\\tSee docs for more information:\\n\\thttps://msdn.microsoft.com/en-us/library/windows/apps/br212853.aspx\\n\\n\\tThere are multiple ways to input notification data:\\n\\n\\t1. The simplest and least custom notification to send is to just pass a string\\n\\tto `message`. This will create a toast notification with one text element. e.g.:\\n\\t\\t\"This is my notification title\"\\n\\n\\t2. You can also pass a dictionary to `message`: it can only contain one or both\\n\\tkeys: [\"text\", \"image\"]. The value of each key must be a list with the text and\\n\\tsrc respectively. e.g.:\\n\\t\\t{\\n\\t\\t\\t\"text\": [\"text1\", \"text2\"],\\n\\t\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t\\t}\\n\\n\\t3. Passing a dictionary to `xml_data` will create one of three types of\\n\\tnotifications depending on the dictionary data (toast, tile, badge).\\n\\tSee `dict_to_xml_schema` docs for more information on dictionary formatting.\\n\\n\\t4. Passing a value to `raw_data` will create a `raw` notification and send the\\n\\tinput data as is.\\n\\n\\t:param uri: str: The device\\'s unique notification uri.\\n\\t:param message: str|dict: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\t# Create a simple toast notification\\n\\tif message:\\n\\t\\twns_type = \"wns/toast\"\\n\\t\\tif isinstance(message, str):\\n\\t\\t\\tmessage = {\\n\\t\\t\\t\\t\"text\": [message, ],\\n\\t\\t\\t}\\n\\t\\tprepared_data = _wns_prepare_toast(data=message, **kwargs)\\n\\t# Create a toast/tile/badge notification from a dictionary\\n\\telif xml_data:\\n\\t\\txml = dict_to_xml_schema(xml_data)\\n\\t\\twns_type = \"wns/%s\" % xml.tag\\n\\t\\tprepared_data = ET.tostring(xml)\\n\\t# Create a raw notification\\n\\telif raw_data:\\n\\t\\twns_type = \"wns/raw\"\\n\\t\\tprepared_data = raw_data\\n\\telse:\\n\\t\\traise TypeError(\\n\\t\\t\\t\"At least one of the following parameters must be set:\"\\n\\t\\t\\t\"`message`, `xml_data`, `raw_data`\"\\n\\t\\t)\\n\\n\\treturn _wns_send(\\n\\t\\turi=uri, data=prepared_data, wns_type=wns_type, application_id=application_id\\n\\t)\\n\\n\\ndef wns_send_bulk_message(\\n\\turi_list, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tWNS doesn\\'t support bulk notification, so we loop through each uri.\\n\\n\\t:param uri_list: list: A list of uris the notification will be sent to.\\n\\t:param message: str: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\tres = []\\n\\tif uri_list:\\n\\t\\tfor uri in uri_list:\\n\\t\\t\\tr = wns_send_message(\\n\\t\\t\\t\\turi=uri, message=message, xml_data=xml_data,\\n\\t\\t\\t\\traw_data=raw_data, application_id=application_id, **kwargs\\n\\t\\t\\t)\\n\\t\\t\\tres.append(r)\\n\\treturn res\\n\\n\\ndef dict_to_xml_schema(data):\\n\\t\"\"\"\\n\\tInput a dictionary to be converted to xml. There should be only one key at\\n\\tthe top level. The value must be a dict with (required) `children` key and\\n\\t(optional) `attrs` key. This will be called the `sub-element dictionary`.\\n\\n\\tThe `attrs` value must be a dictionary; each value will be added to the\\n\\telement\\'s xml tag as attributes. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\n\\twould result in:\\n\\t\\t<example key1=\"value1\" key2=\"value2\"></example>\\n\\n\\tIf the value is a dict it must contain one or more keys which will be used\\n\\tas the sub-element names. Each sub-element must have a value of a sub-element\\n\\tdictionary(see above) or a list of sub-element dictionaries.\\n\\tIf the value is not a dict, it will be the value of the element.\\n\\tIf the value is a list, multiple elements of the same tag will be created\\n\\tfrom each sub-element dict in the list.\\n\\n\\t:param data: dict: Used to create an XML tree. e.g.:\\n\\t\\texample_data = {\\n\\t\\t\\t\"toast\": {\\n\\t\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\\t\"launch\": \"param\",\\n\\t\\t\\t\\t\\t\"duration\": \"short\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\"visual\": {\\n\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\"binding\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"template\": \"ToastText01\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"text\": [\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"1\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text1\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"2\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text2\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor key, value in data.items():\\n\\t\\troot = _add_element_attrs(ET.Element(key), value.get(\"attrs\", {}))\\n\\t\\tchildren = value.get(\"children\", None)\\n\\t\\tif isinstance(children, dict):\\n\\t\\t\\t_add_sub_elements_from_dict(root, children)\\n\\t\\treturn root\\n\\n\\ndef _add_sub_elements_from_dict(parent, sub_dict):\\n\\t\"\"\"\\n\\tAdd SubElements to the parent element.\\n\\n\\t:param parent: ElementTree.Element: The parent element for the newly created SubElement.\\n\\t:param sub_dict: dict: Used to create a new SubElement. See `dict_to_xml_schema`\\n\\tmethod docstring for more information. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\t\"\"\"\\n\\tfor key, value in sub_dict.items():\\n\\t\\tif isinstance(value, list):\\n\\t\\t\\tfor repeated_element in value:\\n\\t\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t\\t_add_element_attrs(sub_element, repeated_element.get(\"attrs\", {}))\\n\\t\\t\\t\\tchildren = repeated_element.get(\"children\", None)\\n\\t\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\t\\tsub_element.text = children\\n\\t\\telse:\\n\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t_add_element_attrs(sub_element, value.get(\"attrs\", {}))\\n\\t\\t\\tchildren = value.get(\"children\", None)\\n\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\tsub_element.text = children\\n\\n\\ndef _add_element_attrs(elem, attrs):\\n\\t\"\"\"\\n\\tAdd attributes to the given element.\\n\\n\\t:param elem: ElementTree.Element: The element the attributes are being added to.\\n\\t:param attrs: dict: A dictionary of attributes. e.g.:\\n\\t\\t{\"attribute1\": \"value\", \"attribute2\": \"another\"}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor attr, value in attrs.items():\\n\\t\\telem.attrib[attr] = value\\n\\treturn elem\\n'"}, {"func_args": {"source": "'\"\"\"\\nWindows Notification Service\\n\\nDocumentation is available on the Windows Dev Center:\\nhttps://msdn.microsoft.com/en-us/windows/uwp/controls-and-patterns/tiles-and-notifications-windows-push-notification-services--wns--overview\\n\"\"\"\\n\\nimport json\\nimport xml.etree.ElementTree as ET\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import HTTPError, Request, urlencode, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import NotificationError\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass WNSError(NotificationError):\\n\\tpass\\n\\n\\nclass WNSAuthenticationError(WNSError):\\n\\tpass\\n\\n\\nclass WNSNotificationResponseError(WNSError):\\n\\tpass\\n\\n\\ndef _wns_authenticate(scope=\"notify.windows.com\", application_id=None):\\n\\t\"\"\"\\n\\tRequests an Access token for WNS communication.\\n\\n\\t:return: dict: {\\'access_token\\': <str>, \\'expires_in\\': <int>, \\'token_type\\': \\'bearer\\'}\\n\\t\"\"\"\\n\\tclient_id = get_manager().get_wns_package_security_id(application_id)\\n\\tclient_secret = get_manager().get_wns_secret_key(application_id)\\n\\tif not client_id:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_PACKAGE_SECURITY_ID\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\tif not client_secret:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_SECRET_KEY\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": \"application/x-www-form-urlencoded\",\\n\\t}\\n\\tparams = {\\n\\t\\t\"grant_type\": \"client_credentials\",\\n\\t\\t\"client_id\": client_id,\\n\\t\\t\"client_secret\": client_secret,\\n\\t\\t\"scope\": scope,\\n\\t}\\n\\tdata = urlencode(params).encode(\"utf-8\")\\n\\n\\trequest = Request(SETTINGS[\"WNS_ACCESS_URL\"], data=data, headers=headers)\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\t# One of your settings is probably jacked up.\\n\\t\\t\\t# https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh868245\\n\\t\\t\\traise WNSAuthenticationError(\"Authentication failed, check your WNS settings.\")\\n\\t\\traise err\\n\\n\\toauth_data = response.read().decode(\"utf-8\")\\n\\ttry:\\n\\t\\toauth_data = json.loads(oauth_data)\\n\\texcept Exception:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Received invalid JSON data from WNS.\")\\n\\n\\taccess_token = oauth_data.get(\"access_token\")\\n\\tif not access_token:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Access token missing from WNS response.\")\\n\\n\\treturn access_token\\n\\n\\ndef _wns_send(uri, data, wns_type=\"wns/toast\", application_id=None):\\n\\t\"\"\"\\n\\tSends a notification data and authentication to WNS.\\n\\n\\t:param uri: str: The device\\'s unique notification URI\\n\\t:param data: dict: The notification data to be sent.\\n\\t:return:\\n\\t\"\"\"\\n\\taccess_token = _wns_authenticate(application_id=application_id)\\n\\n\\tcontent_type = \"text/xml\"\\n\\tif wns_type == \"wns/raw\":\\n\\t\\tcontent_type = \"application/octet-stream\"\\n\\n\\theaders = {\\n\\t\\t# content_type is \"text/xml\" (toast/badge/tile) | \"application/octet-stream\" (raw)\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"Bearer %s\" % (access_token),\\n\\t\\t\"X-WNS-Type\": wns_type,  # wns/toast | wns/badge | wns/tile | wns/raw\\n\\t}\\n\\n\\tif type(data) is str:\\n\\t\\tdata = data.encode(\"utf-8\")\\n\\n\\trequest = Request(uri, data, headers)\\n\\n\\t# A lot of things can happen, let them know which one.\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\tmsg = \"One or more headers were specified incorrectly or conflict with another header.\"\\n\\t\\telif err.code == 401:\\n\\t\\t\\tmsg = \"The cloud service did not present a valid authentication ticket.\"\\n\\t\\telif err.code == 403:\\n\\t\\t\\tmsg = \"The cloud service is not authorized to send a notification to this URI.\"\\n\\t\\telif err.code == 404:\\n\\t\\t\\tmsg = \"The channel URI is not valid or is not recognized by WNS.\"\\n\\t\\telif err.code == 405:\\n\\t\\t\\tmsg = \"Invalid method. Only POST or DELETE is allowed.\"\\n\\t\\telif err.code == 406:\\n\\t\\t\\tmsg = \"The cloud service exceeded its throttle limit\"\\n\\t\\telif err.code == 410:\\n\\t\\t\\tmsg = \"The channel expired.\"\\n\\t\\telif err.code == 413:\\n\\t\\t\\tmsg = \"The notification payload exceeds the 500 byte limit.\"\\n\\t\\telif err.code == 500:\\n\\t\\t\\tmsg = \"An internal failure caused notification delivery to fail.\"\\n\\t\\telif err.code == 503:\\n\\t\\t\\tmsg = \"The server is currently unavailable.\"\\n\\t\\telse:\\n\\t\\t\\traise err\\n\\t\\traise WNSNotificationResponseError(\"HTTP %i: %s\" % (err.code, msg))\\n\\n\\treturn response.read().decode(\"utf-8\")\\n\\n\\ndef _wns_prepare_toast(data, **kwargs):\\n\\t\"\"\"\\n\\tCreates the xml tree for a `toast` notification\\n\\n\\t:param data: dict: The notification data to be converted to an xml tree.\\n\\n\\t{\\n\\t\\t\"text\": [\"Title text\", \"Message Text\", \"Another message!\"],\\n\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t}\\n\\n\\t:return: str\\n\\t\"\"\"\\n\\troot = ET.Element(\"toast\")\\n\\tvisual = ET.SubElement(root, \"visual\")\\n\\tbinding = ET.SubElement(visual, \"binding\")\\n\\tbinding.attrib[\"template\"] = kwargs.pop(\"template\", \"ToastText01\")\\n\\tif \"text\" in data:\\n\\t\\tfor count, item in enumerate(data[\"text\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"text\")\\n\\t\\t\\telem.text = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\tif \"image\" in data:\\n\\t\\tfor count, item in enumerate(data[\"image\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"img\")\\n\\t\\t\\telem.attrib[\"src\"] = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\treturn ET.tostring(root)\\n\\n\\ndef wns_send_message(\\n\\turi, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a notification request to WNS.\\n\\tThere are four notification types that WNS can send: toast, tile, badge and raw.\\n\\tToast, tile, and badge can all be customized to use different\\n\\ttemplates/icons/sounds/launch params/etc.\\n\\tSee docs for more information:\\n\\thttps://msdn.microsoft.com/en-us/library/windows/apps/br212853.aspx\\n\\n\\tThere are multiple ways to input notification data:\\n\\n\\t1. The simplest and least custom notification to send is to just pass a string\\n\\tto `message`. This will create a toast notification with one text element. e.g.:\\n\\t\\t\"This is my notification title\"\\n\\n\\t2. You can also pass a dictionary to `message`: it can only contain one or both\\n\\tkeys: [\"text\", \"image\"]. The value of each key must be a list with the text and\\n\\tsrc respectively. e.g.:\\n\\t\\t{\\n\\t\\t\\t\"text\": [\"text1\", \"text2\"],\\n\\t\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t\\t}\\n\\n\\t3. Passing a dictionary to `xml_data` will create one of three types of\\n\\tnotifications depending on the dictionary data (toast, tile, badge).\\n\\tSee `dict_to_xml_schema` docs for more information on dictionary formatting.\\n\\n\\t4. Passing a value to `raw_data` will create a `raw` notification and send the\\n\\tinput data as is.\\n\\n\\t:param uri: str: The device\\'s unique notification uri.\\n\\t:param message: str|dict: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\t# Create a simple toast notification\\n\\tif message:\\n\\t\\twns_type = \"wns/toast\"\\n\\t\\tif isinstance(message, str):\\n\\t\\t\\tmessage = {\\n\\t\\t\\t\\t\"text\": [message, ],\\n\\t\\t\\t}\\n\\t\\tprepared_data = _wns_prepare_toast(data=message, **kwargs)\\n\\t# Create a toast/tile/badge notification from a dictionary\\n\\telif xml_data:\\n\\t\\txml = dict_to_xml_schema(xml_data)\\n\\t\\twns_type = \"wns/%s\" % xml.tag\\n\\t\\tprepared_data = ET.tostring(xml)\\n\\t# Create a raw notification\\n\\telif raw_data:\\n\\t\\twns_type = \"wns/raw\"\\n\\t\\tprepared_data = raw_data\\n\\telse:\\n\\t\\traise TypeError(\\n\\t\\t\\t\"At least one of the following parameters must be set:\"\\n\\t\\t\\t\"`message`, `xml_data`, `raw_data`\"\\n\\t\\t)\\n\\n\\treturn _wns_send(\\n\\t\\turi=uri, data=prepared_data, wns_type=wns_type, application_id=application_id\\n\\t)\\n\\n\\ndef wns_send_bulk_message(\\n\\turi_list, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tWNS doesn\\'t support bulk notification, so we loop through each uri.\\n\\n\\t:param uri_list: list: A list of uris the notification will be sent to.\\n\\t:param message: str: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\tres = []\\n\\tif uri_list:\\n\\t\\tfor uri in uri_list:\\n\\t\\t\\tr = wns_send_message(\\n\\t\\t\\t\\turi=uri, message=message, xml_data=xml_data,\\n\\t\\t\\t\\traw_data=raw_data, application_id=application_id, **kwargs\\n\\t\\t\\t)\\n\\t\\t\\tres.append(r)\\n\\treturn res\\n\\n\\ndef dict_to_xml_schema(data):\\n\\t\"\"\"\\n\\tInput a dictionary to be converted to xml. There should be only one key at\\n\\tthe top level. The value must be a dict with (required) `children` key and\\n\\t(optional) `attrs` key. This will be called the `sub-element dictionary`.\\n\\n\\tThe `attrs` value must be a dictionary; each value will be added to the\\n\\telement\\'s xml tag as attributes. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\n\\twould result in:\\n\\t\\t<example key1=\"value1\" key2=\"value2\"></example>\\n\\n\\tIf the value is a dict it must contain one or more keys which will be used\\n\\tas the sub-element names. Each sub-element must have a value of a sub-element\\n\\tdictionary(see above) or a list of sub-element dictionaries.\\n\\tIf the value is not a dict, it will be the value of the element.\\n\\tIf the value is a list, multiple elements of the same tag will be created\\n\\tfrom each sub-element dict in the list.\\n\\n\\t:param data: dict: Used to create an XML tree. e.g.:\\n\\t\\texample_data = {\\n\\t\\t\\t\"toast\": {\\n\\t\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\\t\"launch\": \"param\",\\n\\t\\t\\t\\t\\t\"duration\": \"short\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\"visual\": {\\n\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\"binding\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"template\": \"ToastText01\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"text\": [\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"1\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text1\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"2\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text2\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor key, value in data.items():\\n\\t\\troot = _add_element_attrs(ET.Element(key), value.get(\"attrs\", {}))\\n\\t\\tchildren = value.get(\"children\", None)\\n\\t\\tif isinstance(children, dict):\\n\\t\\t\\t_add_sub_elements_from_dict(root, children)\\n\\t\\treturn root\\n\\n\\ndef _add_sub_elements_from_dict(parent, sub_dict):\\n\\t\"\"\"\\n\\tAdd SubElements to the parent element.\\n\\n\\t:param parent: ElementTree.Element: The parent element for the newly created SubElement.\\n\\t:param sub_dict: dict: Used to create a new SubElement. See `dict_to_xml_schema`\\n\\tmethod docstring for more information. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\t\"\"\"\\n\\tfor key, value in sub_dict.items():\\n\\t\\tif isinstance(value, list):\\n\\t\\t\\tfor repeated_element in value:\\n\\t\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t\\t_add_element_attrs(sub_element, repeated_element.get(\"attrs\", {}))\\n\\t\\t\\t\\tchildren = repeated_element.get(\"children\", None)\\n\\t\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\t\\tsub_element.text = children\\n\\t\\telse:\\n\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t_add_element_attrs(sub_element, value.get(\"attrs\", {}))\\n\\t\\t\\tchildren = value.get(\"children\", None)\\n\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\tsub_element.text = children\\n\\n\\ndef _add_element_attrs(elem, attrs):\\n\\t\"\"\"\\n\\tAdd attributes to the given element.\\n\\n\\t:param elem: ElementTree.Element: The element the attributes are being added to.\\n\\t:param attrs: dict: A dictionary of attributes. e.g.:\\n\\t\\t{\"attribute1\": \"value\", \"attribute2\": \"another\"}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor attr, value in attrs.items():\\n\\t\\telem.attrib[attr] = value\\n\\treturn elem\\n'"}, "return_value": "'\"\"\"\\nWindows Notification Service\\n\\nDocumentation is available on the Windows Dev Center:\\nhttps://msdn.microsoft.com/en-us/windows/uwp/controls-and-patterns/tiles-and-notifications-windows-push-notification-services--wns--overview\\n\"\"\"\\n\\nimport json\\nimport xml.etree.ElementTree as ET\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\n\\nfrom .compat import HTTPError, Request, urlencode, urlopen\\nfrom .conf import get_manager\\nfrom .exceptions import NotificationError\\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\\n\\n\\nclass WNSError(NotificationError):\\n\\tpass\\n\\n\\nclass WNSAuthenticationError(WNSError):\\n\\tpass\\n\\n\\nclass WNSNotificationResponseError(WNSError):\\n\\tpass\\n\\n\\ndef _wns_authenticate(scope=\"notify.windows.com\", application_id=None):\\n\\t\"\"\"\\n\\tRequests an Access token for WNS communication.\\n\\n\\t:return: dict: {\\'access_token\\': <str>, \\'expires_in\\': <int>, \\'token_type\\': \\'bearer\\'}\\n\\t\"\"\"\\n\\tclient_id = get_manager().get_wns_package_security_id(application_id)\\n\\tclient_secret = get_manager().get_wns_secret_key(application_id)\\n\\tif not client_id:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_PACKAGE_SECURITY_ID\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\tif not client_secret:\\n\\t\\traise ImproperlyConfigured(\\n\\t\\t\\t\\'You need to set PUSH_NOTIFICATIONS_SETTINGS[\"WNS_SECRET_KEY\"] to use WNS.\\'\\n\\t\\t)\\n\\n\\theaders = {\\n\\t\\t\"Content-Type\": \"application/x-www-form-urlencoded\",\\n\\t}\\n\\tparams = {\\n\\t\\t\"grant_type\": \"client_credentials\",\\n\\t\\t\"client_id\": client_id,\\n\\t\\t\"client_secret\": client_secret,\\n\\t\\t\"scope\": scope,\\n\\t}\\n\\tdata = urlencode(params).encode(\"utf-8\")\\n\\n\\trequest = Request(SETTINGS[\"WNS_ACCESS_URL\"], data=data, headers=headers)\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\t# One of your settings is probably jacked up.\\n\\t\\t\\t# https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh868245\\n\\t\\t\\traise WNSAuthenticationError(\"Authentication failed, check your WNS settings.\")\\n\\t\\traise err\\n\\n\\toauth_data = response.read().decode(\"utf-8\")\\n\\ttry:\\n\\t\\toauth_data = json.loads(oauth_data)\\n\\texcept Exception:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Received invalid JSON data from WNS.\")\\n\\n\\taccess_token = oauth_data.get(\"access_token\")\\n\\tif not access_token:\\n\\t\\t# Upstream WNS issue\\n\\t\\traise WNSAuthenticationError(\"Access token missing from WNS response.\")\\n\\n\\treturn access_token\\n\\n\\ndef _wns_send(uri, data, wns_type=\"wns/toast\", application_id=None):\\n\\t\"\"\"\\n\\tSends a notification data and authentication to WNS.\\n\\n\\t:param uri: str: The device\\'s unique notification URI\\n\\t:param data: dict: The notification data to be sent.\\n\\t:return:\\n\\t\"\"\"\\n\\taccess_token = _wns_authenticate(application_id=application_id)\\n\\n\\tcontent_type = \"text/xml\"\\n\\tif wns_type == \"wns/raw\":\\n\\t\\tcontent_type = \"application/octet-stream\"\\n\\n\\theaders = {\\n\\t\\t# content_type is \"text/xml\" (toast/badge/tile) | \"application/octet-stream\" (raw)\\n\\t\\t\"Content-Type\": content_type,\\n\\t\\t\"Authorization\": \"Bearer %s\" % (access_token),\\n\\t\\t\"X-WNS-Type\": wns_type,  # wns/toast | wns/badge | wns/tile | wns/raw\\n\\t}\\n\\n\\tif type(data) is str:\\n\\t\\tdata = data.encode(\"utf-8\")\\n\\n\\trequest = Request(uri, data, headers)\\n\\n\\t# A lot of things can happen, let them know which one.\\n\\ttry:\\n\\t\\tresponse = urlopen(request)\\n\\texcept HTTPError as err:\\n\\t\\tif err.code == 400:\\n\\t\\t\\tmsg = \"One or more headers were specified incorrectly or conflict with another header.\"\\n\\t\\telif err.code == 401:\\n\\t\\t\\tmsg = \"The cloud service did not present a valid authentication ticket.\"\\n\\t\\telif err.code == 403:\\n\\t\\t\\tmsg = \"The cloud service is not authorized to send a notification to this URI.\"\\n\\t\\telif err.code == 404:\\n\\t\\t\\tmsg = \"The channel URI is not valid or is not recognized by WNS.\"\\n\\t\\telif err.code == 405:\\n\\t\\t\\tmsg = \"Invalid method. Only POST or DELETE is allowed.\"\\n\\t\\telif err.code == 406:\\n\\t\\t\\tmsg = \"The cloud service exceeded its throttle limit\"\\n\\t\\telif err.code == 410:\\n\\t\\t\\tmsg = \"The channel expired.\"\\n\\t\\telif err.code == 413:\\n\\t\\t\\tmsg = \"The notification payload exceeds the 500 byte limit.\"\\n\\t\\telif err.code == 500:\\n\\t\\t\\tmsg = \"An internal failure caused notification delivery to fail.\"\\n\\t\\telif err.code == 503:\\n\\t\\t\\tmsg = \"The server is currently unavailable.\"\\n\\t\\telse:\\n\\t\\t\\traise err\\n\\t\\traise WNSNotificationResponseError(\"HTTP %i: %s\" % (err.code, msg))\\n\\n\\treturn response.read().decode(\"utf-8\")\\n\\n\\ndef _wns_prepare_toast(data, **kwargs):\\n\\t\"\"\"\\n\\tCreates the xml tree for a `toast` notification\\n\\n\\t:param data: dict: The notification data to be converted to an xml tree.\\n\\n\\t{\\n\\t\\t\"text\": [\"Title text\", \"Message Text\", \"Another message!\"],\\n\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t}\\n\\n\\t:return: str\\n\\t\"\"\"\\n\\troot = ET.Element(\"toast\")\\n\\tvisual = ET.SubElement(root, \"visual\")\\n\\tbinding = ET.SubElement(visual, \"binding\")\\n\\tbinding.attrib[\"template\"] = kwargs.pop(\"template\", \"ToastText01\")\\n\\tif \"text\" in data:\\n\\t\\tfor count, item in enumerate(data[\"text\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"text\")\\n\\t\\t\\telem.text = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\tif \"image\" in data:\\n\\t\\tfor count, item in enumerate(data[\"image\"], start=1):\\n\\t\\t\\telem = ET.SubElement(binding, \"img\")\\n\\t\\t\\telem.attrib[\"src\"] = item\\n\\t\\t\\telem.attrib[\"id\"] = str(count)\\n\\treturn ET.tostring(root)\\n\\n\\ndef wns_send_message(\\n\\turi, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tSends a notification request to WNS.\\n\\tThere are four notification types that WNS can send: toast, tile, badge and raw.\\n\\tToast, tile, and badge can all be customized to use different\\n\\ttemplates/icons/sounds/launch params/etc.\\n\\tSee docs for more information:\\n\\thttps://msdn.microsoft.com/en-us/library/windows/apps/br212853.aspx\\n\\n\\tThere are multiple ways to input notification data:\\n\\n\\t1. The simplest and least custom notification to send is to just pass a string\\n\\tto `message`. This will create a toast notification with one text element. e.g.:\\n\\t\\t\"This is my notification title\"\\n\\n\\t2. You can also pass a dictionary to `message`: it can only contain one or both\\n\\tkeys: [\"text\", \"image\"]. The value of each key must be a list with the text and\\n\\tsrc respectively. e.g.:\\n\\t\\t{\\n\\t\\t\\t\"text\": [\"text1\", \"text2\"],\\n\\t\\t\\t\"image\": [\"src1\", \"src2\"],\\n\\t\\t}\\n\\n\\t3. Passing a dictionary to `xml_data` will create one of three types of\\n\\tnotifications depending on the dictionary data (toast, tile, badge).\\n\\tSee `dict_to_xml_schema` docs for more information on dictionary formatting.\\n\\n\\t4. Passing a value to `raw_data` will create a `raw` notification and send the\\n\\tinput data as is.\\n\\n\\t:param uri: str: The device\\'s unique notification uri.\\n\\t:param message: str|dict: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\t# Create a simple toast notification\\n\\tif message:\\n\\t\\twns_type = \"wns/toast\"\\n\\t\\tif isinstance(message, str):\\n\\t\\t\\tmessage = {\\n\\t\\t\\t\\t\"text\": [message, ],\\n\\t\\t\\t}\\n\\t\\tprepared_data = _wns_prepare_toast(data=message, **kwargs)\\n\\t# Create a toast/tile/badge notification from a dictionary\\n\\telif xml_data:\\n\\t\\txml = dict_to_xml_schema(xml_data)\\n\\t\\twns_type = \"wns/%s\" % xml.tag\\n\\t\\tprepared_data = ET.tostring(xml)\\n\\t# Create a raw notification\\n\\telif raw_data:\\n\\t\\twns_type = \"wns/raw\"\\n\\t\\tprepared_data = raw_data\\n\\telse:\\n\\t\\traise TypeError(\\n\\t\\t\\t\"At least one of the following parameters must be set:\"\\n\\t\\t\\t\"`message`, `xml_data`, `raw_data`\"\\n\\t\\t)\\n\\n\\treturn _wns_send(\\n\\t\\turi=uri, data=prepared_data, wns_type=wns_type, application_id=application_id\\n\\t)\\n\\n\\ndef wns_send_bulk_message(\\n\\turi_list, message=None, xml_data=None, raw_data=None, application_id=None, **kwargs\\n):\\n\\t\"\"\"\\n\\tWNS doesn\\'t support bulk notification, so we loop through each uri.\\n\\n\\t:param uri_list: list: A list of uris the notification will be sent to.\\n\\t:param message: str: The notification data to be sent.\\n\\t:param xml_data: dict: A dictionary containing data to be converted to an xml tree.\\n\\t:param raw_data: str: Data to be sent via a `raw` notification.\\n\\t\"\"\"\\n\\tres = []\\n\\tif uri_list:\\n\\t\\tfor uri in uri_list:\\n\\t\\t\\tr = wns_send_message(\\n\\t\\t\\t\\turi=uri, message=message, xml_data=xml_data,\\n\\t\\t\\t\\traw_data=raw_data, application_id=application_id, **kwargs\\n\\t\\t\\t)\\n\\t\\t\\tres.append(r)\\n\\treturn res\\n\\n\\ndef dict_to_xml_schema(data):\\n\\t\"\"\"\\n\\tInput a dictionary to be converted to xml. There should be only one key at\\n\\tthe top level. The value must be a dict with (required) `children` key and\\n\\t(optional) `attrs` key. This will be called the `sub-element dictionary`.\\n\\n\\tThe `attrs` value must be a dictionary; each value will be added to the\\n\\telement\\'s xml tag as attributes. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\n\\twould result in:\\n\\t\\t<example key1=\"value1\" key2=\"value2\"></example>\\n\\n\\tIf the value is a dict it must contain one or more keys which will be used\\n\\tas the sub-element names. Each sub-element must have a value of a sub-element\\n\\tdictionary(see above) or a list of sub-element dictionaries.\\n\\tIf the value is not a dict, it will be the value of the element.\\n\\tIf the value is a list, multiple elements of the same tag will be created\\n\\tfrom each sub-element dict in the list.\\n\\n\\t:param data: dict: Used to create an XML tree. e.g.:\\n\\t\\texample_data = {\\n\\t\\t\\t\"toast\": {\\n\\t\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\\t\"launch\": \"param\",\\n\\t\\t\\t\\t\\t\"duration\": \"short\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\"visual\": {\\n\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\"binding\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"template\": \"ToastText01\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\"children\": {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"text\": [\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"1\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text1\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"attrs\": {\"id\": \"2\"},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"children\": \"text2\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor key, value in data.items():\\n\\t\\troot = _add_element_attrs(ET.Element(key), value.get(\"attrs\", {}))\\n\\t\\tchildren = value.get(\"children\", None)\\n\\t\\tif isinstance(children, dict):\\n\\t\\t\\t_add_sub_elements_from_dict(root, children)\\n\\t\\treturn root\\n\\n\\ndef _add_sub_elements_from_dict(parent, sub_dict):\\n\\t\"\"\"\\n\\tAdd SubElements to the parent element.\\n\\n\\t:param parent: ElementTree.Element: The parent element for the newly created SubElement.\\n\\t:param sub_dict: dict: Used to create a new SubElement. See `dict_to_xml_schema`\\n\\tmethod docstring for more information. e.g.:\\n\\t\\t{\"example\": {\\n\\t\\t\\t\"attrs\": {\\n\\t\\t\\t\\t\"key1\": \"value1\",\\n\\t\\t\\t\\t...\\n\\t\\t\\t},\\n\\t\\t\\t...\\n\\t\\t}}\\n\\t\"\"\"\\n\\tfor key, value in sub_dict.items():\\n\\t\\tif isinstance(value, list):\\n\\t\\t\\tfor repeated_element in value:\\n\\t\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t\\t_add_element_attrs(sub_element, repeated_element.get(\"attrs\", {}))\\n\\t\\t\\t\\tchildren = repeated_element.get(\"children\", None)\\n\\t\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\t\\tsub_element.text = children\\n\\t\\telse:\\n\\t\\t\\tsub_element = ET.SubElement(parent, key)\\n\\t\\t\\t_add_element_attrs(sub_element, value.get(\"attrs\", {}))\\n\\t\\t\\tchildren = value.get(\"children\", None)\\n\\t\\t\\tif isinstance(children, dict):\\n\\t\\t\\t\\t_add_sub_elements_from_dict(sub_element, children)\\n\\t\\t\\telif isinstance(children, str):\\n\\t\\t\\t\\tsub_element.text = children\\n\\n\\ndef _add_element_attrs(elem, attrs):\\n\\t\"\"\"\\n\\tAdd attributes to the given element.\\n\\n\\t:param elem: ElementTree.Element: The element the attributes are being added to.\\n\\t:param attrs: dict: A dictionary of attributes. e.g.:\\n\\t\\t{\"attribute1\": \"value\", \"attribute2\": \"another\"}\\n\\t:return: ElementTree.Element\\n\\t\"\"\"\\n\\tfor attr, value in attrs.items():\\n\\t\\telem.attrib[attr] = value\\n\\treturn elem\\n'"}]}, "rate": {"line": 21, "args": [{"func_args": {"hit": "3", "num": "5"}, "return_value": "'0.6'"}, {"func_args": {"hit": "0", "num": "0"}, "return_value": "'1'"}, {"func_args": {"hit": "36", "num": "98"}, "return_value": "'0.3673'"}, {"func_args": {"hit": "8", "num": "62"}, "return_value": "'0.129'"}, {"func_args": {"hit": "0", "num": "0"}, "return_value": "'1'"}, {"func_args": {"hit": "0", "num": "0"}, "return_value": "'1'"}, {"func_args": {"hit": "94", "num": "124"}, "return_value": "'0.7581'"}, {"func_args": {"hit": "58", "num": "76"}, "return_value": "'0.7632'"}, {"func_args": {"hit": "54", "num": "57"}, "return_value": "'0.9474'"}, {"func_args": {"hit": "17", "num": "20"}, "return_value": "'0.85'"}, {"func_args": {"hit": "3", "num": "3"}, "return_value": "'1'"}, {"func_args": {"hit": "0", "num": "0"}, "return_value": "'1'"}, {"func_args": {"hit": "11", "num": "11"}, "return_value": "'1'"}, {"func_args": {"hit": "2", "num": "2"}, "return_value": "'1'"}, {"func_args": {"hit": "126", "num": "161"}, "return_value": "'0.7826'"}, {"func_args": {"hit": "33", "num": "44"}, "return_value": "'0.75'"}, {"func_args": {"hit": "3", "num": "3"}, "return_value": "'1'"}, {"func_args": {"hit": "2", "num": "2"}, "return_value": "'1'"}, {"func_args": {"hit": "27", "num": "42"}, "return_value": "'0.6429'"}, {"func_args": {"hit": "12", "num": "16"}, "return_value": "'0.75'"}, {"func_args": {"hit": "62", "num": "89"}, "return_value": "'0.6966'"}, {"func_args": {"hit": "9", "num": "14"}, "return_value": "'0.6429'"}, {"func_args": {"hit": "14", "num": "14"}, "return_value": "'1'"}, {"func_args": {"hit": "12", "num": "12"}, "return_value": "'1'"}, {"func_args": {"hit": "44", "num": "64"}, "return_value": "'0.6875'"}, {"func_args": {"hit": "13", "num": "24"}, "return_value": "'0.5417'"}, {"func_args": {"hit": "78", "num": "91"}, "return_value": "'0.8571'"}, {"func_args": {"hit": "44", "num": "50"}, "return_value": "'0.88'"}, {"func_args": {"hit": "6", "num": "6"}, "return_value": "'1'"}, {"func_args": {"hit": "2", "num": "2"}, "return_value": "'1'"}, {"func_args": {"hit": "4", "num": "4"}, "return_value": "'1'"}, {"func_args": {"hit": "2", "num": "2"}, "return_value": "'1'"}, {"func_args": {"hit": "6", "num": "6"}, "return_value": "'1'"}, {"func_args": {"hit": "2", "num": "2"}, "return_value": "'1'"}, {"func_args": {"hit": "5", "num": "5"}, "return_value": "'1'"}, {"func_args": {"hit": "2", "num": "2"}, "return_value": "'1'"}, {"func_args": {"hit": "5", "num": "5"}, "return_value": "'1'"}, {"func_args": {"hit": "2", "num": "2"}, "return_value": "'1'"}, {"func_args": {"hit": "5", "num": "5"}, "return_value": "'1'"}, {"func_args": {"hit": "2", "num": "2"}, "return_value": "'1'"}, {"func_args": {"hit": "5", "num": "5"}, "return_value": "'1'"}, {"func_args": {"hit": "2", "num": "2"}, "return_value": "'1'"}, {"func_args": {"hit": "4", "num": "4"}, "return_value": "'1'"}, {"func_args": {"hit": "2", "num": "2"}, "return_value": "'1'"}, {"func_args": {"hit": "4", "num": "4"}, "return_value": "'1'"}, {"func_args": {"hit": "2", "num": "2"}, "return_value": "'1'"}, {"func_args": {"hit": "0", "num": "0"}, "return_value": "'1'"}, {"func_args": {"hit": "0", "num": "0"}, "return_value": "'1'"}, {"func_args": {"hit": "99", "num": "123"}, "return_value": "'0.8049'"}, {"func_args": {"hit": "51", "num": "64"}, "return_value": "'0.7969'"}, {"func_args": {"hit": "23", "num": "24"}, "return_value": "'0.9583'"}, {"func_args": {"hit": "1", "num": "2"}, "return_value": "'0.5'"}, {"func_args": {"hit": "12", "num": "18"}, "return_value": "'0.6667'"}, {"func_args": {"hit": "0", "num": "2"}, "return_value": "'0'"}, {"func_args": {"hit": "64", "num": "141"}, "return_value": "'0.4539'"}, {"func_args": {"hit": "32", "num": "78"}, "return_value": "'0.4103'"}, {"func_args": {"hit": "430", "num": "638"}, "return_value": "'0.674'"}, {"func_args": {"hit": "178", "num": "314"}, "return_value": "'0.5669'"}, {"func_args": {"hit": "94", "num": "124"}, "return_value": "'0.7581'"}, {"func_args": {"hit": "58", "num": "76"}, "return_value": "'0.7632'"}, {"func_args": {"hit": "229", "num": "306"}, "return_value": "'0.7484'"}, {"func_args": {"hit": "58", "num": "78"}, "return_value": "'0.7436'"}, {"func_args": {"hit": "44", "num": "44"}, "return_value": "'1'"}, {"func_args": {"hit": "18", "num": "18"}, "return_value": "'1'"}, {"func_args": {"hit": "797", "num": "1112"}, "return_value": "'0.7167'"}, {"func_args": {"hit": "312", "num": "486"}, "return_value": "'0.642'"}], "text": "def rate(hit, num):\n    \"\"\"Return the fraction of `hit`/`num`, as a string.\"\"\"\n    if num == 0:\n        return \"1\"\n    else:\n        return \"%.4g\" % (float(hit) / num)"}}