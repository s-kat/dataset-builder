{"iterparentnodeids": {"line": 44, "args": [{"func_args": {"nodeid": "'tests/test_compose.py::test_compose'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_compose'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_compose'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_compose'"}, "return_value": "'tests/test_compose.py::test_compose'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_compose'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_compose'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_compose'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_compose'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_compose'"}, "return_value": "'tests/test_compose.py::test_compose'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_compose'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_expose'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_expose'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_expose'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_expose'"}, "return_value": "'tests/test_compose.py::test_service_parser_expose'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_expose'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_expose'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_expose'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_expose'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_expose'"}, "return_value": "'tests/test_compose.py::test_service_parser_expose'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_expose'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_command'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_command'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_command'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_command'"}, "return_value": "'tests/test_compose.py::test_service_parser_command'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_command'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_command'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_command'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_command'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_command'"}, "return_value": "'tests/test_compose.py::test_service_parser_command'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_command'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_healthcheck'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_healthcheck'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_healthcheck'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_healthcheck'"}, "return_value": "'tests/test_compose.py::test_service_parser_healthcheck'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_healthcheck'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_healthcheck'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_healthcheck'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_healthcheck'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_healthcheck'"}, "return_value": "'tests/test_compose.py::test_service_parser_healthcheck'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_healthcheck'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_healthcheck'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_healthcheck'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_healthcheck'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_healthcheck'"}, "return_value": "'tests/test_compose.py::test_invalid_service_parser_healthcheck'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_healthcheck'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_healthcheck'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_healthcheck'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_healthcheck'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_healthcheck'"}, "return_value": "'tests/test_compose.py::test_invalid_service_parser_healthcheck'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_healthcheck'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_devices'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_devices'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_devices'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_devices'"}, "return_value": "'tests/test_compose.py::test_service_parser_hostconfig_devices'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_devices'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_devices'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_devices'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_devices'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_devices'"}, "return_value": "'tests/test_compose.py::test_service_parser_hostconfig_devices'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_devices'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_restart'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_restart'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_restart'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_restart'"}, "return_value": "'tests/test_compose.py::test_service_parser_hostconfig_restart'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_restart'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_restart'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_restart'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_restart'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_restart'"}, "return_value": "'tests/test_compose.py::test_service_parser_hostconfig_restart'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_restart'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_hostconfig_restart'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_hostconfig_restart'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_hostconfig_restart'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_hostconfig_restart'"}, "return_value": "'tests/test_compose.py::test_invalid_service_parser_hostconfig_restart'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_hostconfig_restart'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_hostconfig_restart'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_hostconfig_restart'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_hostconfig_restart'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_hostconfig_restart'"}, "return_value": "'tests/test_compose.py::test_invalid_service_parser_hostconfig_restart'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_hostconfig_restart'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_parser_hostconfig_ulimits'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_parser_hostconfig_ulimits'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_parser_hostconfig_ulimits'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_parser_hostconfig_ulimits'"}, "return_value": "'tests/test_compose.py::test_parser_hostconfig_ulimits'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_parser_hostconfig_ulimits'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_parser_hostconfig_ulimits'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_parser_hostconfig_ulimits'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_parser_hostconfig_ulimits'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_parser_hostconfig_ulimits'"}, "return_value": "'tests/test_compose.py::test_parser_hostconfig_ulimits'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_parser_hostconfig_ulimits'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_logging'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_logging'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_logging'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_logging'"}, "return_value": "'tests/test_compose.py::test_service_parser_hostconfig_logging'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_logging'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_logging'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_logging'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_logging'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_logging'"}, "return_value": "'tests/test_compose.py::test_service_parser_hostconfig_logging'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_logging'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_ports'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_ports'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_ports'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_ports'"}, "return_value": "'tests/test_compose.py::test_service_parser_hostconfig_ports'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_ports'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_ports'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_ports'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_ports'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_ports'"}, "return_value": "'tests/test_compose.py::test_service_parser_hostconfig_ports'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_hostconfig_ports'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_networks'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_networks'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_networks'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_networks'"}, "return_value": "'tests/test_compose.py::test_service_parser_networks'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_networks'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_networks'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_networks'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_networks'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_networks'"}, "return_value": "'tests/test_compose.py::test_service_parser_networks'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_networks'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_volumes'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_volumes'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_volumes'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_volumes'"}, "return_value": "'tests/test_compose.py::test_service_parser_volumes'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_volumes'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_volumes'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_volumes'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_volumes'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_volumes'"}, "return_value": "'tests/test_compose.py::test_service_parser_volumes'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_service_parser_volumes'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_bind'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_bind'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_bind'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_bind'"}, "return_value": "'tests/test_compose.py::test_bind'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_bind'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_bind'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_bind'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_bind'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_bind'"}, "return_value": "'tests/test_compose.py::test_bind'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_bind'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_volumes'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_volumes'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_volumes'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_volumes'"}, "return_value": "'tests/test_compose.py::test_invalid_service_parser_volumes'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_volumes'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_volumes'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_volumes'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_volumes'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_volumes'"}, "return_value": "'tests/test_compose.py::test_invalid_service_parser_volumes'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_invalid_service_parser_volumes'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_join_create_options'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_join_create_options'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_join_create_options'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_join_create_options'"}, "return_value": "'tests/test_compose.py::test_join_create_options'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_join_create_options'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_join_create_options'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_join_create_options'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_join_create_options'"}, "return_value": "'tests/test_compose.py'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_join_create_options'"}, "return_value": "'tests/test_compose.py::test_join_create_options'"}, {"func_args": {"nodeid": "'tests/test_compose.py::test_join_create_options'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_config.py::TestGetIniConfig::test'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_config.py::TestGetIniConfig::test'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_config.py::TestGetIniConfig::test'"}, "return_value": "'tests/test_config.py'"}, {"func_args": {"nodeid": "'tests/test_config.py::TestGetIniConfig::test'"}, "return_value": "'tests/test_config.py::TestGetIniConfig'"}, {"func_args": {"nodeid": "'tests/test_config.py::TestGetIniConfig::test'"}, "return_value": "'tests/test_config.py::TestGetIniConfig::test'"}, {"func_args": {"nodeid": "'tests/test_config.py::TestGetIniConfig::test'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_config.py::TestGetIniConfig::test'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_config.py::TestGetIniConfig::test'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_config.py::TestGetIniConfig::test'"}, "return_value": "'tests/test_config.py'"}, {"func_args": {"nodeid": "'tests/test_config.py::TestGetIniConfig::test'"}, "return_value": "'tests/test_config.py::TestGetIniConfig'"}, {"func_args": {"nodeid": "'tests/test_config.py::TestGetIniConfig::test'"}, "return_value": "'tests/test_config.py::TestGetIniConfig::test'"}, {"func_args": {"nodeid": "'tests/test_config.py::TestGetIniConfig::test'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_config.py::TestCoreTelemetry::test_suppress_all_exceptions'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_config.py::TestCoreTelemetry::test_suppress_all_exceptions'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_config.py::TestCoreTelemetry::test_suppress_all_exceptions'"}, "return_value": "'tests/test_config.py'"}, {"func_args": {"nodeid": "'tests/test_config.py::TestCoreTelemetry::test_suppress_all_exceptions'"}, "return_value": "'tests/test_config.py::TestCoreTelemetry'"}, {"func_args": {"nodeid": "'tests/test_config.py::TestCoreTelemetry::test_suppress_all_exceptions'"}, "return_value": "'tests/test_config.py::TestCoreTelemetry::test_suppress_all_exceptions'"}, {"func_args": {"nodeid": "'tests/test_config.py::TestCoreTelemetry::test_suppress_all_exceptions'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_config.py::TestCoreTelemetry::test_suppress_all_exceptions'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_config.py::TestCoreTelemetry::test_suppress_all_exceptions'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_config.py::TestCoreTelemetry::test_suppress_all_exceptions'"}, "return_value": "'tests/test_config.py'"}, {"func_args": {"nodeid": "'tests/test_config.py::TestCoreTelemetry::test_suppress_all_exceptions'"}, "return_value": "'tests/test_config.py::TestCoreTelemetry'"}, {"func_args": {"nodeid": "'tests/test_config.py::TestCoreTelemetry::test_suppress_all_exceptions'"}, "return_value": "'tests/test_config.py::TestCoreTelemetry::test_suppress_all_exceptions'"}, {"func_args": {"nodeid": "'tests/test_config.py::TestCoreTelemetry::test_suppress_all_exceptions'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_connectionstr.py::test_empty_connectionstring'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_connectionstr.py::test_empty_connectionstring'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_connectionstr.py::test_empty_connectionstring'"}, "return_value": "'tests/test_connectionstr.py'"}, {"func_args": {"nodeid": "'tests/test_connectionstr.py::test_empty_connectionstring'"}, "return_value": "'tests/test_connectionstr.py::test_empty_connectionstring'"}, {"func_args": {"nodeid": "'tests/test_connectionstr.py::test_empty_connectionstring'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_connectionstr.py::test_valid_connectionstring'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_connectionstr.py::test_valid_connectionstring'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_connectionstr.py::test_valid_connectionstring'"}, "return_value": "'tests/test_connectionstr.py'"}, {"func_args": {"nodeid": "'tests/test_connectionstr.py::test_valid_connectionstring'"}, "return_value": "'tests/test_connectionstr.py::test_valid_connectionstring'"}, {"func_args": {"nodeid": "'tests/test_connectionstr.py::test_valid_connectionstring'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_connectionstr.py::test_invalid_connectionstring'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_connectionstr.py::test_invalid_connectionstring'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_connectionstr.py::test_invalid_connectionstring'"}, "return_value": "'tests/test_connectionstr.py'"}, {"func_args": {"nodeid": "'tests/test_connectionstr.py::test_invalid_connectionstring'"}, "return_value": "'tests/test_connectionstr.py::test_invalid_connectionstring'"}, {"func_args": {"nodeid": "'tests/test_connectionstr.py::test_invalid_connectionstring'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts::test_get_self_signed_certs'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts::test_get_self_signed_certs'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts::test_get_self_signed_certs'"}, "return_value": "'tests/test_edgecert.py'"}, {"func_args": {"nodeid": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts::test_get_self_signed_certs'"}, "return_value": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts'"}, {"func_args": {"nodeid": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts::test_get_self_signed_certs'"}, "return_value": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts::test_get_self_signed_certs'"}, {"func_args": {"nodeid": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts::test_get_self_signed_certs'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts::test_get_self_signed_certs'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts::test_get_self_signed_certs'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts::test_get_self_signed_certs'"}, "return_value": "'tests/test_edgecert.py'"}, {"func_args": {"nodeid": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts::test_get_self_signed_certs'"}, "return_value": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts'"}, {"func_args": {"nodeid": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts::test_get_self_signed_certs'"}, "return_value": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts::test_get_self_signed_certs'"}, {"func_args": {"nodeid": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts::test_get_self_signed_certs'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_fails'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_fails'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_fails'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_fails'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_fails'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_fails'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_fails'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_fails'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_fails'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_fails'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_fails'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_fails'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_fails'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_fails'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType::test_get_os_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_fails'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_fails'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_fails'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_fails'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_fails'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_fails'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_fails'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_fails'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_fails'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_fails'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_fails'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_fails'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_fails'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_fails'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId::test_get_local_image_sha_id_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_no_credentials_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_no_credentials_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_no_credentials_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_no_credentials_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_no_credentials_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_no_credentials_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_no_credentials_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_no_credentials_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_no_credentials_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_no_credentials_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_no_credentials_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_no_credentials_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_no_credentials_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_no_credentials_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_newer_image_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_no_newer_image_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_no_newer_image_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_no_newer_image_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_no_newer_image_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_no_newer_image_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_no_newer_image_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_no_newer_image_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_no_newer_image_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_no_newer_image_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_no_newer_image_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_no_newer_image_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_no_newer_image_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_no_newer_image_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_exists_locally_with_no_newer_image_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_no_image_exists_locally'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_no_image_exists_locally'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_no_image_exists_locally'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_no_image_exists_locally'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_no_image_exists_locally'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_no_image_exists_locally'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_no_image_exists_locally'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_no_image_exists_locally'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_no_image_exists_locally'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_no_image_exists_locally'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_no_image_exists_locally'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_no_image_exists_locally'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_no_image_exists_locally'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_image_no_image_exists_locally'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull::test_pull_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_APIError_is_raised'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_APIError_is_raised'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_APIError_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_APIError_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_APIError_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_APIError_is_raised'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_APIError_is_raised'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_APIError_is_raised'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_APIError_is_raised'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_APIError_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_APIError_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_APIError_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_APIError_is_raised'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_APIError_is_raised'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_ImageNotFound_is_raised'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_ImageNotFound_is_raised'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_ImageNotFound_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_ImageNotFound_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_ImageNotFound_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_ImageNotFound_is_raised'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_ImageNotFound_is_raised'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_ImageNotFound_is_raised'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_ImageNotFound_is_raised'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_ImageNotFound_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_ImageNotFound_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_ImageNotFound_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_ImageNotFound_is_raised'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_ImageNotFound_is_raised'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_containerError_is_raised'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_containerError_is_raised'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_containerError_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_containerError_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_containerError_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_containerError_is_raised'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_containerError_is_raised'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_containerError_is_raised'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_containerError_is_raised'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_containerError_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_containerError_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_containerError_is_raised'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_containerError_is_raised'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_raises_except_when_containerError_is_raised'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_create_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_fails_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_fails_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_fails_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_fails_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_fails_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_fails_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_fails_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_fails_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_invalid_container_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_invalid_container_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_invalid_container_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_invalid_container_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_invalid_container_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_invalid_container_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_invalid_container_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_invalid_container_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_remove_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_fails_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_fails_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_fails_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_fails_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_fails_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_fails_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_fails_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_fails_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_invalid_container_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_invalid_container_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_invalid_container_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_invalid_container_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_invalid_container_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_invalid_container_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_invalid_container_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_invalid_container_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_start_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_status_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_by_label_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_fails_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_fails_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_fails_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_fails_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_fails_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_fails_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_fails_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_fails_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_fails_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_invalid_container_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_invalid_container_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_invalid_container_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_invalid_container_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_invalid_container_raises_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_invalid_container_raises_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_invalid_container_raises_exception'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_invalid_container_raises_exception'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_invalid_container_raises_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_valid'"}, "return_value": "'tests/test_edgedockerclient.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_valid'"}, "return_value": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_valid'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps::test_stop_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_create'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_create'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_create'"}, "return_value": "'tests/test_edgedockerclient_int.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_create'"}, "return_value": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_create'"}, "return_value": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_create'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_create'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_create'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_create'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_create'"}, "return_value": "'tests/test_edgedockerclient_int.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_create'"}, "return_value": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_create'"}, "return_value": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_create'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_create'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_get_os_type'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_get_os_type'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_get_os_type'"}, "return_value": "'tests/test_edgedockerclient_int.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_get_os_type'"}, "return_value": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_get_os_type'"}, "return_value": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_get_os_type'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_get_os_type'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_get_os_type'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_get_os_type'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_get_os_type'"}, "return_value": "'tests/test_edgedockerclient_int.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_get_os_type'"}, "return_value": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_get_os_type'"}, "return_value": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_get_os_type'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_get_os_type'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_pull'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_pull'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_pull'"}, "return_value": "'tests/test_edgedockerclient_int.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_pull'"}, "return_value": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_pull'"}, "return_value": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_pull'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_pull'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_pull'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_pull'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_pull'"}, "return_value": "'tests/test_edgedockerclient_int.py'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_pull'"}, "return_value": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_pull'"}, "return_value": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_pull'"}, {"func_args": {"nodeid": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke::test_pull'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_Login_registries_fail'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_Login_registries_fail'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_Login_registries_fail'"}, "return_value": "'tests/test_edgemanager.py'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_Login_registries_fail'"}, "return_value": "'tests/test_edgemanager.py::TestEdgeManager'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_Login_registries_fail'"}, "return_value": "'tests/test_edgemanager.py::TestEdgeManager::test_Login_registries_fail'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_Login_registries_fail'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_Login_registries_fail'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_Login_registries_fail'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_Login_registries_fail'"}, "return_value": "'tests/test_edgemanager.py'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_Login_registries_fail'"}, "return_value": "'tests/test_edgemanager.py::TestEdgeManager'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_Login_registries_fail'"}, "return_value": "'tests/test_edgemanager.py::TestEdgeManager::test_Login_registries_fail'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_Login_registries_fail'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_no_registries'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_no_registries'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_no_registries'"}, "return_value": "'tests/test_edgemanager.py'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_no_registries'"}, "return_value": "'tests/test_edgemanager.py::TestEdgeManager'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_no_registries'"}, "return_value": "'tests/test_edgemanager.py::TestEdgeManager::test_no_registries'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_no_registries'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_no_registries'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_no_registries'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_no_registries'"}, "return_value": "'tests/test_edgemanager.py'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_no_registries'"}, "return_value": "'tests/test_edgemanager.py::TestEdgeManager'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_no_registries'"}, "return_value": "'tests/test_edgemanager.py::TestEdgeManager::test_no_registries'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_no_registries'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_update_module_twin'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_update_module_twin'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_update_module_twin'"}, "return_value": "'tests/test_edgemanager.py'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_update_module_twin'"}, "return_value": "'tests/test_edgemanager.py::TestEdgeManager'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_update_module_twin'"}, "return_value": "'tests/test_edgemanager.py::TestEdgeManager::test_update_module_twin'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_update_module_twin'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_update_module_twin'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_update_module_twin'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_update_module_twin'"}, "return_value": "'tests/test_edgemanager.py'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_update_module_twin'"}, "return_value": "'tests/test_edgemanager.py::TestEdgeManager'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_update_module_twin'"}, "return_value": "'tests/test_edgemanager.py::TestEdgeManager::test_update_module_twin'"}, {"func_args": {"nodeid": "'tests/test_edgemanager.py::TestEdgeManager::test_update_module_twin'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_exists_returns_false'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_exists_returns_false'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_exists_returns_false'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_exists_returns_false'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_exists_returns_false'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_exists_returns_false'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_exists_returns_false'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_exists_returns_false'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_exists_returns_false'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_exists_returns_false'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_exists_returns_false'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_exists_returns_false'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_exists_returns_false'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_exists_returns_false'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_isdir_returns_false'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_isdir_returns_false'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_isdir_returns_false'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_isdir_returns_false'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_isdir_returns_false'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_isdir_returns_false'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_isdir_returns_false'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_isdir_returns_false'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_isdir_returns_false'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_isdir_returns_false'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_isdir_returns_false'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_isdir_returns_false'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_isdir_returns_false'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_if_isdir_returns_false'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_path_is_none'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_path_is_none'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_path_is_none'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_path_is_none'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_path_is_none'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_path_is_none'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_path_is_none'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_path_is_none'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_path_is_none'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_path_is_none'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_path_is_none'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_path_is_none'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_path_is_none'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_false_path_is_none'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_true'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_true'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_true'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_true'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_true'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_true'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_true'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_true'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_true'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_true'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_true'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_true'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_true'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_dir_exists_returns_true'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_exists_returns_false'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_exists_returns_false'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_exists_returns_false'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_exists_returns_false'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_exists_returns_false'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_exists_returns_false'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_exists_returns_false'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_exists_returns_false'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_exists_returns_false'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_exists_returns_false'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_exists_returns_false'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_exists_returns_false'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_exists_returns_false'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_exists_returns_false'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_isfile_returns_false'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_isfile_returns_false'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_isfile_returns_false'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_isfile_returns_false'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_isfile_returns_false'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_isfile_returns_false'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_isfile_returns_false'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_isfile_returns_false'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_isfile_returns_false'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_isfile_returns_false'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_isfile_returns_false'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_isfile_returns_false'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_isfile_returns_false'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_if_isfile_returns_false'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_path_is_none'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_path_is_none'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_path_is_none'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_path_is_none'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_path_is_none'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_path_is_none'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_path_is_none'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_path_is_none'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_path_is_none'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_path_is_none'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_path_is_none'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_path_is_none'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_path_is_none'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_false_path_is_none'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_true'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_true'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_true'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_true'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_true'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_true'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_true'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_true'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_true'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_true'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_true'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_true'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_true'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_check_if_file_exists_returns_true'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_execute_onerror_callback'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_execute_onerror_callback'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_execute_onerror_callback'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_execute_onerror_callback'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_execute_onerror_callback'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_execute_onerror_callback'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_execute_onerror_callback'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_execute_onerror_callback'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_execute_onerror_callback'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_execute_onerror_callback'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_execute_onerror_callback'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_execute_onerror_callback'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_execute_onerror_callback'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_execute_onerror_callback'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_raises_oserror_when_rmtree_fails'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_raises_oserror_when_rmtree_fails'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_raises_oserror_when_rmtree_fails'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_raises_oserror_when_rmtree_fails'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_raises_oserror_when_rmtree_fails'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_raises_oserror_when_rmtree_fails'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_raises_oserror_when_rmtree_fails'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_raises_oserror_when_rmtree_fails'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_raises_oserror_when_rmtree_fails'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_raises_oserror_when_rmtree_fails'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_raises_oserror_when_rmtree_fails'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_raises_oserror_when_rmtree_fails'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_raises_oserror_when_rmtree_fails'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_raises_oserror_when_rmtree_fails'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_does_not_exist'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_does_not_exist'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_does_not_exist'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_does_not_exist'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_does_not_exist'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_does_not_exist'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_does_not_exist'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_does_not_exist'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_does_not_exist'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_does_not_exist'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_does_not_exist'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_does_not_exist'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_does_not_exist'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_does_not_exist'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_exists'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_exists'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_exists'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_exists'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_exists'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_exists'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_exists'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_exists'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_exists'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_exists'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_exists'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_exists'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_exists'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_delete_dir_when_dir_exists'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_raises_ioerror_when_getfqdn_raises_ioerror'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_raises_ioerror_when_getfqdn_raises_ioerror'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_raises_ioerror_when_getfqdn_raises_ioerror'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_raises_ioerror_when_getfqdn_raises_ioerror'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_raises_ioerror_when_getfqdn_raises_ioerror'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_raises_ioerror_when_getfqdn_raises_ioerror'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_raises_ioerror_when_getfqdn_raises_ioerror'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_raises_ioerror_when_getfqdn_raises_ioerror'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_raises_ioerror_when_getfqdn_raises_ioerror'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_raises_ioerror_when_getfqdn_raises_ioerror'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_raises_ioerror_when_getfqdn_raises_ioerror'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_raises_ioerror_when_getfqdn_raises_ioerror'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_raises_ioerror_when_getfqdn_raises_ioerror'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_raises_ioerror_when_getfqdn_raises_ioerror'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_valid'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_valid'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_valid'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_valid'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_valid'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_valid'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_valid'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_valid'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_hostname_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_sha256_hash'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_sha256_hash'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_sha256_hash'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_sha256_hash'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_sha256_hash'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_get_sha256_hash'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_sha256_hash'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_sha256_hash'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_sha256_hash'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_sha256_hash'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_sha256_hash'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_sha256_hash'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_get_sha256_hash'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_get_sha256_hash'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_hash_connection_str_hostname'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_hash_connection_str_hostname'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_hash_connection_str_hostname'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_hash_connection_str_hostname'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_hash_connection_str_hostname'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_hash_connection_str_hostname'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_hash_connection_str_hostname'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_hash_connection_str_hostname'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_hash_connection_str_hostname'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_hash_connection_str_hostname'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_hash_connection_str_hostname'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_hash_connection_str_hostname'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_hash_connection_str_hostname'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_hash_connection_str_hostname'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_raises_oserror_when_mkdir_fails'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_raises_oserror_when_mkdir_fails'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_raises_oserror_when_mkdir_fails'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_raises_oserror_when_mkdir_fails'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_raises_oserror_when_mkdir_fails'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_raises_oserror_when_mkdir_fails'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_raises_oserror_when_mkdir_fails'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_raises_oserror_when_mkdir_fails'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_raises_oserror_when_mkdir_fails'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_raises_oserror_when_mkdir_fails'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_raises_oserror_when_mkdir_fails'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_raises_oserror_when_mkdir_fails'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_raises_oserror_when_mkdir_fails'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_raises_oserror_when_mkdir_fails'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_does_not_exist'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_does_not_exist'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_does_not_exist'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_does_not_exist'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_does_not_exist'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_does_not_exist'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_does_not_exist'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_does_not_exist'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_does_not_exist'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_does_not_exist'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_does_not_exist'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_does_not_exist'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_does_not_exist'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_does_not_exist'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_exists'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_exists'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_exists'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_exists'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_exists'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_exists'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_exists'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_exists'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_exists'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_exists'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_exists'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_exists'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_exists'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_mkdir_if_needed_when_dir_exists'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_invalid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_invalid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_invalid'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_invalid'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_invalid'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_invalid'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_invalid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_invalid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_invalid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_invalid'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_invalid'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_invalid'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_invalid'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_invalid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_notmatch_device'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_notmatch_device'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_notmatch_device'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_notmatch_device'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_notmatch_device'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_notmatch_device'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_notmatch_device'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_notmatch_device'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_notmatch_device'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_notmatch_device'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_notmatch_device'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_notmatch_device'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_notmatch_device'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_notmatch_device'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_valid'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_valid'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_valid'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_valid'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_valid'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_valid'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_valid'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_valid'"}, "return_value": "'tests/test_utils.py'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_valid'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_valid'"}, "return_value": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_valid'"}, {"func_args": {"nodeid": "'tests/test_utils.py::TestUtilAPIs::test_parse_connection_strs_valid'"}, "return_value": "None"}], "text": "def iterparentnodeids(nodeid: str) -> Iterator[str]:\n    \"\"\"Return the parent node IDs of a given node ID, inclusive.\n\n    For the node ID\n\n        \"testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source\"\n\n    the result would be\n\n        \"\"\n        \"testing\"\n        \"testing/code\"\n        \"testing/code/test_excinfo.py\"\n        \"testing/code/test_excinfo.py::TestFormattedExcinfo\"\n        \"testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source\"\n\n    Note that :: parts are only considered at the last / component.\n    \"\"\"\n    pos = 0\n    sep = SEP\n    yield \"\"\n    while True:\n        at = nodeid.find(sep, pos)\n        if at == -1 and sep == SEP:\n            sep = \"::\"\n        elif at == -1:\n            if nodeid:\n                yield nodeid\n            break\n        else:\n            if at:\n                yield nodeid[:at]\n            pos = at + len(sep)"}, "_get_stderr_fileno": {"line": 68, "args": [{"func_args": {}, "return_value": "2"}]}, "_get_plugin_specs_as_list": {"line": 715, "args": [{"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}], "text": "def _get_plugin_specs_as_list(\n    specs: Union[None, types.ModuleType, str, Sequence[str]]\n) -> List[str]:\n    \"\"\"Parse a plugins specification into a list of plugin names.\"\"\"\n    # None means empty.\n    if specs is None:\n        return []\n    # Workaround for #3899 - a submodule which happens to be called \"pytest_plugins\".\n    if isinstance(specs, types.ModuleType):\n        return []\n    # Comma-separated list.\n    if isinstance(specs, str):\n        return specs.split(\",\") if specs else []\n    # Direct specification.\n    if isinstance(specs, collections.abc.Sequence):\n        return list(specs)\n    raise UsageError(\n        \"Plugins may be specified as a sequence or a ','-separated string of plugin names. Got: %r\"\n        % specs\n    )"}, "_format_trimmed": {"line": 1262, "args": [{"func_args": {"format": "' - {}'", "msg": "\"iotedgehubdev.errors.EdgeDeploymentError: Could not connect to Docker daemon. Please make sure Docker is running : Error while fetching server API version: ('Connection aborted.', FileNotFoundError(2, 'No such file or directory'))\"", "available_width": "57"}, "return_value": "' - iotedgehubdev.errors.EdgeDeploymentError: Could not...'"}], "text": "def _format_trimmed(format: str, msg: str, available_width: int) -> Optional[str]:\n    \"\"\"Format msg into format, ellipsizing it if doesn't fit in available_width.\n\n    Returns None if even the ellipsis can't fit.\n    \"\"\"\n    # Only use the first line.\n    i = msg.find(\"\\n\")\n    if i != -1:\n        msg = msg[:i]\n\n    ellipsis = \"...\"\n    format_width = wcswidth(format.format(\"\"))\n    if format_width + len(ellipsis) > available_width:\n        return None\n\n    if format_width + wcswidth(msg) > available_width:\n        available_width -= len(ellipsis)\n        msg = msg[:available_width]\n        while format_width + wcswidth(msg) > available_width:\n            msg = msg[:-1]\n        msg += ellipsis\n\n    return format.format(msg)"}, "pluralize": {"line": 1350, "args": [{"func_args": {"count": "1", "noun": "'warnings'"}, "return_value": "(1, 'warning')"}, {"func_args": {"count": "1", "noun": "'error'"}, "return_value": "(1, 'error')"}], "text": "def pluralize(count: int, noun: str) -> Tuple[int, str]:\n    # No need to pluralize words such as `failed` or `passed`.\n    if noun not in [\"error\", \"warnings\", \"test\"]:\n        return count, noun\n\n    # The `warnings` key is plural. To avoid API breakage, we keep it that way but\n    # set it to singular here so we can determine plurality in the same way as we do\n    # for `error`.\n    noun = noun.replace(\"warnings\", \"warning\")\n\n    return count, noun + \"s\" if count != 1 else noun"}, "format_session_duration": {"line": 1377, "args": [{"func_args": {"seconds": "3.921264410018921"}, "return_value": "'3.92s'"}], "text": "def format_session_duration(seconds: float) -> str:\n    \"\"\"Format the given seconds in a human readable manner to show in the final summary.\"\"\"\n    if seconds < 60:\n        return f\"{seconds:.2f}s\"\n    else:\n        dt = datetime.timedelta(seconds=int(seconds))\n        return f\"{seconds:.2f}s ({dt})\""}, "_is_same": {"line": 558, "args": [{"func_args": {"f1": "'/usr/app/src/test_repos/iotedgehubdev/tests/test_compose.py'", "f2": "'/usr/app/src/test_repos/iotedgehubdev/tests/test_compose.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/iotedgehubdev/tests/test_config.py'", "f2": "'/usr/app/src/test_repos/iotedgehubdev/tests/test_config.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/iotedgehubdev/tests/test_connectionstr.py'", "f2": "'/usr/app/src/test_repos/iotedgehubdev/tests/test_connectionstr.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/iotedgehubdev/tests/test_edgecert.py'", "f2": "'/usr/app/src/test_repos/iotedgehubdev/tests/test_edgecert.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/iotedgehubdev/tests/test_edgedockerclient.py'", "f2": "'/usr/app/src/test_repos/iotedgehubdev/tests/test_edgedockerclient.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/iotedgehubdev/tests/test_edgedockerclient_int.py'", "f2": "'/usr/app/src/test_repos/iotedgehubdev/tests/test_edgedockerclient_int.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/iotedgehubdev/tests/test_edgemanager.py'", "f2": "'/usr/app/src/test_repos/iotedgehubdev/tests/test_edgemanager.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/iotedgehubdev/tests/test_utils.py'", "f2": "'/usr/app/src/test_repos/iotedgehubdev/tests/test_utils.py'"}, "return_value": "True"}], "text": "def _is_same(f1: str, f2: str) -> bool:\n        return os.path.samefile(f1, f2)"}, "_parse_parametrize_args": {"line": 135, "args": [{"func_args": {"argnames": "'deployment_json_file, actual_output_filename, expected_output_filename'", "argvalues": "[('deployment.json', 'docker-compose_test.yml', 'docker-compose.yml'), ('deployment_with_chunked_create_options.json', 'docker-compose_test_with_chunked_create_options.yml', 'docker-compose_with_chunked_create_options.yml')]", "args": "()", "kwargs": "{}"}, "return_value": "(['deployment_json_file', 'actual_output_filename', 'expected_output_filename'], False)"}, {"func_args": {"argnames": "'deployment_json_file, actual_output_filename, expected_output_filename'", "argvalues": "[('deployment.json', 'docker-compose_test.yml', 'docker-compose.yml'), ('deployment_with_chunked_create_options.json', 'docker-compose_test_with_chunked_create_options.yml', 'docker-compose_with_chunked_create_options.yml')]", "args": "()", "kwargs": "{}"}, "return_value": "(['deployment_json_file', 'actual_output_filename', 'expected_output_filename'], False)"}, {"func_args": {"argnames": "'deployment_json_file, actual_output_filename, expected_output_filename'", "argvalues": "[('deployment.json', 'docker-compose_test.yml', 'docker-compose.yml'), ('deployment_with_chunked_create_options.json', 'docker-compose_test_with_chunked_create_options.yml', 'docker-compose_with_chunked_create_options.yml')]", "args": "()", "kwargs": "{}"}, "return_value": "(['deployment_json_file', 'actual_output_filename', 'expected_output_filename'], False)"}, {"func_args": {"argnames": "'source, target, mode'", "argvalues": "[('tmp', '/tmp/tmp', 'ro'), ('tmp', '/tmp/tmp', 'rw'), ('tmp', '/tmp/tmp', None), ('tmp', 'c:\\\\', 'ro'), ('tmp', 'c:\\\\', 'rw'), ('tmp', 'c:\\\\', None), ('tmp', 'c:\\\\foo bar\\\\tmp', 'ro'), ('tmp', 'c:\\\\foo bar\\\\tmp', 'rw'), ('tmp', 'c:\\\\foo bar\\\\tmp', None), ('tmp', 'c:/foo bar/tmp', 'ro'), ('tmp', 'c:/foo bar/tmp', 'rw'), ('tmp', 'c:/foo bar/tmp', None), ('c:\\\\', '/tmp/tmp', 'ro'), ('c:\\\\', '/tmp/tmp', 'rw'), ('c:\\\\', '/tmp/tmp', None), ('c:\\\\', 'c:\\\\', 'ro'), ('c:\\\\', 'c:\\\\', 'rw'), ('c:\\\\', 'c:\\\\', None), ('c:\\\\', 'c:\\\\foo bar\\\\tmp', 'ro'), ('c:\\\\', 'c:\\\\foo bar\\\\tmp', 'rw'), ('c:\\\\', 'c:\\\\foo bar\\\\tmp', None), ('c:\\\\', 'c:/foo bar/tmp', 'ro'), ('c:\\\\', 'c:/foo bar/tmp', 'rw'), ('c:\\\\', 'c:/foo bar/tmp', None), ('c:\\\\foo bar\\\\tmp\\\\tmp', '/tmp/tmp', 'ro'), ('c:\\\\foo bar\\\\tmp\\\\tmp', '/tmp/tmp', 'rw'), ('c:\\\\foo bar\\\\tmp\\\\tmp', '/tmp/tmp', None), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\', 'ro'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\', 'rw'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\', None), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\foo bar\\\\tmp', 'ro'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\foo bar\\\\tmp', 'rw'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\foo bar\\\\tmp', None), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:/foo bar/tmp', 'ro'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:/foo bar/tmp', 'rw'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:/foo bar/tmp', None), ('c:/foo bar/tmp/tmp', '/tmp/tmp', 'ro'), ('c:/foo bar/tmp/tmp', '/tmp/tmp', 'rw'), ('c:/foo bar/tmp/tmp', '/tmp/tmp', None), ('c:/foo bar/tmp/tmp', 'c:\\\\', 'ro'), ('c:/foo bar/tmp/tmp', 'c:\\\\', 'rw'), ('c:/foo bar/tmp/tmp', 'c:\\\\', None), ('c:/foo bar/tmp/tmp', 'c:\\\\foo bar\\\\tmp', 'ro'), ('c:/foo bar/tmp/tmp', 'c:\\\\foo bar\\\\tmp', 'rw'), ('c:/foo bar/tmp/tmp', 'c:\\\\foo bar\\\\tmp', None), ('c:/foo bar/tmp/tmp', 'c:/foo bar/tmp', 'ro'), ('c:/foo bar/tmp/tmp', 'c:/foo bar/tmp', 'rw'), ('c:/foo bar/tmp/tmp', 'c:/foo bar/tmp', None), (None, '/tmp/tmp', 'ro'), (None, '/tmp/tmp', 'rw'), (None, '/tmp/tmp', None), (None, 'c:\\\\', 'ro'), (None, 'c:\\\\', 'rw'), (None, 'c:\\\\', None), (None, 'c:\\\\foo bar\\\\tmp', 'ro'), (None, 'c:\\\\foo bar\\\\tmp', 'rw'), (None, 'c:\\\\foo bar\\\\tmp', None), (None, 'c:/foo bar/tmp', 'ro'), (None, 'c:/foo bar/tmp', 'rw'), (None, 'c:/foo bar/tmp', None), ('tmp', '/foo bar/tmp', 'ro'), ('tmp', '/foo bar/tmp', 'rw'), ('tmp', '/foo bar/tmp', None), ('/foo bar/tmp/tmp', '/foo bar/tmp', 'ro'), ('/foo bar/tmp/tmp', '/foo bar/tmp', 'rw'), ('/foo bar/tmp/tmp', '/foo bar/tmp', None), (None, '/foo bar/tmp', 'ro'), (None, '/foo bar/tmp', 'rw'), (None, '/foo bar/tmp', None)]", "args": "()", "kwargs": "{}"}, "return_value": "(['source', 'target', 'mode'], False)"}, {"func_args": {"argnames": "'source, target, mode'", "argvalues": "[('tmp', '/tmp/tmp', 'ro'), ('tmp', '/tmp/tmp', 'rw'), ('tmp', '/tmp/tmp', None), ('tmp', 'c:\\\\', 'ro'), ('tmp', 'c:\\\\', 'rw'), ('tmp', 'c:\\\\', None), ('tmp', 'c:\\\\foo bar\\\\tmp', 'ro'), ('tmp', 'c:\\\\foo bar\\\\tmp', 'rw'), ('tmp', 'c:\\\\foo bar\\\\tmp', None), ('tmp', 'c:/foo bar/tmp', 'ro'), ('tmp', 'c:/foo bar/tmp', 'rw'), ('tmp', 'c:/foo bar/tmp', None), ('c:\\\\', '/tmp/tmp', 'ro'), ('c:\\\\', '/tmp/tmp', 'rw'), ('c:\\\\', '/tmp/tmp', None), ('c:\\\\', 'c:\\\\', 'ro'), ('c:\\\\', 'c:\\\\', 'rw'), ('c:\\\\', 'c:\\\\', None), ('c:\\\\', 'c:\\\\foo bar\\\\tmp', 'ro'), ('c:\\\\', 'c:\\\\foo bar\\\\tmp', 'rw'), ('c:\\\\', 'c:\\\\foo bar\\\\tmp', None), ('c:\\\\', 'c:/foo bar/tmp', 'ro'), ('c:\\\\', 'c:/foo bar/tmp', 'rw'), ('c:\\\\', 'c:/foo bar/tmp', None), ('c:\\\\foo bar\\\\tmp\\\\tmp', '/tmp/tmp', 'ro'), ('c:\\\\foo bar\\\\tmp\\\\tmp', '/tmp/tmp', 'rw'), ('c:\\\\foo bar\\\\tmp\\\\tmp', '/tmp/tmp', None), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\', 'ro'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\', 'rw'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\', None), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\foo bar\\\\tmp', 'ro'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\foo bar\\\\tmp', 'rw'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\foo bar\\\\tmp', None), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:/foo bar/tmp', 'ro'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:/foo bar/tmp', 'rw'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:/foo bar/tmp', None), ('c:/foo bar/tmp/tmp', '/tmp/tmp', 'ro'), ('c:/foo bar/tmp/tmp', '/tmp/tmp', 'rw'), ('c:/foo bar/tmp/tmp', '/tmp/tmp', None), ('c:/foo bar/tmp/tmp', 'c:\\\\', 'ro'), ('c:/foo bar/tmp/tmp', 'c:\\\\', 'rw'), ('c:/foo bar/tmp/tmp', 'c:\\\\', None), ('c:/foo bar/tmp/tmp', 'c:\\\\foo bar\\\\tmp', 'ro'), ('c:/foo bar/tmp/tmp', 'c:\\\\foo bar\\\\tmp', 'rw'), ('c:/foo bar/tmp/tmp', 'c:\\\\foo bar\\\\tmp', None), ('c:/foo bar/tmp/tmp', 'c:/foo bar/tmp', 'ro'), ('c:/foo bar/tmp/tmp', 'c:/foo bar/tmp', 'rw'), ('c:/foo bar/tmp/tmp', 'c:/foo bar/tmp', None), (None, '/tmp/tmp', 'ro'), (None, '/tmp/tmp', 'rw'), (None, '/tmp/tmp', None), (None, 'c:\\\\', 'ro'), (None, 'c:\\\\', 'rw'), (None, 'c:\\\\', None), (None, 'c:\\\\foo bar\\\\tmp', 'ro'), (None, 'c:\\\\foo bar\\\\tmp', 'rw'), (None, 'c:\\\\foo bar\\\\tmp', None), (None, 'c:/foo bar/tmp', 'ro'), (None, 'c:/foo bar/tmp', 'rw'), (None, 'c:/foo bar/tmp', None), ('tmp', '/foo bar/tmp', 'ro'), ('tmp', '/foo bar/tmp', 'rw'), ('tmp', '/foo bar/tmp', None), ('/foo bar/tmp/tmp', '/foo bar/tmp', 'ro'), ('/foo bar/tmp/tmp', '/foo bar/tmp', 'rw'), ('/foo bar/tmp/tmp', '/foo bar/tmp', None), (None, '/foo bar/tmp', 'ro'), (None, '/foo bar/tmp', 'rw'), (None, '/foo bar/tmp', None)]", "args": "()", "kwargs": "{}"}, "return_value": "(['source', 'target', 'mode'], False)"}, {"func_args": {"argnames": "'source, target, mode'", "argvalues": "[('tmp', '/tmp/tmp', 'ro'), ('tmp', '/tmp/tmp', 'rw'), ('tmp', '/tmp/tmp', None), ('tmp', 'c:\\\\', 'ro'), ('tmp', 'c:\\\\', 'rw'), ('tmp', 'c:\\\\', None), ('tmp', 'c:\\\\foo bar\\\\tmp', 'ro'), ('tmp', 'c:\\\\foo bar\\\\tmp', 'rw'), ('tmp', 'c:\\\\foo bar\\\\tmp', None), ('tmp', 'c:/foo bar/tmp', 'ro'), ('tmp', 'c:/foo bar/tmp', 'rw'), ('tmp', 'c:/foo bar/tmp', None), ('c:\\\\', '/tmp/tmp', 'ro'), ('c:\\\\', '/tmp/tmp', 'rw'), ('c:\\\\', '/tmp/tmp', None), ('c:\\\\', 'c:\\\\', 'ro'), ('c:\\\\', 'c:\\\\', 'rw'), ('c:\\\\', 'c:\\\\', None), ('c:\\\\', 'c:\\\\foo bar\\\\tmp', 'ro'), ('c:\\\\', 'c:\\\\foo bar\\\\tmp', 'rw'), ('c:\\\\', 'c:\\\\foo bar\\\\tmp', None), ('c:\\\\', 'c:/foo bar/tmp', 'ro'), ('c:\\\\', 'c:/foo bar/tmp', 'rw'), ('c:\\\\', 'c:/foo bar/tmp', None), ('c:\\\\foo bar\\\\tmp\\\\tmp', '/tmp/tmp', 'ro'), ('c:\\\\foo bar\\\\tmp\\\\tmp', '/tmp/tmp', 'rw'), ('c:\\\\foo bar\\\\tmp\\\\tmp', '/tmp/tmp', None), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\', 'ro'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\', 'rw'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\', None), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\foo bar\\\\tmp', 'ro'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\foo bar\\\\tmp', 'rw'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:\\\\foo bar\\\\tmp', None), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:/foo bar/tmp', 'ro'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:/foo bar/tmp', 'rw'), ('c:\\\\foo bar\\\\tmp\\\\tmp', 'c:/foo bar/tmp', None), ('c:/foo bar/tmp/tmp', '/tmp/tmp', 'ro'), ('c:/foo bar/tmp/tmp', '/tmp/tmp', 'rw'), ('c:/foo bar/tmp/tmp', '/tmp/tmp', None), ('c:/foo bar/tmp/tmp', 'c:\\\\', 'ro'), ('c:/foo bar/tmp/tmp', 'c:\\\\', 'rw'), ('c:/foo bar/tmp/tmp', 'c:\\\\', None), ('c:/foo bar/tmp/tmp', 'c:\\\\foo bar\\\\tmp', 'ro'), ('c:/foo bar/tmp/tmp', 'c:\\\\foo bar\\\\tmp', 'rw'), ('c:/foo bar/tmp/tmp', 'c:\\\\foo bar\\\\tmp', None), ('c:/foo bar/tmp/tmp', 'c:/foo bar/tmp', 'ro'), ('c:/foo bar/tmp/tmp', 'c:/foo bar/tmp', 'rw'), ('c:/foo bar/tmp/tmp', 'c:/foo bar/tmp', None), (None, '/tmp/tmp', 'ro'), (None, '/tmp/tmp', 'rw'), (None, '/tmp/tmp', None), (None, 'c:\\\\', 'ro'), (None, 'c:\\\\', 'rw'), (None, 'c:\\\\', None), (None, 'c:\\\\foo bar\\\\tmp', 'ro'), (None, 'c:\\\\foo bar\\\\tmp', 'rw'), (None, 'c:\\\\foo bar\\\\tmp', None), (None, 'c:/foo bar/tmp', 'ro'), (None, 'c:/foo bar/tmp', 'rw'), (None, 'c:/foo bar/tmp', None), ('tmp', '/foo bar/tmp', 'ro'), ('tmp', '/foo bar/tmp', 'rw'), ('tmp', '/foo bar/tmp', None), ('/foo bar/tmp/tmp', '/foo bar/tmp', 'ro'), ('/foo bar/tmp/tmp', '/foo bar/tmp', 'rw'), ('/foo bar/tmp/tmp', '/foo bar/tmp', None), (None, '/foo bar/tmp', 'ro'), (None, '/foo bar/tmp', 'rw'), (None, '/foo bar/tmp', None)]", "args": "()", "kwargs": "{}"}, "return_value": "(['source', 'target', 'mode'], False)"}]}, "_translate_non_printable": {"line": 204, "args": [{"func_args": {"s": "'deployment.json'"}, "return_value": "'deployment.json'"}, {"func_args": {"s": "'docker-compose_test.yml'"}, "return_value": "'docker-compose_test.yml'"}, {"func_args": {"s": "'docker-compose.yml'"}, "return_value": "'docker-compose.yml'"}, {"func_args": {"s": "'deployment_with_chunked_create_options.json'"}, "return_value": "'deployment_with_chunked_create_options.json'"}, {"func_args": {"s": "'docker-compose_test_with_chunked_create_options.yml'"}, "return_value": "'docker-compose_test_with_chunked_create_options.yml'"}, {"func_args": {"s": "'docker-compose_with_chunked_create_options.yml'"}, "return_value": "'docker-compose_with_chunked_create_options.yml'"}, {"func_args": {"s": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"s": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"s": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"s": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"s": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"s": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"s": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"s": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"s": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"s": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"s": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"s": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"s": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"s": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"s": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"s": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"s": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"s": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"s": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"s": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"s": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"s": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"s": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"s": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"s": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'c:\\\\\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"s": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"s": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"s": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"s": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"s": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}, {"func_args": {"s": "'/foo bar/tmp/tmp'"}, "return_value": "'/foo bar/tmp/tmp'"}, {"func_args": {"s": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'/foo bar/tmp/tmp'"}, "return_value": "'/foo bar/tmp/tmp'"}, {"func_args": {"s": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'/foo bar/tmp/tmp'"}, "return_value": "'/foo bar/tmp/tmp'"}, {"func_args": {"s": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}, {"func_args": {"s": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}, {"func_args": {"s": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"s": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}, {"func_args": {"s": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"s": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}], "text": "def _translate_non_printable(s: str) -> str:\n    return s.translate(_non_printable_ascii_translate_table)"}, "ascii_escaped": {"line": 215, "args": [{"func_args": {"val": "'deployment.json'"}, "return_value": "'deployment.json'"}, {"func_args": {"val": "'docker-compose_test.yml'"}, "return_value": "'docker-compose_test.yml'"}, {"func_args": {"val": "'docker-compose.yml'"}, "return_value": "'docker-compose.yml'"}, {"func_args": {"val": "'deployment_with_chunked_create_options.json'"}, "return_value": "'deployment_with_chunked_create_options.json'"}, {"func_args": {"val": "'docker-compose_test_with_chunked_create_options.yml'"}, "return_value": "'docker-compose_test_with_chunked_create_options.yml'"}, {"func_args": {"val": "'docker-compose_with_chunked_create_options.yml'"}, "return_value": "'docker-compose_with_chunked_create_options.yml'"}, {"func_args": {"val": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"val": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"val": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"val": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"val": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"val": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"val": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"val": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"val": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"val": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"val": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"val": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"val": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"val": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp\\\\\\\\tmp'"}, {"func_args": {"val": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"val": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"val": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"val": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"val": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"val": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"val": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"val": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"val": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'c:/foo bar/tmp/tmp'"}, "return_value": "'c:/foo bar/tmp/tmp'"}, {"func_args": {"val": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"val": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'/tmp/tmp'"}, "return_value": "'/tmp/tmp'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'c:\\\\'"}, "return_value": "'c:\\\\\\\\'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'c:\\\\foo bar\\\\tmp'"}, "return_value": "'c:\\\\\\\\foo bar\\\\\\\\tmp'"}, {"func_args": {"val": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'c:/foo bar/tmp'"}, "return_value": "'c:/foo bar/tmp'"}, {"func_args": {"val": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"val": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"val": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'tmp'"}, "return_value": "'tmp'"}, {"func_args": {"val": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}, {"func_args": {"val": "'/foo bar/tmp/tmp'"}, "return_value": "'/foo bar/tmp/tmp'"}, {"func_args": {"val": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'/foo bar/tmp/tmp'"}, "return_value": "'/foo bar/tmp/tmp'"}, {"func_args": {"val": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'/foo bar/tmp/tmp'"}, "return_value": "'/foo bar/tmp/tmp'"}, {"func_args": {"val": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}, {"func_args": {"val": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}, {"func_args": {"val": "'ro'"}, "return_value": "'ro'"}, {"func_args": {"val": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}, {"func_args": {"val": "'rw'"}, "return_value": "'rw'"}, {"func_args": {"val": "'/foo bar/tmp'"}, "return_value": "'/foo bar/tmp'"}], "text": "def ascii_escaped(val: Union[bytes, str]) -> str:\n    r\"\"\"If val is pure ASCII, return it as an str, otherwise, escape\n    bytes objects into a sequence of escaped bytes:\n\n    b'\\xc3\\xb4\\xc5\\xd6' -> r'\\xc3\\xb4\\xc5\\xd6'\n\n    and escapes unicode objects into a sequence of escaped unicode\n    ids, e.g.:\n\n    r'4\\nV\\U00043efa\\x0eMXWB\\x1e\\u3028\\u15fd\\xcd\\U0007d944'\n\n    Note:\n       The obvious \"v.decode('unicode-escape')\" will return\n       valid UTF-8 unicode if it finds them in bytes, but we\n       want to return escaped bytes for any byte, even if they match\n       a UTF-8 string.\n    \"\"\"\n    if isinstance(val, bytes):\n        ret = _bytes_to_ascii(val)\n    else:\n        ret = val.encode(\"unicode_escape\").decode(\"ascii\")\n    return _translate_non_printable(ret)"}, "scope2index": {"line": 803, "args": [{"func_args": {"scope": "'function'", "descr": "\"Fixture 'tear_down'\"", "where": "'tests/test_compose.py'"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "'parametrize() call in test_compose'", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'get_direct_param_fixture_func'\"", "where": "''"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'get_direct_param_fixture_func'\"", "where": "''"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'get_direct_param_fixture_func'\"", "where": "''"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "'parametrize() call in test_bind'", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'get_direct_param_fixture_func'\"", "where": "''"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'get_direct_param_fixture_func'\"", "where": "''"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'get_direct_param_fixture_func'\"", "where": "''"}, "return_value": "4"}, {"func_args": {"scope": "'class'", "descr": "\"Fixture 'fixture'\"", "where": "'tests/test_config.py::TestGetIniConfig'"}, "return_value": "3"}, {"func_args": {"scope": "'class'", "descr": "\"Fixture 'fixture'\"", "where": "'tests/test_config.py::TestCoreTelemetry'"}, "return_value": "3"}, {"func_args": {"scope": "'class'", "descr": "\"Fixture 'fixture'\"", "where": "'tests/test_edgecert.py::TestEdgeCertAPICreateSelfSignedCerts'"}, "return_value": "3"}, {"func_args": {"scope": "'class'", "descr": "\"Fixture 'fixture'\"", "where": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetOSType'"}, "return_value": "3"}, {"func_args": {"scope": "'class'", "descr": "\"Fixture 'fixture'\"", "where": "'tests/test_edgedockerclient.py::TestEdgeDockerClientGetLocalImageSHAId'"}, "return_value": "3"}, {"func_args": {"scope": "'class'", "descr": "\"Fixture 'fixture'\"", "where": "'tests/test_edgedockerclient.py::TestEdgeDockerClientPull'"}, "return_value": "3"}, {"func_args": {"scope": "'class'", "descr": "\"Fixture 'fixture'\"", "where": "'tests/test_edgedockerclient.py::TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"scope": "'class'", "descr": "\"Fixture 'fixture'\"", "where": "'tests/test_edgedockerclient_int.py::TestEdgeDockerClientSmoke'"}, "return_value": "3"}, {"func_args": {"scope": "'class'", "descr": "\"Fixture 'fixture'\"", "where": "'tests/test_edgemanager.py::TestEdgeManager'"}, "return_value": "3"}, {"func_args": {"scope": "'class'", "descr": "\"Fixture 'fixture'\"", "where": "'tests/test_utils.py::TestUtilAPIs'"}, "return_value": "3"}], "text": "def scope2index(scope: str, descr: str, where: Optional[str] = None) -> int:\n    \"\"\"Look up the index of ``scope`` and raise a descriptive value error\n    if not defined.\"\"\"\n    strscopes: Sequence[str] = scopes\n    try:\n        return strscopes.index(scope)\n    except ValueError:\n        fail(\n            \"{} {}got an unexpected scope value '{}'\".format(\n                descr, f\"from {where} \" if where else \"\", scope\n            ),\n            pytrace=False,\n        )"}, "sort_by_scope": {"line": 1539, "args": [{"func_args": {"arg_name": "'tear_down'"}, "return_value": "4"}, {"func_args": {"arg_name": "'deployment_json_file'"}, "return_value": "4"}, {"func_args": {"arg_name": "'actual_output_filename'"}, "return_value": "4"}, {"func_args": {"arg_name": "'expected_output_filename'"}, "return_value": "4"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'tear_down'"}, "return_value": "4"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'tear_down'"}, "return_value": "4"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'tear_down'"}, "return_value": "4"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'tear_down'"}, "return_value": "4"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'tear_down'"}, "return_value": "4"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'tear_down'"}, "return_value": "4"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'tear_down'"}, "return_value": "4"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'tear_down'"}, "return_value": "4"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'tear_down'"}, "return_value": "4"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'tear_down'"}, "return_value": "4"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'tear_down'"}, "return_value": "4"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'tear_down'"}, "return_value": "4"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'tear_down'"}, "return_value": "4"}, {"func_args": {"arg_name": "'source'"}, "return_value": "4"}, {"func_args": {"arg_name": "'target'"}, "return_value": "4"}, {"func_args": {"arg_name": "'mode'"}, "return_value": "4"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'tear_down'"}, "return_value": "4"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'tear_down'"}, "return_value": "4"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestGetIniConfig'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestCoreTelemetry'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeCertAPICreateSelfSignedCerts'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerClientGetOSType'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerClientGetOSType'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerClientGetLocalImageSHAId'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerClientGetLocalImageSHAId'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerClientPull'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerClientPull'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerClientPull'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerClientPull'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerClientPull'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerContainerOps'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerClientSmoke'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerClientSmoke'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeDockerClientSmoke'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeManager'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeManager'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestEdgeManager'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}, {"func_args": {"arg_name": "'unittest_setUpClass_fixture_TestUtilAPIs'"}, "return_value": "3"}, {"func_args": {"arg_name": "'request'"}, "return_value": "4"}], "text": "def sort_by_scope(arg_name: str) -> int:\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum"}, "get_terminal_width": {"line": 15, "args": [{"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}], "text": "def get_terminal_width() -> int:\n    width, _ = shutil.get_terminal_size(fallback=(80, 24))\n\n    # The Windows get_terminal_size may be bogus, let's sanify a bit.\n    if width < 40:\n        width = 80\n\n    return width"}, "actual_path": {"line": 139, "args": [{"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}], "text": "def actual_path(path):\n        \"\"\"The actual path for non-Windows platforms.\"\"\"\n        return path"}, "abs_file": {"line": 144, "args": [{"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, {"func_args": {"path": "'.'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}]}, "find_python_files": {"line": 403, "args": [{"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev'"}, "return_value": "None"}], "text": "def find_python_files(dirname):\n    \"\"\"Yield all of the importable Python files in `dirname`, recursively.\n\n    To be importable, the files have to be in a directory with a __init__.py,\n    except for `dirname` itself, which isn't required to have one.  The\n    assumption is that `dirname` was specified directly, so the user knows\n    best, but sub-directories are checked for a __init__.py to be sure we only\n    find the importable files.\n\n    \"\"\"\n    for i, (dirpath, dirnames, filenames) in enumerate(os.walk(dirname)):\n        if i > 0 and '__init__.py' not in filenames:\n            # If a directory doesn't have __init__.py, then it isn't\n            # importable and neither are its files\n            del dirnames[:]\n            continue\n        for filename in filenames:\n            # We're only interested in files that look like reasonable Python\n            # files: Must end with .py or .pyw, and must not have certain funny\n            # characters that probably mean they are editor junk.\n            if re.match(r\"^[^.#~!$@%^&*()+=,]+\\.pyw?$\", filename):\n                yield os.path.join(dirpath, filename)"}, "canonical_filename": {"line": 53, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}]}, "relative_filename": {"line": 39, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "'iotedgehubdev/constants.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "'iotedgehubdev/telemetry.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "'iotedgehubdev/utils.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "'iotedgehubdev/compose_parser.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "'iotedgehubdev/edgecert.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "'iotedgehubdev/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "'iotedgehubdev/edgedockerclient.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "'iotedgehubdev/edgemanager.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "'iotedgehubdev/certutils.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "'iotedgehubdev/telemetry_upload.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "'iotedgehubdev/cli.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "'iotedgehubdev/hostplatform.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "'iotedgehubdev/errors.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "'iotedgehubdev/decorators.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "'iotedgehubdev/configs.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "'iotedgehubdev/composeproject.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "'iotedgehubdev/output.py'"}]}, "join_regex": {"line": 182, "args": [{"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}], "text": "def join_regex(regexes):\n    \"\"\"Combine a list of regexes into one that matches any of them.\"\"\"\n    return \"|\".join(f\"(?:{r})\" for r in regexes)"}, "tryint": {"line": 370, "args": [{"func_args": {"s": "'iotedgehubdev/__init__.py               '"}, "return_value": "'iotedgehubdev/__init__.py               '"}, {"func_args": {"s": "'6'"}, "return_value": "6"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'iotedgehubdev/certutils.py            '"}, "return_value": "'iotedgehubdev/certutils.py            '"}, {"func_args": {"s": "'400'"}, "return_value": "400"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'348'"}, "return_value": "348"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'13'"}, "return_value": "13"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'iotedgehubdev/cli.py                  '"}, "return_value": "'iotedgehubdev/cli.py                  '"}, {"func_args": {"s": "'227'"}, "return_value": "227"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'148'"}, "return_value": "148"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'35'"}, "return_value": "35"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'iotedgehubdev/compose_parser.py       '"}, "return_value": "'iotedgehubdev/compose_parser.py       '"}, {"func_args": {"s": "'150'"}, "return_value": "150"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'128'"}, "return_value": "128"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'15'"}, "return_value": "15"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'iotedgehubdev/composeproject.py       '"}, "return_value": "'iotedgehubdev/composeproject.py       '"}, {"func_args": {"s": "'148'"}, "return_value": "148"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'127'"}, "return_value": "127"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'14'"}, "return_value": "14"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'iotedgehubdev/configs.py               '"}, "return_value": "'iotedgehubdev/configs.py               '"}, {"func_args": {"s": "'49'"}, "return_value": "49"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'19'"}, "return_value": "19"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'61'"}, "return_value": "61"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'iotedgehubdev/constants.py             '"}, "return_value": "'iotedgehubdev/constants.py             '"}, {"func_args": {"s": "'34'"}, "return_value": "34"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'iotedgehubdev/decorators.py            '"}, "return_value": "'iotedgehubdev/decorators.py            '"}, {"func_args": {"s": "'24'"}, "return_value": "24"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'6'"}, "return_value": "6"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'75'"}, "return_value": "75"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'iotedgehubdev/edgecert.py              '"}, "return_value": "'iotedgehubdev/edgecert.py              '"}, {"func_args": {"s": "'31'"}, "return_value": "31"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'23'"}, "return_value": "23"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'26'"}, "return_value": "26"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'iotedgehubdev/edgedockerclient.py     '"}, "return_value": "'iotedgehubdev/edgedockerclient.py     '"}, {"func_args": {"s": "'212'"}, "return_value": "212"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'168'"}, "return_value": "168"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'21'"}, "return_value": "21"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'iotedgehubdev/edgemanager.py          '"}, "return_value": "'iotedgehubdev/edgemanager.py          '"}, {"func_args": {"s": "'278'"}, "return_value": "278"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'214'"}, "return_value": "214"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'23'"}, "return_value": "23"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'iotedgehubdev/errors.py                '"}, "return_value": "'iotedgehubdev/errors.py                '"}, {"func_args": {"s": "'42'"}, "return_value": "42"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'17'"}, "return_value": "17"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'60'"}, "return_value": "60"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'iotedgehubdev/hostplatform.py          '"}, "return_value": "'iotedgehubdev/hostplatform.py          '"}, {"func_args": {"s": "'50'"}, "return_value": "50"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'16'"}, "return_value": "16"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'68'"}, "return_value": "68"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'iotedgehubdev/output.py                '"}, "return_value": "'iotedgehubdev/output.py                '"}, {"func_args": {"s": "'40'"}, "return_value": "40"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'27'"}, "return_value": "27"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'32'"}, "return_value": "32"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'iotedgehubdev/telemetry.py             '"}, "return_value": "'iotedgehubdev/telemetry.py             '"}, {"func_args": {"s": "'96'"}, "return_value": "96"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'37'"}, "return_value": "37"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'61'"}, "return_value": "61"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'iotedgehubdev/telemetry_upload.py      '"}, "return_value": "'iotedgehubdev/telemetry_upload.py      '"}, {"func_args": {"s": "'39'"}, "return_value": "39"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'26'"}, "return_value": "26"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'33'"}, "return_value": "33"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'iotedgehubdev/utils.py                '"}, "return_value": "'iotedgehubdev/utils.py                '"}, {"func_args": {"s": "'151'"}, "return_value": "151"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'95'"}, "return_value": "95"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'37'"}, "return_value": "37"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}], "text": "def tryint(s):\n        \"\"\"If `s` is a number, return an int, else `s` unchanged.\"\"\"\n        try:\n            return int(s)\n        except ValueError:\n            return s"}, "human_key": {"line": 366, "args": [{"func_args": {"s": "'iotedgehubdev/__init__.py               6      0   100%'"}, "return_value": "['iotedgehubdev/__init__.py               ', 6, '      ', 0, '   ', 100, '%']"}, {"func_args": {"s": "'iotedgehubdev/certutils.py            400    348    13%'"}, "return_value": "['iotedgehubdev/certutils.py            ', 400, '    ', 348, '    ', 13, '%']"}, {"func_args": {"s": "'iotedgehubdev/cli.py                  227    148    35%'"}, "return_value": "['iotedgehubdev/cli.py                  ', 227, '    ', 148, '    ', 35, '%']"}, {"func_args": {"s": "'iotedgehubdev/compose_parser.py       150    128    15%'"}, "return_value": "['iotedgehubdev/compose_parser.py       ', 150, '    ', 128, '    ', 15, '%']"}, {"func_args": {"s": "'iotedgehubdev/composeproject.py       148    127    14%'"}, "return_value": "['iotedgehubdev/composeproject.py       ', 148, '    ', 127, '    ', 14, '%']"}, {"func_args": {"s": "'iotedgehubdev/configs.py               49     19    61%'"}, "return_value": "['iotedgehubdev/configs.py               ', 49, '     ', 19, '    ', 61, '%']"}, {"func_args": {"s": "'iotedgehubdev/constants.py             34      0   100%'"}, "return_value": "['iotedgehubdev/constants.py             ', 34, '      ', 0, '   ', 100, '%']"}, {"func_args": {"s": "'iotedgehubdev/decorators.py            24      6    75%'"}, "return_value": "['iotedgehubdev/decorators.py            ', 24, '      ', 6, '    ', 75, '%']"}, {"func_args": {"s": "'iotedgehubdev/edgecert.py              31     23    26%'"}, "return_value": "['iotedgehubdev/edgecert.py              ', 31, '     ', 23, '    ', 26, '%']"}, {"func_args": {"s": "'iotedgehubdev/edgedockerclient.py     212    168    21%'"}, "return_value": "['iotedgehubdev/edgedockerclient.py     ', 212, '    ', 168, '    ', 21, '%']"}, {"func_args": {"s": "'iotedgehubdev/edgemanager.py          278    214    23%'"}, "return_value": "['iotedgehubdev/edgemanager.py          ', 278, '    ', 214, '    ', 23, '%']"}, {"func_args": {"s": "'iotedgehubdev/errors.py                42     17    60%'"}, "return_value": "['iotedgehubdev/errors.py                ', 42, '     ', 17, '    ', 60, '%']"}, {"func_args": {"s": "'iotedgehubdev/hostplatform.py          50     16    68%'"}, "return_value": "['iotedgehubdev/hostplatform.py          ', 50, '     ', 16, '    ', 68, '%']"}, {"func_args": {"s": "'iotedgehubdev/output.py                40     27    32%'"}, "return_value": "['iotedgehubdev/output.py                ', 40, '     ', 27, '    ', 32, '%']"}, {"func_args": {"s": "'iotedgehubdev/telemetry.py             96     37    61%'"}, "return_value": "['iotedgehubdev/telemetry.py             ', 96, '     ', 37, '    ', 61, '%']"}, {"func_args": {"s": "'iotedgehubdev/telemetry_upload.py      39     26    33%'"}, "return_value": "['iotedgehubdev/telemetry_upload.py      ', 39, '     ', 26, '    ', 33, '%']"}, {"func_args": {"s": "'iotedgehubdev/utils.py                151     95    37%'"}, "return_value": "['iotedgehubdev/utils.py                ', 151, '     ', 95, '    ', 37, '%']"}], "text": "def human_key(s):\n    \"\"\"Turn a string into a list of string and number chunks.\n        \"z23a\" -> [\"z\", 23, \"a\"]\n    \"\"\"\n    def tryint(s):\n        \"\"\"If `s` is a number, return an int, else `s` unchanged.\"\"\"\n        try:\n            return int(s)\n        except ValueError:\n            return s\n\n    return [tryint(c) for c in re.split(r\"(\\d+)\", s)]"}, "<lambda>": {"line": 394, "args": [{"func_args": {"pair": "('iotedgehubdev/__init__.py               6      0   100%', ('iotedgehubdev/__init__.py', 6, 0, '100', 100.0))"}, "return_value": "(['iotedgehubdev/__init__.py               ', 6, '      ', 0, '   ', 100, '%'], ('iotedgehubdev/__init__.py', 6, 0, '100', 100.0))"}, {"func_args": {"pair": "('iotedgehubdev/certutils.py            400    348    13%', ('iotedgehubdev/certutils.py', 400, 348, '13', 13.0))"}, "return_value": "(['iotedgehubdev/certutils.py            ', 400, '    ', 348, '    ', 13, '%'], ('iotedgehubdev/certutils.py', 400, 348, '13', 13.0))"}, {"func_args": {"pair": "('iotedgehubdev/cli.py                  227    148    35%', ('iotedgehubdev/cli.py', 227, 148, '35', 34.801762114537446))"}, "return_value": "(['iotedgehubdev/cli.py                  ', 227, '    ', 148, '    ', 35, '%'], ('iotedgehubdev/cli.py', 227, 148, '35', 34.801762114537446))"}, {"func_args": {"pair": "('iotedgehubdev/compose_parser.py       150    128    15%', ('iotedgehubdev/compose_parser.py', 150, 128, '15', 14.666666666666666))"}, "return_value": "(['iotedgehubdev/compose_parser.py       ', 150, '    ', 128, '    ', 15, '%'], ('iotedgehubdev/compose_parser.py', 150, 128, '15', 14.666666666666666))"}, {"func_args": {"pair": "('iotedgehubdev/composeproject.py       148    127    14%', ('iotedgehubdev/composeproject.py', 148, 127, '14', 14.18918918918919))"}, "return_value": "(['iotedgehubdev/composeproject.py       ', 148, '    ', 127, '    ', 14, '%'], ('iotedgehubdev/composeproject.py', 148, 127, '14', 14.18918918918919))"}, {"func_args": {"pair": "('iotedgehubdev/configs.py               49     19    61%', ('iotedgehubdev/configs.py', 49, 19, '61', 61.224489795918366))"}, "return_value": "(['iotedgehubdev/configs.py               ', 49, '     ', 19, '    ', 61, '%'], ('iotedgehubdev/configs.py', 49, 19, '61', 61.224489795918366))"}, {"func_args": {"pair": "('iotedgehubdev/constants.py             34      0   100%', ('iotedgehubdev/constants.py', 34, 0, '100', 100.0))"}, "return_value": "(['iotedgehubdev/constants.py             ', 34, '      ', 0, '   ', 100, '%'], ('iotedgehubdev/constants.py', 34, 0, '100', 100.0))"}, {"func_args": {"pair": "('iotedgehubdev/decorators.py            24      6    75%', ('iotedgehubdev/decorators.py', 24, 6, '75', 75.0))"}, "return_value": "(['iotedgehubdev/decorators.py            ', 24, '      ', 6, '    ', 75, '%'], ('iotedgehubdev/decorators.py', 24, 6, '75', 75.0))"}, {"func_args": {"pair": "('iotedgehubdev/edgecert.py              31     23    26%', ('iotedgehubdev/edgecert.py', 31, 23, '26', 25.806451612903224))"}, "return_value": "(['iotedgehubdev/edgecert.py              ', 31, '     ', 23, '    ', 26, '%'], ('iotedgehubdev/edgecert.py', 31, 23, '26', 25.806451612903224))"}, {"func_args": {"pair": "('iotedgehubdev/edgedockerclient.py     212    168    21%', ('iotedgehubdev/edgedockerclient.py', 212, 168, '21', 20.754716981132077))"}, "return_value": "(['iotedgehubdev/edgedockerclient.py     ', 212, '    ', 168, '    ', 21, '%'], ('iotedgehubdev/edgedockerclient.py', 212, 168, '21', 20.754716981132077))"}, {"func_args": {"pair": "('iotedgehubdev/edgemanager.py          278    214    23%', ('iotedgehubdev/edgemanager.py', 278, 214, '23', 23.02158273381295))"}, "return_value": "(['iotedgehubdev/edgemanager.py          ', 278, '    ', 214, '    ', 23, '%'], ('iotedgehubdev/edgemanager.py', 278, 214, '23', 23.02158273381295))"}, {"func_args": {"pair": "('iotedgehubdev/errors.py                42     17    60%', ('iotedgehubdev/errors.py', 42, 17, '60', 59.523809523809526))"}, "return_value": "(['iotedgehubdev/errors.py                ', 42, '     ', 17, '    ', 60, '%'], ('iotedgehubdev/errors.py', 42, 17, '60', 59.523809523809526))"}, {"func_args": {"pair": "('iotedgehubdev/hostplatform.py          50     16    68%', ('iotedgehubdev/hostplatform.py', 50, 16, '68', 68.0))"}, "return_value": "(['iotedgehubdev/hostplatform.py          ', 50, '     ', 16, '    ', 68, '%'], ('iotedgehubdev/hostplatform.py', 50, 16, '68', 68.0))"}, {"func_args": {"pair": "('iotedgehubdev/output.py                40     27    32%', ('iotedgehubdev/output.py', 40, 27, '32', 32.5))"}, "return_value": "(['iotedgehubdev/output.py                ', 40, '     ', 27, '    ', 32, '%'], ('iotedgehubdev/output.py', 40, 27, '32', 32.5))"}, {"func_args": {"pair": "('iotedgehubdev/telemetry.py             96     37    61%', ('iotedgehubdev/telemetry.py', 96, 37, '61', 61.458333333333336))"}, "return_value": "(['iotedgehubdev/telemetry.py             ', 96, '     ', 37, '    ', 61, '%'], ('iotedgehubdev/telemetry.py', 96, 37, '61', 61.458333333333336))"}, {"func_args": {"pair": "('iotedgehubdev/telemetry_upload.py      39     26    33%', ('iotedgehubdev/telemetry_upload.py', 39, 26, '33', 33.333333333333336))"}, "return_value": "(['iotedgehubdev/telemetry_upload.py      ', 39, '     ', 26, '    ', 33, '%'], ('iotedgehubdev/telemetry_upload.py', 39, 26, '33', 33.333333333333336))"}, {"func_args": {"pair": "('iotedgehubdev/utils.py                151     95    37%', ('iotedgehubdev/utils.py', 151, 95, '37', 37.086092715231786))"}, "return_value": "(['iotedgehubdev/utils.py                ', 151, '     ', 95, '    ', 37, '%'], ('iotedgehubdev/utils.py', 151, 95, '37', 37.086092715231786))"}]}, "human_sorted_items": {"line": 389, "args": [{"func_args": {"items": "[('iotedgehubdev/__init__.py               6      0   100%', ('iotedgehubdev/__init__.py', 6, 0, '100', 100.0)), ('iotedgehubdev/certutils.py            400    348    13%', ('iotedgehubdev/certutils.py', 400, 348, '13', 13.0)), ('iotedgehubdev/cli.py                  227    148    35%', ('iotedgehubdev/cli.py', 227, 148, '35', 34.801762114537446)), ('iotedgehubdev/compose_parser.py       150    128    15%', ('iotedgehubdev/compose_parser.py', 150, 128, '15', 14.666666666666666)), ('iotedgehubdev/composeproject.py       148    127    14%', ('iotedgehubdev/composeproject.py', 148, 127, '14', 14.18918918918919)), ('iotedgehubdev/configs.py               49     19    61%', ('iotedgehubdev/configs.py', 49, 19, '61', 61.224489795918366)), ('iotedgehubdev/constants.py             34      0   100%', ('iotedgehubdev/constants.py', 34, 0, '100', 100.0)), ('iotedgehubdev/decorators.py            24      6    75%', ('iotedgehubdev/decorators.py', 24, 6, '75', 75.0)), ('iotedgehubdev/edgecert.py              31     23    26%', ('iotedgehubdev/edgecert.py', 31, 23, '26', 25.806451612903224)), ('iotedgehubdev/edgedockerclient.py     212    168    21%', ('iotedgehubdev/edgedockerclient.py', 212, 168, '21', 20.754716981132077)), ('iotedgehubdev/edgemanager.py          278    214    23%', ('iotedgehubdev/edgemanager.py', 278, 214, '23', 23.02158273381295)), ('iotedgehubdev/errors.py                42     17    60%', ('iotedgehubdev/errors.py', 42, 17, '60', 59.523809523809526)), ('iotedgehubdev/hostplatform.py          50     16    68%', ('iotedgehubdev/hostplatform.py', 50, 16, '68', 68.0)), ('iotedgehubdev/output.py                40     27    32%', ('iotedgehubdev/output.py', 40, 27, '32', 32.5)), ('iotedgehubdev/telemetry.py             96     37    61%', ('iotedgehubdev/telemetry.py', 96, 37, '61', 61.458333333333336)), ('iotedgehubdev/telemetry_upload.py      39     26    33%', ('iotedgehubdev/telemetry_upload.py', 39, 26, '33', 33.333333333333336)), ('iotedgehubdev/utils.py                151     95    37%', ('iotedgehubdev/utils.py', 151, 95, '37', 37.086092715231786))]", "reverse": "False"}, "return_value": "[('iotedgehubdev/__init__.py               6      0   100%', ('iotedgehubdev/__init__.py', 6, 0, '100', 100.0)), ('iotedgehubdev/certutils.py            400    348    13%', ('iotedgehubdev/certutils.py', 400, 348, '13', 13.0)), ('iotedgehubdev/cli.py                  227    148    35%', ('iotedgehubdev/cli.py', 227, 148, '35', 34.801762114537446)), ('iotedgehubdev/compose_parser.py       150    128    15%', ('iotedgehubdev/compose_parser.py', 150, 128, '15', 14.666666666666666)), ('iotedgehubdev/composeproject.py       148    127    14%', ('iotedgehubdev/composeproject.py', 148, 127, '14', 14.18918918918919)), ('iotedgehubdev/configs.py               49     19    61%', ('iotedgehubdev/configs.py', 49, 19, '61', 61.224489795918366)), ('iotedgehubdev/constants.py             34      0   100%', ('iotedgehubdev/constants.py', 34, 0, '100', 100.0)), ('iotedgehubdev/decorators.py            24      6    75%', ('iotedgehubdev/decorators.py', 24, 6, '75', 75.0)), ('iotedgehubdev/edgecert.py              31     23    26%', ('iotedgehubdev/edgecert.py', 31, 23, '26', 25.806451612903224)), ('iotedgehubdev/edgedockerclient.py     212    168    21%', ('iotedgehubdev/edgedockerclient.py', 212, 168, '21', 20.754716981132077)), ('iotedgehubdev/edgemanager.py          278    214    23%', ('iotedgehubdev/edgemanager.py', 278, 214, '23', 23.02158273381295)), ('iotedgehubdev/errors.py                42     17    60%', ('iotedgehubdev/errors.py', 42, 17, '60', 59.523809523809526)), ('iotedgehubdev/hostplatform.py          50     16    68%', ('iotedgehubdev/hostplatform.py', 50, 16, '68', 68.0)), ('iotedgehubdev/output.py                40     27    32%', ('iotedgehubdev/output.py', 40, 27, '32', 32.5)), ('iotedgehubdev/telemetry.py             96     37    61%', ('iotedgehubdev/telemetry.py', 96, 37, '61', 61.458333333333336)), ('iotedgehubdev/telemetry_upload.py      39     26    33%', ('iotedgehubdev/telemetry_upload.py', 39, 26, '33', 33.333333333333336)), ('iotedgehubdev/utils.py                151     95    37%', ('iotedgehubdev/utils.py', 151, 95, '37', 37.086092715231786))]"}], "text": "def human_sorted_items(items, reverse=False):\n    \"\"\"Sort the (string, value) items the way humans expect.\n\n    Returns the sorted list of items.\n    \"\"\"\n    return sorted(items, key=lambda pair: (human_key(pair[0]), pair[1]), reverse=reverse)"}, "_to_blob": {"line": 21, "args": [{"func_args": {"b": "b'\\xa0\\x1e'"}, "return_value": "b'\\xa0\\x1e'"}, {"func_args": {"b": "b'\\xe0O\\xff\\xffO\\x04\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00 \\x00\\x00\\xc0L\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x80\\x80\\x00 \\x04\\x00@\\x00\\x01\\x80\\x00\\x00\\x00\\x80\\x00\\x00 \\x04@\\x00\\x80 \\x00\\x08\\x80\\x00\\x10\\x00\\x00@\\x10\\x00\\x00H'"}, "return_value": "b'\\xe0O\\xff\\xffO\\x04\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00 \\x00\\x00\\xc0L\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x80\\x80\\x00 \\x04\\x00@\\x00\\x01\\x80\\x00\\x00\\x00\\x80\\x00\\x00 \\x04@\\x00\\x80 \\x00\\x08\\x80\\x00\\x10\\x00\\x00@\\x10\\x00\\x00H'"}, {"func_args": {"b": "b'\\xe0g\\x8c\\xc1\\xe0\\x0c\\x86\\xc4'"}, "return_value": "b'\\xe0g\\x8c\\xc1\\xe0\\x0c\\x86\\xc4'"}, {"func_args": {"b": "b'\\xe0\\xef\\xf7\\x7f\\x7f\\xf8?'"}, "return_value": "b'\\xe0\\xef\\xf7\\x7f\\x7f\\xf8?'"}, {"func_args": {"b": "b'\\xe0\\xe7\\x9f\\x03\\x0c\\x00\\x06\\x00\\x0c\\xe010000\\x80\\x01\\x18\\x00`0\\x0c8\\x00\\\\\\x03'"}, "return_value": "b'\\xe0\\xe7\\x9f\\x03\\x0c\\x00\\x06\\x00\\x0c\\xe010000\\x80\\x01\\x18\\x00`0\\x0c8\\x00\\\\\\x03'"}, {"func_args": {"b": "b' ?P\\xf2\\xb2'"}, "return_value": "b' ?P\\xf2\\xb2'"}, {"func_args": {"b": "b'\\xe0\\xeb\\xdf>\\r 8\\x00 \\x01\\x00\\x808\\xf0\\xff?\\x00\\x00\\x00\\x00@\\xff\\xfe\\x7f\\x00\\xbf\\xff\\xff\\xff\\xff\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x0f<\\xfe\\xfe\\xff\\xf3~\\x00\\x00\\x00\\x00~\\x01'"}, "return_value": "b'\\xe0\\xeb\\xdf>\\r 8\\x00 \\x01\\x00\\x808\\xf0\\xff?\\x00\\x00\\x00\\x00@\\xff\\xfe\\x7f\\x00\\xbf\\xff\\xff\\xff\\xff\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x0f<\\xfe\\xfe\\xff\\xf3~\\x00\\x00\\x00\\x00~\\x01'"}, {"func_args": {"b": "b'`\\x0b\\x00\\xaf\\xff\\x01\\xc6 c\\x0c'"}, "return_value": "b'`\\x0b\\x00\\xaf\\xff\\x01\\xc6 c\\x0c'"}, {"func_args": {"b": "b'\\xe0\\xfc\\xfd\\x1f\\xfe7\\xfc\\x0f\\x00\\xf0\\xce\\xe03\\xc0;'"}, "return_value": "b'\\xe0\\xfc\\xfd\\x1f\\xfe7\\xfc\\x0f\\x00\\xf0\\xce\\xe03\\xc0;'"}, {"func_args": {"b": "b'\\xe0\\x9b\\xcb\\xff\\x17\\x00\\x00\\x00\\xf0or\\xc8\\xc0\\x18\\x0c\\x07\\xc008\\x04'"}, "return_value": "b'\\xe0\\x9b\\xcb\\xff\\x17\\x00\\x00\\x00\\xf0or\\xc8\\xc0\\x18\\x0c\\x07\\xc008\\x04'"}, {"func_args": {"b": "b'\\xe0\\x9e\\t\\x80\\x01\\x00\\x00\\x01'"}, "return_value": "b'\\xe0\\x9e\\t\\x80\\x01\\x00\\x00\\x01'"}, {"func_args": {"b": "b'0#\\x00\\x00\\x00\\x01\\x00\\x00\\t'"}, "return_value": "b'0#\\x00\\x00\\x00\\x01\\x00\\x00\\t'"}, {"func_args": {"b": "b'`\\xfb\\xf3\\xff\\xff\\x0b\\x003\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00@\\x00\\x00\\x00\\x18\\x00@\\x00\\x00\\x00\\x00\\t\\x00\\x02\\x80\\x00\\x00 \\x00\\x00\\x08\\x00 \"\\x00\\x10@\\x08\\x00\\x00\\x00\\x00 03'"}, "return_value": "b'`\\xfb\\xf3\\xff\\xff\\x0b\\x003\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00@\\x00\\x00\\x00\\x18\\x00@\\x00\\x00\\x00\\x00\\t\\x00\\x02\\x80\\x00\\x00 \\x00\\x00\\x08\\x00 \"\\x00\\x10@\\x08\\x00\\x00\\x00\\x00 03'"}, {"func_args": {"b": "b'\\xe0\\xbdR@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00 \\x01\\x00@\\x00\\x00 \\x00\\x80\\x00\\x00\\x01\\x00\\x00`'"}, "return_value": "b'\\xe0\\xbdR@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00 \\x01\\x00@\\x00\\x00 \\x00\\x80\\x00\\x00\\x01\\x00\\x00`'"}, {"func_args": {"b": "b'\\xb02\\x01\\x02\\x88\\x08\\x04\\x00\\x81\\x00\\x04\\x00\\x08\\x00\\x01\\x08\\x00\\x04\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\xc0\\xff?\\xff\\xfd\\xafyq'"}, "return_value": "b'\\xb02\\x01\\x02\\x88\\x08\\x04\\x00\\x81\\x00\\x04\\x00\\x08\\x00\\x01\\x08\\x00\\x04\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\xc0\\xff?\\xff\\xfd\\xafyq'"}, {"func_args": {"b": "b' E$\\t@\\x08I'"}, "return_value": "b' E$\\t@\\x08I'"}, {"func_args": {"b": "b'\\xe0\\xcf\\xe6K\\x04 @\\x00\\x00B\\x00\\x92\\x04\\x00@\\x80\\x10\\x00\\x02\\x01@@\\x00\\x02\\x04\\x08\\x08 \\x00\\x04\\x00\\x00\\x18\\x0c'"}, "return_value": "b'\\xe0\\xcf\\xe6K\\x04 @\\x00\\x00B\\x00\\x92\\x04\\x00@\\x80\\x10\\x00\\x02\\x01@@\\x00\\x02\\x04\\x08\\x08 \\x00\\x04\\x00\\x00\\x18\\x0c'"}], "text": "def _to_blob(b):\n    \"\"\"Convert a bytestring into a type SQLite will accept for a blob.\"\"\"\n    return b"}, "nums_to_numbits": {"line": 28, "args": [{"func_args": {"nums": "{5, 7, 9, 10, 11, 12}"}, "return_value": "b'\\xa0\\x1e'"}, {"func_args": {"nums": "{407, 5, 6, 7, 8, 9, 10, 11, 14, 143, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 540, 38, 42, 429, 303, 434, 563, 566, 311, 446, 197, 325, 330, 463, 84, 469, 222, 223, 350, 226, 227, 483, 230, 360, 508, 495, 375, 252, 534}"}, "return_value": "b'\\xe0O\\xff\\xffO\\x04\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00 \\x00\\x00\\xc0L\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x80\\x80\\x00 \\x04\\x00@\\x00\\x01\\x80\\x00\\x00\\x00\\x80\\x00\\x00 \\x04@\\x00\\x80 \\x00\\x08\\x80\\x00\\x10\\x00\\x00@\\x10\\x00\\x00H'"}, {"func_args": {"nums": "{5, 6, 7, 8, 9, 10, 13, 14, 18, 19, 23, 24, 30, 31, 37, 38, 39, 42, 43, 49, 50, 55, 58, 62, 63}"}, "return_value": "b'\\xe0g\\x8c\\xc1\\xe0\\x0c\\x86\\xc4'"}, {"func_args": {"nums": "{5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 18, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53}"}, "return_value": "b'\\xe0\\xef\\xf7\\x7f\\x7f\\xf8?'"}, {"func_args": {"nums": "{128, 5, 6, 7, 8, 9, 10, 139, 140, 13, 14, 15, 16, 17, 18, 19, 20, 23, 24, 25, 157, 158, 34, 35, 164, 165, 170, 171, 49, 50, 179, 180, 181, 66, 67, 194, 195, 196, 198, 200, 201, 77, 78, 79, 80, 84, 85, 92, 93, 100, 101, 108, 109, 116, 117, 127}"}, "return_value": "b'\\xe0\\xe7\\x9f\\x03\\x0c\\x00\\x06\\x00\\x0c\\xe010000\\x80\\x01\\x18\\x00`0\\x0c8\\x00\\\\\\x03'"}, {"func_args": {"nums": "{33, 36, 5, 37, 39, 8, 9, 10, 11, 12, 13, 20, 22, 25, 28, 29, 30, 31}"}, "return_value": "b' ?P\\xf2\\xb2'"}, {"func_args": {"nums": "{5, 6, 7, 8, 9, 11, 13, 14, 15, 16, 17, 18, 19, 20, 22, 23, 25, 26, 27, 28, 29, 32, 34, 35, 45, 51, 52, 53, 69, 72, 95, 99, 100, 101, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 166, 168, 169, 170, 171, 172, 173, 174, 175, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 200, 201, 202, 203, 204, 205, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 300, 301, 302, 303, 304, 305, 306, 307, 314, 315, 316, 317, 321, 322, 323, 324, 325, 326, 327, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 348, 349, 350, 351, 353, 354, 355, 356, 357, 358, 393, 394, 395, 396, 397, 398, 400}"}, "return_value": "b'\\xe0\\xeb\\xdf>\\r 8\\x00 \\x01\\x00\\x808\\xf0\\xff?\\x00\\x00\\x00\\x00@\\xff\\xfe\\x7f\\x00\\xbf\\xff\\xff\\xff\\xff\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x0f<\\xfe\\xfe\\xff\\xf3~\\x00\\x00\\x00\\x00~\\x01'"}, {"func_args": {"nums": "{5, 6, 8, 9, 11, 24, 25, 26, 27, 29, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 49, 50, 54, 55, 61, 64, 65, 69, 70, 74, 75}"}, "return_value": "b'`\\x0b\\x00\\xaf\\xff\\x01\\xc6 c\\x0c'"}, {"func_args": {"nums": "{5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 44, 45, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 76, 77, 78, 79, 81, 82, 83, 86, 87, 93, 94, 95, 96, 97, 100, 101, 110, 111, 112, 113, 115, 116, 117}"}, "return_value": "b'\\xe0\\xfc\\xfd\\x1f\\xfe7\\xfc\\x0f\\x00\\xf0\\xce\\xe03\\xc0;'"}, {"func_args": {"nums": "{5, 6, 7, 8, 9, 134, 11, 12, 135, 140, 15, 16, 17, 141, 19, 147, 148, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 154, 36, 68, 69, 70, 71, 72, 73, 74, 75, 77, 78, 81, 84, 85, 86, 91, 94, 95, 102, 103, 107, 108, 149, 114, 115, 120, 121, 122}"}, "return_value": "b'\\xe0\\x9b\\xcb\\xff\\x17\\x00\\x00\\x00\\xf0or\\xc8\\xc0\\x18\\x0c\\x07\\xc008\\x04'"}, {"func_args": {"nums": "{32, 5, 6, 7, 9, 10, 11, 12, 15, 16, 19, 56, 31}"}, "return_value": "b'\\xe0\\x9e\\t\\x80\\x01\\x00\\x00\\x01'"}, {"func_args": {"nums": "{64, 67, 4, 5, 8, 9, 40, 13}"}, "return_value": "b'0#\\x00\\x00\\x00\\x01\\x00\\x00\\t'"}, {"func_args": {"nums": "{129, 385, 5, 6, 389, 8, 9, 11, 12, 13, 14, 15, 16, 17, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 288, 43, 291, 414, 177, 305, 56, 57, 60, 61, 419, 319, 461, 206, 84, 341, 468, 469, 472, 473, 476, 477, 235, 236, 363, 404, 381, 254}"}, "return_value": "b'`\\xfb\\xf3\\xff\\xff\\x0b\\x003\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00@\\x00\\x00\\x00\\x18\\x00@\\x00\\x00\\x00\\x00\\t\\x00\\x02\\x80\\x00\\x00 \\x00\\x00\\x08\\x00 \"\\x00\\x10@\\x08\\x00\\x00\\x00\\x00 03'"}, {"func_args": {"nums": "{5, 6, 7, 8, 10, 11, 12, 13, 15, 17, 20, 149, 22, 30, 167, 184, 213, 214, 101, 104, 126}"}, "return_value": "b'\\xe0\\xbdR@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00 \\x01\\x00@\\x00\\x00 \\x00\\x80\\x00\\x00\\x01\\x00\\x00`'"}, {"func_args": {"nums": "{256, 258, 259, 4, 5, 260, 7, 261, 9, 138, 262, 12, 13, 263, 264, 16, 265, 266, 267, 269, 271, 272, 277, 152, 25, 278, 276, 280, 285, 286, 284, 35, 39, 43, 275, 50, 64, 71, 82, 220, 99, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 112, 240, 241, 242, 243, 244, 245, 251, 248, 249, 250, 123, 252, 253, 254, 255}"}, "return_value": "b'\\xb02\\x01\\x02\\x88\\x08\\x04\\x00\\x81\\x00\\x04\\x00\\x08\\x00\\x01\\x08\\x00\\x04\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\xc0\\xff?\\xff\\xfd\\xafyq'"}, {"func_args": {"nums": "{5, 38, 8, 10, 43, 14, 48, 18, 51, 21, 54, 24, 27}"}, "return_value": "b' E$\\t@\\x08I'"}, {"func_args": {"nums": "{259, 132, 5, 6, 7, 8, 9, 10, 11, 260, 266, 14, 15, 267, 17, 145, 18, 21, 22, 23, 152, 24, 25, 27, 30, 34, 166, 45, 174, 54, 185, 194, 73, 203, 78, 211, 89, 92, 221, 95, 98, 234, 118, 127}"}, "return_value": "b'\\xe0\\xcf\\xe6K\\x04 @\\x00\\x00B\\x00\\x92\\x04\\x00@\\x80\\x10\\x00\\x02\\x01@@\\x00\\x02\\x04\\x08\\x08 \\x00\\x04\\x00\\x00\\x18\\x0c'"}]}, "numbits_to_nums": {"line": 49, "args": [{"func_args": {"numbits": "b'\\xa0\\x1e'"}, "return_value": "[5, 7, 9, 10, 11, 12]"}, {"func_args": {"numbits": "b'\\xe0O\\xff\\xffO\\x04\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00 \\x00\\x00\\xc0L\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x80\\x80\\x00 \\x04\\x00@\\x00\\x01\\x80\\x00\\x00\\x00\\x80\\x00\\x00 \\x04@\\x00\\x80 \\x00\\x08\\x80\\x00\\x10\\x00\\x00@\\x10\\x00\\x00H'"}, "return_value": "[5, 6, 7, 8, 9, 10, 11, 14, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 38, 42, 84, 143, 197, 222, 223, 226, 227, 230, 252, 303, 311, 325, 330, 350, 360, 375, 407, 429, 434, 446, 463, 469, 483, 495, 508, 534, 540, 563, 566]"}, {"func_args": {"numbits": "b'\\xe0\\xeb\\xdf>\\r 8\\x00 \\x01\\x00\\x808\\xf0\\xff?\\x00\\x00\\x00\\x00@\\xff\\xfe\\x7f\\x00\\xbf\\xff\\xff\\xff\\xff\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x0f<\\xfe\\xfe\\xff\\xf3~\\x00\\x00\\x00\\x00~\\x01'"}, "return_value": "[5, 6, 7, 8, 9, 11, 13, 14, 15, 16, 17, 18, 19, 20, 22, 23, 25, 26, 27, 28, 29, 32, 34, 35, 45, 51, 52, 53, 69, 72, 95, 99, 100, 101, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 166, 168, 169, 170, 171, 172, 173, 174, 175, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 200, 201, 202, 203, 204, 205, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 300, 301, 302, 303, 304, 305, 306, 307, 314, 315, 316, 317, 321, 322, 323, 324, 325, 326, 327, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 348, 349, 350, 351, 353, 354, 355, 356, 357, 358, 393, 394, 395, 396, 397, 398, 400]"}, {"func_args": {"numbits": "b'\\xb02\\x01\\x02\\x88\\x08\\x04\\x00\\x81\\x00\\x04\\x00\\x08\\x00\\x01\\x08\\x00\\x04\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\xc0\\xff?\\xff\\xfd\\xafyq'"}, "return_value": "[4, 5, 7, 9, 12, 13, 16, 25, 35, 39, 43, 50, 64, 71, 82, 99, 112, 123, 138, 152, 220, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 248, 249, 250, 251, 252, 253, 254, 255, 256, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 269, 271, 272, 275, 276, 277, 278, 280, 284, 285, 286]"}, {"func_args": {"numbits": "b'\\xe0\\xbdR@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00 \\x01\\x00@\\x00\\x00 \\x00\\x80\\x00\\x00\\x01\\x00\\x00`'"}, "return_value": "[5, 6, 7, 8, 10, 11, 12, 13, 15, 17, 20, 22, 30, 101, 104, 126, 149, 167, 184, 213, 214]"}, {"func_args": {"numbits": "b'`\\x0b\\x00\\xaf\\xff\\x01\\xc6 c\\x0c'"}, "return_value": "[5, 6, 8, 9, 11, 24, 25, 26, 27, 29, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 49, 50, 54, 55, 61, 64, 65, 69, 70, 74, 75]"}, {"func_args": {"numbits": "b'\\xe0\\xef\\xf7\\x7f\\x7f\\xf8?'"}, "return_value": "[5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 18, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53]"}, {"func_args": {"numbits": "b' ?P\\xf2\\xb2'"}, "return_value": "[5, 8, 9, 10, 11, 12, 13, 20, 22, 25, 28, 29, 30, 31, 33, 36, 37, 39]"}, {"func_args": {"numbits": "b'0#\\x00\\x00\\x00\\x01\\x00\\x00\\t'"}, "return_value": "[4, 5, 8, 9, 13, 40, 64, 67]"}, {"func_args": {"numbits": "b'\\xe0\\xcf\\xe6K\\x04 @\\x00\\x00B\\x00\\x92\\x04\\x00@\\x80\\x10\\x00\\x02\\x01@@\\x00\\x02\\x04\\x08\\x08 \\x00\\x04\\x00\\x00\\x18\\x0c'"}, "return_value": "[5, 6, 7, 8, 9, 10, 11, 14, 15, 17, 18, 21, 22, 23, 24, 25, 27, 30, 34, 45, 54, 73, 78, 89, 92, 95, 98, 118, 127, 132, 145, 152, 166, 174, 185, 194, 203, 211, 221, 234, 259, 260, 266, 267]"}, {"func_args": {"numbits": "b'`\\xfb\\xf3\\xff\\xff\\x0b\\x003\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00@\\x00\\x00\\x00\\x18\\x00@\\x00\\x00\\x00\\x00\\t\\x00\\x02\\x80\\x00\\x00 \\x00\\x00\\x08\\x00 \"\\x00\\x10@\\x08\\x00\\x00\\x00\\x00 03'"}, "return_value": "[5, 6, 8, 9, 11, 12, 13, 14, 15, 16, 17, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 56, 57, 60, 61, 84, 129, 177, 206, 235, 236, 254, 288, 291, 305, 319, 341, 363, 381, 385, 389, 404, 414, 419, 461, 468, 469, 472, 473, 476, 477]"}, {"func_args": {"numbits": "b'\\xe0g\\x8c\\xc1\\xe0\\x0c\\x86\\xc4'"}, "return_value": "[5, 6, 7, 8, 9, 10, 13, 14, 18, 19, 23, 24, 30, 31, 37, 38, 39, 42, 43, 49, 50, 55, 58, 62, 63]"}, {"func_args": {"numbits": "b'\\xe0\\xfc\\xfd\\x1f\\xfe7\\xfc\\x0f\\x00\\xf0\\xce\\xe03\\xc0;'"}, "return_value": "[5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 44, 45, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 76, 77, 78, 79, 81, 82, 83, 86, 87, 93, 94, 95, 96, 97, 100, 101, 110, 111, 112, 113, 115, 116, 117]"}, {"func_args": {"numbits": "b' E$\\t@\\x08I'"}, "return_value": "[5, 8, 10, 14, 18, 21, 24, 27, 38, 43, 48, 51, 54]"}, {"func_args": {"numbits": "b'\\xe0\\x9b\\xcb\\xff\\x17\\x00\\x00\\x00\\xf0or\\xc8\\xc0\\x18\\x0c\\x07\\xc008\\x04'"}, "return_value": "[5, 6, 7, 8, 9, 11, 12, 15, 16, 17, 19, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 36, 68, 69, 70, 71, 72, 73, 74, 75, 77, 78, 81, 84, 85, 86, 91, 94, 95, 102, 103, 107, 108, 114, 115, 120, 121, 122, 134, 135, 140, 141, 147, 148, 149, 154]"}, {"func_args": {"numbits": "b'\\xe0\\x9e\\t\\x80\\x01\\x00\\x00\\x01'"}, "return_value": "[5, 6, 7, 9, 10, 11, 12, 15, 16, 19, 31, 32, 56]"}, {"func_args": {"numbits": "b'\\xe0\\xe7\\x9f\\x03\\x0c\\x00\\x06\\x00\\x0c\\xe010000\\x80\\x01\\x18\\x00`0\\x0c8\\x00\\\\\\x03'"}, "return_value": "[5, 6, 7, 8, 9, 10, 13, 14, 15, 16, 17, 18, 19, 20, 23, 24, 25, 34, 35, 49, 50, 66, 67, 77, 78, 79, 80, 84, 85, 92, 93, 100, 101, 108, 109, 116, 117, 127, 128, 139, 140, 157, 158, 164, 165, 170, 171, 179, 180, 181, 194, 195, 196, 198, 200, 201]"}]}, "combinable_files": {"line": 55, "args": [{"func_args": {"data_file": "'/usr/app/src/test_repos/iotedgehubdev/.coverage'", "data_paths": "None"}, "return_value": "['/usr/app/src/test_repos/iotedgehubdev/.coverage.cae2a1e14906.53794.189045']"}], "text": "def combinable_files(data_file, data_paths=None):\n    \"\"\"Make a list of data files to be combined.\n\n    `data_file` is a path to a data file.  `data_paths` is a list of files or\n    directories of files.\n\n    Returns a list of absolute file paths.\n    \"\"\"\n    data_dir, local = os.path.split(os.path.abspath(data_file))\n\n    data_paths = data_paths or [data_dir]\n    files_to_combine = []\n    for p in data_paths:\n        if os.path.isfile(p):\n            files_to_combine.append(os.path.abspath(p))\n        elif os.path.isdir(p):\n            pattern = os.path.join(os.path.abspath(p), f\"{local}.*\")\n            files_to_combine.extend(glob.glob(pattern))\n        else:\n            raise NoDataError(f\"Couldn't combine from non-existent path '{p}'\")\n    return files_to_combine"}, "source_for_file": {"line": 97, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}], "text": "def source_for_file(filename):\n    \"\"\"Return the source filename for `filename`.\n\n    Given a file name being traced, return the best guess as to the source\n    file to attribute it to.\n\n    \"\"\"\n    if filename.endswith(\".py\"):\n        # .py files are themselves source files.\n        return filename\n\n    elif filename.endswith((\".pyc\", \".pyo\")):\n        # Bytecode files probably have source files near them.\n        py_filename = filename[:-1]\n        if os.path.exists(py_filename):\n            # Found a .py file, use that.\n            return py_filename\n        if env.WINDOWS:\n            # On Windows, it could be a .pyw file.\n            pyw_filename = py_filename + \"w\"\n            if os.path.exists(pyw_filename):\n                return pyw_filename\n        # Didn't find source, but it's probably the .py file we want.\n        return py_filename\n\n    elif filename.endswith(\"$py.class\"):\n        # Jython is easy to guess.\n        return filename[:-9] + \".py\"\n\n    # No idea, just use the file name as-is.\n    return filename"}, "source_for_morf": {"line": 130, "args": [{"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, {"func_args": {"morf": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}], "text": "def source_for_morf(morf):\n    \"\"\"Get the source filename for the module-or-file `morf`.\"\"\"\n    if hasattr(morf, '__file__') and morf.__file__:\n        filename = morf.__file__\n    elif isinstance(morf, types.ModuleType):\n        # A module should have had .__file__, otherwise we can't use it.\n        # This could be a PEP-420 namespace package.\n        raise CoverageException(f\"Module {morf} has no file\")\n    else:\n        filename = morf\n\n    filename = source_for_file(filename)\n    return filename"}, "read_python_source": {"line": 20, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "b\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport pkg_resources\\n\\npkg_resources.declare_namespace(__name__)\\n\\n__author__ = 'Microsoft Corporation'\\n__version__ = '0.14.10'\\n__AIkey__ = '95b20d64-f54f-4de3-8ad5-165a75a6c6fe'\\n__production__ = 'iotedgehubdev'\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport os\\nfrom OpenSSL import crypto\\nfrom shutil import copy2\\nfrom datetime import datetime\\nfrom .errors import EdgeFileAccessError, EdgeInvalidArgument, EdgeValueError\\nfrom .constants import EdgeConstants as EC\\nfrom .utils import Utils\\n\\n\\nclass EdgeCertUtil(object):\\n\\n    TYPE_RSA = 0\\n    MIN_VALIDITY_DAYS = 1\\n    MAX_VALIDITY_DAYS = 1095  # 3 years\\n    MIN_PASSPHRASE_LENGTH = 4\\n    MAX_PASSPHRASE_LENGTH = 1023\\n    CA_KEY_LEN = 4096\\n    CA_INT_KEY_LEN = 4096\\n    SERVER_KEY_LEN = 2048\\n    MIN_COMMON_NAME_LEN = 1\\n    MAX_COMMON_NAME_LEN = 64\\n    DIGEST = \\'sha256\\'\\n    _type_dict = {TYPE_RSA: crypto.TYPE_RSA}\\n    _subject_validation_dict = {\\n        EC.SUBJECT_COUNTRY_KEY: {\\'MIN\\': 2, \\'MAX\\': 2},\\n        EC.SUBJECT_STATE_KEY: {\\'MIN\\': 0, \\'MAX\\': 128},\\n        EC.SUBJECT_LOCALITY_KEY: {\\'MIN\\': 0, \\'MAX\\': 128},\\n        EC.SUBJECT_ORGANIZATION_KEY: {\\'MIN\\': 0, \\'MAX\\': 64},\\n        EC.SUBJECT_ORGANIZATION_UNIT_KEY: {\\'MIN\\': 0, \\'MAX\\': 64},\\n        EC.SUBJECT_COMMON_NAME_KEY: {\\'MIN\\': MIN_COMMON_NAME_LEN,\\n                                     \\'MAX\\': MAX_COMMON_NAME_LEN}\\n    }\\n\\n    def __init__(self, serial_num=1000):\\n        self._cert_chain = {}\\n        self._serial_number = serial_num\\n\\n    def create_root_ca_cert(self, id_str, **kwargs):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Duplicate root CA certificate ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        validity_days_from_now = self._get_kwargs_validity(**kwargs)\\n        subj_dict = None\\n        if \\'subject_dict\\' in kwargs:\\n            subj_dict = kwargs[\\'subject_dict\\']\\n            if self.is_valid_certificate_subject(subj_dict) is False:\\n                msg = \\'Certificate subject dictionary is invalid.\\'\\n                raise EdgeValueError(msg)\\n        else:\\n            msg = \\'Certificate subject dictionary is required\\'\\n            raise EdgeValueError(msg)\\n        passphrase = self._get_kwargs_passphrase(**kwargs)\\n\\n        key_obj = self._create_key_pair(EdgeCertUtil.TYPE_RSA,\\n                                        EdgeCertUtil.CA_KEY_LEN)\\n        csr_obj = self._create_csr(key_obj,\\n                                   C=subj_dict[EC.SUBJECT_COUNTRY_KEY],\\n                                   ST=subj_dict[EC.SUBJECT_STATE_KEY],\\n                                   L=subj_dict[EC.SUBJECT_LOCALITY_KEY],\\n                                   O=subj_dict[EC.SUBJECT_ORGANIZATION_KEY],\\n                                   OU=subj_dict[EC.SUBJECT_ORGANIZATION_KEY],\\n                                   CN=subj_dict[EC.SUBJECT_COMMON_NAME_KEY])\\n\\n        validity_secs_from_now = validity_days_from_now * 24 * 60 * 60\\n        cert_obj = self._create_ca_cert(csr_obj,\\n                                        csr_obj,\\n                                        key_obj,\\n                                        (0, validity_secs_from_now),\\n                                        False)\\n        self._serial_number += 1\\n        cert_dict = {}\\n        cert_dict[\\'key_pair\\'] = key_obj\\n        cert_dict[\\'csr\\'] = csr_obj\\n        cert_dict[\\'cert\\'] = cert_obj\\n        cert_dict[\\'issuer_id\\'] = id_str\\n        cert_dict[\\'passphrase\\'] = passphrase\\n        self._cert_chain[id_str] = cert_dict\\n\\n    def create_intermediate_ca_cert(self, id_str, issuer_id_str, **kwargs):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Duplicate intermediate CA certificate ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        if issuer_id_str not in list(self._cert_chain.keys()):\\n            msg = \\'Invalid issuer certificate ID: {0}\\'.format(issuer_id_str)\\n            raise EdgeValueError(msg)\\n\\n        validity_days_from_now = self._get_kwargs_validity(**kwargs)\\n        passphrase = self._get_kwargs_passphrase(**kwargs)\\n\\n        min_length = self._subject_validation_dict[EC.SUBJECT_COMMON_NAME_KEY][\\'MIN\\']\\n        max_length = self._subject_validation_dict[EC.SUBJECT_COMMON_NAME_KEY][\\'MAX\\']\\n        common_name = self._get_kwargs_string(\\'common_name\\', min_length, max_length, **kwargs)\\n        if common_name is None:\\n            msg = \\'Invalid common name: {0}\\'.format(common_name)\\n            raise EdgeValueError(msg)\\n\\n        set_terminal_ca = True\\n        if \\'set_terminal_ca\\' in kwargs:\\n            set_terminal_ca = kwargs[\\'set_terminal_ca\\']\\n\\n        try:\\n            issuer_cert_dict = self._cert_chain[issuer_id_str]\\n            issuer_cert = issuer_cert_dict[\\'cert\\']\\n\\n            not_after_ts = issuer_cert.get_notAfter()\\n            valid_days = self._get_maximum_validity_days(not_after_ts,\\n                                                         validity_days_from_now)\\n\\n            issuer_key = issuer_cert_dict[\\'key_pair\\']\\n            key_obj = self._create_key_pair(EdgeCertUtil.TYPE_RSA, EdgeCertUtil.CA_KEY_LEN)\\n            csr_obj = self._create_csr(key_obj,\\n                                       C=issuer_cert.get_subject().countryName,\\n                                       ST=issuer_cert.get_subject().stateOrProvinceName,\\n                                       L=issuer_cert.get_subject().localityName,\\n                                       O=issuer_cert.get_subject().organizationName,\\n                                       OU=issuer_cert.get_subject().organizationalUnitName,\\n                                       CN=common_name)\\n\\n            validity_secs_from_now = valid_days * 24 * 60 * 60\\n            cert_obj = self._create_ca_cert(csr_obj,\\n                                            issuer_cert,\\n                                            issuer_key,\\n                                            (0, validity_secs_from_now),\\n                                            set_terminal_ca)\\n            self._serial_number += 1\\n            cert_dict = {}\\n            cert_dict[\\'key_pair\\'] = key_obj\\n            cert_dict[\\'csr\\'] = csr_obj\\n            cert_dict[\\'cert\\'] = cert_obj\\n            cert_dict[\\'issuer_id\\'] = issuer_id_str\\n            cert_dict[\\'passphrase\\'] = passphrase\\n            self._cert_chain[id_str] = cert_dict\\n        except EdgeValueError:\\n            msg = \\'Could not create intermediate certificate for {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n    def create_server_cert(self, id_str, issuer_id_str, **kwargs):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Duplicate intermediate CA certificate ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        if issuer_id_str not in list(self._cert_chain.keys()):\\n            msg = \\'Invalid issuer certificate ID: {0}\\'.format(issuer_id_str)\\n            raise EdgeValueError(msg)\\n\\n        validity_days_from_now = self._get_kwargs_validity(**kwargs)\\n\\n        passphrase = self._get_kwargs_passphrase(**kwargs)\\n\\n        max_length = self._subject_validation_dict[EC.SUBJECT_COMMON_NAME_KEY][\\'MAX\\']\\n        hostname = kwargs.get(\\'hostname\\', None)\\n        if hostname is None:\\n            msg = \\'Invalid hostname: {0}\\'.format(hostname)\\n            raise EdgeValueError(msg)\\n        # CN length is limited to 64. Since the certificate is used internally so just cut to 64.\\n        common_name = hostname if len(hostname) <= max_length else hostname[:max_length]\\n\\n        try:\\n            issuer_cert_dict = self._cert_chain[issuer_id_str]\\n            issuer_cert = issuer_cert_dict[\\'cert\\']\\n            issuer_key = issuer_cert_dict[\\'key_pair\\']\\n            key_obj = self._create_key_pair(EdgeCertUtil.TYPE_RSA, EdgeCertUtil.SERVER_KEY_LEN)\\n            csr_obj = self._create_csr(key_obj,\\n                                       C=issuer_cert.get_subject().countryName,\\n                                       ST=issuer_cert.get_subject().stateOrProvinceName,\\n                                       L=issuer_cert.get_subject().localityName,\\n                                       O=issuer_cert.get_subject().organizationName,\\n                                       OU=issuer_cert.get_subject().organizationalUnitName,\\n                                       CN=common_name)\\n            not_after_ts = issuer_cert.get_notAfter()\\n            valid_days = self._get_maximum_validity_days(not_after_ts,\\n                                                         validity_days_from_now)\\n            validity_secs_from_now = valid_days * 24 * 60 * 60\\n            cert_obj = self._create_server_cert(csr_obj,\\n                                                issuer_cert,\\n                                                issuer_key,\\n                                                (0, validity_secs_from_now),\\n                                                hostname)\\n            self._serial_number += 1\\n            cert_dict = {}\\n            cert_dict[\\'key_pair\\'] = key_obj\\n            cert_dict[\\'csr\\'] = csr_obj\\n            cert_dict[\\'cert\\'] = cert_obj\\n            cert_dict[\\'issuer_id\\'] = issuer_id_str\\n            cert_dict[\\'passphrase\\'] = passphrase\\n            self._cert_chain[id_str] = cert_dict\\n        except EdgeValueError:\\n            msg = \\'Could not create server certificate for {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n    def export_pfx_cert(self, id_str, dir_path):\\n        if id_str not in self._cert_chain:\\n            msg = \\'Invalid cert ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        try:\\n            cert_dict = self._cert_chain[id_str]\\n            cert_obj = cert_dict[\\'cert\\']\\n            key_obj = cert_dict[\\'key_pair\\']\\n            pfx = crypto.PKCS12()\\n            pfx.set_privatekey(key_obj)\\n            pfx.set_certificate(cert_obj)\\n            pfx_data = pfx.export()\\n            prefix = id_str\\n            path = os.path.realpath(dir_path)\\n            path = os.path.join(path, prefix)\\n            cert_dir = os.path.join(path, \\'cert\\')\\n            pfx_output_file_name = os.path.join(cert_dir, prefix + EC.PFX_SUFFIX)\\n            with open(pfx_output_file_name, \\'wb\\') as pfx_file:\\n                pfx_file.write(pfx_data)\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting PFX cert ID: {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(id_str, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, pfx_output_file_name)\\n\\n    @staticmethod\\n    def get_cert_file_path(id_str, dir_path):\\n        return os.path.join(dir_path, id_str, \\'cert\\', id_str + EC.CERT_SUFFIX)\\n\\n    @staticmethod\\n    def get_pfx_file_path(id_str, dir_path):\\n        return os.path.join(dir_path, id_str, \\'cert\\', id_str + EC.PFX_SUFFIX)\\n\\n    def load_cert_from_file(self, id_str, cert_path, key_path, key_passphrase):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Could not load cert from file. Certificate already in chain. ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n        cert_dict = {}\\n        # Load cert\\n        try:\\n            with open(cert_path, \\'r\\') as cert_file:\\n                cert_content = cert_file.read()\\n                cert_dict[\\'cert\\'] = crypto.load_certificate(crypto.FILETYPE_PEM, cert_content)\\n        except Exception as ex:\\n            raise EdgeInvalidArgument(\\'Failed to load cert from %s. Error: %s\\' % (cert_path, ex), ex)\\n        # Load key\\n        try:\\n            with open(key_path, \\'r\\') as key_file:\\n                key_content = key_file.read()\\n                cert_dict[\\'key_pair\\'] = crypto.load_privatekey(crypto.FILETYPE_PEM, key_content, key_passphrase)\\n        except Exception as ex:\\n            raise EdgeInvalidArgument(\\n                \\'Failed to load private key from %s. Please check your passphase first. Error: %s\\' % (key_path, ex), ex)\\n        self._cert_chain[id_str] = cert_dict\\n\\n    def export_simulator_cert_artifacts_to_dir(self, id_str, dir_path):\\n        if Utils.check_if_directory_exists(dir_path) is False:\\n            msg = \\'Invalid export directory {0}\\'.format(dir_path)\\n            raise EdgeValueError(msg)\\n\\n        cert_dict = self._get_cert_dict(id_str)\\n        prefix = id_str\\n        try:\\n            path = os.path.realpath(dir_path)\\n            path = os.path.join(path, prefix)\\n            Utils.delete_dir(path)\\n            Utils.mkdir_if_needed(path)\\n            priv_dir = os.path.join(path, \\'private\\')\\n            Utils.mkdir_if_needed(priv_dir)\\n            os.chmod(priv_dir, 0o700)\\n            cert_dir = os.path.join(path, \\'cert\\')\\n            Utils.mkdir_if_needed(cert_dir)\\n\\n            # export the private key\\n            priv_key_file_name = prefix + \\'.key.pem\\'\\n            priv_key_file = os.path.join(priv_dir, priv_key_file_name)\\n            self._dump_cert_key(cert_dict, priv_key_file)\\n\\n            # export the cert\\n            cert_file_name = prefix + EC.CERT_SUFFIX\\n            cert_file = os.path.join(cert_dir, cert_file_name)\\n            current_cert_file_path = cert_file\\n            self._dump_cert_content(cert_dict, cert_file)\\n\\n            # export any chain certs\\n            if \\'ca_chain\\' in list(cert_dict.keys()):\\n                src_chain_cert_file = cert_dict[\\'ca_chain\\']\\n                cert_file_name = prefix + \\'-chain.cert.pem\\'\\n                cert_file = os.path.join(cert_dir, cert_file_name)\\n                copy2(src_chain_cert_file, cert_file)\\n\\n            # check if this is the root cert in the chain, i.e. issuer is itself\\n            if cert_dict[\\'issuer_id\\'] == id_str:\\n                cert_file_name = prefix + \\'-root.cert.pem\\'\\n                cert_file = os.path.join(cert_dir, cert_file_name)\\n                if \\'ca_root\\' in list(cert_dict.keys()):\\n                    src_root_cert_file = cert_dict[\\'ca_root\\']\\n                else:\\n                    src_root_cert_file = current_cert_file_path\\n                copy2(src_root_cert_file, cert_file)\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting certs for ID: {0}.\\\\n\\' \\\\\\n                  \\' Error seen when copying/exporting file {1}.\\' \\\\\\n                  \\' Errno: {2} Error: {3}\\'.format(id_str, ex.filename, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, path)\\n\\n    def export_device_ca_cert_artifacts_to_dir(self, id_str, dir_path):\\n        output_files = Utils.get_device_ca_file_paths(dir_path, id_str)\\n        cert_path = output_files[EC.CERT_SUFFIX]\\n        key_path = output_files[EC.KEY_SUFFIX]\\n        cert_dict = self._get_cert_dict(id_str)\\n        self._dump_cert_content(cert_dict, cert_path)\\n        self._dump_cert_key(cert_dict, key_path)\\n\\n    def chain_simulator_ca_certs(self, output_prefix, prefixes, certs_dir):\\n        try:\\n            output_dir = os.path.join(certs_dir, output_prefix)\\n            Utils.delete_dir(output_dir)\\n            Utils.mkdir_if_needed(output_dir)\\n            output_dir = os.path.join(output_dir, \\'cert\\')\\n            Utils.mkdir_if_needed(output_dir)\\n            output_file_name = os.path.join(output_dir, output_prefix + EC.CERT_SUFFIX)\\n            self._chain_ca_certs(output_file_name, prefixes, certs_dir, self._simulator_cert_file_path_gen)\\n        except IOError as ex:\\n            msg = \\'IO Error when creating chain cert: {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(output_file_name, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_file_name)\\n\\n    def chain_device_ca_certs(self, output_prefix, id_strs, certs_dir):\\n        cert_files = Utils.get_device_ca_file_paths(certs_dir, output_prefix)\\n        chain_path = cert_files[EC.CHAIN_CERT_SUFFIX]\\n        self._chain_ca_certs(chain_path, id_strs, certs_dir, self._device_ca_cert_file_path_gen)\\n\\n    def is_valid_certificate_subject(self, subject_dict):\\n        result = True\\n        for key in list(EdgeCertUtil._subject_validation_dict.keys()):\\n            try:\\n                field = subject_dict[key]\\n                if field is not None:\\n                    length_field = len(field)\\n                    min_len = EdgeCertUtil._subject_validation_dict[key][\\'MIN\\']\\n                    max_len = EdgeCertUtil._subject_validation_dict[key][\\'MAX\\']\\n                    if length_field < min_len or length_field > max_len:\\n                        result = False\\n                else:\\n                    result = False\\n            except KeyError:\\n                result = False\\n\\n            if result is False:\\n                break\\n        return result\\n\\n    def _create_csr(self, key_pair, **kwargs):\\n        csr = crypto.X509Req()\\n        subj = csr.get_subject()\\n        for key, value in list(kwargs.items()):\\n            if value:\\n                setattr(subj, key, value)\\n        csr.set_pubkey(key_pair)\\n        csr.sign(key_pair, EdgeCertUtil.DIGEST)\\n        return csr\\n\\n    def _create_cert_common(self,\\n                            csr,\\n                            issuer_cert,\\n                            validity_period):\\n        not_before, not_after = validity_period\\n        cert = crypto.X509()\\n        cert.set_serial_number(self._serial_number)\\n        cert.gmtime_adj_notBefore(not_before)\\n        cert.gmtime_adj_notAfter(not_after)\\n        cert.set_issuer(issuer_cert.get_subject())\\n        cert.set_subject(csr.get_subject())\\n        cert.set_pubkey(csr.get_pubkey())\\n        cert.set_version(2)\\n        return cert\\n\\n    def _create_ca_cert(self,\\n                        csr,\\n                        issuer_cert,\\n                        issuer_key_pair,\\n                        validity_period,\\n                        path_len_zero):\\n        cert = self._create_cert_common(csr, issuer_cert, validity_period)\\n        val = b\\'CA:TRUE\\'\\n        if path_len_zero:\\n            val += b\\', pathlen:0\\'\\n        extensions = []\\n        extensions.append(crypto.X509Extension(b\\'basicConstraints\\',\\n                                               critical=True, value=val))\\n        extensions.append(crypto.X509Extension(b\\'subjectKeyIdentifier\\',\\n                                               False,\\n                                               b\\'hash\\',\\n                                               subject=cert))\\n        extensions.append(crypto.X509Extension(b\\'keyUsage\\',\\n                                               critical=True,\\n                                               value=b\\'digitalSignature, cRLSign, keyCertSign\\'))\\n        # authorityKeyIdentifier requires subjectKeyIdentifier in issuer cert, add it first\\n        cert.add_extensions(extensions)\\n\\n        del extensions[:]\\n        extensions.append(crypto.X509Extension(b\\'authorityKeyIdentifier\\',\\n                                               False,\\n                                               b\\'keyid:always,issuer:always\\',\\n                                               issuer=issuer_cert if isinstance(issuer_cert, crypto.X509) else cert))\\n        cert.add_extensions(extensions)\\n        cert.sign(issuer_key_pair, EdgeCertUtil.DIGEST)\\n        return cert\\n\\n    def _create_server_cert(self,\\n                            csr,\\n                            issuer_cert,\\n                            issuer_key_pair,\\n                            validity_period,\\n                            hostname):\\n        cert = self._create_cert_common(csr,\\n                                        issuer_cert,\\n                                        validity_period)\\n\\n        extensions = []\\n        extensions.append(crypto.X509Extension(b\\'basicConstraints\\',\\n                                               critical=False,\\n                                               value=b\\'CA:FALSE\\'))\\n        altDns = \\',\\'.join([\\'DNS:localhost\\', \\'DNS:{0}\\'.format(hostname)]).encode(\\'utf-8\\')\\n        extensions.append(crypto.X509Extension(b\\'subjectAltName\\',\\n                                               critical=False,\\n                                               value=altDns))\\n        cert.add_extensions(extensions)\\n        cert.sign(issuer_key_pair, EdgeCertUtil.DIGEST)\\n        return cert\\n\\n    def _create_key_pair(self, private_key_type, key_bit_len):\\n        key_pair = crypto.PKey()\\n        key_pair.generate_key(EdgeCertUtil._type_dict[private_key_type], key_bit_len)\\n        return key_pair\\n\\n    def _get_maximum_validity_days(self, not_after_ts_asn1, validity_days_from_now):\\n        result = 0\\n        try:\\n            expiration_date = datetime.strptime(not_after_ts_asn1.decode(\\'utf-8\\'), \"%Y%m%d%H%M%SZ\")\\n            expires_in = expiration_date - datetime.now()\\n            if expires_in.days > 0:\\n                result = min(expires_in.days, validity_days_from_now)\\n            return result\\n        except Exception:\\n            msg = \\'Certificate date format incompatible {0}\\'.format(not_after_ts_asn1)\\n            raise EdgeValueError(msg)\\n\\n    def _get_kwargs_validity(self, **kwargs):\\n        validity_days_from_now = 365\\n        min_validity = EdgeCertUtil.MIN_VALIDITY_DAYS\\n        max_validity = EdgeCertUtil.MAX_VALIDITY_DAYS\\n        kwarg_key = \\'validity_days_from_now\\'\\n        if kwarg_key in kwargs:\\n            validity_days_from_now = kwargs[kwarg_key]\\n\\n        if validity_days_from_now < min_validity or validity_days_from_now > max_validity:\\n            msg = \\'Certificate validity days needs to be greater than or equal to {0} \\' \\\\\\n                  \\'and less than {1} days. Value provided: {2}\\'. format(min_validity,\\n                                                                        max_validity,\\n                                                                        validity_days_from_now)\\n            raise EdgeValueError(msg)\\n\\n        return validity_days_from_now\\n\\n    def _validate_string_length(self, test_string, min_length, max_length):\\n        length = len(test_string)\\n        if min_length > length or length > max_length:\\n            return False\\n        return True\\n\\n    def _get_kwargs_passphrase(self, **kwargs):\\n        passphrase = None\\n        min_length = EdgeCertUtil.MIN_PASSPHRASE_LENGTH\\n        max_length = EdgeCertUtil.MAX_PASSPHRASE_LENGTH\\n        kwarg_key = \\'passphrase\\'\\n        if kwarg_key in kwargs:\\n            passphrase = kwargs[kwarg_key]\\n        if passphrase is not None:\\n            if self._validate_string_length(passphrase, min_length, max_length) is False:\\n                msg = \\'Private key passphrase needs to greater than or equal to {0} and less \\' \\\\\\n                      \\'than {1} characters.\\'.format(min_length, max_length)\\n                raise EdgeValueError(msg)\\n        return passphrase\\n\\n    def _get_kwargs_string(self, kwarg_key, min_length, max_length, default_str=None, **kwargs):\\n        result_str = default_str\\n        if kwarg_key in kwargs:\\n            result_str = kwargs[kwarg_key]\\n        if result_str is not None:\\n            if self._validate_string_length(result_str, min_length, max_length) is False:\\n                msg = \\'KWarg[{0}]:{1} string length needs to greater than or equal to {2} and \\' \\\\\\n                      \\'less than {3} characters.\\'.format(kwarg_key, result_str,\\n                                                         min_length, max_length)\\n                raise EdgeValueError(msg)\\n        return result_str\\n\\n    def _dump_cert_content(self, cert_dict, output_path):\\n        Utils.mkdir_if_needed(os.path.dirname(output_path))\\n        cert_obj = cert_dict[\\'cert\\']\\n        try:\\n            with open(output_path, \\'w\\') as output_file:\\n                output_file.write(crypto.dump_certificate(crypto.FILETYPE_PEM,\\n                                                          cert_obj).decode(\\'utf-8\\'))\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting certs.\\\\n\\' \\\\\\n                  \\' Error seen when exporting file {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(ex.filename, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_path)\\n\\n    def _dump_cert_key(self, cert_dict, output_path):\\n        Utils.mkdir_if_needed(os.path.dirname(output_path))\\n        try:\\n            if \\'key_file\\' in cert_dict:\\n                key_file_path = cert_dict[\\'key_file\\']\\n                copy2(key_file_path, output_path)\\n            else:\\n                key_obj = cert_dict[\\'key_pair\\']\\n                key_passphrase = cert_dict[\\'passphrase\\']\\n                passphrase = None\\n                if key_passphrase and key_passphrase != \\'\\':\\n                    passphrase = key_passphrase.encode(\\'utf-8\\')\\n                cipher = None\\n                if passphrase:\\n                    cipher = \\'aes256\\'\\n                with open(output_path, \\'w\\') as output_file:\\n                    output_file.write(crypto.dump_privatekey(crypto.FILETYPE_PEM,\\n                                                             key_obj,\\n                                                             cipher=cipher,\\n                                                             passphrase=passphrase).decode(\\'utf-8\\'))\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting certs.\\\\n\\' \\\\\\n                  \\' Error seen when exporting file {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(ex.filename, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_path)\\n\\n    def _get_cert_dict(self, id_str):\\n        if id_str not in list(self._cert_chain.keys()):\\n            msg = \\'Certificate not in chain. ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n        return self._cert_chain[id_str]\\n\\n    def _chain_ca_certs(self, output_path, id_strs, certs_dir, cert_file_path_gen):\\n        file_names = []\\n        for id_str in id_strs:\\n            cert_dict = self._get_cert_dict(id_str)\\n            if \\'ca_chain\\' in list(cert_dict.keys()):\\n                # this cert contains an existing certificate chain\\n                # pick the chain instead of the actual cert\\n                cert_file_name = id_str + \\'-chain.cert.pem\\'\\n            else:\\n                cert_file_name = id_str + EC.CERT_SUFFIX\\n            cert_file = cert_file_path_gen(id_str, cert_file_name, certs_dir)\\n            path = os.path.realpath(cert_file)\\n            file_names.append(path)\\n        try:\\n            with open(output_path, \\'wb\\') as output_file:\\n                for file_name in file_names:\\n                    with open(file_name, \\'rb\\') as input_file:\\n                        output_file.write(input_file.read())\\n        except IOError as ex:\\n            msg = \\'IO Error when creating chain cert: {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(output_path, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_path)\\n\\n    def _simulator_cert_file_path_gen(self, id_str, cert_file_name, certs_dir):\\n        return os.path.join(certs_dir, id_str, \\'cert\\', cert_file_name)\\n\\n    def _device_ca_cert_file_path_gen(self, id_str, cert_file_name, certs_dir):\\n        return os.path.join(certs_dir, cert_file_name)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport json\\nimport os\\nimport sys\\nimport re\\nfrom functools import wraps\\n\\nimport click\\n\\nfrom . import configs, decorators, telemetry\\nfrom .constants import EdgeConstants\\nfrom .edgecert import EdgeCert\\nfrom .edgemanager import EdgeManager\\nfrom .hostplatform import HostPlatform\\nfrom .output import Output\\nfrom .utils import Utils\\nfrom .errors import EdgeError, InvalidConfigError\\n\\nCONTEXT_SETTINGS = dict(help_option_names=[\\'-h\\', \\'--help\\'], max_content_width=120)\\noutput = Output()\\n\\nCONN_STR = \\'connectionString\\'\\nCERT_PATH = \\'certPath\\'\\nGATEWAY_HOST = \\'gatewayhost\\'\\nDOCKER_HOST = \\'DOCKER_HOST\\'\\nHUB_CONN_STR = \\'iothubConnectionString\\'\\n\\n# a set of parameters whose value should be logged as given\\nPARAMS_WITH_VALUES = {\\'edge_runtime_version\\'}\\n\\n@decorators.suppress_all_exceptions()\\ndef _parse_params(*args, **kwargs):\\n    params = []\\n    for key, value in kwargs.items():\\n        if (value is None) or (key in PARAMS_WITH_VALUES):\\n            params.append(\\'{0}={1}\\'.format(key, value))\\n        else:\\n            params.append(\\'{0}!=None\\'.format(key))\\n    return params\\n\\n\\ndef _send_failed_telemetry(e):\\n    output.error(str(e))\\n    telemetry.fail(str(e), \\'Command failed\\')\\n    telemetry.flush()\\n\\n\\ndef _with_telemetry(func):\\n    @wraps(func)\\n    def _wrapper(*args, **kwargs):\\n        configs.check_firsttime()\\n        params = _parse_params(*args, **kwargs)\\n        telemetry.start(func.__name__, params)\\n        try:\\n            value = func(*args, **kwargs)\\n            telemetry.success()\\n            telemetry.flush()\\n            return value\\n        except InvalidConfigError as e:\\n            _send_failed_telemetry(e)\\n            sys.exit(2)\\n        except Exception as e:\\n            _send_failed_telemetry(e)\\n            sys.exit(1)\\n\\n    return _wrapper\\n\\n\\ndef _parse_config_json():\\n    try:\\n        config_file = HostPlatform.get_config_file_path()\\n\\n        if not Utils.check_if_file_exists(config_file):\\n            raise ValueError(\\'Cannot find config file. Please run `{0}` first.\\'.format(_get_setup_command()))\\n\\n        with open(config_file) as f:\\n            try:\\n                config_json = json.load(f)\\n\\n                connection_str = config_json[CONN_STR]\\n                cert_path = config_json[CERT_PATH]\\n                gatewayhost = config_json[GATEWAY_HOST]\\n                hub_conn_str = config_json.get(HUB_CONN_STR)\\n                return EdgeManager(connection_str, gatewayhost, cert_path, hub_conn_str)\\n\\n            except (ValueError, KeyError):\\n                raise ValueError(\\'Invalid config file. Please run `{0}` again.\\'.format(_get_setup_command()))\\n    except Exception as e:\\n        raise InvalidConfigError(str(e))\\n\\n\\ndef _get_setup_command():\\n    return \\'{0}iotedgehubdev setup -c \"<edge-device-connection-string>\"\\'.format(\\'\\' if os.name == \\'nt\\' else \\'sudo \\')\\n\\n\\n@click.group(context_settings=CONTEXT_SETTINGS, invoke_without_command=True)\\n@click.version_option()\\ndef main():\\n    ctx = click.get_current_context()\\n    if ctx.invoked_subcommand is None:\\n        click.echo(ctx.get_help())\\n        sys.exit(0)\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\\'Setup the IoT Edge Simulator. This must be done before starting.\\')\\n@click.option(\\'--connection-string\\',\\n              \\'-c\\',\\n              required=True,\\n              help=\\'Set Azure IoT Edge device connection string. Note: Use double quotes when supplying this input.\\')\\n@click.option(\\'--gateway-host\\',\\n              \\'-g\\',\\n              required=False,\\n              default=Utils.get_hostname(),\\n              show_default=True,\\n              help=\\'GatewayHostName value for the module to connect.\\')\\n@click.option(\\'--iothub-connection-string\\',\\n              \\'-i\\',\\n              required=False,\\n              help=\\'Set Azure IoT Hub connection string. Note: Use double quotes when supplying this input.\\')\\n@_with_telemetry\\ndef setup(connection_string, gateway_host, iothub_connection_string):\\n    try:\\n        gateway_host = gateway_host.lower()\\n        certDir = HostPlatform.get_default_cert_path()\\n        Utils.parse_connection_strs(connection_string, iothub_connection_string)\\n        if iothub_connection_string is None:\\n            configDict = {\\n                CONN_STR: connection_string,\\n                CERT_PATH: certDir,\\n                GATEWAY_HOST: gateway_host\\n            }\\n        else:\\n            configDict = {\\n                CONN_STR: connection_string,\\n                CERT_PATH: certDir,\\n                GATEWAY_HOST: gateway_host,\\n                HUB_CONN_STR: iothub_connection_string\\n            }\\n\\n        fileType = \\'edgehub.config\\'\\n        Utils.mkdir_if_needed(certDir)\\n        edgeCert = EdgeCert(certDir, gateway_host)\\n        edgeCert.generate_self_signed_certs()\\n        configFile = HostPlatform.get_config_file_path()\\n        Utils.delete_file(configFile, fileType)\\n        Utils.mkdir_if_needed(HostPlatform.get_config_path())\\n        configJson = json.dumps(configDict, indent=2, sort_keys=True)\\n        Utils.create_file(configFile, configJson, fileType)\\n\\n        dataDir = HostPlatform.get_share_data_path()\\n        Utils.mkdir_if_needed(dataDir)\\n        os.chmod(dataDir, 0o755)\\n\\n        with open(EdgeManager.COMPOSE_FILE, \\'w\\') as f:\\n            f.write(\\'version: \\\\\\'3.6\\\\\\'\\')\\n        os.chmod(EdgeManager.COMPOSE_FILE, 0o777)\\n        output.info(\\'Setup IoT Edge Simulator successfully.\\')\\n    except Exception as e:\\n        raise e\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               # short_help hack to prevent Click truncating help text (https://github.com/pallets/click/issues/486)\\n               short_help=\\'Get the module credentials such as connection string and certificate file path.\\',\\n               help=\\'Get the module credentials such as connection string and certificate file path.\\')\\n@click.option(\\'--modules\\',\\n              \\'-m\\',\\n              required=False,\\n              default=\\'target\\',\\n              show_default=True,\\n              help=\\'Specify the vertical-bar-separated (\"|\") module names to get credentials for, e.g., \"module1|module2\". \\'\\n                   \\'Note: Use double quotes when supplying this input.\\')\\n@click.option(\\'--local\\',\\n              \\'-l\\',\\n              required=False,\\n              is_flag=True,\\n              default=False,\\n              show_default=True,\\n              help=\\'Set `localhost` to `GatewayHostName` for module to run on host natively.\\')\\n@click.option(\\'--output-file\\',\\n              \\'-o\\',\\n              required=False,\\n              show_default=True,\\n              help=\\'Specify the output file to save the connection string. If the file exists, the content will be overwritten.\\')\\n@_with_telemetry\\ndef modulecred(modules, local, output_file):\\n    edge_manager = _parse_config_json()\\n\\n    if edge_manager:\\n        modules = [module.strip() for module in modules.strip().split(\\'|\\')]\\n        credential = edge_manager.outputModuleCred(modules, local, output_file)\\n        output.info(credential[0])\\n        output.info(credential[1])\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Start the IoT Edge Simulator.\")\\n@click.option(\\'--inputs\\',\\n              \\'-i\\',\\n              required=False,\\n              help=\\'Start IoT Edge Simulator in single module mode \\'\\n                   \\'using the specified comma-separated inputs of the target module, e.g., `input1,input2`.\\')\\n@click.option(\\'--port\\',\\n              \\'-p\\',\\n              required=False,\\n              default=53000,\\n              show_default=True,\\n              help=\\'Port of the service for sending message.\\')\\n@click.option(\\'--deployment\\',\\n              \\'-d\\',\\n              required=False,\\n              help=\\'Start IoT Edge Simulator in solution mode using the specified deployment manifest.\\')\\n@click.option(\\'--verbose\\',\\n              \\'-v\\',\\n              required=False,\\n              is_flag=True,\\n              default=False,\\n              show_default=True,\\n              help=\\'Show the solution container logs.\\')\\n@click.option(\\'--host\\',\\n              \\'-H\\',\\n              required=False,\\n              help=\\'Docker daemon socket to connect to.\\')\\n@click.option(\\'--environment\\',\\n              \\'-e\\',\\n              required=False,\\n              multiple=True,\\n              help=\\'Environment variables for single module mode, e.g., `-e \"Env1=Value1\" -e \"Env2=Value2\"`.\\')\\n@click.option(\\'--edge-runtime-version\\',\\n              \\'-er\\',\\n              required=False,\\n              multiple=False,\\n              default=\\'1.2\\',\\n              show_default=True,\\n              help=\\'EdgeHub image version. Currently supported tags 1.0x, 1.1x, or 1.2x\\')\\n@_with_telemetry\\ndef start(inputs, port, deployment, verbose, host, environment, edge_runtime_version):\\n    edge_manager = _parse_config_json()\\n\\n    if edge_manager:\\n        if host is not None:\\n            os.environ[DOCKER_HOST] = str(host)\\n\\n        hostname_hash, suffix = Utils.hash_connection_str_hostname(edge_manager.hostname)\\n        telemetry.add_extra_props({\\'iothubhostname\\': hostname_hash, \\'iothubhostnamesuffix\\': suffix})\\n\\n        if inputs is None and deployment is not None:\\n            if len(environment) > 0:\\n                output.info(\\'Environment variables are ignored in solution mode.\\')\\n\\n            if len(edge_runtime_version) > 0:\\n                output.info(\\'edgeHub image version is ignored in solution mode.\\')\\n\\n            with open(deployment) as json_file:\\n                json_data = json.load(json_file)\\n                if \\'modulesContent\\' in json_data:\\n                    module_content = json_data[\\'modulesContent\\']\\n                elif \\'moduleContent\\' in json_data:\\n                    module_content = json_data[\\'moduleContent\\']\\n            edge_manager.start_solution(module_content, verbose, output)\\n            if not verbose:\\n                output.info(\\'IoT Edge Simulator has been started in solution mode.\\')\\n        else:\\n            if edge_runtime_version is not None:\\n                # The only validated versions are 1.0, 1.1, and 1.2 variants, hence the current limitation\\n                if re.match(r\\'^(1\\\\.0)|(1\\\\.1)|(1\\\\.2)\\', edge_runtime_version) is None:\\n                    raise ValueError(\\'-edge-runtime-version `{0}` is not valid.\\'.format(edge_runtime_version))\\n\\n            if deployment is not None:\\n                output.info(\\'Deployment manifest is ignored when inputs are present.\\')\\n            if inputs is None:\\n                input_list = [\\'input1\\']\\n            else:\\n                input_list = [input_.strip() for input_ in inputs.strip().split(\\',\\')]\\n\\n            for env in environment:\\n                if re.match(r\\'^[a-zA-Z][a-zA-Z0-9_]*?=.*$\\', env) is None:\\n                    raise ValueError(\\'Environment variable: `{0}` is not valid.\\'.format(env))\\n\\n            edge_manager.start_singlemodule(input_list, port, environment, edge_runtime_version)\\n\\n            data = \\'--data \\\\\\'{{\"inputName\": \"{0}\",\"data\":\"hello world\"}}\\\\\\'\\'.format(input_list[0])\\n            url = \\'http://localhost:{0}/api/v1/messages\\'.format(port)\\n            curl_msg = \\'        curl --header \"Content-Type: application/json\" --request POST {0} {1}\\'.format(data, url)\\n            output.info(\\'IoT Edge Simulator has been started in single module mode.\\')\\n            output.info(\\'Please run `iotedgehubdev modulecred` to get credential to connect your module.\\')\\n            output.info(\\'And send message through:\\')\\n            output.line()\\n            output.echo(curl_msg, \\'green\\')\\n            output.line()\\n            output.info(\\n                \\'Please refer to https://github.com/Azure/iot-edge-testing-utility/blob/master/swagger.json\\'\\n                \\' for detail schema\\')\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Stop the IoT Edge Simulator.\")\\n@click.option(\\'--host\\',\\n              \\'-H\\',\\n              required=False,\\n              help=\\'Docker daemon socket to connect to\\')\\n@_with_telemetry\\ndef stop(host):\\n    if host is not None:\\n        os.environ[DOCKER_HOST] = str(host)\\n    EdgeManager.stop()\\n    output.info(\\'IoT Edge Simulator has been stopped successfully.\\')\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Determine whether config file is valid.\")\\n@_with_telemetry\\ndef validateconfig():\\n    _parse_config_json()\\n    output.info(\\'Config file is valid.\\')\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Create IoT Edge device CA\")\\n@click.option(\\'--output-dir\\',\\n              \\'-o\\',\\n              required=False,\\n              default=\".\",\\n              help=\\'The output folder of generated certs. \\'\\n              \\'The tool will create a certs folder under given path to store the certs.\\')\\n@click.option(\\'--valid-days\\',\\n              \\'-d\\',\\n              required=False,\\n              default=90,\\n              show_default=True,\\n              help=\\'Days before cert expires.\\')\\n@click.option(\\'--force\\',\\n              \\'-f\\',\\n              required=False,\\n              is_flag=True,\\n              default=False,\\n              show_default=True,\\n              help=\\'Whether overwrite existing cert files.\\')\\n@click.option(\\'--trusted-ca\\',\\n              \\'-c\\',\\n              required=False,\\n              help=\\'Path of your own trusted ca used to sign IoT Edge device ca. \\'\\n              \\'Please also provide trsuted ca private key and related passphase (if have).\\'\\n              )\\n@click.option(\\'--trusted-ca-key\\',\\n              \\'-k\\',\\n              required=False,\\n              help=\\'Path of your own trusted ca private key used to sign IoT Edge device ca. \\'\\n              \\'Please also provide trusted ca and related passphase (if have).\\')\\n@click.option(\\'--trusted-ca-key-passphase\\',\\n              \\'-p\\',\\n              required=False,\\n              help=\\'Passphase of your own trusted ca private key.\\')\\n@_with_telemetry\\ndef generatedeviceca(output_dir, valid_days, force, trusted_ca, trusted_ca_key, trusted_ca_key_passphase):\\n    try:\\n        output_dir = os.path.abspath(os.path.join(output_dir, EdgeConstants.CERT_FOLDER))\\n        if trusted_ca_key_passphase:\\n            trusted_ca_key_passphase = trusted_ca_key_passphase.encode()  # crypto requires byte string\\n        # Check whether create new trusted CA and generate files to be created\\n        output_files = list(Utils.get_device_ca_file_paths(output_dir, EdgeConstants.DEVICE_CA_ID).values())\\n        if trusted_ca and trusted_ca_key:\\n            output.info(\\'Trusted CA (certification authority) and trusted CA key were provided.\\'\\n                        \\' Load trusted CA from given files.\\')\\n        else:\\n            output.info(\\'Trusted CA (certification authority) and Trusted CA key were not provided.\\'\\n                        \\' Will create new trusted CA.\\')\\n            root_ca_files = Utils.get_device_ca_file_paths(output_dir, EdgeConstants.ROOT_CA_ID)\\n            output_files.append(root_ca_files[EdgeConstants.CERT_SUFFIX])\\n            output_files.append(root_ca_files[EdgeConstants.KEY_SUFFIX])\\n        # Check whether the output files exist\\n        existing_files = []\\n        for file in output_files:\\n            if os.path.exists(file):\\n                existing_files.append(file)\\n        if len(existing_files) > 0:\\n            if force:\\n                output.info(\\'Following cert files already exist and will be overwritten: %s\\' % existing_files)\\n            else:\\n                raise EdgeError(\\'Following cert files already exist. \\'\\n                                \\'You can use --force option to overwrite existing files: %s\\' % existing_files)\\n        # Generate certs\\n        edgeCert = EdgeCert(output_dir, \\'\\')\\n        edgeCert.generate_device_ca(valid_days, force, trusted_ca, trusted_ca_key, trusted_ca_key_passphase)\\n        output.info(\\'Successfully generated device CA. Please find the generated certs at %s\\' % output_dir)\\n    except Exception as e:\\n        raise e\\n\\n\\nmain.add_command(setup)\\nmain.add_command(modulecred)\\nmain.add_command(start)\\nmain.add_command(stop)\\nmain.add_command(validateconfig)\\nmain.add_command(generatedeviceca)\\n\\nif __name__ == \"__main__\":\\n    main()\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\nimport os\\nimport re\\n\\nfrom jsonpath_rw import parse\\n\\nfrom .constants import EdgeConstants\\n\\n\\nclass CreateOptionParser(object):\\n    def __init__(self, create_option):\\n        self.create_option = create_option\\n\\n    def parse_create_option(self):\\n        ret = {}\\n        for compose_key in COMPOSE_KEY_CREATE_OPTION_MAPPING:\\n            create_option_value = self.get_create_option_value(compose_key)\\n            if create_option_value:\\n                parser_func = COMPOSE_KEY_CREATE_OPTION_MAPPING[compose_key][\\'parser_func\\']\\n                ret[compose_key] = parser_func(create_option_value)\\n        return ret\\n\\n    def get_create_option_value(self, compose_key):\\n        create_option_value_dict = {}\\n        for API_key, API_jsonpath in COMPOSE_KEY_CREATE_OPTION_MAPPING[compose_key][\\'API_Info\\'].items():\\n            jsonpath_expr = parse(API_jsonpath)\\n            value_list = jsonpath_expr.find(self.create_option)\\n            if value_list:\\n                create_option_value_dict[API_key] = value_list[0].value\\n        return create_option_value_dict\\n\\n\\ndef service_parser_naive(create_options_details):\\n    return list(create_options_details.values())[0]\\n\\n\\ndef service_parser_expose(create_options_details):\\n    return list(create_options_details[\\'ExposedPorts\\'].keys())\\n\\n\\ndef service_parser_command(create_options_details):\\n    cmd = create_options_details[\\'Cmd\\']\\n    if not isinstance(cmd, list):\\n        return cmd\\n    return \\' \\'.join(cmd).strip()\\n\\n\\ndef service_parser_healthcheck(create_options_details):\\n    healthcheck_config = create_options_details[\\'Healthcheck\\']\\n    try:\\n        return {\\n            \\'test\\': healthcheck_config[\\'Test\\'],\\n            \\'interval\\': time_ns_ms(healthcheck_config[\\'Interval\\']),\\n            \\'timeout\\': time_ns_ms(healthcheck_config[\\'Timeout\\']),\\n            \\'retries\\': healthcheck_config[\\'Retries\\'],\\n            \\'start_period\\': time_ns_ms(healthcheck_config[\\'StartPeriod\\'])\\n        }\\n    except KeyError as err:\\n        raise KeyError(\\'Missing key : {0} in Healthcheck\\'.format(err))\\n\\n\\ndef service_parser_stop_timeout(create_options_details):\\n    try:\\n        return str(int(create_options_details[\\'StopTimeout\\'])) + \\'s\\'\\n    except TypeError:\\n        raise TypeError(\\'StopTimeout should be an integer.\\')\\n\\n\\ndef service_parser_hostconfig_devices(create_options_details):\\n    devices_list = []\\n    for device in create_options_details[\\'Devices\\']:\\n        try:\\n            devices_list.append(\"{0}:{1}:{2}\".format(device[\\'PathOnHost\\'],\\n                                                     device[\\'PathInContainer\\'], device[\\'CgroupPermissions\\']))\\n        except KeyError as err:\\n            raise KeyError(\\'Missing key : {0} in HostConfig.Devices.\\'.format(err))\\n    return devices_list\\n\\n\\ndef service_parser_hostconfig_restart(create_options_details):\\n    restart_config = create_options_details[\\'RestartPolicy\\']\\n    ret = \"\"\\n    if restart_config[\\'Name\\'] == \"\":\\n        ret = \"no\"\\n    elif restart_config[\\'Name\\'] == \"on-failure\":\\n        try:\\n            ret = \"on-failure:{0}\".format(restart_config[\\'MaximumRetryCount\\'])\\n        except KeyError as err:\\n            raise KeyError(\\'Missing key : {0} in HostConfig.RestartPolicy.\\'.format(err))\\n    elif restart_config[\\'Name\\'] == \"always\" or restart_config[\\'Name\\'] == \"unless-stopped\":\\n        ret = restart_config[\\'Name\\']\\n    else:\\n        raise ValueError(\"RestartPolicy Name should be one of \\'\\', \\'always\\', \\'unless-stopped\\', \\'on-failure\\'\")\\n    return ret\\n\\n\\ndef service_parser_hostconfig_ulimits(create_options_details):\\n    ulimits_dict = {}\\n    for ulimit in create_options_details[\\'Ulimits\\']:\\n        try:\\n            ulimits_dict[ulimit[\\'Name\\']] = {\\n                \\'soft\\': ulimit[\\'Soft\\'],\\n                \\'hard\\': ulimit[\\'Hard\\']\\n            }\\n        except KeyError as err:\\n            raise KeyError(\\'Missing key : {0} in HostConfig.Ulimits\\'.format(err))\\n    return ulimits_dict\\n\\n\\ndef service_parser_hostconfig_logging(create_options_details):\\n    try:\\n        logging_dict = {\\n            \\'driver\\': create_options_details[\\'LogConfig\\'][\\'Type\\'],\\n            \\'options\\': create_options_details[\\'LogConfig\\'][\\'Config\\']\\n        }\\n    except KeyError as err:\\n        raise KeyError(\\'Missing key : {0} in HostConfig.LogConfig\\'.format(err))\\n    return logging_dict\\n\\n\\ndef service_parser_hostconfig_ports(create_options_details):\\n    ports_list = []\\n    for container_port, host_ports in create_options_details[\\'PortBindings\\'].items():\\n        for host_port_info in host_ports:\\n            host_port = \"\"\\n            if \\'HostIp\\' in host_port_info and \\'HostPort\\' in host_port_info:\\n                host_port = \"{0}:{1}\".format(host_port_info[\\'HostIp\\'], host_port_info[\\'HostPort\\'])\\n            elif \\'HostIp\\' in host_port_info:\\n                host_port = host_port_info[\\'HostIp\\']\\n            elif \\'HostPort\\' in host_port_info:\\n                host_port = host_port_info[\\'HostPort\\']\\n            ports_list.append(\"{0}:{1}\".format(host_port, container_port))\\n    return ports_list\\n\\n\\ndef service_parser_networks(create_options_details):\\n    networks_dict = {}\\n    for nw, nw_config in create_options_details[\\'NetworkingConfig\\'].items():\\n        networks_dict[nw] = {}\\n        if \\'Aliases\\' in nw_config:\\n            networks_dict[nw][\\'aliases\\'] = nw_config[\\'Aliases\\']\\n        if \\'IPAMConfig\\' in nw_config:\\n            if \\'IPv4Address\\' in nw_config[\\'IPAMConfig\\']:\\n                networks_dict[nw][\\'ipv4_address\\'] = nw_config[\\'IPAMConfig\\'][\\'IPv4Address\\']\\n            if \\'IPv6Address\\' in nw_config[\\'IPAMConfig\\']:\\n                networks_dict[nw][\\'ipv6_address\\'] = nw_config[\\'IPAMConfig\\'][\\'IPv6Address\\']\\n    return networks_dict\\n\\n\\ndef service_parser_volumes(create_options_details):\\n    volumes_list = []\\n    for mount in create_options_details.get(\\'Mounts\\', []):\\n        try:\\n            volume_info = {\\n                \\'target\\': mount[\\'Target\\'],\\n                \\'type\\': mount[\\'Type\\']\\n            }\\n            if mount[\\'Type\\'] == \\'volume\\' or mount[\\'Type\\'] == \\'bind\\':\\n                volume_info[\\'source\\'] = mount[\\'Source\\']\\n            if \\'ReadOnly\\' in mount:\\n                volume_info[\\'read_only\\'] = mount[\\'ReadOnly\\']\\n\\n            if mount[\\'Type\\'] == \\'volume\\' and \\'VolumeOptions\\' in mount:\\n                if \\'NoCopy\\' in mount[\\'VolumeOptions\\']:\\n                    volume_info[\\'volume\\'] = {\\n                        \\'nocopy\\': mount[\\'VolumeOptions\\'][\\'NoCopy\\']\\n                    }\\n            if mount[\\'Type\\'] == \\'bind\\' and \\'BindOptions\\' in mount:\\n                if \\'Propagation\\' in mount[\\'BindOptions\\']:\\n                    volume_info[\\'bind\\'] = {\\n                        \\'propagation\\': mount[\\'BindOptions\\'][\\'Propagation\\']\\n                    }\\n            if mount[\\'Type\\'] == \\'tmpfs\\' and \\'TmpfsOptions\\' in mount:\\n                if \\'SizeBytes\\' in mount[\\'TmpfsOptions\\']:\\n                    volume_info[\\'tmpfs\\'] = {\\n                        \\'size\\': mount[\\'TmpfsOptions\\'][\\'SizeBytes\\']\\n                    }\\n        except KeyError as e:\\n            raise KeyError(\\'Missing key {0} in create option HostConfig Mounts.\\'.format(e))\\n        volumes_list.append(volume_info)\\n\\n    for bind in create_options_details.get(\\'Binds\\', []):\\n        target = None\\n\\n        # Binds should be in the format [source:]destination[:mode]\\n        # Windows format and LCOW format are more strict than Linux format due to colons in Windows paths,\\n        # so match with them first\\n        match = re.match(EdgeConstants.MOUNT_WIN_REGEX, bind) or re.match(EdgeConstants.MOUNT_LCOW_REGEX, bind)\\n        if match is not None:\\n            source = match.group(\\'source\\') or \\'\\'\\n            target = match.group(\\'destination\\')\\n            read_only = match.group(\\'mode\\') == \\'ro\\'\\n        else:\\n            # Port of Docker daemon\\n            # https://github.com/docker/docker-ce/blob/1c27a55b6259743f35549e96d06334a53d0c0549/components/engine/volume/mounts/linux_parser.go#L18-L28\\n            parts = bind.split(\\':\\')\\n            if len(parts) == 2 or (len(parts) == 3 and parts[2] in (\\'ro\\', \\'rw\\', \\'\\')):\\n                if parts[0] != \\'\\':\\n                    source = parts[0]\\n                    target = parts[1]\\n                    read_only = len(parts) == 3 and parts[2] == \\'ro\\'\\n\\n        if target is not None:\\n            volume_info = {\\n                \\'type\\': \\'bind\\' if source and os.path.isabs(source) else \\'volume\\',\\n                \\'source\\': source,\\n                \\'target\\': target\\n            }\\n            if read_only:\\n                volume_info[\\'read_only\\'] = True\\n            volumes_list.append(volume_info)\\n        else:\\n            raise ValueError(\\'Invalid create option Binds: {0}\\'.format(bind))\\n\\n    return volumes_list\\n\\n\\ndef time_ns_ms(ns):\\n    if ns != 0 and ns < 1000000:\\n        raise ValueError(\\'The time should be 0 or at least 1000000 (1 ms)\\')\\n    return str(int(ns / 1000000)) + \\'ms\\'\\n\\n\\n\\'\\'\\'\\nThe mapping relationship between docker compose key and create option API key\\n\\'docker compose key\\': {\\'API_Info\\': {\\'API key\\':\\'API jsonpath\\'}, \\'parser_func\\': parser_func},\\n\\'\\'\\'\\nCOMPOSE_KEY_CREATE_OPTION_MAPPING = {\\n    \\'hostname\\': {\\'API_Info\\': {\\'Hostname\\': \"$[\\'Hostname\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'domainname\\': {\\'API_Info\\': {\\'Domainname\\': \"$[\\'Domainname\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'user\\': {\\'API_Info\\': {\\'User\\': \"$[\\'User\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'expose\\': {\\'API_Info\\': {\\'ExposedPorts\\': \"$[\\'ExposedPorts\\']\"}, \\'parser_func\\': service_parser_expose},\\n    \\'tty\\': {\\'API_Info\\': {\\'Tty\\': \"$[\\'Tty\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'environment\\': {\\'API_Info\\': {\\'Env\\': \"$[\\'Env\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'command\\': {\\'API_Info\\': {\\'Cmd\\': \"$[\\'Cmd\\']\"}, \\'parser_func\\': service_parser_command},\\n    \\'healthcheck\\': {\\'API_Info\\': {\\'Healthcheck\\': \"$[\\'Healthcheck\\']\"}, \\'parser_func\\': service_parser_healthcheck},\\n    \\'image\\': {\\'API_Info\\': {\\'Image\\': \"$[\\'Image\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'working_dir\\': {\\'API_Info\\': {\\'WorkingDir\\': \"$[\\'WorkingDir\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'entrypoint\\': {\\'API_Info\\': {\\'Entrypoint\\': \"$[\\'Entrypoint\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'mac_address\\': {\\'API_Info\\': {\\'MacAddress\\': \"$[\\'MacAddress\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'labels\\': {\\'API_Info\\': {\\'Labels\\': \"$[\\'Labels\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'stop_signal\\': {\\'API_Info\\': {\\'StopSignal\\': \"$[\\'StopSignal\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'stop_grace_period\\': {\\'API_Info\\': {\\'StopTimeout\\': \"$[\\'StopTimeout\\']\"}, \\'parser_func\\': service_parser_stop_timeout},\\n\\n    # HostConfig\\n    \\'ports\\': {\\'API_Info\\': {\\'PortBindings\\': \"$[\\'HostConfig\\'][\\'PortBindings\\']\"}, \\'parser_func\\': service_parser_hostconfig_ports},\\n    \\'privileged\\': {\\'API_Info\\': {\\'Privileged\\': \"$[\\'HostConfig\\'][\\'Privileged\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'network_mode\\': {\\'API_Info\\': {\\'NetworkMode\\': \"$[\\'HostConfig\\'][\\'NetworkMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'devices\\': {\\'API_Info\\': {\\'Devices\\': \"$[\\'HostConfig\\'][\\'Devices\\']\"}, \\'parser_func\\': service_parser_hostconfig_devices},\\n    \\'dns\\': {\\'API_Info\\': {\\'Dns\\': \"$[\\'HostConfig\\'][\\'Dns\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'dns_search\\': {\\'API_Info\\': {\\'DnsSearch\\': \"$[\\'HostConfig\\'][\\'DnsSearch\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'restart\\': {\\n        \\'API_Info\\': {\\'RestartPolicy\\': \"$[\\'HostConfig\\'][\\'RestartPolicy\\']\"},\\n        \\'parser_func\\': service_parser_hostconfig_restart\\n    },\\n    \\'cap_add\\': {\\'API_Info\\': {\\'CapAdd\\': \"$[\\'HostConfig\\'][\\'CapAdd\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'cap_drop\\': {\\'API_Info\\': {\\'CapDrop\\': \"$[\\'HostConfig\\'][\\'CapDrop\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'ulimits\\': {\\'API_Info\\': {\\'Ulimits\\': \"$[\\'HostConfig\\'][\\'Ulimits\\']\"}, \\'parser_func\\': service_parser_hostconfig_ulimits},\\n    \\'logging\\': {\\'API_Info\\': {\\'LogConfig\\': \"$[\\'HostConfig\\'][\\'LogConfig\\']\"}, \\'parser_func\\': service_parser_hostconfig_logging},\\n    \\'extra_hosts\\': {\\'API_Info\\': {\\'ExtraHosts\\': \"$[\\'HostConfig\\'][\\'ExtraHosts\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'read_only\\': {\\'API_Info\\': {\\'ReadonlyRootfs\\': \"$[\\'HostConfig\\'][\\'ReadonlyRootfs\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'pid\\': {\\'API_Info\\': {\\'PidMode\\': \"$[\\'HostConfig\\'][\\'PidMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'security_opt\\': {\\'API_Info\\': {\\'SecurityOpt\\': \"$[\\'HostConfig\\'][\\'SecurityOpt\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'ipc\\': {\\'API_Info\\': {\\'IpcMode\\': \"$[\\'HostConfig\\'][\\'IpcMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'cgroup_parent\\': {\\'API_Info\\': {\\'CgroupParent\\': \"$[\\'HostConfig\\'][\\'CgroupParent\\']\"}, \\'parser_func\\': service_parser_naive},\\n    # \\'shm_size:\\':{\\'API_Info\\':\\'ShmSize\\',\\'parser_func\\':service_parser_naive},\\n    \\'sysctls\\': {\\'API_Info\\': {\\'Sysctls\\': \"$[\\'HostConfig\\'][\\'Sysctls\\']\"}, \\'parser_func\\': service_parser_naive},\\n    # \\'tmpfs:\\':{\\'API_Info\\':\\'Tmpfs\\',\\'parser_func\\':service_parser_naive},\\n    \\'userns_mode\\': {\\'API_Info\\': {\\'UsernsMode\\': \"$[\\'HostConfig\\'][\\'UsernsMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'isolation\\': {\\'API_Info\\': {\\'Isolation\\': \"$[\\'HostConfig\\'][\\'Isolation\\']\"}, \\'parser_func\\': service_parser_naive},\\n\\n    # Volumes\\n    \\'volumes\\': {\\n        \\'API_Info\\': {\\n            \\'Mounts\\': \"$[\\'HostConfig\\'][\\'Mounts\\']\",\\n            \\'Binds\\': \"$[\\'HostConfig\\'][\\'Binds\\']\"\\n        },\\n        \\'parser_func\\': service_parser_volumes\\n    },\\n\\n    # NetworkingConfig\\n    \\'networks\\': {\\n        \\'API_Info\\': {\\'NetworkingConfig\\': \"$[\\'NetworkingConfig\\'][\\'EndpointsConfig\\']\"},\\n        \\'parser_func\\': service_parser_networks\\n    }\\n}\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport json\\nimport os\\nimport sys\\nimport yaml\\n\\nfrom collections import OrderedDict\\nfrom io import StringIO\\nfrom .compose_parser import CreateOptionParser\\nfrom .output import Output\\n\\nCOMPOSE_VERSION = 3.6\\n\\nCREATE_OPTIONS_MAX_CHUNKS = 100\\n\\n\\nclass ComposeProject(object):\\n\\n    def __init__(self, module_content):\\n        self.module_content = module_content\\n        self.yaml_dict = OrderedDict()\\n        self.Services = OrderedDict()\\n        self.Networks = {}\\n        self.Volumes = {}\\n        self.edge_info = {}\\n\\n    def compose(self):\\n        modules = {\\n            self.edge_info[\\'hub_name\\']:\\n            self.module_content[\\'$edgeAgent\\'][\\'properties.desired\\'][\\'systemModules\\'][\\'edgeHub\\']\\n        }\\n        modules.update(self.module_content[\\'$edgeAgent\\'][\\'properties.desired\\'][\\'modules\\'])\\n        for service_name, config in modules.items():\\n            self.Services[service_name] = {}\\n            create_option_str = ComposeProject._join_create_options(config[\\'settings\\'])\\n            if create_option_str:\\n                create_option = json.loads(create_option_str)\\n                create_option_parser = CreateOptionParser(create_option)\\n                self.Services[service_name].update(create_option_parser.parse_create_option())\\n            self.Services[service_name][\\'image\\'] = config[\\'settings\\'][\\'image\\']\\n            self.Services[service_name][\\'container_name\\'] = service_name\\n\\n            if \\'networks\\' not in self.Services[service_name]:\\n                self.Services[service_name][\\'networks\\'] = {}\\n                self.Services[service_name][\\'networks\\'][self.edge_info[\\'network_info\\'][\\'NW_NAME\\']] = None\\n\\n            if \\'network_mode\\' in self.Services[service_name]:\\n                del self.Services[service_name][\\'network_mode\\']\\n\\n            if \\'host\\' in self.Services[service_name][\\'networks\\']:\\n                self.Services[service_name][\\'network_mode\\'] = \\'host\\'\\n                del self.Services[service_name][\\'networks\\']\\n\\n            if \\'labels\\' not in self.Services[service_name]:\\n                self.Services[service_name][\\'labels\\'] = {self.edge_info[\\'labels\\']: \"\"}\\n            else:\\n                self.Services[service_name][\\'labels\\'][self.edge_info[\\'labels\\']] = \"\"\\n\\n            try:\\n                # Default restart policy is \\'on-unhealthy\\'\\n                # https://github.com/Azure/iotedge/blob/8bd573590cdc149c014cf994dba58fc63f1a5c74/edge-agent/src/Microsoft.Azure.Devices.Edge.Agent.Core/Constants.cs#L18\\n                restart_policy = config.get(\\'restartPolicy\\', \\'on-unhealthy\\')\\n                self.Services[service_name][\\'restart\\'] = {\\n                    \\'never\\': \\'no\\',\\n                    \\'on-failure\\': \\'on-failure\\',\\n                    \\'always\\': \\'always\\',\\n                    \\'on-unhealthy\\': \\'always\\',\\n                    \\'unknown\\': \\'no\\'\\n                }[restart_policy]\\n\\n                if restart_policy == \\'on-unhealthy\\':\\n                    Output().warning(\\'Unsupported restart policy \\\\\\'{0}\\\\\\' in solution mode. Falling back to \\\\\\'always\\\\\\'.\\'\\n                                     .format(restart_policy))\\n            except KeyError as e:\\n                raise KeyError(\\'Unsupported restart policy {0} in solution mode.\\'.format(e))\\n\\n            if \\'env\\' in config:\\n                self.Services[service_name][\\'environment\\'] = self.config_env(\\n                    self.Services[service_name].get(\\'environment\\', []), config[\\'env\\'])\\n\\n            if service_name == self.edge_info[\\'hub_name\\']:\\n                self.config_edge_hub(service_name)\\n            else:\\n                self.config_modules(service_name)\\n\\n            if \\'networks\\' in self.Services[service_name]:\\n                for nw in self.Services[service_name][\\'networks\\']:\\n                    self.Networks[nw] = {\\n                        \\'external\\': True\\n                    }\\n\\n            for vol in self.Services[service_name][\\'volumes\\']:\\n                if vol[\\'type\\'] == \\'volume\\':\\n                    self.Volumes[vol[\\'source\\']] = {\\n                        \\'name\\': vol[\\'source\\']\\n                    }\\n\\n    def set_edge_info(self, info):\\n        self.edge_info = info\\n\\n    def config_modules(self, service_name):\\n        config = self.Services[service_name]\\n        if \\'volumes\\' not in config:\\n            config[\\'volumes\\'] = []\\n        config[\\'volumes\\'].append({\\n            \\'type\\': \\'volume\\',\\n            \\'source\\': self.edge_info[\\'volume_info\\'][\\'MODULE_VOLUME\\'],\\n            \\'target\\': self.edge_info[\\'volume_info\\'][\\'MODULE_MOUNT\\']\\n        })\\n\\n        if \\'environment\\' not in config:\\n            config[\\'environment\\'] = []\\n        for module_env in self.edge_info[\\'env_info\\'][\\'module_env\\']:\\n            config[\\'environment\\'].append(module_env)\\n        config[\\'environment\\'].append(\\n            \\'EdgeHubConnectionString=\\' + self.edge_info[\\'ConnStr_info\\'][service_name]\\n        )\\n\\n        if \\'depends_on\\' not in config:\\n            config[\\'depends_on\\'] = []\\n        config[\\'depends_on\\'].append(self.edge_info[\\'hub_name\\'])\\n\\n    def config_edge_hub(self, service_name):\\n        config = self.Services[service_name]\\n        if \\'volumes\\' not in config:\\n            config[\\'volumes\\'] = []\\n        config[\\'volumes\\'].append({\\n            \\'type\\': \\'volume\\',\\n            \\'source\\': self.edge_info[\\'volume_info\\'][\\'HUB_VOLUME\\'],\\n            \\'target\\': self.edge_info[\\'volume_info\\'][\\'HUB_MOUNT\\']\\n        })\\n\\n        config[\\'networks\\'][self.edge_info[\\'network_info\\'][\\'NW_NAME\\']] = {\\n            \\'aliases\\': [self.edge_info[\\'network_info\\'][\\'ALIASES\\']]\\n        }\\n\\n        if \\'environment\\' not in config:\\n            config[\\'environment\\'] = []\\n        routes_env = self.parse_routes()\\n        for e in routes_env:\\n            config[\\'environment\\'].append(e)\\n        config[\\'environment\\'].append(\\n            \\'IotHubConnectionString=\\' + self.edge_info[\\'ConnStr_info\\'][\\'$edgeHub\\'])\\n        config[\\'environment\\'].extend(self.edge_info[\\'env_info\\'][\\'hub_env\\'])\\n\\n    def config_env(self, env_list, env_section):\\n        env_dict = {}\\n        for env in env_list:\\n            if \\'=\\' in env:\\n                k, v = env.split(\\'=\\', 1)\\n            else:\\n                k, v = env, \\'\\'\\n            env_dict[k] = v\\n        for k, v in env_section.items():\\n            if \\'value\\' not in v:\\n                env_dict[k] = \\'\\'\\n            else:\\n                env_dict[k] = v[\\'value\\']\\n        ret = []\\n        for k, v in env_dict.items():\\n            ret.append(\"{0}={1}\".format(k, v))\\n        return ret\\n\\n    def parse_routes(self):\\n        routes = self.module_content[\\'$edgeHub\\'][\\'properties.desired\\'][\\'routes\\']\\n        schema_version = self.module_content[\\'$edgeHub\\'][\\'properties.desired\\'][\\'schemaVersion\\']\\n        routes_env = []\\n        route_id = 1\\n\\n        for route in routes.values():\\n            if isinstance(route, str):\\n                routes_env.append(\\'routes__r{0}={1}\\'.format(route_id, route))\\n            else:\\n                if schema_version >= \"1.1\":\\n                    routes_env.append(\\'routes__r{0}={1}\\'.format(route_id, route[\"route\"]))\\n                else:\\n                    raise Exception(\"Route priority/TTL is not supported in schema {0}.\".format(schema_version))\\n            route_id = route_id + 1\\n        return routes_env\\n\\n    def dump(self, target):\\n        def setup_yaml():\\n            def represent_dict_order(self, data):\\n                return self.represent_mapping(\\'tag:yaml.org,2002:map\\', data.items())\\n            yaml.add_representer(OrderedDict, represent_dict_order)\\n        setup_yaml()\\n\\n        def my_unicode_repr(self, data):\\n            return self.represent_str(data.encode(\\'utf-8\\'))\\n\\n        self.yaml_dict[\\'version\\'] = str(COMPOSE_VERSION)\\n        self.yaml_dict[\\'services\\'] = self.Services\\n        self.yaml_dict[\\'networks\\'] = self.Networks\\n        self.yaml_dict[\\'volumes\\'] = self.Volumes\\n\\n        if sys.version_info[0] < 3:\\n            # Add # noqa: F821 to ignore undefined name \\'unicode\\' error\\n            yaml.add_representer(unicode, my_unicode_repr)  # noqa: F821\\n        yml_stream = StringIO()\\n\\n        yaml.dump(self.yaml_dict, yml_stream, default_flow_style=False)\\n        yml_str = yml_stream.getvalue().replace(\\'$\\', \\'$$\\')\\n\\n        if not os.path.exists(os.path.dirname(target)):\\n            os.makedirs(os.path.dirname(target))\\n\\n        with open(target, \\'w\\') as f:\\n            f.write(yml_str)\\n\\n    @staticmethod\\n    def _join_create_options(settings):\\n        if \\'createOptions\\' not in settings:\\n            return \\'\\'\\n\\n        res = settings[\\'createOptions\\']\\n\\n        i = 0\\n        while True:\\n            i += 1\\n            key = \\'createOptions{0:0=2d}\\'.format(i)\\n            if i < CREATE_OPTIONS_MAX_CHUNKS and key in settings:\\n                res += settings[key]\\n            else:\\n                break\\n\\n        return res\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport os\\nimport configparser\\n\\nfrom . import decorators\\nfrom .hostplatform import HostPlatform\\n\\nPRIVACY_STATEMENT = \"\"\"\\nWelcome to iotedgehubdev!\\n-------------------------\\nTelemetry\\n---------\\nThe iotedgehubdev collects usage data in order to improve your experience.\\nThe data is anonymous and does not include commandline argument values.\\nThe data is collected by Microsoft.\\n\\nYou can change your telemetry settings by updating \\'collect_telemetry\\' to \\'no\\' in {0}\\n\"\"\"\\n\\n\\nclass ProductConfig(object):\\n    def __init__(self):\\n        self.config = configparser.ConfigParser({\\n            \\'firsttime\\': \\'yes\\'\\n        })\\n        self.setup_config()\\n\\n    @decorators.suppress_all_exceptions()\\n    def setup_config(self):\\n        try:\\n            configPath = HostPlatform.get_config_path()\\n            iniFilePath = HostPlatform.get_setting_ini_path()\\n            if not os.path.exists(configPath):\\n                os.makedirs(configPath)\\n            if not os.path.exists(iniFilePath):\\n                with open(iniFilePath, \\'w\\') as iniFile:\\n                    self.config.write(iniFile)\\n            else:\\n                with open(iniFilePath, \\'r\\') as iniFile:\\n                    self.config.read_file(iniFile)\\n                with open(iniFilePath, \\'w\\') as iniFile:\\n                    self.config.write(iniFile)\\n        except Exception:\\n            pass\\n\\n    @decorators.suppress_all_exceptions()\\n    def update_config(self):\\n        with open(HostPlatform.get_setting_ini_path(), \\'w\\') as iniFile:\\n            self.config.write(iniFile)\\n\\n    @decorators.suppress_all_exceptions()\\n    def set_val(self, direct, section, val):\\n        if val is not None:\\n            self.config.set(direct, section, val)\\n            self.update_config()\\n\\n\\n_prod_config = ProductConfig()\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef get_ini_config():\\n    return _prod_config.config\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef update_ini():\\n    _prod_config.update_config()\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef check_firsttime():\\n    if \\'no\\' != _prod_config.config.get(\\'DEFAULT\\', \\'firsttime\\'):\\n        config = _prod_config.config\\n        config.set(\\'DEFAULT\\', \\'firsttime\\', \\'no\\')\\n        print(PRIVACY_STATEMENT.format(HostPlatform.get_setting_ini_path()))\\n        config.set(\\'DEFAULT\\', \\'collect_telemetry\\', \\'yes\\')\\n        _prod_config.update_config()\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nclass EdgeConstants():\\n    HOSTNAME_KEY = \\'HostName\\'\\n    DEVICE_ID_KEY = \\'DeviceId\\'\\n    ACCESS_KEY_KEY = \\'SharedAccessKey\\'\\n    ACCESS_KEY_NAME = \\'SharedAccessKeyName\\'\\n    DEVICE_ACCESS_KEY_KEY = \\'Device_SharedAccessKey\\'\\n    HUB_ACCESS_KEY_KEY = \\'Hub_SharedAccessKey\\'\\n\\n    SUBJECT_COUNTRY_KEY = \\'countryCode\\'\\n    SUBJECT_STATE_KEY = \\'state\\'\\n    SUBJECT_LOCALITY_KEY = \\'locality\\'\\n    SUBJECT_ORGANIZATION_KEY = \\'organization\\'\\n    SUBJECT_ORGANIZATION_UNIT_KEY = \\'organizationUnit\\'\\n    SUBJECT_COMMON_NAME_KEY = \\'commonName\\'\\n\\n    EDGE_CHAIN_CA = \\'edge-chain-ca\\'\\n    EDGE_HUB_SERVER = \\'edge-hub-server\\'\\n    EDGE_DEVICE_CA = \\'edge-device-ca\\'\\n    EDGE_AGENT_CA = \\'edge-agent-ca\\'\\n    CERT_SUFFIX = \\'.cert.pem\\'\\n    CHAIN_CERT_SUFFIX = \\'-chain.cert.pem\\'\\n    PFX_SUFFIX = \\'.cert.pfx\\'\\n    KEY_SUFFIX = \\'.key.pem\\'\\n    ROOT_CA_ID = \\'azure-iot-test-only.root.ca\\'\\n    DEVICE_CA_ID = \\'iot-edge-device-ca\\'\\n    CERT_FOLDER = \\'certs\\'\\n\\n    CERT_DEFAULT_DICT = {\\n        SUBJECT_COUNTRY_KEY: \\'US\\',\\n        SUBJECT_STATE_KEY: \\'Washington\\',\\n        SUBJECT_LOCALITY_KEY: \\'Redmond\\',\\n        SUBJECT_ORGANIZATION_KEY: \\'Default Edge Organization\\',\\n        SUBJECT_ORGANIZATION_UNIT_KEY: \\'Edge Unit\\',\\n        SUBJECT_COMMON_NAME_KEY: \\'Edge Test Device CA\\'\\n    }\\n\\n    # Port of Docker daemon\\n    # https://github.com/docker/docker-ce/blob/f9756bfb29877236a83979170ef2c0aa35eb57c6/components/engine/volume/mounts/windows_parser.go#L19-L76\\n    MOUNT_HOST_DIR_REGEX = r\\'(?:\\\\\\\\\\\\\\\\\\\\?\\\\\\\\)?[a-z]:[\\\\\\\\/](?:[^\\\\\\\\/:*?\"<>|\\\\r\\\\n]+[\\\\\\\\/]?)*\\'\\n    MOUNT_NAME_REGEX = r\\'[^\\\\\\\\/:*?\"<>|\\\\r\\\\n]+\\'\\n    MOUNT_PIPE_REGEX = r\\'[/\\\\\\\\]{2}.[/\\\\\\\\]pipe[/\\\\\\\\][^:*?\"<>|\\\\r\\\\n]+\\'\\n    MOUNT_SOURCE_REGEX = r\\'((?P<source>((\\' + MOUNT_HOST_DIR_REGEX + r\\')|(\\' + \\\\\\n        MOUNT_NAME_REGEX + r\\')|(\\' + MOUNT_PIPE_REGEX + r\\'))):)?\\'\\n    MOUNT_MODE_REGEX = r\\'(:(?P<mode>(?i)ro|rw))?\\'\\n    MOUNT_WIN_DEST_REGEX = r\\'(?P<destination>((?:\\\\\\\\\\\\\\\\\\\\?\\\\\\\\)?([a-z]):((?:[\\\\\\\\/][^\\\\\\\\/:*?\"<>\\\\r\\\\n]+)*[\\\\\\\\/]?))|(\\' + \\\\\\n        MOUNT_PIPE_REGEX + r\\'))\\'\\n    MOUNT_LCOW_DEST_REGEX = r\\'(?P<destination>/(?:[^\\\\\\\\/:*?\"<>\\\\r\\\\n]+[/]?)*)\\'\\n    MOUNT_WIN_REGEX = r\\'^\\' + MOUNT_SOURCE_REGEX + MOUNT_WIN_DEST_REGEX + MOUNT_MODE_REGEX + r\\'$\\'\\n    MOUNT_LCOW_REGEX = r\\'^\\' + MOUNT_SOURCE_REGEX + MOUNT_LCOW_DEST_REGEX + MOUNT_MODE_REGEX + r\\'$\\'\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nfrom functools import wraps\\n\\n\\ndef suppress_all_exceptions(fallback_return=None):\\n    def _decorator(func):\\n        @wraps(func)\\n        def _wrapped_func(*args, **kwargs):\\n            try:\\n                return func(*args, **kwargs)\\n            except Exception:\\n                if fallback_return:\\n                    return fallback_return\\n                else:\\n                    pass\\n\\n        return _wrapped_func\\n\\n    return _decorator\\n\\n\\ndef hash256_result(func):\\n    \"\"\"Secure the return string of the annotated function with SHA256 algorithm. If the annotated\\n    function doesn\\'t return string or return None, raise ValueError.\"\"\"\\n    @wraps(func)\\n    def _decorator(*args, **kwargs):\\n        val = func(*args, **kwargs)\\n        if not val:\\n            raise ValueError(\\'Return value is None\\')\\n        elif not isinstance(val, str):\\n            raise ValueError(\\'Return value is not string\\')\\n\\n        from .utils import Utils\\n        return Utils.get_sha256_hash(val)\\n\\n    return _decorator\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "b\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\nfrom .certutils import EdgeCertUtil\\nfrom .constants import EdgeConstants\\n\\n\\nclass EdgeCert(object):\\n    def __init__(self, certs_dir, hostname):\\n        self.certs_dir = certs_dir\\n        self.hostname = hostname\\n\\n    def generate_self_signed_certs(self):\\n        cert_util = EdgeCertUtil()\\n        cert_util.create_root_ca_cert(EdgeConstants.EDGE_DEVICE_CA,\\n                                      validity_days_from_now=365,\\n                                      subject_dict=EdgeConstants.CERT_DEFAULT_DICT,\\n                                      passphrase=None)\\n        cert_util.export_simulator_cert_artifacts_to_dir(EdgeConstants.EDGE_DEVICE_CA, self.certs_dir)\\n\\n        cert_util.create_intermediate_ca_cert(EdgeConstants.EDGE_AGENT_CA,\\n                                              EdgeConstants.EDGE_DEVICE_CA,\\n                                              validity_days_from_now=365,\\n                                              common_name='Edge Agent CA',\\n                                              set_terminal_ca=False,\\n                                              passphrase=None)\\n        cert_util.export_simulator_cert_artifacts_to_dir(EdgeConstants.EDGE_AGENT_CA, self.certs_dir)\\n\\n        cert_util.create_server_cert(EdgeConstants.EDGE_HUB_SERVER,\\n                                     EdgeConstants.EDGE_AGENT_CA,\\n                                     validity_days_from_now=365,\\n                                     hostname=self.hostname)\\n        cert_util.export_simulator_cert_artifacts_to_dir(EdgeConstants.EDGE_HUB_SERVER, self.certs_dir)\\n        cert_util.export_pfx_cert(EdgeConstants.EDGE_HUB_SERVER, self.certs_dir)\\n\\n        prefixes = [EdgeConstants.EDGE_AGENT_CA, EdgeConstants.EDGE_DEVICE_CA]\\n        cert_util.chain_simulator_ca_certs(EdgeConstants.EDGE_CHAIN_CA, prefixes, self.certs_dir)\\n\\n    # Generate IoT Edge device CA to be configured in IoT Edge runtime\\n    def generate_device_ca(self, valid_days, overwrite_existing, trusted_ca, trusted_ca_key, trusted_ca_key_passphase):\\n        # Function level variables\\n        create_root_ca = not (trusted_ca and trusted_ca_key)\\n        # Generate certs\\n        cert_util = EdgeCertUtil()\\n        if create_root_ca:\\n            cert_util.create_root_ca_cert(EdgeConstants.ROOT_CA_ID,\\n                                          validity_days_from_now=valid_days,\\n                                          subject_dict=EdgeConstants.CERT_DEFAULT_DICT,\\n                                          passphrase=None)\\n            cert_util.export_device_ca_cert_artifacts_to_dir(EdgeConstants.ROOT_CA_ID, self.certs_dir)\\n        else:\\n            cert_util.load_cert_from_file(EdgeConstants.ROOT_CA_ID, trusted_ca, trusted_ca_key, trusted_ca_key_passphase)\\n\\n        cert_util.create_intermediate_ca_cert(EdgeConstants.DEVICE_CA_ID, EdgeConstants.ROOT_CA_ID,\\n                                              validity_days_from_now=valid_days,\\n                                              common_name='Edge Device CA',\\n                                              set_terminal_ca=False,\\n                                              passphrase=None)\\n        cert_util.export_device_ca_cert_artifacts_to_dir(EdgeConstants.DEVICE_CA_ID, self.certs_dir)\\n        cert_util.chain_device_ca_certs(EdgeConstants.DEVICE_CA_ID,\\n                                        [EdgeConstants.DEVICE_CA_ID, EdgeConstants.ROOT_CA_ID],\\n                                        self.certs_dir)\\n\\n    def get_cert_file_path(self, id_str):\\n        return EdgeCertUtil.get_cert_file_path(id_str, self.certs_dir)\\n\\n    def get_pfx_file_path(self, id_str):\\n        return EdgeCertUtil.get_pfx_file_path(id_str, self.certs_dir)\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport docker\\nimport os\\nimport time\\nimport tarfile\\nfrom io import BytesIO\\nfrom .errors import EdgeDeploymentError\\nfrom .utils import Utils\\n\\n\\nclass EdgeDockerClient(object):\\n    _DOCKER_INFO_OS_TYPE_KEY = \\'OSType\\'\\n\\n    def __init__(self, docker_client=None):\\n        if docker_client is not None:\\n            self._client = docker_client\\n        else:\\n            try:\\n                self._client = docker.DockerClient.from_env(version=\\'auto\\')\\n            except Exception as ex:\\n                msg = \\'Could not connect to Docker daemon. Please make sure Docker is running\\'\\n                raise EdgeDeploymentError(msg, ex)\\n\\n    def __enter__(self):\\n        return self\\n\\n    def __exit__(self, exc_type, exc_value, traceback):\\n        if self._client is not None:\\n            self._client.api.close()\\n\\n    def stop_remove_by_label(self, label):\\n        try:\\n            filter_dict = {\\'label\\': label}\\n            containers = self._client.containers.list(all=True, filters=filter_dict)\\n            for container in containers:\\n                container.stop()\\n                self.remove(container.name)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not stop and remove containers by label: {0}\\'.format(label)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def get_local_image_sha_id(self, image):\\n        local_id = None\\n        try:\\n            inspect_dict = self._client.api.inspect_image(image)\\n            local_id = inspect_dict[\\'Id\\']\\n        except docker.errors.APIError:\\n            local_id = None\\n        return local_id\\n\\n    def pull(self, image, username, password):\\n        old_id = self.get_local_image_sha_id(image)\\n        try:\\n            is_updated = True\\n            auth_dict = None\\n            if username is not None:\\n                auth_dict = {\\'username\\': username, \\'password\\': password}\\n            self._client.images.pull(image, auth_config=auth_dict)\\n            if old_id is not None:\\n                inspect_dict = self._client.api.inspect_image(image)\\n                new_id = inspect_dict[\\'Id\\']\\n                if new_id == old_id:\\n                    is_updated = False\\n\\n            return is_updated\\n        except docker.errors.APIError as ex:\\n            msg = \\'Error during pull for image {0}\\'.format(image)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def pullIfNotExist(self, image, username, password):\\n        imageId = self.get_local_image_sha_id(image)\\n        if imageId is None:\\n            return self.pull(image, username, password)\\n\\n    def status(self, container_name):\\n        try:\\n            containers = self._client.containers.list(all=True)\\n            for container in containers:\\n                if container_name == container.name:\\n                    return container.status\\n            return None\\n        except docker.errors.APIError as ex:\\n            msg = \\'Error while checking status for: {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def stop(self, container_name):\\n        self._exec_container_method(container_name, \\'stop\\')\\n\\n    def start(self, container_name):\\n        self._exec_container_method(container_name, \\'start\\')\\n\\n    def remove(self, container_name):\\n        self._exec_container_method(container_name, \\'remove\\')\\n\\n    def create_network(self, network_name):\\n        create_network = False\\n        try:\\n            networks = self._client.networks.list(names=[network_name])\\n            if networks:\\n                num_networks = len(networks)\\n                if num_networks == 0:\\n                    create_network = True\\n            else:\\n                create_network = True\\n            if create_network is True:\\n                os_name = self.get_os_type()\\n                if os_name == \\'windows\\':\\n                    return self._client.networks.create(network_name, driver=\\'nat\\')\\n                else:\\n                    return self._client.networks.create(network_name, driver=\\'bridge\\')\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not create docker network: {0}\\'.format(network_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def create_volume(self, volume_name):\\n        try:\\n            volume = self._get_volume_if_exists(volume_name)\\n            if volume is None:\\n                return self._client.volumes.create(volume_name)\\n        except docker .errors.APIError as ex:\\n            msg = \\'Docker volume create failed for: {0}\\'.format(volume_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def create_config_for_network(self, nw_name, *args, **kwargs):\\n        return self._client.api.create_networking_config({\\n            nw_name: self._client.api.create_endpoint_config(*args, **kwargs)\\n        })\\n\\n    def create_container(self, image, **kwargs):\\n        try:\\n            return self._client.api.create_container(image, **kwargs)\\n        except docker.errors.ContainerError as ex_ctr:\\n            msg = \\'Container exited with errors: {0}\\'.format(kwargs.get(\\'name\\', None))\\n            raise EdgeDeploymentError(msg, ex_ctr)\\n        except docker.errors.ImageNotFound as ex_img:\\n            msg = \\'Docker create failed. Image not found: {0}\\'.format(image)\\n            raise EdgeDeploymentError(msg, ex_img)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker create failed for image: {0}\\'.format(image)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def create_host_config(self, *args, **kwargs):\\n        try:\\n            return self._client.api.create_host_config(*args, **kwargs)\\n        except Exception as ex:\\n            msg = \\'docker create host config failed\\'\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def copy_file_to_volume(self,\\n                            container_name,\\n                            volume_name,\\n                            volume_dest_file_name,\\n                            volume_dest_dir_path,\\n                            host_src_file):\\n        if self.get_os_type() == \\'windows\\':\\n            self._insert_file_in_volume_mount(volume_name, host_src_file, volume_dest_file_name)\\n        else:\\n            self._insert_file_in_container(container_name,\\n                                           volume_dest_file_name,\\n                                           volume_dest_dir_path,\\n                                           host_src_file)\\n\\n    def get_os_type(self):\\n        try:\\n            info = self._client.info()\\n            return info[EdgeDockerClient._DOCKER_INFO_OS_TYPE_KEY].lower()\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker daemon returned error\\'\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def destroy_network(self, network_name):\\n        try:\\n            networks = self._client.networks.list(names=[network_name])\\n            if networks is not None:\\n                for network in networks:\\n                    if network.name == network_name:\\n                        network.remove()\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not remove docker network: {0}\\'.format(network_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def remove_volume(self, volume_name, force=False):\\n        try:\\n            volume = self._get_volume_if_exists(volume_name)\\n            if volume is not None:\\n                volume.remove(force)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker volume remove failed for: {0}, force flag: {1}\\'.format(volume_name, force)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _get_volume_if_exists(self, name):\\n        try:\\n            return self._client.volumes.get(name)\\n        except docker.errors.NotFound:\\n            return None\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker volume get failed for: {0}\\'.format(name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _exec_container_method(self, container_name, method, **kwargs):\\n        container = self._get_container_by_name(container_name)\\n        try:\\n            getattr(container, method)(**kwargs)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not {0} container: {1}\\'.format(method, container_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _get_container_by_name(self, container_name):\\n        try:\\n            return self._client.containers.get(container_name)\\n        except docker.errors.NotFound as nf_ex:\\n            msg = \\'Could not find container by name {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, nf_ex)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Error getting container by name: {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _insert_file_in_volume_mount(self, volume_name, host_src_file, volume_dest_file_name):\\n        try:\\n            volume_info = self._client.api.inspect_volume(volume_name)\\n            Utils.copy_files(host_src_file.replace(\\'\\\\\\\\\\\\\\\\\\', \\'\\\\\\\\\\'),\\n                             os.path.join(volume_info[\\'Mountpoint\\'].replace(\\'\\\\\\\\\\\\\\\\\\', \\'\\\\\\\\\\'), volume_dest_file_name))\\n        except docker.errors.APIError as docker_ex:\\n            msg = \\'Docker volume inspect failed for: {0}\\'.format(volume_name)\\n            raise EdgeDeploymentError(msg, docker_ex)\\n        except (OSError, IOError) as ex_os:\\n            msg = \\'File IO error seen copying files to volume: {0}. \\' \\\\\\n                  \\'Errno: {1}, Error {2}\\'.format(volume_name, str(ex_os.errno), ex_os.strerror)\\n            raise EdgeDeploymentError(msg, ex_os)\\n\\n    def _insert_file_in_container(self,\\n                                  container_name,\\n                                  volume_dest_file_name,\\n                                  volume_dest_dir_path,\\n                                  host_src_file):\\n        try:\\n            (tar_stream, dest_archive_info, container_tar_file) = \\\\\\n                EdgeDockerClient.create_tar_objects(volume_dest_file_name)\\n            file_data = open(host_src_file, \\'rb\\').read()\\n            dest_archive_info.size = len(file_data)\\n            dest_archive_info.mtime = time.time()\\n            dest_archive_info.mode = 0o444\\n            container_tar_file.addfile(dest_archive_info, BytesIO(file_data))\\n            container_tar_file.close()\\n            tar_stream.seek(0)\\n            container = self._get_container_by_name(container_name)\\n            container.put_archive(volume_dest_dir_path, tar_stream)\\n        except docker.errors.APIError as docker_ex:\\n            msg = \\'Container put_archive failed for container: {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, docker_ex)\\n        except (OSError, IOError) as ex_os:\\n            msg = \\'File IO error seen during put archive for container: {0}. \\' \\\\\\n                  \\'Errno: {1}, Error {2}\\'.format(container_name, str(ex_os.errno), ex_os.strerror)\\n            raise EdgeDeploymentError(msg, ex_os)\\n\\n    @staticmethod\\n    def create_tar_objects(container_dest_file_name):\\n        tar_stream = BytesIO()\\n        dest_archive_info = tarfile.TarInfo(name=container_dest_file_name)\\n        container_tar_file = tarfile.TarFile(fileobj=tar_stream, mode=\\'w\\')\\n        return (tar_stream, dest_archive_info, container_tar_file)\\n\\n    @classmethod\\n    def create_instance(cls, docker_client):\\n        \"\"\"\\n        Factory method useful in testing.\\n        \"\"\"\\n        return cls(docker_client)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport json\\nimport os\\n\\nimport docker\\nimport requests\\n\\nfrom .composeproject import ComposeProject\\nfrom .constants import EdgeConstants as EC\\nfrom .edgecert import EdgeCert\\nfrom .edgedockerclient import EdgeDockerClient\\nfrom .errors import ResponseError, RegistriesLoginError\\nfrom .hostplatform import HostPlatform\\nfrom .utils import Utils\\n\\n\\nclass EdgeManager(object):\\n    LABEL = \\'iotedgehubdev\\'\\n    EDGEHUB_IMG = \\'mcr.microsoft.com/azureiotedge-hub:{0}\\'\\n    TESTUTILITY_IMG = \\'mcr.microsoft.com/azureiotedge-testing-utility:1.0.0\\'\\n    EDGEHUB_MODULE = \\'$edgeHub\\'\\n    EDGEHUB = \\'edgeHubDev\\'\\n    INPUT = \\'input\\'\\n    NW_NAME = \\'azure-iot-edge-dev\\'\\n    MOUNT_BASE = \\'mnt\\'\\n    HUB_VOLUME = \\'edgehubdev\\'\\n    HUB_MOUNT = \\'{0}/edgehub\\'\\n    MODULE_VOLUME = \\'edgemoduledev\\'\\n    MODULE_MOUNT = \\'{0}/edgemodule\\'\\n    HUB_CA_ENV = \\'EdgeModuleHubServerCAChainCertificateFile={0}/edgehub/edge-chain-ca.cert.pem\\'\\n    HUB_CERT_ENV = \\'EdgeModuleHubServerCertificateFile={0}/edgehub/edge-hub-server.cert.pfx\\'\\n    HUB_SRC_ENV = \\'configSource=local\\'\\n    MODULE_CA_ENV = \"EdgeModuleCACertificateFile={0}/edgemodule/edge-device-ca.cert.pem\"\\n    HUB_SSLPATH_ENV = \\'SSL_CERTIFICATE_PATH={0}/edgehub/\\'\\n    HUB_SSLCRT_ENV = \\'SSL_CERTIFICATE_NAME=edge-hub-server.cert.pfx\\'\\n    CERT_HELPER = \\'cert_helper\\'\\n    HELPER_IMG = \\'hello-world:latest\\'\\n    COMPOSE_FILE = os.path.join(HostPlatform.get_share_data_path(), \\'docker-compose.yml\\')\\n\\n    def __init__(self, connection_str, gatewayhost, cert_path, hub_conn_str=None):\\n        connection_str_dict = Utils.parse_connection_strs(connection_str, hub_conn_str)\\n        self._hostname = connection_str_dict[EC.HOSTNAME_KEY]\\n        self._device_id = connection_str_dict[EC.DEVICE_ID_KEY]\\n        self._access_key = connection_str_dict[EC.DEVICE_ACCESS_KEY_KEY]\\n        self._compose_file = None\\n        self._gatewayhost = gatewayhost\\n        self._device_uri = \\'{0}/devices/{1}\\'.format(self._hostname, self._device_id)\\n        self._cert_path = cert_path\\n        self._edge_cert = EdgeCert(self._cert_path, self._gatewayhost)\\n        self._hub_access_key = connection_str_dict.get(EC.HUB_ACCESS_KEY_KEY)\\n        self._hub_access_name = connection_str_dict.get(EC.ACCESS_KEY_NAME)\\n\\n    @property\\n    def hostname(self):\\n        return self._hostname\\n\\n    @staticmethod\\n    def stop(edgedockerclient=None):\\n        if edgedockerclient is None:\\n            edgedockerclient = EdgeDockerClient()\\n\\n        compose_err = None\\n        label_err = None\\n        try:\\n            if os.path.exists(EdgeManager.COMPOSE_FILE):\\n                cmd = \"docker-compose -f {0} down\".format(EdgeManager.COMPOSE_FILE)\\n                Utils.exe_proc(cmd.split())\\n        except Exception as e:\\n            compose_err = e\\n\\n        try:\\n            edgedockerclient.stop_remove_by_label(EdgeManager.LABEL)\\n        except Exception as e:\\n            label_err = e\\n\\n        if compose_err or label_err:\\n            raise Exception(\\'{0}{1}\\'.format(\\n                \\'\\' if compose_err is None else str(compose_err),\\n                \\'\\' if label_err is None else str(label_err)))\\n\\n    def start_singlemodule(self, inputs, port, envs, edgehub_image_version):\\n        edgedockerclient = EdgeDockerClient()\\n        mount_base = self._obtain_mount_path(edgedockerclient)\\n        if mount_base is None:\\n            raise Exception(\"OS Type is not supported\")\\n\\n        EdgeManager.stop(edgedockerclient)\\n        self._prepare(edgedockerclient)\\n\\n        edgeHubConnStr = self.getOrAddModule(EdgeManager.EDGEHUB_MODULE, False)\\n        inputConnStr = self.getOrAddModule(EdgeManager.INPUT, False)\\n        routes = self._generateRoutesEnvFromInputs(inputs)\\n        self._start_edge_hub(edgedockerclient, edgeHubConnStr, routes, mount_base, envs, edgehub_image_version)\\n\\n        module_mount = EdgeManager.MODULE_MOUNT.format(mount_base)\\n        edgedockerclient.pullIfNotExist(EdgeManager.TESTUTILITY_IMG, None, None)\\n        network_config = edgedockerclient.create_config_for_network(EdgeManager.NW_NAME)\\n        inputEnv = [EdgeManager.MODULE_CA_ENV.format(mount_base), \"EdgeHubConnectionString={0}\".format(inputConnStr)]\\n        input_host_config = edgedockerclient.create_host_config(\\n            mounts=[docker.types.Mount(module_mount, EdgeManager.MODULE_VOLUME)],\\n            port_bindings={\\n                \\'3000\\': port\\n            },\\n            restart_policy={\\n                \\'MaximumRetryCount\\': 3,\\n                \\'Name\\': \\'on-failure\\'\\n            }\\n        )\\n        inputContainer = edgedockerclient.create_container(\\n            EdgeManager.TESTUTILITY_IMG,\\n            name=EdgeManager.INPUT,\\n            volumes=[module_mount],\\n            host_config=input_host_config,\\n            networking_config=network_config,\\n            environment=inputEnv,\\n            labels=[EdgeManager.LABEL],\\n            ports=[(3000, \\'tcp\\')]\\n        )\\n\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.INPUT, EdgeManager.MODULE_VOLUME, self._device_cert(),\\n            module_mount,\\n            self._edge_cert.get_cert_file_path(EC.EDGE_DEVICE_CA))\\n        edgedockerclient.start(inputContainer.get(\\'Id\\'))\\n\\n    def config_solution(self, module_content, target, mount_base):\\n        module_names = [EdgeManager.EDGEHUB_MODULE]\\n        custom_modules = module_content[\\'$edgeAgent\\'][\\'properties.desired\\'][\\'modules\\']\\n        for module_name in custom_modules:\\n            module_names.append(module_name)\\n\\n        ConnStr_info = {}\\n        for module_name in module_names:\\n            ConnStr_info[module_name] = self.getOrAddModule(module_name, False)\\n\\n        env_info = {\\n            \\'hub_env\\': [\\n                EdgeManager.HUB_CA_ENV.format(mount_base),\\n                EdgeManager.HUB_CERT_ENV.format(mount_base),\\n                EdgeManager.HUB_SRC_ENV,\\n                EdgeManager.HUB_SSLPATH_ENV.format(mount_base),\\n                EdgeManager.HUB_SSLCRT_ENV\\n            ],\\n            \\'module_env\\': [\\n                EdgeManager.MODULE_CA_ENV.format(mount_base)\\n            ]\\n        }\\n\\n        volume_info = {\\n            \\'HUB_MOUNT\\': EdgeManager.HUB_MOUNT.format(mount_base),\\n            \\'HUB_VOLUME\\': EdgeManager.HUB_VOLUME,\\n            \\'MODULE_VOLUME\\': EdgeManager.MODULE_VOLUME,\\n            \\'MODULE_MOUNT\\': EdgeManager.MODULE_MOUNT.format(mount_base)\\n        }\\n\\n        network_info = {\\n            \\'NW_NAME\\': EdgeManager.NW_NAME,\\n            \\'ALIASES\\': self._gatewayhost\\n        }\\n\\n        compose_project = ComposeProject(module_content)\\n        compose_project.set_edge_info({\\n            \\'ConnStr_info\\': ConnStr_info,\\n            \\'env_info\\': env_info,\\n            \\'volume_info\\': volume_info,\\n            \\'network_info\\': network_info,\\n            \\'hub_name\\': EdgeManager.EDGEHUB,\\n            \\'labels\\': EdgeManager.LABEL\\n        })\\n\\n        compose_project.compose()\\n        compose_project.dump(target)\\n\\n    def start_solution(self, module_content, verbose, output):\\n        try:\\n            EdgeManager.login_registries(module_content)\\n        except RegistriesLoginError as e:\\n            output.warning(e.getmsg())\\n\\n        edgedockerclient = EdgeDockerClient()\\n        mount_base = self._obtain_mount_path(edgedockerclient)\\n        if not mount_base:\\n            raise Exception(\"OS Type is not supported\")\\n\\n        EdgeManager.stop(edgedockerclient)\\n        self._prepare(edgedockerclient)\\n        self._prepare_cert(edgedockerclient, mount_base)\\n\\n        self.config_solution(module_content, EdgeManager.COMPOSE_FILE, mount_base)\\n        try:\\n            self.update_module_twin(module_content)\\n        except Exception as e:\\n            output.warning(str(e))\\n\\n        cmd_pull = [\\'docker-compose\\', \\'-f\\', EdgeManager.COMPOSE_FILE, \\'pull\\', EdgeManager.EDGEHUB]\\n        Utils.exe_proc(cmd_pull)\\n        if verbose:\\n            cmd_up = [\\'docker-compose\\', \\'-f\\', EdgeManager.COMPOSE_FILE, \\'up\\']\\n        else:\\n            cmd_up = [\\'docker-compose\\', \\'-f\\', EdgeManager.COMPOSE_FILE, \\'up\\', \\'-d\\']\\n        Utils.exe_proc(cmd_up)\\n\\n    def update_module_twin(self, module_content):\\n        if self._hub_access_key is None:\\n            return\\n\\n        twinErrorMsg = \\'\\'\\n        sas = Utils.get_iot_hub_sas_token(self._hostname, self._hub_access_key, self._hub_access_name)\\n        for name in module_content:\\n            if name == \\'$edgeAgent\\' or name == \\'$edgeHub\\':\\n                continue\\n            twin = module_content.get(name).get(\\'properties.desired\\')\\n            uri = self._get_update_twin_uri(name)\\n            res = requests.patch(\\n                uri,\\n                headers={\\n                    \\'Authorization\\': sas,\\n                    \\'Content-Type\\': \"application/json\",\\n                    \\'If-Match\\': \\'\"*\"\\'\\n                },\\n                data=json.dumps({\\n                    \\'properties\\': {\\n                        \\'desired\\': twin\\n                    }\\n                })\\n            )\\n            if res.ok is not True:\\n                twinErrorMsg += \\'Fail to update {0} twin. Code:{1}. Detail:{2}\\'.format(name, res.status_code, res.text)\\n        if twinErrorMsg:\\n            raise Exception(twinErrorMsg)\\n\\n    @staticmethod\\n    def login_registries(module_content):\\n        registryCredentials = module_content.get(\\'$edgeAgent\\', {}).get(\\'properties.desired\\', {}).get(\\n            \\'runtime\\', {}).get(\\'settings\\', {}).get(\\'registryCredentials\\')\\n        if not registryCredentials:\\n            return\\n        failLogin = []\\n        errMsg = \\'\\'\\n        for key in registryCredentials:\\n            value = registryCredentials[key]\\n            try:\\n                cmd_login = [\\'docker\\', \\'login\\', \\'-u\\', value[\\'username\\'], \\'-p\\', value[\\'password\\'], value[\\'address\\']]\\n                Utils.exe_proc(cmd_login)\\n            except Exception as e:\\n                failLogin.append(key)\\n                errMsg += \\'{0}\\\\n\\'.format(str(e))\\n        if failLogin:\\n            raise RegistriesLoginError(failLogin, errMsg)\\n\\n    def _prepare_cert(self, edgedockerclient, mount_base):\\n        status = edgedockerclient.status(EdgeManager.CERT_HELPER)\\n        if status is not None:\\n            edgedockerclient.stop(EdgeManager.CERT_HELPER)\\n            edgedockerclient.remove(EdgeManager.CERT_HELPER)\\n\\n        hub_mount = EdgeManager.HUB_MOUNT.format(mount_base)\\n        module_mount = EdgeManager.MODULE_MOUNT.format(mount_base)\\n\\n        helper_host_config = edgedockerclient.create_host_config(\\n            mounts=[docker.types.Mount(hub_mount, EdgeManager.HUB_VOLUME),\\n                    docker.types.Mount(module_mount, EdgeManager.MODULE_VOLUME)]\\n        )\\n\\n        edgedockerclient.pull(EdgeManager.HELPER_IMG, None, None)\\n\\n        edgedockerclient.create_container(\\n            EdgeManager.HELPER_IMG,\\n            name=EdgeManager.CERT_HELPER,\\n            volumes=[hub_mount, module_mount],\\n            host_config=helper_host_config,\\n            labels=[EdgeManager.LABEL]\\n        )\\n\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.CERT_HELPER, EdgeManager.HUB_VOLUME, EdgeManager._chain_cert(),\\n            hub_mount, self._edge_cert.get_cert_file_path(EC.EDGE_CHAIN_CA))\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.CERT_HELPER, EdgeManager.HUB_VOLUME, EdgeManager._hubserver_pfx(),\\n            hub_mount, self._edge_cert.get_pfx_file_path(EC.EDGE_HUB_SERVER))\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.CERT_HELPER, EdgeManager.MODULE_VOLUME, self._device_cert(),\\n            module_mount, self._edge_cert.get_cert_file_path(EC.EDGE_DEVICE_CA))\\n\\n    def start(self, modulesDict, routes):\\n        return\\n\\n    def getOrAddModule(self, name, islocal):\\n        try:\\n            return self.getModule(name, islocal)\\n        except ResponseError as geterr:\\n            if geterr.status_code == 404:\\n                try:\\n                    return self.addModule(name, islocal)\\n                except ResponseError as adderr:\\n                    if adderr.status_code == 400:\\n                        raise ResponseError(400, adderr.value + \" Please make sure you are using an Edge device.\")\\n                    raise adderr\\n            else:\\n                raise geterr\\n\\n    def outputModuleCred(self, names, islocal, output_file):\\n        connstrENV = \\'EdgeHubConnectionString={0}\\'.format(\\'|\\'.join([self.getOrAddModule(name, islocal) for name in names]))\\n        deviceCAEnv = \\'EdgeModuleCACertificateFile={0}\\'.format(self._edge_cert.get_cert_file_path(EC.EDGE_DEVICE_CA))\\n        cred = [connstrENV, deviceCAEnv]\\n\\n        if output_file is not None:\\n            output_path = os.path.abspath(output_file)\\n            dir = os.path.dirname(output_path)\\n            if not os.path.exists(dir):\\n                os.makedirs(dir)\\n            with open(output_path, \\'w+\\') as envFile:\\n                envFile.writelines([\\'\\\\n\\', cred[0], \\'\\\\n\\', cred[1]])\\n        return cred\\n\\n    def getModule(self, name, islocal):\\n        moduleUri = self._getModuleReqUri(name)\\n        sas = Utils.get_iot_hub_sas_token(self._device_uri, self._access_key, None)\\n        res = requests.get(\\n            moduleUri,\\n            headers={\\n                \\'Authorization\\': sas,\\n                \\'Content-Type\\': \\'application/json\\'\\n            }\\n        )\\n        if res.ok is not True:\\n            raise ResponseError(res.status_code, res.text)\\n        else:\\n            jsonObj = res.json()\\n            auth = jsonObj[\\'authentication\\']\\n            if auth is not None:\\n                authType = auth[\\'type\\']\\n                authKey = auth[\\'symmetricKey\\']\\n                if authType == \\'sas\\' and authKey is not None and authKey[\\'primaryKey\\'] is not None:\\n                    return self._generateModuleConnectionStr(res, islocal)\\n            return self.updateModule(name, jsonObj[\\'etag\\'], islocal)\\n\\n    def updateModule(self, name, etag, islocal):\\n        moduleUri = self._getModuleReqUri(name)\\n        sas = Utils.get_iot_hub_sas_token(self._device_uri, self._access_key, None)\\n        res = requests.put(\\n            moduleUri,\\n            headers={\\n                \\'Authorization\\': sas,\\n                \\'Content-Type\\': \"application/json\",\\n                \\'If-Match\\': \\'\"*\"\\'\\n            },\\n            data=json.dumps({\\n                \\'moduleId\\': name,\\n                \\'deviceId\\': self._device_id,\\n                \\'authentication\\': {\\n                    \\'type\\': \\'sas\\'\\n                }\\n            })\\n        )\\n        if res.ok is not True:\\n            raise ResponseError(res.status_code, res.text)\\n        return self._generateModuleConnectionStr(res, islocal)\\n\\n    def addModule(self, name, islocal):\\n        moduleUri = self._getModuleReqUri(name)\\n        sas = Utils.get_iot_hub_sas_token(self._device_uri, self._access_key, None)\\n        res = requests.put(\\n            moduleUri,\\n            headers={\\n                \"Authorization\": sas,\\n                \"Content-Type\": \"application/json\"\\n            },\\n            data=json.dumps({\\n                \\'moduleId\\': name,\\n                \\'deviceId\\': self._device_id\\n            })\\n        )\\n        if res.ok is not True:\\n            raise ResponseError(res.status_code, res.text)\\n        return self._generateModuleConnectionStr(res, islocal)\\n\\n    def _getModuleReqUri(self, name):\\n        return \"https://{0}/devices/{1}/modules/{2}?api-version=2018-06-30\".format(\\n            self._hostname, self._device_id, name)\\n\\n    def _get_update_twin_uri(self, name):\\n        return \"https://{0}/twins/{1}/modules/{2}?api-version=2018-06-30\".format(\\n            self._hostname, self._device_id, name)\\n\\n    def _generateModuleConnectionStr(self, response, islocal):\\n        jsonObj = response.json()\\n        moduleId = jsonObj[\\'moduleId\\']\\n        deviceId = jsonObj[\\'deviceId\\']\\n        sasKey = jsonObj[\\'authentication\\'][\\'symmetricKey\\'][\\'primaryKey\\']\\n        hubTemplate = \\'HostName={0};DeviceId={1};ModuleId={2};SharedAccessKey={3}\\'\\n        moduleTemplate = \\'HostName={0};GatewayHostName={1};DeviceId={2};ModuleId={3};SharedAccessKey={4}\\'\\n        gatewayhost = self._gatewayhost\\n        if (islocal):\\n            gatewayhost = \\'localhost\\'\\n        if (moduleId == \\'$edgeHub\\'):\\n            return hubTemplate.format(self._hostname, deviceId, moduleId, sasKey)\\n        else:\\n            return moduleTemplate.format(self._hostname, gatewayhost, deviceId, moduleId, sasKey)\\n\\n    def _generateRoutesEnvFromInputs(self, inputs):\\n        routes = [\\n            \\'routes__output=FROM /messages/modules/target/outputs/* INTO BrokeredEndpoint(\"/modules/input/inputs/print\")\\'\\n        ]\\n        template = \\'routes__r{0}=FROM /messages/modules/input/outputs/{1} INTO BrokeredEndpoint(\"/modules/target/inputs/{2}\")\\'\\n        inputSet = set(inputs)\\n        for (idx, input) in enumerate(inputSet):\\n            routes.append(template.format(idx + 1, input, input))\\n        return routes\\n\\n    def _prepare(self, edgedockerclient):\\n        edgedockerclient.create_network(EdgeManager.NW_NAME)\\n        edgedockerclient.create_volume(EdgeManager.HUB_VOLUME)\\n        edgedockerclient.create_volume(EdgeManager.MODULE_VOLUME)\\n\\n    def _start_edge_hub(self, edgedockerclient, edgeHubConnStr, routes, mount_base, envs, edgehub_image_version):\\n        edgehub_image = EdgeManager.EDGEHUB_IMG.format(edgehub_image_version)\\n        edgedockerclient.pull(edgehub_image, None, None)\\n        network_config = edgedockerclient.create_config_for_network(EdgeManager.NW_NAME, aliases=[self._gatewayhost])\\n        hub_mount = EdgeManager.HUB_MOUNT.format(mount_base)\\n        hub_host_config = edgedockerclient.create_host_config(\\n            mounts=[docker.types.Mount(hub_mount, EdgeManager.HUB_VOLUME)],\\n            port_bindings={\\n                \\'8883\\': 8883,\\n                \\'443\\': 443,\\n                \\'5671\\': 5671\\n            }\\n        )\\n        hubEnv = [\\n            EdgeManager.HUB_CA_ENV.format(mount_base),\\n            EdgeManager.HUB_CERT_ENV.format(mount_base),\\n            EdgeManager.HUB_SRC_ENV,\\n            EdgeManager.HUB_SSLPATH_ENV.format(mount_base),\\n            EdgeManager.HUB_SSLCRT_ENV,\\n            \\'IotHubConnectionString={0}\\'.format(edgeHubConnStr)]\\n        hubEnv.extend(routes)\\n        hubEnv.extend(list(envs))\\n\\n        hubContainer = edgedockerclient.create_container(\\n            edgehub_image,\\n            name=EdgeManager.EDGEHUB,\\n            volumes=[hub_mount],\\n            host_config=hub_host_config,\\n            networking_config=network_config,\\n            environment=hubEnv,\\n            labels=[EdgeManager.LABEL],\\n            ports=[(8883, \\'tcp\\'), (443, \\'tcp\\'), (5671, \\'tcp\\')]\\n        )\\n\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.EDGEHUB, EdgeManager.HUB_VOLUME, EdgeManager._chain_cert(),\\n            hub_mount, self._edge_cert.get_cert_file_path(EC.EDGE_CHAIN_CA))\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.EDGEHUB, EdgeManager.HUB_VOLUME, EdgeManager._hubserver_pfx(),\\n            hub_mount, self._edge_cert.get_pfx_file_path(EC.EDGE_HUB_SERVER))\\n        edgedockerclient.start(hubContainer.get(\\'Id\\'))\\n\\n    def _obtain_mount_path(self, edgedockerclient):\\n        os_type = edgedockerclient.get_os_type().lower()\\n        if os_type == \\'linux\\':\\n            return \\'/{0}\\'.format(EdgeManager.MOUNT_BASE)\\n        elif os_type == \\'windows\\':\\n            return \\'c:/{0}\\'.format(EdgeManager.MOUNT_BASE)\\n\\n    @staticmethod\\n    def _chain_cert():\\n        return EC.EDGE_CHAIN_CA + EC.CERT_SUFFIX\\n\\n    @staticmethod\\n    def _hubserver_pfx():\\n        return EC.EDGE_HUB_SERVER + EC.PFX_SUFFIX\\n\\n    @staticmethod\\n    def _device_cert():\\n        return EC.EDGE_DEVICE_CA + EC.CERT_SUFFIX\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "b\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nclass EdgeError(Exception):\\n    def __init__(self, msg, ex=None):\\n        if ex:\\n            msg += ' : {0}'.format(str(ex))\\n        super(EdgeError, self).__init__(msg)\\n        self._ex = ex\\n\\n\\nclass EdgeInvalidArgument(EdgeError):\\n    def __init__(self, msg, ex=None):\\n        super(EdgeInvalidArgument, self).__init__(msg, ex)\\n\\n\\nclass EdgeValueError(EdgeError):\\n    def __init__(self, msg, ex=None):\\n        super(EdgeValueError, self).__init__(msg, ex)\\n\\n\\nclass EdgeFileAccessError(EdgeError):\\n    def __init__(self, msg, file_name, ex=None):\\n        msg += ': {0}'.format(file_name)\\n        super(EdgeFileAccessError, self).__init__(msg, ex)\\n        self.file_name = file_name\\n\\n\\nclass EdgeFileParseError(EdgeError):\\n    def __init__(self, msg, file_name, ex=None):\\n        msg += ': {0}'.format(file_name)\\n        super(EdgeFileParseError, self).__init__(msg, ex)\\n        self.file_name = file_name\\n\\n\\nclass EdgeDeploymentError(EdgeError):\\n    def __init__(self, msg, ex=None):\\n        super(EdgeDeploymentError, self).__init__(msg, ex)\\n\\n\\nclass ResponseError(EdgeError):\\n    def __init__(self, status_code, value):\\n        super(ResponseError, self).__init__('Code:{0}. Detail:{1}'.format(status_code, value))\\n        self.value = value\\n        self.status_code = status_code\\n\\n\\nclass RegistriesLoginError(EdgeError):\\n    def __init__(self, registries, errmsg):\\n        super(RegistriesLoginError, self).__init__(errmsg)\\n        self._registries = registries\\n        self._errmsg = errmsg\\n\\n    def getmsg(self):\\n        return ('Fail to login {0}. Detail: {1}').format(self._registries, self._errmsg)\\n\\n    def registries(self):\\n        return self._registries\\n\\n\\nclass InvalidConfigError(EdgeError):\\n    def __init__(self, msg):\\n        super(InvalidConfigError, self).__init__(msg)\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "b\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport os\\nimport platform\\nfrom .errors import EdgeInvalidArgument\\n\\n\\nclass HostPlatform(object):\\n    _edge_dir = 'iotedgehubdev'\\n    _edgehub_config = 'edgehub.json'\\n    _setting_ini = 'setting.ini'\\n    _certs = 'certs'\\n    _data = 'data'\\n    _windows_config_path = os.getenv('PROGRAMDATA', '%%PROGRAMDATA%%')\\n\\n    _platforms = {\\n        'linux': {\\n            'supported_deployments': ['docker'],\\n            'default_deployment': 'docker',\\n            'default_edge_conf_dir': '/etc/' + _edge_dir,\\n            'default_edge_data_dir': '/var/lib/' + _edge_dir,\\n            'default_edge_meta_dir_env': 'HOME',\\n            'deployment': {\\n                'docker': {\\n                    'linux': {\\n                        'default_uri': 'unix:///var/run/docker.sock'\\n                    },\\n                }\\n            }\\n        },\\n        'windows': {\\n            'supported_deployments': ['docker'],\\n            'default_deployment': 'docker',\\n            'default_edge_conf_dir': _windows_config_path + '\\\\\\\\' + _edge_dir + '\\\\\\\\config',\\n            'default_edge_data_dir': _windows_config_path + '\\\\\\\\' + _edge_dir + '\\\\\\\\data',\\n            'default_edge_meta_dir_env': 'USERPROFILE',\\n            'deployment': {\\n                'docker': {\\n                    'linux': {\\n                        'default_uri': 'unix:///var/run/docker.sock'\\n                    },\\n                    'windows': {\\n                        'default_uri': 'npipe://./pipe/docker_engine'\\n                    }\\n                }\\n            }\\n        },\\n        'darwin': {\\n            'supported_deployments': ['docker'],\\n            'default_deployment': 'docker',\\n            'default_edge_conf_dir': '/etc/' + _edge_dir,\\n            'default_edge_data_dir': '/var/lib/' + _edge_dir,\\n            'default_edge_meta_dir_env': 'HOME',\\n            'deployment': {\\n                'docker': {\\n                    'linux': {\\n                        'default_uri': 'unix:///var/run/docker.sock'\\n                    },\\n                }\\n            }\\n        }\\n    }\\n\\n    # @staticmethod\\n    # def is_host_supported(host):\\n    #     if host is None:\\n    #         raise EdgeInvalidArgument('host cannot be None')\\n\\n    #     host = host.lower()\\n    #     if host in _platforms:\\n    #         return True\\n    #     return False\\n\\n    @staticmethod\\n    def get_config_path():\\n        host = platform.system()\\n        if host is None:\\n            raise EdgeInvalidArgument('host cannot be None')\\n        host = host.lower()\\n        if host in HostPlatform._platforms:\\n            return HostPlatform._platforms[host]['default_edge_conf_dir']\\n        return None\\n\\n    @staticmethod\\n    def get_config_file_path():\\n        configPath = HostPlatform.get_config_path()\\n        if configPath is not None:\\n            return os.path.join(configPath, HostPlatform._edgehub_config)\\n        return None\\n\\n    @staticmethod\\n    def get_setting_ini_path():\\n        configPath = HostPlatform.get_config_path()\\n        if configPath is not None:\\n            return os.path.join(configPath, HostPlatform._setting_ini)\\n        return None\\n\\n    @staticmethod\\n    def get_default_cert_path():\\n        host = platform.system()\\n        if host is None:\\n            raise EdgeInvalidArgument('host cannot be None')\\n        host = host.lower()\\n        if host in HostPlatform._platforms:\\n            return os.path.join(HostPlatform._platforms[host]['default_edge_data_dir'], HostPlatform._certs)\\n        return None\\n\\n    @staticmethod\\n    def get_share_data_path():\\n        host = platform.system()\\n        if host is None:\\n            raise EdgeInvalidArgument('host cannot be None')\\n        host = host.lower()\\n        if host in HostPlatform._platforms:\\n            return os.path.join(HostPlatform._platforms[host]['default_edge_data_dir'], HostPlatform._data)\\n        return None\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport click\\n\\n\\nclass Output:\\n\\n    def info(self, text, suppress=False):\\n        if not suppress:\\n            self.echo(text, color=\\'yellow\\')\\n\\n    def status(self, text):\\n        self.info(text)\\n        self.line()\\n\\n    def prompt(self, text):\\n        self.echo(text, color=\\'white\\')\\n\\n    def warning(self, text):\\n        self.echo(\"WARNING: \" + text, color=\\'yellow\\')\\n\\n    def error(self, text):\\n        self.echo(\"ERROR: \" + text, color=\\'red\\', err=True)\\n\\n    def header(self, text, suppress=False):\\n\\n        if not suppress:\\n            self.line()\\n            s = \"======== {0} ========\".format(text).upper()\\n            m = \"=\" * len(s)\\n            self.echo(m, color=\\'white\\')\\n            self.echo(s, color=\\'white\\')\\n            self.echo(m, color=\\'white\\')\\n            self.line()\\n\\n    def param(self, text, value, status, suppress):\\n        if value and not suppress:\\n            self.header(\"SETTING \" + text)\\n            self.status(status)\\n\\n    def footer(self, text, suppress=False):\\n        if not suppress:\\n            self.info(text.upper())\\n            self.line()\\n\\n    def procout(self, text):\\n        self.echo(text, dim=True)\\n\\n    def line(self):\\n        self.echo(text=\"\")\\n\\n    def echo(self, text, color=\"\", dim=False, err=False):\\n        try:\\n            click.secho(text, fg=color, dim=dim, err=err)\\n        except Exception:\\n            print(text)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "b\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport datetime\\nimport json\\nimport platform\\nimport uuid\\nimport multiprocessing\\n\\nfrom collections import defaultdict\\nfrom functools import wraps\\n\\n\\nfrom . import configs, decorators\\nfrom . import telemetry_upload as telemetry_core\\nfrom . import __production__ as production_name\\n\\nPRODUCT_NAME = production_name\\n\\n\\nclass TelemetrySession(object):\\n    def __init__(self, correlation_id=None):\\n        self.start_time = None\\n        self.end_time = None\\n        self.correlation_id = correlation_id or str(uuid.uuid4())\\n        self.command = 'command_name'\\n        self.parameters = []\\n        self.result = 'None'\\n        self.result_summary = None\\n        self.exception = None\\n        self.extra_props = {}\\n        self.machineId = self._get_hash_mac_address()\\n        self.events = defaultdict(list)\\n\\n    def generate_payload(self):\\n        props = {\\n            'EventId': str(uuid.uuid4()),\\n            'CorrelationId': self.correlation_id,\\n            'MachineId': self.machineId,\\n            'ProductName': PRODUCT_NAME,\\n            'ProductVersion': _get_core_version(),\\n            'CommandName': self.command,\\n            'OS.Type': platform.system().lower(),\\n            'OS.Version': platform.version().lower(),\\n            'Result': self.result,\\n            'StartTime': str(self.start_time),\\n            'EndTime': str(self.end_time),\\n            'Parameters': ','.join(self.parameters)\\n        }\\n\\n        if self.result_summary:\\n            props['ResultSummary'] = self.result_summary\\n\\n        if self.exception:\\n            props['Exception'] = self.exception\\n\\n        props.update(self.extra_props)\\n\\n        self.events[_get_AI_key()].append({\\n            'name': '{}/command'.format(PRODUCT_NAME),\\n            'properties': props\\n        })\\n\\n        payload = json.dumps(self.events)\\n        return _remove_symbols(payload)\\n\\n    @decorators.suppress_all_exceptions()\\n    @decorators.hash256_result\\n    def _get_hash_mac_address(self):\\n        s = ''\\n        for index, c in enumerate(hex(uuid.getnode())[2:].upper()):\\n            s += c\\n            if index % 2:\\n                s += '-'\\n\\n        s = s.strip('-')\\n        return s\\n\\n\\n_session = TelemetrySession()\\n\\n\\ndef _user_agrees_to_telemetry(func):\\n    @wraps(func)\\n    def _wrapper(*args, **kwargs):\\n        if not configs.get_ini_config().getboolean('DEFAULT', 'collect_telemetry'):\\n            return None\\n        return func(*args, **kwargs)\\n\\n    return _wrapper\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef start(cmdname, params=[]):\\n    _session.command = cmdname\\n    _session.start_time = datetime.datetime.utcnow()\\n    if params is not None:\\n        _session.parameters.extend(params)\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef success():\\n    _session.result = 'Success'\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef fail(exception, summary):\\n    _session.exception = exception\\n    _session.result = 'Fail'\\n    _session.result_summary = summary\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef add_extra_props(props):\\n    if props is not None:\\n        _session.extra_props.update(props)\\n\\n\\n@_user_agrees_to_telemetry\\n@decorators.suppress_all_exceptions()\\ndef flush():\\n    # flush out current information\\n    _session.end_time = datetime.datetime.utcnow()\\n\\n    payload = _session.generate_payload()\\n    if payload:\\n        _upload_telemetry_with_user_agreement(payload)\\n\\n    # reset session fields, retaining correlation id and application\\n    _session.__init__(correlation_id=_session.correlation_id)\\n\\n\\n@decorators.suppress_all_exceptions(fallback_return=None)\\ndef _get_core_version():\\n    from iotedgehubdev import __version__ as core_version\\n    return core_version\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef _get_AI_key():\\n    from iotedgehubdev import __AIkey__ as key\\n    return key\\n\\n\\n# This includes a final user-agreement-check; ALL methods sending telemetry MUST call this.\\n@_user_agrees_to_telemetry\\n@decorators.suppress_all_exceptions()\\ndef _upload_telemetry_with_user_agreement(payload):\\n    p = multiprocessing.Process(target=telemetry_core.upload, args=(payload,))\\n    p.start()\\n\\n\\ndef _remove_symbols(s):\\n    if isinstance(s, str):\\n        for c in '$%^&|':\\n            s = s.replace(c, '_')\\n    return s\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport urllib.request as HTTPClient\\nimport sys\\nimport json\\n\\nfrom applicationinsights import TelemetryClient\\nfrom applicationinsights.exceptions import enable\\nfrom applicationinsights.channel import SynchronousSender, SynchronousQueue, TelemetryChannel\\nfrom iotedgehubdev import decorators\\n\\n\\nclass LimitedRetrySender(SynchronousSender):\\n    def __init__(self):\\n        super(LimitedRetrySender, self).__init__()\\n\\n    def send(self, data_to_send):\\n        \"\"\" Override the default resend mechanism in SenderBase. Stop resend when it fails.\"\"\"\\n        request_payload = json.dumps([a.write() for a in data_to_send])\\n\\n        request = HTTPClient.Request(self._service_endpoint_uri, bytearray(request_payload, \\'utf-8\\'),\\n                                     {\\'Accept\\': \\'application/json\\', \\'Content-Type\\': \\'application/json; charset=utf-8\\'})\\n        try:\\n            HTTPClient.urlopen(request, timeout=10)\\n        except Exception:  # pylint: disable=broad-except\\n            pass\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef upload(data_to_save):\\n    try:\\n        data_to_save = json.loads(data_to_save)\\n    except Exception:\\n        pass\\n\\n    for instrumentation_key in data_to_save:\\n        client = TelemetryClient(instrumentation_key=instrumentation_key,\\n                                 telemetry_channel=TelemetryChannel(queue=SynchronousQueue(LimitedRetrySender())))\\n        enable(instrumentation_key)\\n        for record in data_to_save[instrumentation_key]:\\n            name = record[\\'name\\']\\n            raw_properties = record[\\'properties\\']\\n            properties = {}\\n            measurements = {}\\n            for k, v in raw_properties.items():\\n                if isinstance(v, str):\\n                    properties[k] = v\\n                else:\\n                    measurements[k] = v\\n            client.track_event(name, properties, measurements)\\n        client.flush()\\n\\n\\nif __name__ == \\'__main__\\':\\n    # If user doesn\\'t agree to upload telemetry, this scripts won\\'t be executed. The caller should control.\\n    upload(sys.argv[1])\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport errno\\nimport os\\nimport shutil\\nimport socket\\nimport stat\\nimport subprocess\\n\\n\\nfrom base64 import b64decode, b64encode\\nfrom hashlib import sha256\\nfrom hmac import HMAC\\nfrom time import time\\nfrom urllib.parse import urlencode, quote_plus\\nfrom .constants import EdgeConstants as EC\\nfrom .decorators import suppress_all_exceptions\\nfrom .errors import EdgeFileAccessError\\n\\n\\nclass Utils(object):\\n    @staticmethod\\n    def parse_connection_strs(device_conn_str, hub_conn_str=None):\\n        data = Utils._parse_device_connection_str(device_conn_str)\\n        data[EC.DEVICE_ACCESS_KEY_KEY] = data.pop(EC.ACCESS_KEY_KEY)\\n        if hub_conn_str is not None:\\n            hub_data = Utils._parse_hub_connection_str(hub_conn_str, data[EC.HOSTNAME_KEY])\\n            data[EC.HUB_ACCESS_KEY_KEY] = hub_data[EC.ACCESS_KEY_KEY]\\n            data[EC.ACCESS_KEY_NAME] = hub_data[EC.ACCESS_KEY_NAME]\\n        return data\\n\\n    @staticmethod\\n    def _parse_device_connection_str(connection_string):\\n        data = Utils._split_connection_string(connection_string)\\n        if len(data) > 0:\\n            if EC.HOSTNAME_KEY not in data or EC.DEVICE_ID_KEY not in data or EC.ACCESS_KEY_KEY not in data:\\n                if EC.ACCESS_KEY_NAME in data:\\n                    raise KeyError(\\'Please make sure you are using a device connection string \\'\\n                                   \\'instead of an IoT Hub connection string\\')\\n                else:\\n                    raise KeyError(\\'Error parsing connection string. \\'\\n                                   \\'Please make sure you wrap the connection string with double quotes when supplying it via CLI\\')\\n            return data\\n        else:\\n            raise KeyError(\\'Error parsing connection string\\')\\n\\n    @staticmethod\\n    def _parse_hub_connection_str(hub_connection_string, host_name):\\n        hub_data = Utils._split_connection_string(hub_connection_string)\\n        if len(hub_data) > 0:\\n            if EC.HOSTNAME_KEY not in hub_data or EC.ACCESS_KEY_NAME not in hub_data or EC.ACCESS_KEY_KEY not in hub_data:\\n                if EC.DEVICE_ID_KEY in hub_data:\\n                    raise KeyError(\\'Please make sure you are using a IoT Hub connection string \\'\\n                                   \\'instead of an device connection string\\')\\n                else:\\n                    raise KeyError(\\'Error parsing connection string. \\'\\n                                   \\'Please make sure you wrap the connection string with double quotes when supplying it via CLI\\')\\n            elif hub_data[EC.HOSTNAME_KEY] != host_name:\\n                raise KeyError(\\'Please make sure the device belongs to the IoT Hub\\')\\n            return hub_data\\n        else:\\n            raise KeyError(\\'Error parsing IoT Hub connection string\\')\\n\\n    @staticmethod\\n    def _split_connection_string(connection_string):\\n        data = dict()\\n        if connection_string is not None:\\n            parts = connection_string.split(\\';\\')\\n            for part in parts:\\n                if \"=\" in part:\\n                    subparts = [s.strip() for s in part.split(\"=\", 1)]\\n                    data[subparts[0]] = subparts[1]\\n        return data\\n\\n    @staticmethod\\n    def get_hostname():\\n        try:\\n            return socket.getfqdn()\\n        except IOError as ex:\\n            raise ex\\n\\n    @staticmethod\\n    def check_if_file_exists(file_path):\\n        if file_path is None \\\\\\n           or os.path.exists(file_path) is False \\\\\\n           or os.path.isfile(file_path) is False:\\n            return False\\n        return True\\n\\n    @staticmethod\\n    def check_if_directory_exists(dir_path):\\n        if dir_path is None \\\\\\n           or os.path.exists(dir_path) is False \\\\\\n           or os.path.isdir(dir_path) is False:\\n            return False\\n        return True\\n\\n    @staticmethod\\n    def delete_dir(dir_path):\\n        try:\\n            if os.path.exists(dir_path):\\n                shutil.rmtree(dir_path, onerror=Utils._remove_readonly_callback)\\n        except OSError as ex:\\n            raise ex\\n\\n    @staticmethod\\n    def mkdir_if_needed(dir_path):\\n        try:\\n            os.makedirs(dir_path)\\n        except OSError as ex:\\n            if ex.errno != errno.EEXIST:\\n                raise ex\\n\\n    @staticmethod\\n    def delete_file(file_path, file_type_diagnostic):\\n        try:\\n            if os.path.exists(file_path):\\n                os.unlink(file_path)\\n        except OSError as ex:\\n            msg = \\'Error deleteing {0}: {1}. \\' \\\\\\n                  \\'Errno: {2}, Error: {3}\\'.format(file_type_diagnostic,\\n                                                  file_path, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, file_path)\\n\\n    @staticmethod\\n    def create_file(file_path, data, file_type_diagnostic, mode=0o644):\\n        try:\\n            fd = os.open(file_path, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, mode)\\n            with os.fdopen(fd, \\'w\\') as output_file:\\n                output_file.write(data)\\n        except OSError as ex:\\n            msg = \\'Error creating {0}: {1}. \\' \\\\\\n                  \\'Errno: {2}, Error: {3}\\'.format(file_type_diagnostic,\\n                                                  file_path, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, file_path)\\n\\n    @staticmethod\\n    def get_iot_hub_sas_token(uri, key, policy_name, expiry=3600):\\n        ttl = time() + expiry\\n        sign_key = \"%s\\\\n%d\" % ((quote_plus(uri)), int(ttl))\\n        signature = b64encode(\\n            HMAC(b64decode(key), sign_key.encode(\"utf-8\"), sha256).digest())\\n\\n        rawtoken = {\\n            \"sr\": uri,\\n            \"sig\": signature,\\n            \"se\": str(int(ttl))\\n        }\\n\\n        if policy_name is not None:\\n            rawtoken[\"skn\"] = policy_name\\n\\n        return \"SharedAccessSignature \" + urlencode(rawtoken)\\n\\n    @staticmethod\\n    def copy_files(src_path, dst_path):\\n        try:\\n            shutil.copy2(src_path, dst_path)\\n        except OSError as ex:\\n            raise ex\\n\\n    @staticmethod\\n    def _remove_readonly_callback(func, path, excinfo):\\n        del func, excinfo\\n        os.chmod(path, stat.S_IWRITE)\\n        os.unlink(path)\\n\\n    @staticmethod\\n    def exe_proc(params, shell=False, cwd=None, suppress_out=False):\\n        try:\\n            subprocess.check_call(params, shell=shell, cwd=cwd)\\n        except KeyboardInterrupt:\\n            raise\\n        except Exception as e:\\n            raise Exception(\"Error while executing command: {0}. {1}\".format(\\' \\'.join(params), str(e)))\\n\\n    @staticmethod\\n    @suppress_all_exceptions()\\n    def hash_connection_str_hostname(hostname):\\n        \"\"\"Hash connection string hostname to count distint IoT Hub number\"\"\"\\n        if not hostname:\\n            return (\"\", \"\")\\n\\n        # get hostname suffix (e.g., azure-devices.net) to distinguish national clouds\\n        if \".\" in hostname:\\n            hostname_suffix = hostname[hostname.index(\".\") + 1:]\\n        else:\\n            hostname_suffix = \"\"\\n\\n        return (Utils.get_sha256_hash(hostname), hostname_suffix)\\n\\n    @staticmethod\\n    def get_sha256_hash(val):\\n        hash_object = sha256(val.encode(\\'utf-8\\'))\\n\\n        return str(hash_object.hexdigest()).lower()\\n\\n    @staticmethod\\n    def get_device_ca_file_paths(root_dir, cert_id):\\n        result = {}\\n        result[EC.CERT_SUFFIX] = os.path.join(root_dir, cert_id + EC.CERT_SUFFIX)\\n        result[EC.KEY_SUFFIX] = os.path.join(root_dir, cert_id + EC.KEY_SUFFIX)\\n        result[EC.CHAIN_CERT_SUFFIX] = os.path.join(root_dir, cert_id + EC.CHAIN_CERT_SUFFIX)\\n        return result\\n'"}]}, "get_python_source": {"line": 37, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/__init__.py'"}, "return_value": "\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport pkg_resources\\n\\npkg_resources.declare_namespace(__name__)\\n\\n__author__ = 'Microsoft Corporation'\\n__version__ = '0.14.10'\\n__AIkey__ = '95b20d64-f54f-4de3-8ad5-165a75a6c6fe'\\n__production__ = 'iotedgehubdev'\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/certutils.py'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport os\\nfrom OpenSSL import crypto\\nfrom shutil import copy2\\nfrom datetime import datetime\\nfrom .errors import EdgeFileAccessError, EdgeInvalidArgument, EdgeValueError\\nfrom .constants import EdgeConstants as EC\\nfrom .utils import Utils\\n\\n\\nclass EdgeCertUtil(object):\\n\\n    TYPE_RSA = 0\\n    MIN_VALIDITY_DAYS = 1\\n    MAX_VALIDITY_DAYS = 1095  # 3 years\\n    MIN_PASSPHRASE_LENGTH = 4\\n    MAX_PASSPHRASE_LENGTH = 1023\\n    CA_KEY_LEN = 4096\\n    CA_INT_KEY_LEN = 4096\\n    SERVER_KEY_LEN = 2048\\n    MIN_COMMON_NAME_LEN = 1\\n    MAX_COMMON_NAME_LEN = 64\\n    DIGEST = \\'sha256\\'\\n    _type_dict = {TYPE_RSA: crypto.TYPE_RSA}\\n    _subject_validation_dict = {\\n        EC.SUBJECT_COUNTRY_KEY: {\\'MIN\\': 2, \\'MAX\\': 2},\\n        EC.SUBJECT_STATE_KEY: {\\'MIN\\': 0, \\'MAX\\': 128},\\n        EC.SUBJECT_LOCALITY_KEY: {\\'MIN\\': 0, \\'MAX\\': 128},\\n        EC.SUBJECT_ORGANIZATION_KEY: {\\'MIN\\': 0, \\'MAX\\': 64},\\n        EC.SUBJECT_ORGANIZATION_UNIT_KEY: {\\'MIN\\': 0, \\'MAX\\': 64},\\n        EC.SUBJECT_COMMON_NAME_KEY: {\\'MIN\\': MIN_COMMON_NAME_LEN,\\n                                     \\'MAX\\': MAX_COMMON_NAME_LEN}\\n    }\\n\\n    def __init__(self, serial_num=1000):\\n        self._cert_chain = {}\\n        self._serial_number = serial_num\\n\\n    def create_root_ca_cert(self, id_str, **kwargs):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Duplicate root CA certificate ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        validity_days_from_now = self._get_kwargs_validity(**kwargs)\\n        subj_dict = None\\n        if \\'subject_dict\\' in kwargs:\\n            subj_dict = kwargs[\\'subject_dict\\']\\n            if self.is_valid_certificate_subject(subj_dict) is False:\\n                msg = \\'Certificate subject dictionary is invalid.\\'\\n                raise EdgeValueError(msg)\\n        else:\\n            msg = \\'Certificate subject dictionary is required\\'\\n            raise EdgeValueError(msg)\\n        passphrase = self._get_kwargs_passphrase(**kwargs)\\n\\n        key_obj = self._create_key_pair(EdgeCertUtil.TYPE_RSA,\\n                                        EdgeCertUtil.CA_KEY_LEN)\\n        csr_obj = self._create_csr(key_obj,\\n                                   C=subj_dict[EC.SUBJECT_COUNTRY_KEY],\\n                                   ST=subj_dict[EC.SUBJECT_STATE_KEY],\\n                                   L=subj_dict[EC.SUBJECT_LOCALITY_KEY],\\n                                   O=subj_dict[EC.SUBJECT_ORGANIZATION_KEY],\\n                                   OU=subj_dict[EC.SUBJECT_ORGANIZATION_KEY],\\n                                   CN=subj_dict[EC.SUBJECT_COMMON_NAME_KEY])\\n\\n        validity_secs_from_now = validity_days_from_now * 24 * 60 * 60\\n        cert_obj = self._create_ca_cert(csr_obj,\\n                                        csr_obj,\\n                                        key_obj,\\n                                        (0, validity_secs_from_now),\\n                                        False)\\n        self._serial_number += 1\\n        cert_dict = {}\\n        cert_dict[\\'key_pair\\'] = key_obj\\n        cert_dict[\\'csr\\'] = csr_obj\\n        cert_dict[\\'cert\\'] = cert_obj\\n        cert_dict[\\'issuer_id\\'] = id_str\\n        cert_dict[\\'passphrase\\'] = passphrase\\n        self._cert_chain[id_str] = cert_dict\\n\\n    def create_intermediate_ca_cert(self, id_str, issuer_id_str, **kwargs):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Duplicate intermediate CA certificate ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        if issuer_id_str not in list(self._cert_chain.keys()):\\n            msg = \\'Invalid issuer certificate ID: {0}\\'.format(issuer_id_str)\\n            raise EdgeValueError(msg)\\n\\n        validity_days_from_now = self._get_kwargs_validity(**kwargs)\\n        passphrase = self._get_kwargs_passphrase(**kwargs)\\n\\n        min_length = self._subject_validation_dict[EC.SUBJECT_COMMON_NAME_KEY][\\'MIN\\']\\n        max_length = self._subject_validation_dict[EC.SUBJECT_COMMON_NAME_KEY][\\'MAX\\']\\n        common_name = self._get_kwargs_string(\\'common_name\\', min_length, max_length, **kwargs)\\n        if common_name is None:\\n            msg = \\'Invalid common name: {0}\\'.format(common_name)\\n            raise EdgeValueError(msg)\\n\\n        set_terminal_ca = True\\n        if \\'set_terminal_ca\\' in kwargs:\\n            set_terminal_ca = kwargs[\\'set_terminal_ca\\']\\n\\n        try:\\n            issuer_cert_dict = self._cert_chain[issuer_id_str]\\n            issuer_cert = issuer_cert_dict[\\'cert\\']\\n\\n            not_after_ts = issuer_cert.get_notAfter()\\n            valid_days = self._get_maximum_validity_days(not_after_ts,\\n                                                         validity_days_from_now)\\n\\n            issuer_key = issuer_cert_dict[\\'key_pair\\']\\n            key_obj = self._create_key_pair(EdgeCertUtil.TYPE_RSA, EdgeCertUtil.CA_KEY_LEN)\\n            csr_obj = self._create_csr(key_obj,\\n                                       C=issuer_cert.get_subject().countryName,\\n                                       ST=issuer_cert.get_subject().stateOrProvinceName,\\n                                       L=issuer_cert.get_subject().localityName,\\n                                       O=issuer_cert.get_subject().organizationName,\\n                                       OU=issuer_cert.get_subject().organizationalUnitName,\\n                                       CN=common_name)\\n\\n            validity_secs_from_now = valid_days * 24 * 60 * 60\\n            cert_obj = self._create_ca_cert(csr_obj,\\n                                            issuer_cert,\\n                                            issuer_key,\\n                                            (0, validity_secs_from_now),\\n                                            set_terminal_ca)\\n            self._serial_number += 1\\n            cert_dict = {}\\n            cert_dict[\\'key_pair\\'] = key_obj\\n            cert_dict[\\'csr\\'] = csr_obj\\n            cert_dict[\\'cert\\'] = cert_obj\\n            cert_dict[\\'issuer_id\\'] = issuer_id_str\\n            cert_dict[\\'passphrase\\'] = passphrase\\n            self._cert_chain[id_str] = cert_dict\\n        except EdgeValueError:\\n            msg = \\'Could not create intermediate certificate for {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n    def create_server_cert(self, id_str, issuer_id_str, **kwargs):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Duplicate intermediate CA certificate ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        if issuer_id_str not in list(self._cert_chain.keys()):\\n            msg = \\'Invalid issuer certificate ID: {0}\\'.format(issuer_id_str)\\n            raise EdgeValueError(msg)\\n\\n        validity_days_from_now = self._get_kwargs_validity(**kwargs)\\n\\n        passphrase = self._get_kwargs_passphrase(**kwargs)\\n\\n        max_length = self._subject_validation_dict[EC.SUBJECT_COMMON_NAME_KEY][\\'MAX\\']\\n        hostname = kwargs.get(\\'hostname\\', None)\\n        if hostname is None:\\n            msg = \\'Invalid hostname: {0}\\'.format(hostname)\\n            raise EdgeValueError(msg)\\n        # CN length is limited to 64. Since the certificate is used internally so just cut to 64.\\n        common_name = hostname if len(hostname) <= max_length else hostname[:max_length]\\n\\n        try:\\n            issuer_cert_dict = self._cert_chain[issuer_id_str]\\n            issuer_cert = issuer_cert_dict[\\'cert\\']\\n            issuer_key = issuer_cert_dict[\\'key_pair\\']\\n            key_obj = self._create_key_pair(EdgeCertUtil.TYPE_RSA, EdgeCertUtil.SERVER_KEY_LEN)\\n            csr_obj = self._create_csr(key_obj,\\n                                       C=issuer_cert.get_subject().countryName,\\n                                       ST=issuer_cert.get_subject().stateOrProvinceName,\\n                                       L=issuer_cert.get_subject().localityName,\\n                                       O=issuer_cert.get_subject().organizationName,\\n                                       OU=issuer_cert.get_subject().organizationalUnitName,\\n                                       CN=common_name)\\n            not_after_ts = issuer_cert.get_notAfter()\\n            valid_days = self._get_maximum_validity_days(not_after_ts,\\n                                                         validity_days_from_now)\\n            validity_secs_from_now = valid_days * 24 * 60 * 60\\n            cert_obj = self._create_server_cert(csr_obj,\\n                                                issuer_cert,\\n                                                issuer_key,\\n                                                (0, validity_secs_from_now),\\n                                                hostname)\\n            self._serial_number += 1\\n            cert_dict = {}\\n            cert_dict[\\'key_pair\\'] = key_obj\\n            cert_dict[\\'csr\\'] = csr_obj\\n            cert_dict[\\'cert\\'] = cert_obj\\n            cert_dict[\\'issuer_id\\'] = issuer_id_str\\n            cert_dict[\\'passphrase\\'] = passphrase\\n            self._cert_chain[id_str] = cert_dict\\n        except EdgeValueError:\\n            msg = \\'Could not create server certificate for {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n    def export_pfx_cert(self, id_str, dir_path):\\n        if id_str not in self._cert_chain:\\n            msg = \\'Invalid cert ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        try:\\n            cert_dict = self._cert_chain[id_str]\\n            cert_obj = cert_dict[\\'cert\\']\\n            key_obj = cert_dict[\\'key_pair\\']\\n            pfx = crypto.PKCS12()\\n            pfx.set_privatekey(key_obj)\\n            pfx.set_certificate(cert_obj)\\n            pfx_data = pfx.export()\\n            prefix = id_str\\n            path = os.path.realpath(dir_path)\\n            path = os.path.join(path, prefix)\\n            cert_dir = os.path.join(path, \\'cert\\')\\n            pfx_output_file_name = os.path.join(cert_dir, prefix + EC.PFX_SUFFIX)\\n            with open(pfx_output_file_name, \\'wb\\') as pfx_file:\\n                pfx_file.write(pfx_data)\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting PFX cert ID: {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(id_str, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, pfx_output_file_name)\\n\\n    @staticmethod\\n    def get_cert_file_path(id_str, dir_path):\\n        return os.path.join(dir_path, id_str, \\'cert\\', id_str + EC.CERT_SUFFIX)\\n\\n    @staticmethod\\n    def get_pfx_file_path(id_str, dir_path):\\n        return os.path.join(dir_path, id_str, \\'cert\\', id_str + EC.PFX_SUFFIX)\\n\\n    def load_cert_from_file(self, id_str, cert_path, key_path, key_passphrase):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Could not load cert from file. Certificate already in chain. ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n        cert_dict = {}\\n        # Load cert\\n        try:\\n            with open(cert_path, \\'r\\') as cert_file:\\n                cert_content = cert_file.read()\\n                cert_dict[\\'cert\\'] = crypto.load_certificate(crypto.FILETYPE_PEM, cert_content)\\n        except Exception as ex:\\n            raise EdgeInvalidArgument(\\'Failed to load cert from %s. Error: %s\\' % (cert_path, ex), ex)\\n        # Load key\\n        try:\\n            with open(key_path, \\'r\\') as key_file:\\n                key_content = key_file.read()\\n                cert_dict[\\'key_pair\\'] = crypto.load_privatekey(crypto.FILETYPE_PEM, key_content, key_passphrase)\\n        except Exception as ex:\\n            raise EdgeInvalidArgument(\\n                \\'Failed to load private key from %s. Please check your passphase first. Error: %s\\' % (key_path, ex), ex)\\n        self._cert_chain[id_str] = cert_dict\\n\\n    def export_simulator_cert_artifacts_to_dir(self, id_str, dir_path):\\n        if Utils.check_if_directory_exists(dir_path) is False:\\n            msg = \\'Invalid export directory {0}\\'.format(dir_path)\\n            raise EdgeValueError(msg)\\n\\n        cert_dict = self._get_cert_dict(id_str)\\n        prefix = id_str\\n        try:\\n            path = os.path.realpath(dir_path)\\n            path = os.path.join(path, prefix)\\n            Utils.delete_dir(path)\\n            Utils.mkdir_if_needed(path)\\n            priv_dir = os.path.join(path, \\'private\\')\\n            Utils.mkdir_if_needed(priv_dir)\\n            os.chmod(priv_dir, 0o700)\\n            cert_dir = os.path.join(path, \\'cert\\')\\n            Utils.mkdir_if_needed(cert_dir)\\n\\n            # export the private key\\n            priv_key_file_name = prefix + \\'.key.pem\\'\\n            priv_key_file = os.path.join(priv_dir, priv_key_file_name)\\n            self._dump_cert_key(cert_dict, priv_key_file)\\n\\n            # export the cert\\n            cert_file_name = prefix + EC.CERT_SUFFIX\\n            cert_file = os.path.join(cert_dir, cert_file_name)\\n            current_cert_file_path = cert_file\\n            self._dump_cert_content(cert_dict, cert_file)\\n\\n            # export any chain certs\\n            if \\'ca_chain\\' in list(cert_dict.keys()):\\n                src_chain_cert_file = cert_dict[\\'ca_chain\\']\\n                cert_file_name = prefix + \\'-chain.cert.pem\\'\\n                cert_file = os.path.join(cert_dir, cert_file_name)\\n                copy2(src_chain_cert_file, cert_file)\\n\\n            # check if this is the root cert in the chain, i.e. issuer is itself\\n            if cert_dict[\\'issuer_id\\'] == id_str:\\n                cert_file_name = prefix + \\'-root.cert.pem\\'\\n                cert_file = os.path.join(cert_dir, cert_file_name)\\n                if \\'ca_root\\' in list(cert_dict.keys()):\\n                    src_root_cert_file = cert_dict[\\'ca_root\\']\\n                else:\\n                    src_root_cert_file = current_cert_file_path\\n                copy2(src_root_cert_file, cert_file)\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting certs for ID: {0}.\\\\n\\' \\\\\\n                  \\' Error seen when copying/exporting file {1}.\\' \\\\\\n                  \\' Errno: {2} Error: {3}\\'.format(id_str, ex.filename, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, path)\\n\\n    def export_device_ca_cert_artifacts_to_dir(self, id_str, dir_path):\\n        output_files = Utils.get_device_ca_file_paths(dir_path, id_str)\\n        cert_path = output_files[EC.CERT_SUFFIX]\\n        key_path = output_files[EC.KEY_SUFFIX]\\n        cert_dict = self._get_cert_dict(id_str)\\n        self._dump_cert_content(cert_dict, cert_path)\\n        self._dump_cert_key(cert_dict, key_path)\\n\\n    def chain_simulator_ca_certs(self, output_prefix, prefixes, certs_dir):\\n        try:\\n            output_dir = os.path.join(certs_dir, output_prefix)\\n            Utils.delete_dir(output_dir)\\n            Utils.mkdir_if_needed(output_dir)\\n            output_dir = os.path.join(output_dir, \\'cert\\')\\n            Utils.mkdir_if_needed(output_dir)\\n            output_file_name = os.path.join(output_dir, output_prefix + EC.CERT_SUFFIX)\\n            self._chain_ca_certs(output_file_name, prefixes, certs_dir, self._simulator_cert_file_path_gen)\\n        except IOError as ex:\\n            msg = \\'IO Error when creating chain cert: {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(output_file_name, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_file_name)\\n\\n    def chain_device_ca_certs(self, output_prefix, id_strs, certs_dir):\\n        cert_files = Utils.get_device_ca_file_paths(certs_dir, output_prefix)\\n        chain_path = cert_files[EC.CHAIN_CERT_SUFFIX]\\n        self._chain_ca_certs(chain_path, id_strs, certs_dir, self._device_ca_cert_file_path_gen)\\n\\n    def is_valid_certificate_subject(self, subject_dict):\\n        result = True\\n        for key in list(EdgeCertUtil._subject_validation_dict.keys()):\\n            try:\\n                field = subject_dict[key]\\n                if field is not None:\\n                    length_field = len(field)\\n                    min_len = EdgeCertUtil._subject_validation_dict[key][\\'MIN\\']\\n                    max_len = EdgeCertUtil._subject_validation_dict[key][\\'MAX\\']\\n                    if length_field < min_len or length_field > max_len:\\n                        result = False\\n                else:\\n                    result = False\\n            except KeyError:\\n                result = False\\n\\n            if result is False:\\n                break\\n        return result\\n\\n    def _create_csr(self, key_pair, **kwargs):\\n        csr = crypto.X509Req()\\n        subj = csr.get_subject()\\n        for key, value in list(kwargs.items()):\\n            if value:\\n                setattr(subj, key, value)\\n        csr.set_pubkey(key_pair)\\n        csr.sign(key_pair, EdgeCertUtil.DIGEST)\\n        return csr\\n\\n    def _create_cert_common(self,\\n                            csr,\\n                            issuer_cert,\\n                            validity_period):\\n        not_before, not_after = validity_period\\n        cert = crypto.X509()\\n        cert.set_serial_number(self._serial_number)\\n        cert.gmtime_adj_notBefore(not_before)\\n        cert.gmtime_adj_notAfter(not_after)\\n        cert.set_issuer(issuer_cert.get_subject())\\n        cert.set_subject(csr.get_subject())\\n        cert.set_pubkey(csr.get_pubkey())\\n        cert.set_version(2)\\n        return cert\\n\\n    def _create_ca_cert(self,\\n                        csr,\\n                        issuer_cert,\\n                        issuer_key_pair,\\n                        validity_period,\\n                        path_len_zero):\\n        cert = self._create_cert_common(csr, issuer_cert, validity_period)\\n        val = b\\'CA:TRUE\\'\\n        if path_len_zero:\\n            val += b\\', pathlen:0\\'\\n        extensions = []\\n        extensions.append(crypto.X509Extension(b\\'basicConstraints\\',\\n                                               critical=True, value=val))\\n        extensions.append(crypto.X509Extension(b\\'subjectKeyIdentifier\\',\\n                                               False,\\n                                               b\\'hash\\',\\n                                               subject=cert))\\n        extensions.append(crypto.X509Extension(b\\'keyUsage\\',\\n                                               critical=True,\\n                                               value=b\\'digitalSignature, cRLSign, keyCertSign\\'))\\n        # authorityKeyIdentifier requires subjectKeyIdentifier in issuer cert, add it first\\n        cert.add_extensions(extensions)\\n\\n        del extensions[:]\\n        extensions.append(crypto.X509Extension(b\\'authorityKeyIdentifier\\',\\n                                               False,\\n                                               b\\'keyid:always,issuer:always\\',\\n                                               issuer=issuer_cert if isinstance(issuer_cert, crypto.X509) else cert))\\n        cert.add_extensions(extensions)\\n        cert.sign(issuer_key_pair, EdgeCertUtil.DIGEST)\\n        return cert\\n\\n    def _create_server_cert(self,\\n                            csr,\\n                            issuer_cert,\\n                            issuer_key_pair,\\n                            validity_period,\\n                            hostname):\\n        cert = self._create_cert_common(csr,\\n                                        issuer_cert,\\n                                        validity_period)\\n\\n        extensions = []\\n        extensions.append(crypto.X509Extension(b\\'basicConstraints\\',\\n                                               critical=False,\\n                                               value=b\\'CA:FALSE\\'))\\n        altDns = \\',\\'.join([\\'DNS:localhost\\', \\'DNS:{0}\\'.format(hostname)]).encode(\\'utf-8\\')\\n        extensions.append(crypto.X509Extension(b\\'subjectAltName\\',\\n                                               critical=False,\\n                                               value=altDns))\\n        cert.add_extensions(extensions)\\n        cert.sign(issuer_key_pair, EdgeCertUtil.DIGEST)\\n        return cert\\n\\n    def _create_key_pair(self, private_key_type, key_bit_len):\\n        key_pair = crypto.PKey()\\n        key_pair.generate_key(EdgeCertUtil._type_dict[private_key_type], key_bit_len)\\n        return key_pair\\n\\n    def _get_maximum_validity_days(self, not_after_ts_asn1, validity_days_from_now):\\n        result = 0\\n        try:\\n            expiration_date = datetime.strptime(not_after_ts_asn1.decode(\\'utf-8\\'), \"%Y%m%d%H%M%SZ\")\\n            expires_in = expiration_date - datetime.now()\\n            if expires_in.days > 0:\\n                result = min(expires_in.days, validity_days_from_now)\\n            return result\\n        except Exception:\\n            msg = \\'Certificate date format incompatible {0}\\'.format(not_after_ts_asn1)\\n            raise EdgeValueError(msg)\\n\\n    def _get_kwargs_validity(self, **kwargs):\\n        validity_days_from_now = 365\\n        min_validity = EdgeCertUtil.MIN_VALIDITY_DAYS\\n        max_validity = EdgeCertUtil.MAX_VALIDITY_DAYS\\n        kwarg_key = \\'validity_days_from_now\\'\\n        if kwarg_key in kwargs:\\n            validity_days_from_now = kwargs[kwarg_key]\\n\\n        if validity_days_from_now < min_validity or validity_days_from_now > max_validity:\\n            msg = \\'Certificate validity days needs to be greater than or equal to {0} \\' \\\\\\n                  \\'and less than {1} days. Value provided: {2}\\'. format(min_validity,\\n                                                                        max_validity,\\n                                                                        validity_days_from_now)\\n            raise EdgeValueError(msg)\\n\\n        return validity_days_from_now\\n\\n    def _validate_string_length(self, test_string, min_length, max_length):\\n        length = len(test_string)\\n        if min_length > length or length > max_length:\\n            return False\\n        return True\\n\\n    def _get_kwargs_passphrase(self, **kwargs):\\n        passphrase = None\\n        min_length = EdgeCertUtil.MIN_PASSPHRASE_LENGTH\\n        max_length = EdgeCertUtil.MAX_PASSPHRASE_LENGTH\\n        kwarg_key = \\'passphrase\\'\\n        if kwarg_key in kwargs:\\n            passphrase = kwargs[kwarg_key]\\n        if passphrase is not None:\\n            if self._validate_string_length(passphrase, min_length, max_length) is False:\\n                msg = \\'Private key passphrase needs to greater than or equal to {0} and less \\' \\\\\\n                      \\'than {1} characters.\\'.format(min_length, max_length)\\n                raise EdgeValueError(msg)\\n        return passphrase\\n\\n    def _get_kwargs_string(self, kwarg_key, min_length, max_length, default_str=None, **kwargs):\\n        result_str = default_str\\n        if kwarg_key in kwargs:\\n            result_str = kwargs[kwarg_key]\\n        if result_str is not None:\\n            if self._validate_string_length(result_str, min_length, max_length) is False:\\n                msg = \\'KWarg[{0}]:{1} string length needs to greater than or equal to {2} and \\' \\\\\\n                      \\'less than {3} characters.\\'.format(kwarg_key, result_str,\\n                                                         min_length, max_length)\\n                raise EdgeValueError(msg)\\n        return result_str\\n\\n    def _dump_cert_content(self, cert_dict, output_path):\\n        Utils.mkdir_if_needed(os.path.dirname(output_path))\\n        cert_obj = cert_dict[\\'cert\\']\\n        try:\\n            with open(output_path, \\'w\\') as output_file:\\n                output_file.write(crypto.dump_certificate(crypto.FILETYPE_PEM,\\n                                                          cert_obj).decode(\\'utf-8\\'))\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting certs.\\\\n\\' \\\\\\n                  \\' Error seen when exporting file {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(ex.filename, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_path)\\n\\n    def _dump_cert_key(self, cert_dict, output_path):\\n        Utils.mkdir_if_needed(os.path.dirname(output_path))\\n        try:\\n            if \\'key_file\\' in cert_dict:\\n                key_file_path = cert_dict[\\'key_file\\']\\n                copy2(key_file_path, output_path)\\n            else:\\n                key_obj = cert_dict[\\'key_pair\\']\\n                key_passphrase = cert_dict[\\'passphrase\\']\\n                passphrase = None\\n                if key_passphrase and key_passphrase != \\'\\':\\n                    passphrase = key_passphrase.encode(\\'utf-8\\')\\n                cipher = None\\n                if passphrase:\\n                    cipher = \\'aes256\\'\\n                with open(output_path, \\'w\\') as output_file:\\n                    output_file.write(crypto.dump_privatekey(crypto.FILETYPE_PEM,\\n                                                             key_obj,\\n                                                             cipher=cipher,\\n                                                             passphrase=passphrase).decode(\\'utf-8\\'))\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting certs.\\\\n\\' \\\\\\n                  \\' Error seen when exporting file {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(ex.filename, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_path)\\n\\n    def _get_cert_dict(self, id_str):\\n        if id_str not in list(self._cert_chain.keys()):\\n            msg = \\'Certificate not in chain. ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n        return self._cert_chain[id_str]\\n\\n    def _chain_ca_certs(self, output_path, id_strs, certs_dir, cert_file_path_gen):\\n        file_names = []\\n        for id_str in id_strs:\\n            cert_dict = self._get_cert_dict(id_str)\\n            if \\'ca_chain\\' in list(cert_dict.keys()):\\n                # this cert contains an existing certificate chain\\n                # pick the chain instead of the actual cert\\n                cert_file_name = id_str + \\'-chain.cert.pem\\'\\n            else:\\n                cert_file_name = id_str + EC.CERT_SUFFIX\\n            cert_file = cert_file_path_gen(id_str, cert_file_name, certs_dir)\\n            path = os.path.realpath(cert_file)\\n            file_names.append(path)\\n        try:\\n            with open(output_path, \\'wb\\') as output_file:\\n                for file_name in file_names:\\n                    with open(file_name, \\'rb\\') as input_file:\\n                        output_file.write(input_file.read())\\n        except IOError as ex:\\n            msg = \\'IO Error when creating chain cert: {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(output_path, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_path)\\n\\n    def _simulator_cert_file_path_gen(self, id_str, cert_file_name, certs_dir):\\n        return os.path.join(certs_dir, id_str, \\'cert\\', cert_file_name)\\n\\n    def _device_ca_cert_file_path_gen(self, id_str, cert_file_name, certs_dir):\\n        return os.path.join(certs_dir, cert_file_name)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/cli.py'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport json\\nimport os\\nimport sys\\nimport re\\nfrom functools import wraps\\n\\nimport click\\n\\nfrom . import configs, decorators, telemetry\\nfrom .constants import EdgeConstants\\nfrom .edgecert import EdgeCert\\nfrom .edgemanager import EdgeManager\\nfrom .hostplatform import HostPlatform\\nfrom .output import Output\\nfrom .utils import Utils\\nfrom .errors import EdgeError, InvalidConfigError\\n\\nCONTEXT_SETTINGS = dict(help_option_names=[\\'-h\\', \\'--help\\'], max_content_width=120)\\noutput = Output()\\n\\nCONN_STR = \\'connectionString\\'\\nCERT_PATH = \\'certPath\\'\\nGATEWAY_HOST = \\'gatewayhost\\'\\nDOCKER_HOST = \\'DOCKER_HOST\\'\\nHUB_CONN_STR = \\'iothubConnectionString\\'\\n\\n# a set of parameters whose value should be logged as given\\nPARAMS_WITH_VALUES = {\\'edge_runtime_version\\'}\\n\\n@decorators.suppress_all_exceptions()\\ndef _parse_params(*args, **kwargs):\\n    params = []\\n    for key, value in kwargs.items():\\n        if (value is None) or (key in PARAMS_WITH_VALUES):\\n            params.append(\\'{0}={1}\\'.format(key, value))\\n        else:\\n            params.append(\\'{0}!=None\\'.format(key))\\n    return params\\n\\n\\ndef _send_failed_telemetry(e):\\n    output.error(str(e))\\n    telemetry.fail(str(e), \\'Command failed\\')\\n    telemetry.flush()\\n\\n\\ndef _with_telemetry(func):\\n    @wraps(func)\\n    def _wrapper(*args, **kwargs):\\n        configs.check_firsttime()\\n        params = _parse_params(*args, **kwargs)\\n        telemetry.start(func.__name__, params)\\n        try:\\n            value = func(*args, **kwargs)\\n            telemetry.success()\\n            telemetry.flush()\\n            return value\\n        except InvalidConfigError as e:\\n            _send_failed_telemetry(e)\\n            sys.exit(2)\\n        except Exception as e:\\n            _send_failed_telemetry(e)\\n            sys.exit(1)\\n\\n    return _wrapper\\n\\n\\ndef _parse_config_json():\\n    try:\\n        config_file = HostPlatform.get_config_file_path()\\n\\n        if not Utils.check_if_file_exists(config_file):\\n            raise ValueError(\\'Cannot find config file. Please run `{0}` first.\\'.format(_get_setup_command()))\\n\\n        with open(config_file) as f:\\n            try:\\n                config_json = json.load(f)\\n\\n                connection_str = config_json[CONN_STR]\\n                cert_path = config_json[CERT_PATH]\\n                gatewayhost = config_json[GATEWAY_HOST]\\n                hub_conn_str = config_json.get(HUB_CONN_STR)\\n                return EdgeManager(connection_str, gatewayhost, cert_path, hub_conn_str)\\n\\n            except (ValueError, KeyError):\\n                raise ValueError(\\'Invalid config file. Please run `{0}` again.\\'.format(_get_setup_command()))\\n    except Exception as e:\\n        raise InvalidConfigError(str(e))\\n\\n\\ndef _get_setup_command():\\n    return \\'{0}iotedgehubdev setup -c \"<edge-device-connection-string>\"\\'.format(\\'\\' if os.name == \\'nt\\' else \\'sudo \\')\\n\\n\\n@click.group(context_settings=CONTEXT_SETTINGS, invoke_without_command=True)\\n@click.version_option()\\ndef main():\\n    ctx = click.get_current_context()\\n    if ctx.invoked_subcommand is None:\\n        click.echo(ctx.get_help())\\n        sys.exit(0)\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\\'Setup the IoT Edge Simulator. This must be done before starting.\\')\\n@click.option(\\'--connection-string\\',\\n              \\'-c\\',\\n              required=True,\\n              help=\\'Set Azure IoT Edge device connection string. Note: Use double quotes when supplying this input.\\')\\n@click.option(\\'--gateway-host\\',\\n              \\'-g\\',\\n              required=False,\\n              default=Utils.get_hostname(),\\n              show_default=True,\\n              help=\\'GatewayHostName value for the module to connect.\\')\\n@click.option(\\'--iothub-connection-string\\',\\n              \\'-i\\',\\n              required=False,\\n              help=\\'Set Azure IoT Hub connection string. Note: Use double quotes when supplying this input.\\')\\n@_with_telemetry\\ndef setup(connection_string, gateway_host, iothub_connection_string):\\n    try:\\n        gateway_host = gateway_host.lower()\\n        certDir = HostPlatform.get_default_cert_path()\\n        Utils.parse_connection_strs(connection_string, iothub_connection_string)\\n        if iothub_connection_string is None:\\n            configDict = {\\n                CONN_STR: connection_string,\\n                CERT_PATH: certDir,\\n                GATEWAY_HOST: gateway_host\\n            }\\n        else:\\n            configDict = {\\n                CONN_STR: connection_string,\\n                CERT_PATH: certDir,\\n                GATEWAY_HOST: gateway_host,\\n                HUB_CONN_STR: iothub_connection_string\\n            }\\n\\n        fileType = \\'edgehub.config\\'\\n        Utils.mkdir_if_needed(certDir)\\n        edgeCert = EdgeCert(certDir, gateway_host)\\n        edgeCert.generate_self_signed_certs()\\n        configFile = HostPlatform.get_config_file_path()\\n        Utils.delete_file(configFile, fileType)\\n        Utils.mkdir_if_needed(HostPlatform.get_config_path())\\n        configJson = json.dumps(configDict, indent=2, sort_keys=True)\\n        Utils.create_file(configFile, configJson, fileType)\\n\\n        dataDir = HostPlatform.get_share_data_path()\\n        Utils.mkdir_if_needed(dataDir)\\n        os.chmod(dataDir, 0o755)\\n\\n        with open(EdgeManager.COMPOSE_FILE, \\'w\\') as f:\\n            f.write(\\'version: \\\\\\'3.6\\\\\\'\\')\\n        os.chmod(EdgeManager.COMPOSE_FILE, 0o777)\\n        output.info(\\'Setup IoT Edge Simulator successfully.\\')\\n    except Exception as e:\\n        raise e\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               # short_help hack to prevent Click truncating help text (https://github.com/pallets/click/issues/486)\\n               short_help=\\'Get the module credentials such as connection string and certificate file path.\\',\\n               help=\\'Get the module credentials such as connection string and certificate file path.\\')\\n@click.option(\\'--modules\\',\\n              \\'-m\\',\\n              required=False,\\n              default=\\'target\\',\\n              show_default=True,\\n              help=\\'Specify the vertical-bar-separated (\"|\") module names to get credentials for, e.g., \"module1|module2\". \\'\\n                   \\'Note: Use double quotes when supplying this input.\\')\\n@click.option(\\'--local\\',\\n              \\'-l\\',\\n              required=False,\\n              is_flag=True,\\n              default=False,\\n              show_default=True,\\n              help=\\'Set `localhost` to `GatewayHostName` for module to run on host natively.\\')\\n@click.option(\\'--output-file\\',\\n              \\'-o\\',\\n              required=False,\\n              show_default=True,\\n              help=\\'Specify the output file to save the connection string. If the file exists, the content will be overwritten.\\')\\n@_with_telemetry\\ndef modulecred(modules, local, output_file):\\n    edge_manager = _parse_config_json()\\n\\n    if edge_manager:\\n        modules = [module.strip() for module in modules.strip().split(\\'|\\')]\\n        credential = edge_manager.outputModuleCred(modules, local, output_file)\\n        output.info(credential[0])\\n        output.info(credential[1])\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Start the IoT Edge Simulator.\")\\n@click.option(\\'--inputs\\',\\n              \\'-i\\',\\n              required=False,\\n              help=\\'Start IoT Edge Simulator in single module mode \\'\\n                   \\'using the specified comma-separated inputs of the target module, e.g., `input1,input2`.\\')\\n@click.option(\\'--port\\',\\n              \\'-p\\',\\n              required=False,\\n              default=53000,\\n              show_default=True,\\n              help=\\'Port of the service for sending message.\\')\\n@click.option(\\'--deployment\\',\\n              \\'-d\\',\\n              required=False,\\n              help=\\'Start IoT Edge Simulator in solution mode using the specified deployment manifest.\\')\\n@click.option(\\'--verbose\\',\\n              \\'-v\\',\\n              required=False,\\n              is_flag=True,\\n              default=False,\\n              show_default=True,\\n              help=\\'Show the solution container logs.\\')\\n@click.option(\\'--host\\',\\n              \\'-H\\',\\n              required=False,\\n              help=\\'Docker daemon socket to connect to.\\')\\n@click.option(\\'--environment\\',\\n              \\'-e\\',\\n              required=False,\\n              multiple=True,\\n              help=\\'Environment variables for single module mode, e.g., `-e \"Env1=Value1\" -e \"Env2=Value2\"`.\\')\\n@click.option(\\'--edge-runtime-version\\',\\n              \\'-er\\',\\n              required=False,\\n              multiple=False,\\n              default=\\'1.2\\',\\n              show_default=True,\\n              help=\\'EdgeHub image version. Currently supported tags 1.0x, 1.1x, or 1.2x\\')\\n@_with_telemetry\\ndef start(inputs, port, deployment, verbose, host, environment, edge_runtime_version):\\n    edge_manager = _parse_config_json()\\n\\n    if edge_manager:\\n        if host is not None:\\n            os.environ[DOCKER_HOST] = str(host)\\n\\n        hostname_hash, suffix = Utils.hash_connection_str_hostname(edge_manager.hostname)\\n        telemetry.add_extra_props({\\'iothubhostname\\': hostname_hash, \\'iothubhostnamesuffix\\': suffix})\\n\\n        if inputs is None and deployment is not None:\\n            if len(environment) > 0:\\n                output.info(\\'Environment variables are ignored in solution mode.\\')\\n\\n            if len(edge_runtime_version) > 0:\\n                output.info(\\'edgeHub image version is ignored in solution mode.\\')\\n\\n            with open(deployment) as json_file:\\n                json_data = json.load(json_file)\\n                if \\'modulesContent\\' in json_data:\\n                    module_content = json_data[\\'modulesContent\\']\\n                elif \\'moduleContent\\' in json_data:\\n                    module_content = json_data[\\'moduleContent\\']\\n            edge_manager.start_solution(module_content, verbose, output)\\n            if not verbose:\\n                output.info(\\'IoT Edge Simulator has been started in solution mode.\\')\\n        else:\\n            if edge_runtime_version is not None:\\n                # The only validated versions are 1.0, 1.1, and 1.2 variants, hence the current limitation\\n                if re.match(r\\'^(1\\\\.0)|(1\\\\.1)|(1\\\\.2)\\', edge_runtime_version) is None:\\n                    raise ValueError(\\'-edge-runtime-version `{0}` is not valid.\\'.format(edge_runtime_version))\\n\\n            if deployment is not None:\\n                output.info(\\'Deployment manifest is ignored when inputs are present.\\')\\n            if inputs is None:\\n                input_list = [\\'input1\\']\\n            else:\\n                input_list = [input_.strip() for input_ in inputs.strip().split(\\',\\')]\\n\\n            for env in environment:\\n                if re.match(r\\'^[a-zA-Z][a-zA-Z0-9_]*?=.*$\\', env) is None:\\n                    raise ValueError(\\'Environment variable: `{0}` is not valid.\\'.format(env))\\n\\n            edge_manager.start_singlemodule(input_list, port, environment, edge_runtime_version)\\n\\n            data = \\'--data \\\\\\'{{\"inputName\": \"{0}\",\"data\":\"hello world\"}}\\\\\\'\\'.format(input_list[0])\\n            url = \\'http://localhost:{0}/api/v1/messages\\'.format(port)\\n            curl_msg = \\'        curl --header \"Content-Type: application/json\" --request POST {0} {1}\\'.format(data, url)\\n            output.info(\\'IoT Edge Simulator has been started in single module mode.\\')\\n            output.info(\\'Please run `iotedgehubdev modulecred` to get credential to connect your module.\\')\\n            output.info(\\'And send message through:\\')\\n            output.line()\\n            output.echo(curl_msg, \\'green\\')\\n            output.line()\\n            output.info(\\n                \\'Please refer to https://github.com/Azure/iot-edge-testing-utility/blob/master/swagger.json\\'\\n                \\' for detail schema\\')\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Stop the IoT Edge Simulator.\")\\n@click.option(\\'--host\\',\\n              \\'-H\\',\\n              required=False,\\n              help=\\'Docker daemon socket to connect to\\')\\n@_with_telemetry\\ndef stop(host):\\n    if host is not None:\\n        os.environ[DOCKER_HOST] = str(host)\\n    EdgeManager.stop()\\n    output.info(\\'IoT Edge Simulator has been stopped successfully.\\')\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Determine whether config file is valid.\")\\n@_with_telemetry\\ndef validateconfig():\\n    _parse_config_json()\\n    output.info(\\'Config file is valid.\\')\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Create IoT Edge device CA\")\\n@click.option(\\'--output-dir\\',\\n              \\'-o\\',\\n              required=False,\\n              default=\".\",\\n              help=\\'The output folder of generated certs. \\'\\n              \\'The tool will create a certs folder under given path to store the certs.\\')\\n@click.option(\\'--valid-days\\',\\n              \\'-d\\',\\n              required=False,\\n              default=90,\\n              show_default=True,\\n              help=\\'Days before cert expires.\\')\\n@click.option(\\'--force\\',\\n              \\'-f\\',\\n              required=False,\\n              is_flag=True,\\n              default=False,\\n              show_default=True,\\n              help=\\'Whether overwrite existing cert files.\\')\\n@click.option(\\'--trusted-ca\\',\\n              \\'-c\\',\\n              required=False,\\n              help=\\'Path of your own trusted ca used to sign IoT Edge device ca. \\'\\n              \\'Please also provide trsuted ca private key and related passphase (if have).\\'\\n              )\\n@click.option(\\'--trusted-ca-key\\',\\n              \\'-k\\',\\n              required=False,\\n              help=\\'Path of your own trusted ca private key used to sign IoT Edge device ca. \\'\\n              \\'Please also provide trusted ca and related passphase (if have).\\')\\n@click.option(\\'--trusted-ca-key-passphase\\',\\n              \\'-p\\',\\n              required=False,\\n              help=\\'Passphase of your own trusted ca private key.\\')\\n@_with_telemetry\\ndef generatedeviceca(output_dir, valid_days, force, trusted_ca, trusted_ca_key, trusted_ca_key_passphase):\\n    try:\\n        output_dir = os.path.abspath(os.path.join(output_dir, EdgeConstants.CERT_FOLDER))\\n        if trusted_ca_key_passphase:\\n            trusted_ca_key_passphase = trusted_ca_key_passphase.encode()  # crypto requires byte string\\n        # Check whether create new trusted CA and generate files to be created\\n        output_files = list(Utils.get_device_ca_file_paths(output_dir, EdgeConstants.DEVICE_CA_ID).values())\\n        if trusted_ca and trusted_ca_key:\\n            output.info(\\'Trusted CA (certification authority) and trusted CA key were provided.\\'\\n                        \\' Load trusted CA from given files.\\')\\n        else:\\n            output.info(\\'Trusted CA (certification authority) and Trusted CA key were not provided.\\'\\n                        \\' Will create new trusted CA.\\')\\n            root_ca_files = Utils.get_device_ca_file_paths(output_dir, EdgeConstants.ROOT_CA_ID)\\n            output_files.append(root_ca_files[EdgeConstants.CERT_SUFFIX])\\n            output_files.append(root_ca_files[EdgeConstants.KEY_SUFFIX])\\n        # Check whether the output files exist\\n        existing_files = []\\n        for file in output_files:\\n            if os.path.exists(file):\\n                existing_files.append(file)\\n        if len(existing_files) > 0:\\n            if force:\\n                output.info(\\'Following cert files already exist and will be overwritten: %s\\' % existing_files)\\n            else:\\n                raise EdgeError(\\'Following cert files already exist. \\'\\n                                \\'You can use --force option to overwrite existing files: %s\\' % existing_files)\\n        # Generate certs\\n        edgeCert = EdgeCert(output_dir, \\'\\')\\n        edgeCert.generate_device_ca(valid_days, force, trusted_ca, trusted_ca_key, trusted_ca_key_passphase)\\n        output.info(\\'Successfully generated device CA. Please find the generated certs at %s\\' % output_dir)\\n    except Exception as e:\\n        raise e\\n\\n\\nmain.add_command(setup)\\nmain.add_command(modulecred)\\nmain.add_command(start)\\nmain.add_command(stop)\\nmain.add_command(validateconfig)\\nmain.add_command(generatedeviceca)\\n\\nif __name__ == \"__main__\":\\n    main()\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/compose_parser.py'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\nimport os\\nimport re\\n\\nfrom jsonpath_rw import parse\\n\\nfrom .constants import EdgeConstants\\n\\n\\nclass CreateOptionParser(object):\\n    def __init__(self, create_option):\\n        self.create_option = create_option\\n\\n    def parse_create_option(self):\\n        ret = {}\\n        for compose_key in COMPOSE_KEY_CREATE_OPTION_MAPPING:\\n            create_option_value = self.get_create_option_value(compose_key)\\n            if create_option_value:\\n                parser_func = COMPOSE_KEY_CREATE_OPTION_MAPPING[compose_key][\\'parser_func\\']\\n                ret[compose_key] = parser_func(create_option_value)\\n        return ret\\n\\n    def get_create_option_value(self, compose_key):\\n        create_option_value_dict = {}\\n        for API_key, API_jsonpath in COMPOSE_KEY_CREATE_OPTION_MAPPING[compose_key][\\'API_Info\\'].items():\\n            jsonpath_expr = parse(API_jsonpath)\\n            value_list = jsonpath_expr.find(self.create_option)\\n            if value_list:\\n                create_option_value_dict[API_key] = value_list[0].value\\n        return create_option_value_dict\\n\\n\\ndef service_parser_naive(create_options_details):\\n    return list(create_options_details.values())[0]\\n\\n\\ndef service_parser_expose(create_options_details):\\n    return list(create_options_details[\\'ExposedPorts\\'].keys())\\n\\n\\ndef service_parser_command(create_options_details):\\n    cmd = create_options_details[\\'Cmd\\']\\n    if not isinstance(cmd, list):\\n        return cmd\\n    return \\' \\'.join(cmd).strip()\\n\\n\\ndef service_parser_healthcheck(create_options_details):\\n    healthcheck_config = create_options_details[\\'Healthcheck\\']\\n    try:\\n        return {\\n            \\'test\\': healthcheck_config[\\'Test\\'],\\n            \\'interval\\': time_ns_ms(healthcheck_config[\\'Interval\\']),\\n            \\'timeout\\': time_ns_ms(healthcheck_config[\\'Timeout\\']),\\n            \\'retries\\': healthcheck_config[\\'Retries\\'],\\n            \\'start_period\\': time_ns_ms(healthcheck_config[\\'StartPeriod\\'])\\n        }\\n    except KeyError as err:\\n        raise KeyError(\\'Missing key : {0} in Healthcheck\\'.format(err))\\n\\n\\ndef service_parser_stop_timeout(create_options_details):\\n    try:\\n        return str(int(create_options_details[\\'StopTimeout\\'])) + \\'s\\'\\n    except TypeError:\\n        raise TypeError(\\'StopTimeout should be an integer.\\')\\n\\n\\ndef service_parser_hostconfig_devices(create_options_details):\\n    devices_list = []\\n    for device in create_options_details[\\'Devices\\']:\\n        try:\\n            devices_list.append(\"{0}:{1}:{2}\".format(device[\\'PathOnHost\\'],\\n                                                     device[\\'PathInContainer\\'], device[\\'CgroupPermissions\\']))\\n        except KeyError as err:\\n            raise KeyError(\\'Missing key : {0} in HostConfig.Devices.\\'.format(err))\\n    return devices_list\\n\\n\\ndef service_parser_hostconfig_restart(create_options_details):\\n    restart_config = create_options_details[\\'RestartPolicy\\']\\n    ret = \"\"\\n    if restart_config[\\'Name\\'] == \"\":\\n        ret = \"no\"\\n    elif restart_config[\\'Name\\'] == \"on-failure\":\\n        try:\\n            ret = \"on-failure:{0}\".format(restart_config[\\'MaximumRetryCount\\'])\\n        except KeyError as err:\\n            raise KeyError(\\'Missing key : {0} in HostConfig.RestartPolicy.\\'.format(err))\\n    elif restart_config[\\'Name\\'] == \"always\" or restart_config[\\'Name\\'] == \"unless-stopped\":\\n        ret = restart_config[\\'Name\\']\\n    else:\\n        raise ValueError(\"RestartPolicy Name should be one of \\'\\', \\'always\\', \\'unless-stopped\\', \\'on-failure\\'\")\\n    return ret\\n\\n\\ndef service_parser_hostconfig_ulimits(create_options_details):\\n    ulimits_dict = {}\\n    for ulimit in create_options_details[\\'Ulimits\\']:\\n        try:\\n            ulimits_dict[ulimit[\\'Name\\']] = {\\n                \\'soft\\': ulimit[\\'Soft\\'],\\n                \\'hard\\': ulimit[\\'Hard\\']\\n            }\\n        except KeyError as err:\\n            raise KeyError(\\'Missing key : {0} in HostConfig.Ulimits\\'.format(err))\\n    return ulimits_dict\\n\\n\\ndef service_parser_hostconfig_logging(create_options_details):\\n    try:\\n        logging_dict = {\\n            \\'driver\\': create_options_details[\\'LogConfig\\'][\\'Type\\'],\\n            \\'options\\': create_options_details[\\'LogConfig\\'][\\'Config\\']\\n        }\\n    except KeyError as err:\\n        raise KeyError(\\'Missing key : {0} in HostConfig.LogConfig\\'.format(err))\\n    return logging_dict\\n\\n\\ndef service_parser_hostconfig_ports(create_options_details):\\n    ports_list = []\\n    for container_port, host_ports in create_options_details[\\'PortBindings\\'].items():\\n        for host_port_info in host_ports:\\n            host_port = \"\"\\n            if \\'HostIp\\' in host_port_info and \\'HostPort\\' in host_port_info:\\n                host_port = \"{0}:{1}\".format(host_port_info[\\'HostIp\\'], host_port_info[\\'HostPort\\'])\\n            elif \\'HostIp\\' in host_port_info:\\n                host_port = host_port_info[\\'HostIp\\']\\n            elif \\'HostPort\\' in host_port_info:\\n                host_port = host_port_info[\\'HostPort\\']\\n            ports_list.append(\"{0}:{1}\".format(host_port, container_port))\\n    return ports_list\\n\\n\\ndef service_parser_networks(create_options_details):\\n    networks_dict = {}\\n    for nw, nw_config in create_options_details[\\'NetworkingConfig\\'].items():\\n        networks_dict[nw] = {}\\n        if \\'Aliases\\' in nw_config:\\n            networks_dict[nw][\\'aliases\\'] = nw_config[\\'Aliases\\']\\n        if \\'IPAMConfig\\' in nw_config:\\n            if \\'IPv4Address\\' in nw_config[\\'IPAMConfig\\']:\\n                networks_dict[nw][\\'ipv4_address\\'] = nw_config[\\'IPAMConfig\\'][\\'IPv4Address\\']\\n            if \\'IPv6Address\\' in nw_config[\\'IPAMConfig\\']:\\n                networks_dict[nw][\\'ipv6_address\\'] = nw_config[\\'IPAMConfig\\'][\\'IPv6Address\\']\\n    return networks_dict\\n\\n\\ndef service_parser_volumes(create_options_details):\\n    volumes_list = []\\n    for mount in create_options_details.get(\\'Mounts\\', []):\\n        try:\\n            volume_info = {\\n                \\'target\\': mount[\\'Target\\'],\\n                \\'type\\': mount[\\'Type\\']\\n            }\\n            if mount[\\'Type\\'] == \\'volume\\' or mount[\\'Type\\'] == \\'bind\\':\\n                volume_info[\\'source\\'] = mount[\\'Source\\']\\n            if \\'ReadOnly\\' in mount:\\n                volume_info[\\'read_only\\'] = mount[\\'ReadOnly\\']\\n\\n            if mount[\\'Type\\'] == \\'volume\\' and \\'VolumeOptions\\' in mount:\\n                if \\'NoCopy\\' in mount[\\'VolumeOptions\\']:\\n                    volume_info[\\'volume\\'] = {\\n                        \\'nocopy\\': mount[\\'VolumeOptions\\'][\\'NoCopy\\']\\n                    }\\n            if mount[\\'Type\\'] == \\'bind\\' and \\'BindOptions\\' in mount:\\n                if \\'Propagation\\' in mount[\\'BindOptions\\']:\\n                    volume_info[\\'bind\\'] = {\\n                        \\'propagation\\': mount[\\'BindOptions\\'][\\'Propagation\\']\\n                    }\\n            if mount[\\'Type\\'] == \\'tmpfs\\' and \\'TmpfsOptions\\' in mount:\\n                if \\'SizeBytes\\' in mount[\\'TmpfsOptions\\']:\\n                    volume_info[\\'tmpfs\\'] = {\\n                        \\'size\\': mount[\\'TmpfsOptions\\'][\\'SizeBytes\\']\\n                    }\\n        except KeyError as e:\\n            raise KeyError(\\'Missing key {0} in create option HostConfig Mounts.\\'.format(e))\\n        volumes_list.append(volume_info)\\n\\n    for bind in create_options_details.get(\\'Binds\\', []):\\n        target = None\\n\\n        # Binds should be in the format [source:]destination[:mode]\\n        # Windows format and LCOW format are more strict than Linux format due to colons in Windows paths,\\n        # so match with them first\\n        match = re.match(EdgeConstants.MOUNT_WIN_REGEX, bind) or re.match(EdgeConstants.MOUNT_LCOW_REGEX, bind)\\n        if match is not None:\\n            source = match.group(\\'source\\') or \\'\\'\\n            target = match.group(\\'destination\\')\\n            read_only = match.group(\\'mode\\') == \\'ro\\'\\n        else:\\n            # Port of Docker daemon\\n            # https://github.com/docker/docker-ce/blob/1c27a55b6259743f35549e96d06334a53d0c0549/components/engine/volume/mounts/linux_parser.go#L18-L28\\n            parts = bind.split(\\':\\')\\n            if len(parts) == 2 or (len(parts) == 3 and parts[2] in (\\'ro\\', \\'rw\\', \\'\\')):\\n                if parts[0] != \\'\\':\\n                    source = parts[0]\\n                    target = parts[1]\\n                    read_only = len(parts) == 3 and parts[2] == \\'ro\\'\\n\\n        if target is not None:\\n            volume_info = {\\n                \\'type\\': \\'bind\\' if source and os.path.isabs(source) else \\'volume\\',\\n                \\'source\\': source,\\n                \\'target\\': target\\n            }\\n            if read_only:\\n                volume_info[\\'read_only\\'] = True\\n            volumes_list.append(volume_info)\\n        else:\\n            raise ValueError(\\'Invalid create option Binds: {0}\\'.format(bind))\\n\\n    return volumes_list\\n\\n\\ndef time_ns_ms(ns):\\n    if ns != 0 and ns < 1000000:\\n        raise ValueError(\\'The time should be 0 or at least 1000000 (1 ms)\\')\\n    return str(int(ns / 1000000)) + \\'ms\\'\\n\\n\\n\\'\\'\\'\\nThe mapping relationship between docker compose key and create option API key\\n\\'docker compose key\\': {\\'API_Info\\': {\\'API key\\':\\'API jsonpath\\'}, \\'parser_func\\': parser_func},\\n\\'\\'\\'\\nCOMPOSE_KEY_CREATE_OPTION_MAPPING = {\\n    \\'hostname\\': {\\'API_Info\\': {\\'Hostname\\': \"$[\\'Hostname\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'domainname\\': {\\'API_Info\\': {\\'Domainname\\': \"$[\\'Domainname\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'user\\': {\\'API_Info\\': {\\'User\\': \"$[\\'User\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'expose\\': {\\'API_Info\\': {\\'ExposedPorts\\': \"$[\\'ExposedPorts\\']\"}, \\'parser_func\\': service_parser_expose},\\n    \\'tty\\': {\\'API_Info\\': {\\'Tty\\': \"$[\\'Tty\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'environment\\': {\\'API_Info\\': {\\'Env\\': \"$[\\'Env\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'command\\': {\\'API_Info\\': {\\'Cmd\\': \"$[\\'Cmd\\']\"}, \\'parser_func\\': service_parser_command},\\n    \\'healthcheck\\': {\\'API_Info\\': {\\'Healthcheck\\': \"$[\\'Healthcheck\\']\"}, \\'parser_func\\': service_parser_healthcheck},\\n    \\'image\\': {\\'API_Info\\': {\\'Image\\': \"$[\\'Image\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'working_dir\\': {\\'API_Info\\': {\\'WorkingDir\\': \"$[\\'WorkingDir\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'entrypoint\\': {\\'API_Info\\': {\\'Entrypoint\\': \"$[\\'Entrypoint\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'mac_address\\': {\\'API_Info\\': {\\'MacAddress\\': \"$[\\'MacAddress\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'labels\\': {\\'API_Info\\': {\\'Labels\\': \"$[\\'Labels\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'stop_signal\\': {\\'API_Info\\': {\\'StopSignal\\': \"$[\\'StopSignal\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'stop_grace_period\\': {\\'API_Info\\': {\\'StopTimeout\\': \"$[\\'StopTimeout\\']\"}, \\'parser_func\\': service_parser_stop_timeout},\\n\\n    # HostConfig\\n    \\'ports\\': {\\'API_Info\\': {\\'PortBindings\\': \"$[\\'HostConfig\\'][\\'PortBindings\\']\"}, \\'parser_func\\': service_parser_hostconfig_ports},\\n    \\'privileged\\': {\\'API_Info\\': {\\'Privileged\\': \"$[\\'HostConfig\\'][\\'Privileged\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'network_mode\\': {\\'API_Info\\': {\\'NetworkMode\\': \"$[\\'HostConfig\\'][\\'NetworkMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'devices\\': {\\'API_Info\\': {\\'Devices\\': \"$[\\'HostConfig\\'][\\'Devices\\']\"}, \\'parser_func\\': service_parser_hostconfig_devices},\\n    \\'dns\\': {\\'API_Info\\': {\\'Dns\\': \"$[\\'HostConfig\\'][\\'Dns\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'dns_search\\': {\\'API_Info\\': {\\'DnsSearch\\': \"$[\\'HostConfig\\'][\\'DnsSearch\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'restart\\': {\\n        \\'API_Info\\': {\\'RestartPolicy\\': \"$[\\'HostConfig\\'][\\'RestartPolicy\\']\"},\\n        \\'parser_func\\': service_parser_hostconfig_restart\\n    },\\n    \\'cap_add\\': {\\'API_Info\\': {\\'CapAdd\\': \"$[\\'HostConfig\\'][\\'CapAdd\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'cap_drop\\': {\\'API_Info\\': {\\'CapDrop\\': \"$[\\'HostConfig\\'][\\'CapDrop\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'ulimits\\': {\\'API_Info\\': {\\'Ulimits\\': \"$[\\'HostConfig\\'][\\'Ulimits\\']\"}, \\'parser_func\\': service_parser_hostconfig_ulimits},\\n    \\'logging\\': {\\'API_Info\\': {\\'LogConfig\\': \"$[\\'HostConfig\\'][\\'LogConfig\\']\"}, \\'parser_func\\': service_parser_hostconfig_logging},\\n    \\'extra_hosts\\': {\\'API_Info\\': {\\'ExtraHosts\\': \"$[\\'HostConfig\\'][\\'ExtraHosts\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'read_only\\': {\\'API_Info\\': {\\'ReadonlyRootfs\\': \"$[\\'HostConfig\\'][\\'ReadonlyRootfs\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'pid\\': {\\'API_Info\\': {\\'PidMode\\': \"$[\\'HostConfig\\'][\\'PidMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'security_opt\\': {\\'API_Info\\': {\\'SecurityOpt\\': \"$[\\'HostConfig\\'][\\'SecurityOpt\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'ipc\\': {\\'API_Info\\': {\\'IpcMode\\': \"$[\\'HostConfig\\'][\\'IpcMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'cgroup_parent\\': {\\'API_Info\\': {\\'CgroupParent\\': \"$[\\'HostConfig\\'][\\'CgroupParent\\']\"}, \\'parser_func\\': service_parser_naive},\\n    # \\'shm_size:\\':{\\'API_Info\\':\\'ShmSize\\',\\'parser_func\\':service_parser_naive},\\n    \\'sysctls\\': {\\'API_Info\\': {\\'Sysctls\\': \"$[\\'HostConfig\\'][\\'Sysctls\\']\"}, \\'parser_func\\': service_parser_naive},\\n    # \\'tmpfs:\\':{\\'API_Info\\':\\'Tmpfs\\',\\'parser_func\\':service_parser_naive},\\n    \\'userns_mode\\': {\\'API_Info\\': {\\'UsernsMode\\': \"$[\\'HostConfig\\'][\\'UsernsMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'isolation\\': {\\'API_Info\\': {\\'Isolation\\': \"$[\\'HostConfig\\'][\\'Isolation\\']\"}, \\'parser_func\\': service_parser_naive},\\n\\n    # Volumes\\n    \\'volumes\\': {\\n        \\'API_Info\\': {\\n            \\'Mounts\\': \"$[\\'HostConfig\\'][\\'Mounts\\']\",\\n            \\'Binds\\': \"$[\\'HostConfig\\'][\\'Binds\\']\"\\n        },\\n        \\'parser_func\\': service_parser_volumes\\n    },\\n\\n    # NetworkingConfig\\n    \\'networks\\': {\\n        \\'API_Info\\': {\\'NetworkingConfig\\': \"$[\\'NetworkingConfig\\'][\\'EndpointsConfig\\']\"},\\n        \\'parser_func\\': service_parser_networks\\n    }\\n}\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/composeproject.py'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport json\\nimport os\\nimport sys\\nimport yaml\\n\\nfrom collections import OrderedDict\\nfrom io import StringIO\\nfrom .compose_parser import CreateOptionParser\\nfrom .output import Output\\n\\nCOMPOSE_VERSION = 3.6\\n\\nCREATE_OPTIONS_MAX_CHUNKS = 100\\n\\n\\nclass ComposeProject(object):\\n\\n    def __init__(self, module_content):\\n        self.module_content = module_content\\n        self.yaml_dict = OrderedDict()\\n        self.Services = OrderedDict()\\n        self.Networks = {}\\n        self.Volumes = {}\\n        self.edge_info = {}\\n\\n    def compose(self):\\n        modules = {\\n            self.edge_info[\\'hub_name\\']:\\n            self.module_content[\\'$edgeAgent\\'][\\'properties.desired\\'][\\'systemModules\\'][\\'edgeHub\\']\\n        }\\n        modules.update(self.module_content[\\'$edgeAgent\\'][\\'properties.desired\\'][\\'modules\\'])\\n        for service_name, config in modules.items():\\n            self.Services[service_name] = {}\\n            create_option_str = ComposeProject._join_create_options(config[\\'settings\\'])\\n            if create_option_str:\\n                create_option = json.loads(create_option_str)\\n                create_option_parser = CreateOptionParser(create_option)\\n                self.Services[service_name].update(create_option_parser.parse_create_option())\\n            self.Services[service_name][\\'image\\'] = config[\\'settings\\'][\\'image\\']\\n            self.Services[service_name][\\'container_name\\'] = service_name\\n\\n            if \\'networks\\' not in self.Services[service_name]:\\n                self.Services[service_name][\\'networks\\'] = {}\\n                self.Services[service_name][\\'networks\\'][self.edge_info[\\'network_info\\'][\\'NW_NAME\\']] = None\\n\\n            if \\'network_mode\\' in self.Services[service_name]:\\n                del self.Services[service_name][\\'network_mode\\']\\n\\n            if \\'host\\' in self.Services[service_name][\\'networks\\']:\\n                self.Services[service_name][\\'network_mode\\'] = \\'host\\'\\n                del self.Services[service_name][\\'networks\\']\\n\\n            if \\'labels\\' not in self.Services[service_name]:\\n                self.Services[service_name][\\'labels\\'] = {self.edge_info[\\'labels\\']: \"\"}\\n            else:\\n                self.Services[service_name][\\'labels\\'][self.edge_info[\\'labels\\']] = \"\"\\n\\n            try:\\n                # Default restart policy is \\'on-unhealthy\\'\\n                # https://github.com/Azure/iotedge/blob/8bd573590cdc149c014cf994dba58fc63f1a5c74/edge-agent/src/Microsoft.Azure.Devices.Edge.Agent.Core/Constants.cs#L18\\n                restart_policy = config.get(\\'restartPolicy\\', \\'on-unhealthy\\')\\n                self.Services[service_name][\\'restart\\'] = {\\n                    \\'never\\': \\'no\\',\\n                    \\'on-failure\\': \\'on-failure\\',\\n                    \\'always\\': \\'always\\',\\n                    \\'on-unhealthy\\': \\'always\\',\\n                    \\'unknown\\': \\'no\\'\\n                }[restart_policy]\\n\\n                if restart_policy == \\'on-unhealthy\\':\\n                    Output().warning(\\'Unsupported restart policy \\\\\\'{0}\\\\\\' in solution mode. Falling back to \\\\\\'always\\\\\\'.\\'\\n                                     .format(restart_policy))\\n            except KeyError as e:\\n                raise KeyError(\\'Unsupported restart policy {0} in solution mode.\\'.format(e))\\n\\n            if \\'env\\' in config:\\n                self.Services[service_name][\\'environment\\'] = self.config_env(\\n                    self.Services[service_name].get(\\'environment\\', []), config[\\'env\\'])\\n\\n            if service_name == self.edge_info[\\'hub_name\\']:\\n                self.config_edge_hub(service_name)\\n            else:\\n                self.config_modules(service_name)\\n\\n            if \\'networks\\' in self.Services[service_name]:\\n                for nw in self.Services[service_name][\\'networks\\']:\\n                    self.Networks[nw] = {\\n                        \\'external\\': True\\n                    }\\n\\n            for vol in self.Services[service_name][\\'volumes\\']:\\n                if vol[\\'type\\'] == \\'volume\\':\\n                    self.Volumes[vol[\\'source\\']] = {\\n                        \\'name\\': vol[\\'source\\']\\n                    }\\n\\n    def set_edge_info(self, info):\\n        self.edge_info = info\\n\\n    def config_modules(self, service_name):\\n        config = self.Services[service_name]\\n        if \\'volumes\\' not in config:\\n            config[\\'volumes\\'] = []\\n        config[\\'volumes\\'].append({\\n            \\'type\\': \\'volume\\',\\n            \\'source\\': self.edge_info[\\'volume_info\\'][\\'MODULE_VOLUME\\'],\\n            \\'target\\': self.edge_info[\\'volume_info\\'][\\'MODULE_MOUNT\\']\\n        })\\n\\n        if \\'environment\\' not in config:\\n            config[\\'environment\\'] = []\\n        for module_env in self.edge_info[\\'env_info\\'][\\'module_env\\']:\\n            config[\\'environment\\'].append(module_env)\\n        config[\\'environment\\'].append(\\n            \\'EdgeHubConnectionString=\\' + self.edge_info[\\'ConnStr_info\\'][service_name]\\n        )\\n\\n        if \\'depends_on\\' not in config:\\n            config[\\'depends_on\\'] = []\\n        config[\\'depends_on\\'].append(self.edge_info[\\'hub_name\\'])\\n\\n    def config_edge_hub(self, service_name):\\n        config = self.Services[service_name]\\n        if \\'volumes\\' not in config:\\n            config[\\'volumes\\'] = []\\n        config[\\'volumes\\'].append({\\n            \\'type\\': \\'volume\\',\\n            \\'source\\': self.edge_info[\\'volume_info\\'][\\'HUB_VOLUME\\'],\\n            \\'target\\': self.edge_info[\\'volume_info\\'][\\'HUB_MOUNT\\']\\n        })\\n\\n        config[\\'networks\\'][self.edge_info[\\'network_info\\'][\\'NW_NAME\\']] = {\\n            \\'aliases\\': [self.edge_info[\\'network_info\\'][\\'ALIASES\\']]\\n        }\\n\\n        if \\'environment\\' not in config:\\n            config[\\'environment\\'] = []\\n        routes_env = self.parse_routes()\\n        for e in routes_env:\\n            config[\\'environment\\'].append(e)\\n        config[\\'environment\\'].append(\\n            \\'IotHubConnectionString=\\' + self.edge_info[\\'ConnStr_info\\'][\\'$edgeHub\\'])\\n        config[\\'environment\\'].extend(self.edge_info[\\'env_info\\'][\\'hub_env\\'])\\n\\n    def config_env(self, env_list, env_section):\\n        env_dict = {}\\n        for env in env_list:\\n            if \\'=\\' in env:\\n                k, v = env.split(\\'=\\', 1)\\n            else:\\n                k, v = env, \\'\\'\\n            env_dict[k] = v\\n        for k, v in env_section.items():\\n            if \\'value\\' not in v:\\n                env_dict[k] = \\'\\'\\n            else:\\n                env_dict[k] = v[\\'value\\']\\n        ret = []\\n        for k, v in env_dict.items():\\n            ret.append(\"{0}={1}\".format(k, v))\\n        return ret\\n\\n    def parse_routes(self):\\n        routes = self.module_content[\\'$edgeHub\\'][\\'properties.desired\\'][\\'routes\\']\\n        schema_version = self.module_content[\\'$edgeHub\\'][\\'properties.desired\\'][\\'schemaVersion\\']\\n        routes_env = []\\n        route_id = 1\\n\\n        for route in routes.values():\\n            if isinstance(route, str):\\n                routes_env.append(\\'routes__r{0}={1}\\'.format(route_id, route))\\n            else:\\n                if schema_version >= \"1.1\":\\n                    routes_env.append(\\'routes__r{0}={1}\\'.format(route_id, route[\"route\"]))\\n                else:\\n                    raise Exception(\"Route priority/TTL is not supported in schema {0}.\".format(schema_version))\\n            route_id = route_id + 1\\n        return routes_env\\n\\n    def dump(self, target):\\n        def setup_yaml():\\n            def represent_dict_order(self, data):\\n                return self.represent_mapping(\\'tag:yaml.org,2002:map\\', data.items())\\n            yaml.add_representer(OrderedDict, represent_dict_order)\\n        setup_yaml()\\n\\n        def my_unicode_repr(self, data):\\n            return self.represent_str(data.encode(\\'utf-8\\'))\\n\\n        self.yaml_dict[\\'version\\'] = str(COMPOSE_VERSION)\\n        self.yaml_dict[\\'services\\'] = self.Services\\n        self.yaml_dict[\\'networks\\'] = self.Networks\\n        self.yaml_dict[\\'volumes\\'] = self.Volumes\\n\\n        if sys.version_info[0] < 3:\\n            # Add # noqa: F821 to ignore undefined name \\'unicode\\' error\\n            yaml.add_representer(unicode, my_unicode_repr)  # noqa: F821\\n        yml_stream = StringIO()\\n\\n        yaml.dump(self.yaml_dict, yml_stream, default_flow_style=False)\\n        yml_str = yml_stream.getvalue().replace(\\'$\\', \\'$$\\')\\n\\n        if not os.path.exists(os.path.dirname(target)):\\n            os.makedirs(os.path.dirname(target))\\n\\n        with open(target, \\'w\\') as f:\\n            f.write(yml_str)\\n\\n    @staticmethod\\n    def _join_create_options(settings):\\n        if \\'createOptions\\' not in settings:\\n            return \\'\\'\\n\\n        res = settings[\\'createOptions\\']\\n\\n        i = 0\\n        while True:\\n            i += 1\\n            key = \\'createOptions{0:0=2d}\\'.format(i)\\n            if i < CREATE_OPTIONS_MAX_CHUNKS and key in settings:\\n                res += settings[key]\\n            else:\\n                break\\n\\n        return res\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/configs.py'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport os\\nimport configparser\\n\\nfrom . import decorators\\nfrom .hostplatform import HostPlatform\\n\\nPRIVACY_STATEMENT = \"\"\"\\nWelcome to iotedgehubdev!\\n-------------------------\\nTelemetry\\n---------\\nThe iotedgehubdev collects usage data in order to improve your experience.\\nThe data is anonymous and does not include commandline argument values.\\nThe data is collected by Microsoft.\\n\\nYou can change your telemetry settings by updating \\'collect_telemetry\\' to \\'no\\' in {0}\\n\"\"\"\\n\\n\\nclass ProductConfig(object):\\n    def __init__(self):\\n        self.config = configparser.ConfigParser({\\n            \\'firsttime\\': \\'yes\\'\\n        })\\n        self.setup_config()\\n\\n    @decorators.suppress_all_exceptions()\\n    def setup_config(self):\\n        try:\\n            configPath = HostPlatform.get_config_path()\\n            iniFilePath = HostPlatform.get_setting_ini_path()\\n            if not os.path.exists(configPath):\\n                os.makedirs(configPath)\\n            if not os.path.exists(iniFilePath):\\n                with open(iniFilePath, \\'w\\') as iniFile:\\n                    self.config.write(iniFile)\\n            else:\\n                with open(iniFilePath, \\'r\\') as iniFile:\\n                    self.config.read_file(iniFile)\\n                with open(iniFilePath, \\'w\\') as iniFile:\\n                    self.config.write(iniFile)\\n        except Exception:\\n            pass\\n\\n    @decorators.suppress_all_exceptions()\\n    def update_config(self):\\n        with open(HostPlatform.get_setting_ini_path(), \\'w\\') as iniFile:\\n            self.config.write(iniFile)\\n\\n    @decorators.suppress_all_exceptions()\\n    def set_val(self, direct, section, val):\\n        if val is not None:\\n            self.config.set(direct, section, val)\\n            self.update_config()\\n\\n\\n_prod_config = ProductConfig()\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef get_ini_config():\\n    return _prod_config.config\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef update_ini():\\n    _prod_config.update_config()\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef check_firsttime():\\n    if \\'no\\' != _prod_config.config.get(\\'DEFAULT\\', \\'firsttime\\'):\\n        config = _prod_config.config\\n        config.set(\\'DEFAULT\\', \\'firsttime\\', \\'no\\')\\n        print(PRIVACY_STATEMENT.format(HostPlatform.get_setting_ini_path()))\\n        config.set(\\'DEFAULT\\', \\'collect_telemetry\\', \\'yes\\')\\n        _prod_config.update_config()\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/constants.py'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nclass EdgeConstants():\\n    HOSTNAME_KEY = \\'HostName\\'\\n    DEVICE_ID_KEY = \\'DeviceId\\'\\n    ACCESS_KEY_KEY = \\'SharedAccessKey\\'\\n    ACCESS_KEY_NAME = \\'SharedAccessKeyName\\'\\n    DEVICE_ACCESS_KEY_KEY = \\'Device_SharedAccessKey\\'\\n    HUB_ACCESS_KEY_KEY = \\'Hub_SharedAccessKey\\'\\n\\n    SUBJECT_COUNTRY_KEY = \\'countryCode\\'\\n    SUBJECT_STATE_KEY = \\'state\\'\\n    SUBJECT_LOCALITY_KEY = \\'locality\\'\\n    SUBJECT_ORGANIZATION_KEY = \\'organization\\'\\n    SUBJECT_ORGANIZATION_UNIT_KEY = \\'organizationUnit\\'\\n    SUBJECT_COMMON_NAME_KEY = \\'commonName\\'\\n\\n    EDGE_CHAIN_CA = \\'edge-chain-ca\\'\\n    EDGE_HUB_SERVER = \\'edge-hub-server\\'\\n    EDGE_DEVICE_CA = \\'edge-device-ca\\'\\n    EDGE_AGENT_CA = \\'edge-agent-ca\\'\\n    CERT_SUFFIX = \\'.cert.pem\\'\\n    CHAIN_CERT_SUFFIX = \\'-chain.cert.pem\\'\\n    PFX_SUFFIX = \\'.cert.pfx\\'\\n    KEY_SUFFIX = \\'.key.pem\\'\\n    ROOT_CA_ID = \\'azure-iot-test-only.root.ca\\'\\n    DEVICE_CA_ID = \\'iot-edge-device-ca\\'\\n    CERT_FOLDER = \\'certs\\'\\n\\n    CERT_DEFAULT_DICT = {\\n        SUBJECT_COUNTRY_KEY: \\'US\\',\\n        SUBJECT_STATE_KEY: \\'Washington\\',\\n        SUBJECT_LOCALITY_KEY: \\'Redmond\\',\\n        SUBJECT_ORGANIZATION_KEY: \\'Default Edge Organization\\',\\n        SUBJECT_ORGANIZATION_UNIT_KEY: \\'Edge Unit\\',\\n        SUBJECT_COMMON_NAME_KEY: \\'Edge Test Device CA\\'\\n    }\\n\\n    # Port of Docker daemon\\n    # https://github.com/docker/docker-ce/blob/f9756bfb29877236a83979170ef2c0aa35eb57c6/components/engine/volume/mounts/windows_parser.go#L19-L76\\n    MOUNT_HOST_DIR_REGEX = r\\'(?:\\\\\\\\\\\\\\\\\\\\?\\\\\\\\)?[a-z]:[\\\\\\\\/](?:[^\\\\\\\\/:*?\"<>|\\\\r\\\\n]+[\\\\\\\\/]?)*\\'\\n    MOUNT_NAME_REGEX = r\\'[^\\\\\\\\/:*?\"<>|\\\\r\\\\n]+\\'\\n    MOUNT_PIPE_REGEX = r\\'[/\\\\\\\\]{2}.[/\\\\\\\\]pipe[/\\\\\\\\][^:*?\"<>|\\\\r\\\\n]+\\'\\n    MOUNT_SOURCE_REGEX = r\\'((?P<source>((\\' + MOUNT_HOST_DIR_REGEX + r\\')|(\\' + \\\\\\n        MOUNT_NAME_REGEX + r\\')|(\\' + MOUNT_PIPE_REGEX + r\\'))):)?\\'\\n    MOUNT_MODE_REGEX = r\\'(:(?P<mode>(?i)ro|rw))?\\'\\n    MOUNT_WIN_DEST_REGEX = r\\'(?P<destination>((?:\\\\\\\\\\\\\\\\\\\\?\\\\\\\\)?([a-z]):((?:[\\\\\\\\/][^\\\\\\\\/:*?\"<>\\\\r\\\\n]+)*[\\\\\\\\/]?))|(\\' + \\\\\\n        MOUNT_PIPE_REGEX + r\\'))\\'\\n    MOUNT_LCOW_DEST_REGEX = r\\'(?P<destination>/(?:[^\\\\\\\\/:*?\"<>\\\\r\\\\n]+[/]?)*)\\'\\n    MOUNT_WIN_REGEX = r\\'^\\' + MOUNT_SOURCE_REGEX + MOUNT_WIN_DEST_REGEX + MOUNT_MODE_REGEX + r\\'$\\'\\n    MOUNT_LCOW_REGEX = r\\'^\\' + MOUNT_SOURCE_REGEX + MOUNT_LCOW_DEST_REGEX + MOUNT_MODE_REGEX + r\\'$\\'\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/decorators.py'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nfrom functools import wraps\\n\\n\\ndef suppress_all_exceptions(fallback_return=None):\\n    def _decorator(func):\\n        @wraps(func)\\n        def _wrapped_func(*args, **kwargs):\\n            try:\\n                return func(*args, **kwargs)\\n            except Exception:\\n                if fallback_return:\\n                    return fallback_return\\n                else:\\n                    pass\\n\\n        return _wrapped_func\\n\\n    return _decorator\\n\\n\\ndef hash256_result(func):\\n    \"\"\"Secure the return string of the annotated function with SHA256 algorithm. If the annotated\\n    function doesn\\'t return string or return None, raise ValueError.\"\"\"\\n    @wraps(func)\\n    def _decorator(*args, **kwargs):\\n        val = func(*args, **kwargs)\\n        if not val:\\n            raise ValueError(\\'Return value is None\\')\\n        elif not isinstance(val, str):\\n            raise ValueError(\\'Return value is not string\\')\\n\\n        from .utils import Utils\\n        return Utils.get_sha256_hash(val)\\n\\n    return _decorator\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgecert.py'"}, "return_value": "\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\nfrom .certutils import EdgeCertUtil\\nfrom .constants import EdgeConstants\\n\\n\\nclass EdgeCert(object):\\n    def __init__(self, certs_dir, hostname):\\n        self.certs_dir = certs_dir\\n        self.hostname = hostname\\n\\n    def generate_self_signed_certs(self):\\n        cert_util = EdgeCertUtil()\\n        cert_util.create_root_ca_cert(EdgeConstants.EDGE_DEVICE_CA,\\n                                      validity_days_from_now=365,\\n                                      subject_dict=EdgeConstants.CERT_DEFAULT_DICT,\\n                                      passphrase=None)\\n        cert_util.export_simulator_cert_artifacts_to_dir(EdgeConstants.EDGE_DEVICE_CA, self.certs_dir)\\n\\n        cert_util.create_intermediate_ca_cert(EdgeConstants.EDGE_AGENT_CA,\\n                                              EdgeConstants.EDGE_DEVICE_CA,\\n                                              validity_days_from_now=365,\\n                                              common_name='Edge Agent CA',\\n                                              set_terminal_ca=False,\\n                                              passphrase=None)\\n        cert_util.export_simulator_cert_artifacts_to_dir(EdgeConstants.EDGE_AGENT_CA, self.certs_dir)\\n\\n        cert_util.create_server_cert(EdgeConstants.EDGE_HUB_SERVER,\\n                                     EdgeConstants.EDGE_AGENT_CA,\\n                                     validity_days_from_now=365,\\n                                     hostname=self.hostname)\\n        cert_util.export_simulator_cert_artifacts_to_dir(EdgeConstants.EDGE_HUB_SERVER, self.certs_dir)\\n        cert_util.export_pfx_cert(EdgeConstants.EDGE_HUB_SERVER, self.certs_dir)\\n\\n        prefixes = [EdgeConstants.EDGE_AGENT_CA, EdgeConstants.EDGE_DEVICE_CA]\\n        cert_util.chain_simulator_ca_certs(EdgeConstants.EDGE_CHAIN_CA, prefixes, self.certs_dir)\\n\\n    # Generate IoT Edge device CA to be configured in IoT Edge runtime\\n    def generate_device_ca(self, valid_days, overwrite_existing, trusted_ca, trusted_ca_key, trusted_ca_key_passphase):\\n        # Function level variables\\n        create_root_ca = not (trusted_ca and trusted_ca_key)\\n        # Generate certs\\n        cert_util = EdgeCertUtil()\\n        if create_root_ca:\\n            cert_util.create_root_ca_cert(EdgeConstants.ROOT_CA_ID,\\n                                          validity_days_from_now=valid_days,\\n                                          subject_dict=EdgeConstants.CERT_DEFAULT_DICT,\\n                                          passphrase=None)\\n            cert_util.export_device_ca_cert_artifacts_to_dir(EdgeConstants.ROOT_CA_ID, self.certs_dir)\\n        else:\\n            cert_util.load_cert_from_file(EdgeConstants.ROOT_CA_ID, trusted_ca, trusted_ca_key, trusted_ca_key_passphase)\\n\\n        cert_util.create_intermediate_ca_cert(EdgeConstants.DEVICE_CA_ID, EdgeConstants.ROOT_CA_ID,\\n                                              validity_days_from_now=valid_days,\\n                                              common_name='Edge Device CA',\\n                                              set_terminal_ca=False,\\n                                              passphrase=None)\\n        cert_util.export_device_ca_cert_artifacts_to_dir(EdgeConstants.DEVICE_CA_ID, self.certs_dir)\\n        cert_util.chain_device_ca_certs(EdgeConstants.DEVICE_CA_ID,\\n                                        [EdgeConstants.DEVICE_CA_ID, EdgeConstants.ROOT_CA_ID],\\n                                        self.certs_dir)\\n\\n    def get_cert_file_path(self, id_str):\\n        return EdgeCertUtil.get_cert_file_path(id_str, self.certs_dir)\\n\\n    def get_pfx_file_path(self, id_str):\\n        return EdgeCertUtil.get_pfx_file_path(id_str, self.certs_dir)\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgedockerclient.py'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport docker\\nimport os\\nimport time\\nimport tarfile\\nfrom io import BytesIO\\nfrom .errors import EdgeDeploymentError\\nfrom .utils import Utils\\n\\n\\nclass EdgeDockerClient(object):\\n    _DOCKER_INFO_OS_TYPE_KEY = \\'OSType\\'\\n\\n    def __init__(self, docker_client=None):\\n        if docker_client is not None:\\n            self._client = docker_client\\n        else:\\n            try:\\n                self._client = docker.DockerClient.from_env(version=\\'auto\\')\\n            except Exception as ex:\\n                msg = \\'Could not connect to Docker daemon. Please make sure Docker is running\\'\\n                raise EdgeDeploymentError(msg, ex)\\n\\n    def __enter__(self):\\n        return self\\n\\n    def __exit__(self, exc_type, exc_value, traceback):\\n        if self._client is not None:\\n            self._client.api.close()\\n\\n    def stop_remove_by_label(self, label):\\n        try:\\n            filter_dict = {\\'label\\': label}\\n            containers = self._client.containers.list(all=True, filters=filter_dict)\\n            for container in containers:\\n                container.stop()\\n                self.remove(container.name)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not stop and remove containers by label: {0}\\'.format(label)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def get_local_image_sha_id(self, image):\\n        local_id = None\\n        try:\\n            inspect_dict = self._client.api.inspect_image(image)\\n            local_id = inspect_dict[\\'Id\\']\\n        except docker.errors.APIError:\\n            local_id = None\\n        return local_id\\n\\n    def pull(self, image, username, password):\\n        old_id = self.get_local_image_sha_id(image)\\n        try:\\n            is_updated = True\\n            auth_dict = None\\n            if username is not None:\\n                auth_dict = {\\'username\\': username, \\'password\\': password}\\n            self._client.images.pull(image, auth_config=auth_dict)\\n            if old_id is not None:\\n                inspect_dict = self._client.api.inspect_image(image)\\n                new_id = inspect_dict[\\'Id\\']\\n                if new_id == old_id:\\n                    is_updated = False\\n\\n            return is_updated\\n        except docker.errors.APIError as ex:\\n            msg = \\'Error during pull for image {0}\\'.format(image)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def pullIfNotExist(self, image, username, password):\\n        imageId = self.get_local_image_sha_id(image)\\n        if imageId is None:\\n            return self.pull(image, username, password)\\n\\n    def status(self, container_name):\\n        try:\\n            containers = self._client.containers.list(all=True)\\n            for container in containers:\\n                if container_name == container.name:\\n                    return container.status\\n            return None\\n        except docker.errors.APIError as ex:\\n            msg = \\'Error while checking status for: {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def stop(self, container_name):\\n        self._exec_container_method(container_name, \\'stop\\')\\n\\n    def start(self, container_name):\\n        self._exec_container_method(container_name, \\'start\\')\\n\\n    def remove(self, container_name):\\n        self._exec_container_method(container_name, \\'remove\\')\\n\\n    def create_network(self, network_name):\\n        create_network = False\\n        try:\\n            networks = self._client.networks.list(names=[network_name])\\n            if networks:\\n                num_networks = len(networks)\\n                if num_networks == 0:\\n                    create_network = True\\n            else:\\n                create_network = True\\n            if create_network is True:\\n                os_name = self.get_os_type()\\n                if os_name == \\'windows\\':\\n                    return self._client.networks.create(network_name, driver=\\'nat\\')\\n                else:\\n                    return self._client.networks.create(network_name, driver=\\'bridge\\')\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not create docker network: {0}\\'.format(network_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def create_volume(self, volume_name):\\n        try:\\n            volume = self._get_volume_if_exists(volume_name)\\n            if volume is None:\\n                return self._client.volumes.create(volume_name)\\n        except docker .errors.APIError as ex:\\n            msg = \\'Docker volume create failed for: {0}\\'.format(volume_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def create_config_for_network(self, nw_name, *args, **kwargs):\\n        return self._client.api.create_networking_config({\\n            nw_name: self._client.api.create_endpoint_config(*args, **kwargs)\\n        })\\n\\n    def create_container(self, image, **kwargs):\\n        try:\\n            return self._client.api.create_container(image, **kwargs)\\n        except docker.errors.ContainerError as ex_ctr:\\n            msg = \\'Container exited with errors: {0}\\'.format(kwargs.get(\\'name\\', None))\\n            raise EdgeDeploymentError(msg, ex_ctr)\\n        except docker.errors.ImageNotFound as ex_img:\\n            msg = \\'Docker create failed. Image not found: {0}\\'.format(image)\\n            raise EdgeDeploymentError(msg, ex_img)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker create failed for image: {0}\\'.format(image)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def create_host_config(self, *args, **kwargs):\\n        try:\\n            return self._client.api.create_host_config(*args, **kwargs)\\n        except Exception as ex:\\n            msg = \\'docker create host config failed\\'\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def copy_file_to_volume(self,\\n                            container_name,\\n                            volume_name,\\n                            volume_dest_file_name,\\n                            volume_dest_dir_path,\\n                            host_src_file):\\n        if self.get_os_type() == \\'windows\\':\\n            self._insert_file_in_volume_mount(volume_name, host_src_file, volume_dest_file_name)\\n        else:\\n            self._insert_file_in_container(container_name,\\n                                           volume_dest_file_name,\\n                                           volume_dest_dir_path,\\n                                           host_src_file)\\n\\n    def get_os_type(self):\\n        try:\\n            info = self._client.info()\\n            return info[EdgeDockerClient._DOCKER_INFO_OS_TYPE_KEY].lower()\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker daemon returned error\\'\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def destroy_network(self, network_name):\\n        try:\\n            networks = self._client.networks.list(names=[network_name])\\n            if networks is not None:\\n                for network in networks:\\n                    if network.name == network_name:\\n                        network.remove()\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not remove docker network: {0}\\'.format(network_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def remove_volume(self, volume_name, force=False):\\n        try:\\n            volume = self._get_volume_if_exists(volume_name)\\n            if volume is not None:\\n                volume.remove(force)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker volume remove failed for: {0}, force flag: {1}\\'.format(volume_name, force)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _get_volume_if_exists(self, name):\\n        try:\\n            return self._client.volumes.get(name)\\n        except docker.errors.NotFound:\\n            return None\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker volume get failed for: {0}\\'.format(name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _exec_container_method(self, container_name, method, **kwargs):\\n        container = self._get_container_by_name(container_name)\\n        try:\\n            getattr(container, method)(**kwargs)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not {0} container: {1}\\'.format(method, container_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _get_container_by_name(self, container_name):\\n        try:\\n            return self._client.containers.get(container_name)\\n        except docker.errors.NotFound as nf_ex:\\n            msg = \\'Could not find container by name {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, nf_ex)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Error getting container by name: {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _insert_file_in_volume_mount(self, volume_name, host_src_file, volume_dest_file_name):\\n        try:\\n            volume_info = self._client.api.inspect_volume(volume_name)\\n            Utils.copy_files(host_src_file.replace(\\'\\\\\\\\\\\\\\\\\\', \\'\\\\\\\\\\'),\\n                             os.path.join(volume_info[\\'Mountpoint\\'].replace(\\'\\\\\\\\\\\\\\\\\\', \\'\\\\\\\\\\'), volume_dest_file_name))\\n        except docker.errors.APIError as docker_ex:\\n            msg = \\'Docker volume inspect failed for: {0}\\'.format(volume_name)\\n            raise EdgeDeploymentError(msg, docker_ex)\\n        except (OSError, IOError) as ex_os:\\n            msg = \\'File IO error seen copying files to volume: {0}. \\' \\\\\\n                  \\'Errno: {1}, Error {2}\\'.format(volume_name, str(ex_os.errno), ex_os.strerror)\\n            raise EdgeDeploymentError(msg, ex_os)\\n\\n    def _insert_file_in_container(self,\\n                                  container_name,\\n                                  volume_dest_file_name,\\n                                  volume_dest_dir_path,\\n                                  host_src_file):\\n        try:\\n            (tar_stream, dest_archive_info, container_tar_file) = \\\\\\n                EdgeDockerClient.create_tar_objects(volume_dest_file_name)\\n            file_data = open(host_src_file, \\'rb\\').read()\\n            dest_archive_info.size = len(file_data)\\n            dest_archive_info.mtime = time.time()\\n            dest_archive_info.mode = 0o444\\n            container_tar_file.addfile(dest_archive_info, BytesIO(file_data))\\n            container_tar_file.close()\\n            tar_stream.seek(0)\\n            container = self._get_container_by_name(container_name)\\n            container.put_archive(volume_dest_dir_path, tar_stream)\\n        except docker.errors.APIError as docker_ex:\\n            msg = \\'Container put_archive failed for container: {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, docker_ex)\\n        except (OSError, IOError) as ex_os:\\n            msg = \\'File IO error seen during put archive for container: {0}. \\' \\\\\\n                  \\'Errno: {1}, Error {2}\\'.format(container_name, str(ex_os.errno), ex_os.strerror)\\n            raise EdgeDeploymentError(msg, ex_os)\\n\\n    @staticmethod\\n    def create_tar_objects(container_dest_file_name):\\n        tar_stream = BytesIO()\\n        dest_archive_info = tarfile.TarInfo(name=container_dest_file_name)\\n        container_tar_file = tarfile.TarFile(fileobj=tar_stream, mode=\\'w\\')\\n        return (tar_stream, dest_archive_info, container_tar_file)\\n\\n    @classmethod\\n    def create_instance(cls, docker_client):\\n        \"\"\"\\n        Factory method useful in testing.\\n        \"\"\"\\n        return cls(docker_client)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/edgemanager.py'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport json\\nimport os\\n\\nimport docker\\nimport requests\\n\\nfrom .composeproject import ComposeProject\\nfrom .constants import EdgeConstants as EC\\nfrom .edgecert import EdgeCert\\nfrom .edgedockerclient import EdgeDockerClient\\nfrom .errors import ResponseError, RegistriesLoginError\\nfrom .hostplatform import HostPlatform\\nfrom .utils import Utils\\n\\n\\nclass EdgeManager(object):\\n    LABEL = \\'iotedgehubdev\\'\\n    EDGEHUB_IMG = \\'mcr.microsoft.com/azureiotedge-hub:{0}\\'\\n    TESTUTILITY_IMG = \\'mcr.microsoft.com/azureiotedge-testing-utility:1.0.0\\'\\n    EDGEHUB_MODULE = \\'$edgeHub\\'\\n    EDGEHUB = \\'edgeHubDev\\'\\n    INPUT = \\'input\\'\\n    NW_NAME = \\'azure-iot-edge-dev\\'\\n    MOUNT_BASE = \\'mnt\\'\\n    HUB_VOLUME = \\'edgehubdev\\'\\n    HUB_MOUNT = \\'{0}/edgehub\\'\\n    MODULE_VOLUME = \\'edgemoduledev\\'\\n    MODULE_MOUNT = \\'{0}/edgemodule\\'\\n    HUB_CA_ENV = \\'EdgeModuleHubServerCAChainCertificateFile={0}/edgehub/edge-chain-ca.cert.pem\\'\\n    HUB_CERT_ENV = \\'EdgeModuleHubServerCertificateFile={0}/edgehub/edge-hub-server.cert.pfx\\'\\n    HUB_SRC_ENV = \\'configSource=local\\'\\n    MODULE_CA_ENV = \"EdgeModuleCACertificateFile={0}/edgemodule/edge-device-ca.cert.pem\"\\n    HUB_SSLPATH_ENV = \\'SSL_CERTIFICATE_PATH={0}/edgehub/\\'\\n    HUB_SSLCRT_ENV = \\'SSL_CERTIFICATE_NAME=edge-hub-server.cert.pfx\\'\\n    CERT_HELPER = \\'cert_helper\\'\\n    HELPER_IMG = \\'hello-world:latest\\'\\n    COMPOSE_FILE = os.path.join(HostPlatform.get_share_data_path(), \\'docker-compose.yml\\')\\n\\n    def __init__(self, connection_str, gatewayhost, cert_path, hub_conn_str=None):\\n        connection_str_dict = Utils.parse_connection_strs(connection_str, hub_conn_str)\\n        self._hostname = connection_str_dict[EC.HOSTNAME_KEY]\\n        self._device_id = connection_str_dict[EC.DEVICE_ID_KEY]\\n        self._access_key = connection_str_dict[EC.DEVICE_ACCESS_KEY_KEY]\\n        self._compose_file = None\\n        self._gatewayhost = gatewayhost\\n        self._device_uri = \\'{0}/devices/{1}\\'.format(self._hostname, self._device_id)\\n        self._cert_path = cert_path\\n        self._edge_cert = EdgeCert(self._cert_path, self._gatewayhost)\\n        self._hub_access_key = connection_str_dict.get(EC.HUB_ACCESS_KEY_KEY)\\n        self._hub_access_name = connection_str_dict.get(EC.ACCESS_KEY_NAME)\\n\\n    @property\\n    def hostname(self):\\n        return self._hostname\\n\\n    @staticmethod\\n    def stop(edgedockerclient=None):\\n        if edgedockerclient is None:\\n            edgedockerclient = EdgeDockerClient()\\n\\n        compose_err = None\\n        label_err = None\\n        try:\\n            if os.path.exists(EdgeManager.COMPOSE_FILE):\\n                cmd = \"docker-compose -f {0} down\".format(EdgeManager.COMPOSE_FILE)\\n                Utils.exe_proc(cmd.split())\\n        except Exception as e:\\n            compose_err = e\\n\\n        try:\\n            edgedockerclient.stop_remove_by_label(EdgeManager.LABEL)\\n        except Exception as e:\\n            label_err = e\\n\\n        if compose_err or label_err:\\n            raise Exception(\\'{0}{1}\\'.format(\\n                \\'\\' if compose_err is None else str(compose_err),\\n                \\'\\' if label_err is None else str(label_err)))\\n\\n    def start_singlemodule(self, inputs, port, envs, edgehub_image_version):\\n        edgedockerclient = EdgeDockerClient()\\n        mount_base = self._obtain_mount_path(edgedockerclient)\\n        if mount_base is None:\\n            raise Exception(\"OS Type is not supported\")\\n\\n        EdgeManager.stop(edgedockerclient)\\n        self._prepare(edgedockerclient)\\n\\n        edgeHubConnStr = self.getOrAddModule(EdgeManager.EDGEHUB_MODULE, False)\\n        inputConnStr = self.getOrAddModule(EdgeManager.INPUT, False)\\n        routes = self._generateRoutesEnvFromInputs(inputs)\\n        self._start_edge_hub(edgedockerclient, edgeHubConnStr, routes, mount_base, envs, edgehub_image_version)\\n\\n        module_mount = EdgeManager.MODULE_MOUNT.format(mount_base)\\n        edgedockerclient.pullIfNotExist(EdgeManager.TESTUTILITY_IMG, None, None)\\n        network_config = edgedockerclient.create_config_for_network(EdgeManager.NW_NAME)\\n        inputEnv = [EdgeManager.MODULE_CA_ENV.format(mount_base), \"EdgeHubConnectionString={0}\".format(inputConnStr)]\\n        input_host_config = edgedockerclient.create_host_config(\\n            mounts=[docker.types.Mount(module_mount, EdgeManager.MODULE_VOLUME)],\\n            port_bindings={\\n                \\'3000\\': port\\n            },\\n            restart_policy={\\n                \\'MaximumRetryCount\\': 3,\\n                \\'Name\\': \\'on-failure\\'\\n            }\\n        )\\n        inputContainer = edgedockerclient.create_container(\\n            EdgeManager.TESTUTILITY_IMG,\\n            name=EdgeManager.INPUT,\\n            volumes=[module_mount],\\n            host_config=input_host_config,\\n            networking_config=network_config,\\n            environment=inputEnv,\\n            labels=[EdgeManager.LABEL],\\n            ports=[(3000, \\'tcp\\')]\\n        )\\n\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.INPUT, EdgeManager.MODULE_VOLUME, self._device_cert(),\\n            module_mount,\\n            self._edge_cert.get_cert_file_path(EC.EDGE_DEVICE_CA))\\n        edgedockerclient.start(inputContainer.get(\\'Id\\'))\\n\\n    def config_solution(self, module_content, target, mount_base):\\n        module_names = [EdgeManager.EDGEHUB_MODULE]\\n        custom_modules = module_content[\\'$edgeAgent\\'][\\'properties.desired\\'][\\'modules\\']\\n        for module_name in custom_modules:\\n            module_names.append(module_name)\\n\\n        ConnStr_info = {}\\n        for module_name in module_names:\\n            ConnStr_info[module_name] = self.getOrAddModule(module_name, False)\\n\\n        env_info = {\\n            \\'hub_env\\': [\\n                EdgeManager.HUB_CA_ENV.format(mount_base),\\n                EdgeManager.HUB_CERT_ENV.format(mount_base),\\n                EdgeManager.HUB_SRC_ENV,\\n                EdgeManager.HUB_SSLPATH_ENV.format(mount_base),\\n                EdgeManager.HUB_SSLCRT_ENV\\n            ],\\n            \\'module_env\\': [\\n                EdgeManager.MODULE_CA_ENV.format(mount_base)\\n            ]\\n        }\\n\\n        volume_info = {\\n            \\'HUB_MOUNT\\': EdgeManager.HUB_MOUNT.format(mount_base),\\n            \\'HUB_VOLUME\\': EdgeManager.HUB_VOLUME,\\n            \\'MODULE_VOLUME\\': EdgeManager.MODULE_VOLUME,\\n            \\'MODULE_MOUNT\\': EdgeManager.MODULE_MOUNT.format(mount_base)\\n        }\\n\\n        network_info = {\\n            \\'NW_NAME\\': EdgeManager.NW_NAME,\\n            \\'ALIASES\\': self._gatewayhost\\n        }\\n\\n        compose_project = ComposeProject(module_content)\\n        compose_project.set_edge_info({\\n            \\'ConnStr_info\\': ConnStr_info,\\n            \\'env_info\\': env_info,\\n            \\'volume_info\\': volume_info,\\n            \\'network_info\\': network_info,\\n            \\'hub_name\\': EdgeManager.EDGEHUB,\\n            \\'labels\\': EdgeManager.LABEL\\n        })\\n\\n        compose_project.compose()\\n        compose_project.dump(target)\\n\\n    def start_solution(self, module_content, verbose, output):\\n        try:\\n            EdgeManager.login_registries(module_content)\\n        except RegistriesLoginError as e:\\n            output.warning(e.getmsg())\\n\\n        edgedockerclient = EdgeDockerClient()\\n        mount_base = self._obtain_mount_path(edgedockerclient)\\n        if not mount_base:\\n            raise Exception(\"OS Type is not supported\")\\n\\n        EdgeManager.stop(edgedockerclient)\\n        self._prepare(edgedockerclient)\\n        self._prepare_cert(edgedockerclient, mount_base)\\n\\n        self.config_solution(module_content, EdgeManager.COMPOSE_FILE, mount_base)\\n        try:\\n            self.update_module_twin(module_content)\\n        except Exception as e:\\n            output.warning(str(e))\\n\\n        cmd_pull = [\\'docker-compose\\', \\'-f\\', EdgeManager.COMPOSE_FILE, \\'pull\\', EdgeManager.EDGEHUB]\\n        Utils.exe_proc(cmd_pull)\\n        if verbose:\\n            cmd_up = [\\'docker-compose\\', \\'-f\\', EdgeManager.COMPOSE_FILE, \\'up\\']\\n        else:\\n            cmd_up = [\\'docker-compose\\', \\'-f\\', EdgeManager.COMPOSE_FILE, \\'up\\', \\'-d\\']\\n        Utils.exe_proc(cmd_up)\\n\\n    def update_module_twin(self, module_content):\\n        if self._hub_access_key is None:\\n            return\\n\\n        twinErrorMsg = \\'\\'\\n        sas = Utils.get_iot_hub_sas_token(self._hostname, self._hub_access_key, self._hub_access_name)\\n        for name in module_content:\\n            if name == \\'$edgeAgent\\' or name == \\'$edgeHub\\':\\n                continue\\n            twin = module_content.get(name).get(\\'properties.desired\\')\\n            uri = self._get_update_twin_uri(name)\\n            res = requests.patch(\\n                uri,\\n                headers={\\n                    \\'Authorization\\': sas,\\n                    \\'Content-Type\\': \"application/json\",\\n                    \\'If-Match\\': \\'\"*\"\\'\\n                },\\n                data=json.dumps({\\n                    \\'properties\\': {\\n                        \\'desired\\': twin\\n                    }\\n                })\\n            )\\n            if res.ok is not True:\\n                twinErrorMsg += \\'Fail to update {0} twin. Code:{1}. Detail:{2}\\'.format(name, res.status_code, res.text)\\n        if twinErrorMsg:\\n            raise Exception(twinErrorMsg)\\n\\n    @staticmethod\\n    def login_registries(module_content):\\n        registryCredentials = module_content.get(\\'$edgeAgent\\', {}).get(\\'properties.desired\\', {}).get(\\n            \\'runtime\\', {}).get(\\'settings\\', {}).get(\\'registryCredentials\\')\\n        if not registryCredentials:\\n            return\\n        failLogin = []\\n        errMsg = \\'\\'\\n        for key in registryCredentials:\\n            value = registryCredentials[key]\\n            try:\\n                cmd_login = [\\'docker\\', \\'login\\', \\'-u\\', value[\\'username\\'], \\'-p\\', value[\\'password\\'], value[\\'address\\']]\\n                Utils.exe_proc(cmd_login)\\n            except Exception as e:\\n                failLogin.append(key)\\n                errMsg += \\'{0}\\\\n\\'.format(str(e))\\n        if failLogin:\\n            raise RegistriesLoginError(failLogin, errMsg)\\n\\n    def _prepare_cert(self, edgedockerclient, mount_base):\\n        status = edgedockerclient.status(EdgeManager.CERT_HELPER)\\n        if status is not None:\\n            edgedockerclient.stop(EdgeManager.CERT_HELPER)\\n            edgedockerclient.remove(EdgeManager.CERT_HELPER)\\n\\n        hub_mount = EdgeManager.HUB_MOUNT.format(mount_base)\\n        module_mount = EdgeManager.MODULE_MOUNT.format(mount_base)\\n\\n        helper_host_config = edgedockerclient.create_host_config(\\n            mounts=[docker.types.Mount(hub_mount, EdgeManager.HUB_VOLUME),\\n                    docker.types.Mount(module_mount, EdgeManager.MODULE_VOLUME)]\\n        )\\n\\n        edgedockerclient.pull(EdgeManager.HELPER_IMG, None, None)\\n\\n        edgedockerclient.create_container(\\n            EdgeManager.HELPER_IMG,\\n            name=EdgeManager.CERT_HELPER,\\n            volumes=[hub_mount, module_mount],\\n            host_config=helper_host_config,\\n            labels=[EdgeManager.LABEL]\\n        )\\n\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.CERT_HELPER, EdgeManager.HUB_VOLUME, EdgeManager._chain_cert(),\\n            hub_mount, self._edge_cert.get_cert_file_path(EC.EDGE_CHAIN_CA))\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.CERT_HELPER, EdgeManager.HUB_VOLUME, EdgeManager._hubserver_pfx(),\\n            hub_mount, self._edge_cert.get_pfx_file_path(EC.EDGE_HUB_SERVER))\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.CERT_HELPER, EdgeManager.MODULE_VOLUME, self._device_cert(),\\n            module_mount, self._edge_cert.get_cert_file_path(EC.EDGE_DEVICE_CA))\\n\\n    def start(self, modulesDict, routes):\\n        return\\n\\n    def getOrAddModule(self, name, islocal):\\n        try:\\n            return self.getModule(name, islocal)\\n        except ResponseError as geterr:\\n            if geterr.status_code == 404:\\n                try:\\n                    return self.addModule(name, islocal)\\n                except ResponseError as adderr:\\n                    if adderr.status_code == 400:\\n                        raise ResponseError(400, adderr.value + \" Please make sure you are using an Edge device.\")\\n                    raise adderr\\n            else:\\n                raise geterr\\n\\n    def outputModuleCred(self, names, islocal, output_file):\\n        connstrENV = \\'EdgeHubConnectionString={0}\\'.format(\\'|\\'.join([self.getOrAddModule(name, islocal) for name in names]))\\n        deviceCAEnv = \\'EdgeModuleCACertificateFile={0}\\'.format(self._edge_cert.get_cert_file_path(EC.EDGE_DEVICE_CA))\\n        cred = [connstrENV, deviceCAEnv]\\n\\n        if output_file is not None:\\n            output_path = os.path.abspath(output_file)\\n            dir = os.path.dirname(output_path)\\n            if not os.path.exists(dir):\\n                os.makedirs(dir)\\n            with open(output_path, \\'w+\\') as envFile:\\n                envFile.writelines([\\'\\\\n\\', cred[0], \\'\\\\n\\', cred[1]])\\n        return cred\\n\\n    def getModule(self, name, islocal):\\n        moduleUri = self._getModuleReqUri(name)\\n        sas = Utils.get_iot_hub_sas_token(self._device_uri, self._access_key, None)\\n        res = requests.get(\\n            moduleUri,\\n            headers={\\n                \\'Authorization\\': sas,\\n                \\'Content-Type\\': \\'application/json\\'\\n            }\\n        )\\n        if res.ok is not True:\\n            raise ResponseError(res.status_code, res.text)\\n        else:\\n            jsonObj = res.json()\\n            auth = jsonObj[\\'authentication\\']\\n            if auth is not None:\\n                authType = auth[\\'type\\']\\n                authKey = auth[\\'symmetricKey\\']\\n                if authType == \\'sas\\' and authKey is not None and authKey[\\'primaryKey\\'] is not None:\\n                    return self._generateModuleConnectionStr(res, islocal)\\n            return self.updateModule(name, jsonObj[\\'etag\\'], islocal)\\n\\n    def updateModule(self, name, etag, islocal):\\n        moduleUri = self._getModuleReqUri(name)\\n        sas = Utils.get_iot_hub_sas_token(self._device_uri, self._access_key, None)\\n        res = requests.put(\\n            moduleUri,\\n            headers={\\n                \\'Authorization\\': sas,\\n                \\'Content-Type\\': \"application/json\",\\n                \\'If-Match\\': \\'\"*\"\\'\\n            },\\n            data=json.dumps({\\n                \\'moduleId\\': name,\\n                \\'deviceId\\': self._device_id,\\n                \\'authentication\\': {\\n                    \\'type\\': \\'sas\\'\\n                }\\n            })\\n        )\\n        if res.ok is not True:\\n            raise ResponseError(res.status_code, res.text)\\n        return self._generateModuleConnectionStr(res, islocal)\\n\\n    def addModule(self, name, islocal):\\n        moduleUri = self._getModuleReqUri(name)\\n        sas = Utils.get_iot_hub_sas_token(self._device_uri, self._access_key, None)\\n        res = requests.put(\\n            moduleUri,\\n            headers={\\n                \"Authorization\": sas,\\n                \"Content-Type\": \"application/json\"\\n            },\\n            data=json.dumps({\\n                \\'moduleId\\': name,\\n                \\'deviceId\\': self._device_id\\n            })\\n        )\\n        if res.ok is not True:\\n            raise ResponseError(res.status_code, res.text)\\n        return self._generateModuleConnectionStr(res, islocal)\\n\\n    def _getModuleReqUri(self, name):\\n        return \"https://{0}/devices/{1}/modules/{2}?api-version=2018-06-30\".format(\\n            self._hostname, self._device_id, name)\\n\\n    def _get_update_twin_uri(self, name):\\n        return \"https://{0}/twins/{1}/modules/{2}?api-version=2018-06-30\".format(\\n            self._hostname, self._device_id, name)\\n\\n    def _generateModuleConnectionStr(self, response, islocal):\\n        jsonObj = response.json()\\n        moduleId = jsonObj[\\'moduleId\\']\\n        deviceId = jsonObj[\\'deviceId\\']\\n        sasKey = jsonObj[\\'authentication\\'][\\'symmetricKey\\'][\\'primaryKey\\']\\n        hubTemplate = \\'HostName={0};DeviceId={1};ModuleId={2};SharedAccessKey={3}\\'\\n        moduleTemplate = \\'HostName={0};GatewayHostName={1};DeviceId={2};ModuleId={3};SharedAccessKey={4}\\'\\n        gatewayhost = self._gatewayhost\\n        if (islocal):\\n            gatewayhost = \\'localhost\\'\\n        if (moduleId == \\'$edgeHub\\'):\\n            return hubTemplate.format(self._hostname, deviceId, moduleId, sasKey)\\n        else:\\n            return moduleTemplate.format(self._hostname, gatewayhost, deviceId, moduleId, sasKey)\\n\\n    def _generateRoutesEnvFromInputs(self, inputs):\\n        routes = [\\n            \\'routes__output=FROM /messages/modules/target/outputs/* INTO BrokeredEndpoint(\"/modules/input/inputs/print\")\\'\\n        ]\\n        template = \\'routes__r{0}=FROM /messages/modules/input/outputs/{1} INTO BrokeredEndpoint(\"/modules/target/inputs/{2}\")\\'\\n        inputSet = set(inputs)\\n        for (idx, input) in enumerate(inputSet):\\n            routes.append(template.format(idx + 1, input, input))\\n        return routes\\n\\n    def _prepare(self, edgedockerclient):\\n        edgedockerclient.create_network(EdgeManager.NW_NAME)\\n        edgedockerclient.create_volume(EdgeManager.HUB_VOLUME)\\n        edgedockerclient.create_volume(EdgeManager.MODULE_VOLUME)\\n\\n    def _start_edge_hub(self, edgedockerclient, edgeHubConnStr, routes, mount_base, envs, edgehub_image_version):\\n        edgehub_image = EdgeManager.EDGEHUB_IMG.format(edgehub_image_version)\\n        edgedockerclient.pull(edgehub_image, None, None)\\n        network_config = edgedockerclient.create_config_for_network(EdgeManager.NW_NAME, aliases=[self._gatewayhost])\\n        hub_mount = EdgeManager.HUB_MOUNT.format(mount_base)\\n        hub_host_config = edgedockerclient.create_host_config(\\n            mounts=[docker.types.Mount(hub_mount, EdgeManager.HUB_VOLUME)],\\n            port_bindings={\\n                \\'8883\\': 8883,\\n                \\'443\\': 443,\\n                \\'5671\\': 5671\\n            }\\n        )\\n        hubEnv = [\\n            EdgeManager.HUB_CA_ENV.format(mount_base),\\n            EdgeManager.HUB_CERT_ENV.format(mount_base),\\n            EdgeManager.HUB_SRC_ENV,\\n            EdgeManager.HUB_SSLPATH_ENV.format(mount_base),\\n            EdgeManager.HUB_SSLCRT_ENV,\\n            \\'IotHubConnectionString={0}\\'.format(edgeHubConnStr)]\\n        hubEnv.extend(routes)\\n        hubEnv.extend(list(envs))\\n\\n        hubContainer = edgedockerclient.create_container(\\n            edgehub_image,\\n            name=EdgeManager.EDGEHUB,\\n            volumes=[hub_mount],\\n            host_config=hub_host_config,\\n            networking_config=network_config,\\n            environment=hubEnv,\\n            labels=[EdgeManager.LABEL],\\n            ports=[(8883, \\'tcp\\'), (443, \\'tcp\\'), (5671, \\'tcp\\')]\\n        )\\n\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.EDGEHUB, EdgeManager.HUB_VOLUME, EdgeManager._chain_cert(),\\n            hub_mount, self._edge_cert.get_cert_file_path(EC.EDGE_CHAIN_CA))\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.EDGEHUB, EdgeManager.HUB_VOLUME, EdgeManager._hubserver_pfx(),\\n            hub_mount, self._edge_cert.get_pfx_file_path(EC.EDGE_HUB_SERVER))\\n        edgedockerclient.start(hubContainer.get(\\'Id\\'))\\n\\n    def _obtain_mount_path(self, edgedockerclient):\\n        os_type = edgedockerclient.get_os_type().lower()\\n        if os_type == \\'linux\\':\\n            return \\'/{0}\\'.format(EdgeManager.MOUNT_BASE)\\n        elif os_type == \\'windows\\':\\n            return \\'c:/{0}\\'.format(EdgeManager.MOUNT_BASE)\\n\\n    @staticmethod\\n    def _chain_cert():\\n        return EC.EDGE_CHAIN_CA + EC.CERT_SUFFIX\\n\\n    @staticmethod\\n    def _hubserver_pfx():\\n        return EC.EDGE_HUB_SERVER + EC.PFX_SUFFIX\\n\\n    @staticmethod\\n    def _device_cert():\\n        return EC.EDGE_DEVICE_CA + EC.CERT_SUFFIX\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/errors.py'"}, "return_value": "\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nclass EdgeError(Exception):\\n    def __init__(self, msg, ex=None):\\n        if ex:\\n            msg += ' : {0}'.format(str(ex))\\n        super(EdgeError, self).__init__(msg)\\n        self._ex = ex\\n\\n\\nclass EdgeInvalidArgument(EdgeError):\\n    def __init__(self, msg, ex=None):\\n        super(EdgeInvalidArgument, self).__init__(msg, ex)\\n\\n\\nclass EdgeValueError(EdgeError):\\n    def __init__(self, msg, ex=None):\\n        super(EdgeValueError, self).__init__(msg, ex)\\n\\n\\nclass EdgeFileAccessError(EdgeError):\\n    def __init__(self, msg, file_name, ex=None):\\n        msg += ': {0}'.format(file_name)\\n        super(EdgeFileAccessError, self).__init__(msg, ex)\\n        self.file_name = file_name\\n\\n\\nclass EdgeFileParseError(EdgeError):\\n    def __init__(self, msg, file_name, ex=None):\\n        msg += ': {0}'.format(file_name)\\n        super(EdgeFileParseError, self).__init__(msg, ex)\\n        self.file_name = file_name\\n\\n\\nclass EdgeDeploymentError(EdgeError):\\n    def __init__(self, msg, ex=None):\\n        super(EdgeDeploymentError, self).__init__(msg, ex)\\n\\n\\nclass ResponseError(EdgeError):\\n    def __init__(self, status_code, value):\\n        super(ResponseError, self).__init__('Code:{0}. Detail:{1}'.format(status_code, value))\\n        self.value = value\\n        self.status_code = status_code\\n\\n\\nclass RegistriesLoginError(EdgeError):\\n    def __init__(self, registries, errmsg):\\n        super(RegistriesLoginError, self).__init__(errmsg)\\n        self._registries = registries\\n        self._errmsg = errmsg\\n\\n    def getmsg(self):\\n        return ('Fail to login {0}. Detail: {1}').format(self._registries, self._errmsg)\\n\\n    def registries(self):\\n        return self._registries\\n\\n\\nclass InvalidConfigError(EdgeError):\\n    def __init__(self, msg):\\n        super(InvalidConfigError, self).__init__(msg)\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/hostplatform.py'"}, "return_value": "\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport os\\nimport platform\\nfrom .errors import EdgeInvalidArgument\\n\\n\\nclass HostPlatform(object):\\n    _edge_dir = 'iotedgehubdev'\\n    _edgehub_config = 'edgehub.json'\\n    _setting_ini = 'setting.ini'\\n    _certs = 'certs'\\n    _data = 'data'\\n    _windows_config_path = os.getenv('PROGRAMDATA', '%%PROGRAMDATA%%')\\n\\n    _platforms = {\\n        'linux': {\\n            'supported_deployments': ['docker'],\\n            'default_deployment': 'docker',\\n            'default_edge_conf_dir': '/etc/' + _edge_dir,\\n            'default_edge_data_dir': '/var/lib/' + _edge_dir,\\n            'default_edge_meta_dir_env': 'HOME',\\n            'deployment': {\\n                'docker': {\\n                    'linux': {\\n                        'default_uri': 'unix:///var/run/docker.sock'\\n                    },\\n                }\\n            }\\n        },\\n        'windows': {\\n            'supported_deployments': ['docker'],\\n            'default_deployment': 'docker',\\n            'default_edge_conf_dir': _windows_config_path + '\\\\\\\\' + _edge_dir + '\\\\\\\\config',\\n            'default_edge_data_dir': _windows_config_path + '\\\\\\\\' + _edge_dir + '\\\\\\\\data',\\n            'default_edge_meta_dir_env': 'USERPROFILE',\\n            'deployment': {\\n                'docker': {\\n                    'linux': {\\n                        'default_uri': 'unix:///var/run/docker.sock'\\n                    },\\n                    'windows': {\\n                        'default_uri': 'npipe://./pipe/docker_engine'\\n                    }\\n                }\\n            }\\n        },\\n        'darwin': {\\n            'supported_deployments': ['docker'],\\n            'default_deployment': 'docker',\\n            'default_edge_conf_dir': '/etc/' + _edge_dir,\\n            'default_edge_data_dir': '/var/lib/' + _edge_dir,\\n            'default_edge_meta_dir_env': 'HOME',\\n            'deployment': {\\n                'docker': {\\n                    'linux': {\\n                        'default_uri': 'unix:///var/run/docker.sock'\\n                    },\\n                }\\n            }\\n        }\\n    }\\n\\n    # @staticmethod\\n    # def is_host_supported(host):\\n    #     if host is None:\\n    #         raise EdgeInvalidArgument('host cannot be None')\\n\\n    #     host = host.lower()\\n    #     if host in _platforms:\\n    #         return True\\n    #     return False\\n\\n    @staticmethod\\n    def get_config_path():\\n        host = platform.system()\\n        if host is None:\\n            raise EdgeInvalidArgument('host cannot be None')\\n        host = host.lower()\\n        if host in HostPlatform._platforms:\\n            return HostPlatform._platforms[host]['default_edge_conf_dir']\\n        return None\\n\\n    @staticmethod\\n    def get_config_file_path():\\n        configPath = HostPlatform.get_config_path()\\n        if configPath is not None:\\n            return os.path.join(configPath, HostPlatform._edgehub_config)\\n        return None\\n\\n    @staticmethod\\n    def get_setting_ini_path():\\n        configPath = HostPlatform.get_config_path()\\n        if configPath is not None:\\n            return os.path.join(configPath, HostPlatform._setting_ini)\\n        return None\\n\\n    @staticmethod\\n    def get_default_cert_path():\\n        host = platform.system()\\n        if host is None:\\n            raise EdgeInvalidArgument('host cannot be None')\\n        host = host.lower()\\n        if host in HostPlatform._platforms:\\n            return os.path.join(HostPlatform._platforms[host]['default_edge_data_dir'], HostPlatform._certs)\\n        return None\\n\\n    @staticmethod\\n    def get_share_data_path():\\n        host = platform.system()\\n        if host is None:\\n            raise EdgeInvalidArgument('host cannot be None')\\n        host = host.lower()\\n        if host in HostPlatform._platforms:\\n            return os.path.join(HostPlatform._platforms[host]['default_edge_data_dir'], HostPlatform._data)\\n        return None\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/output.py'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport click\\n\\n\\nclass Output:\\n\\n    def info(self, text, suppress=False):\\n        if not suppress:\\n            self.echo(text, color=\\'yellow\\')\\n\\n    def status(self, text):\\n        self.info(text)\\n        self.line()\\n\\n    def prompt(self, text):\\n        self.echo(text, color=\\'white\\')\\n\\n    def warning(self, text):\\n        self.echo(\"WARNING: \" + text, color=\\'yellow\\')\\n\\n    def error(self, text):\\n        self.echo(\"ERROR: \" + text, color=\\'red\\', err=True)\\n\\n    def header(self, text, suppress=False):\\n\\n        if not suppress:\\n            self.line()\\n            s = \"======== {0} ========\".format(text).upper()\\n            m = \"=\" * len(s)\\n            self.echo(m, color=\\'white\\')\\n            self.echo(s, color=\\'white\\')\\n            self.echo(m, color=\\'white\\')\\n            self.line()\\n\\n    def param(self, text, value, status, suppress):\\n        if value and not suppress:\\n            self.header(\"SETTING \" + text)\\n            self.status(status)\\n\\n    def footer(self, text, suppress=False):\\n        if not suppress:\\n            self.info(text.upper())\\n            self.line()\\n\\n    def procout(self, text):\\n        self.echo(text, dim=True)\\n\\n    def line(self):\\n        self.echo(text=\"\")\\n\\n    def echo(self, text, color=\"\", dim=False, err=False):\\n        try:\\n            click.secho(text, fg=color, dim=dim, err=err)\\n        except Exception:\\n            print(text)\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry.py'"}, "return_value": "\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport datetime\\nimport json\\nimport platform\\nimport uuid\\nimport multiprocessing\\n\\nfrom collections import defaultdict\\nfrom functools import wraps\\n\\n\\nfrom . import configs, decorators\\nfrom . import telemetry_upload as telemetry_core\\nfrom . import __production__ as production_name\\n\\nPRODUCT_NAME = production_name\\n\\n\\nclass TelemetrySession(object):\\n    def __init__(self, correlation_id=None):\\n        self.start_time = None\\n        self.end_time = None\\n        self.correlation_id = correlation_id or str(uuid.uuid4())\\n        self.command = 'command_name'\\n        self.parameters = []\\n        self.result = 'None'\\n        self.result_summary = None\\n        self.exception = None\\n        self.extra_props = {}\\n        self.machineId = self._get_hash_mac_address()\\n        self.events = defaultdict(list)\\n\\n    def generate_payload(self):\\n        props = {\\n            'EventId': str(uuid.uuid4()),\\n            'CorrelationId': self.correlation_id,\\n            'MachineId': self.machineId,\\n            'ProductName': PRODUCT_NAME,\\n            'ProductVersion': _get_core_version(),\\n            'CommandName': self.command,\\n            'OS.Type': platform.system().lower(),\\n            'OS.Version': platform.version().lower(),\\n            'Result': self.result,\\n            'StartTime': str(self.start_time),\\n            'EndTime': str(self.end_time),\\n            'Parameters': ','.join(self.parameters)\\n        }\\n\\n        if self.result_summary:\\n            props['ResultSummary'] = self.result_summary\\n\\n        if self.exception:\\n            props['Exception'] = self.exception\\n\\n        props.update(self.extra_props)\\n\\n        self.events[_get_AI_key()].append({\\n            'name': '{}/command'.format(PRODUCT_NAME),\\n            'properties': props\\n        })\\n\\n        payload = json.dumps(self.events)\\n        return _remove_symbols(payload)\\n\\n    @decorators.suppress_all_exceptions()\\n    @decorators.hash256_result\\n    def _get_hash_mac_address(self):\\n        s = ''\\n        for index, c in enumerate(hex(uuid.getnode())[2:].upper()):\\n            s += c\\n            if index % 2:\\n                s += '-'\\n\\n        s = s.strip('-')\\n        return s\\n\\n\\n_session = TelemetrySession()\\n\\n\\ndef _user_agrees_to_telemetry(func):\\n    @wraps(func)\\n    def _wrapper(*args, **kwargs):\\n        if not configs.get_ini_config().getboolean('DEFAULT', 'collect_telemetry'):\\n            return None\\n        return func(*args, **kwargs)\\n\\n    return _wrapper\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef start(cmdname, params=[]):\\n    _session.command = cmdname\\n    _session.start_time = datetime.datetime.utcnow()\\n    if params is not None:\\n        _session.parameters.extend(params)\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef success():\\n    _session.result = 'Success'\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef fail(exception, summary):\\n    _session.exception = exception\\n    _session.result = 'Fail'\\n    _session.result_summary = summary\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef add_extra_props(props):\\n    if props is not None:\\n        _session.extra_props.update(props)\\n\\n\\n@_user_agrees_to_telemetry\\n@decorators.suppress_all_exceptions()\\ndef flush():\\n    # flush out current information\\n    _session.end_time = datetime.datetime.utcnow()\\n\\n    payload = _session.generate_payload()\\n    if payload:\\n        _upload_telemetry_with_user_agreement(payload)\\n\\n    # reset session fields, retaining correlation id and application\\n    _session.__init__(correlation_id=_session.correlation_id)\\n\\n\\n@decorators.suppress_all_exceptions(fallback_return=None)\\ndef _get_core_version():\\n    from iotedgehubdev import __version__ as core_version\\n    return core_version\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef _get_AI_key():\\n    from iotedgehubdev import __AIkey__ as key\\n    return key\\n\\n\\n# This includes a final user-agreement-check; ALL methods sending telemetry MUST call this.\\n@_user_agrees_to_telemetry\\n@decorators.suppress_all_exceptions()\\ndef _upload_telemetry_with_user_agreement(payload):\\n    p = multiprocessing.Process(target=telemetry_core.upload, args=(payload,))\\n    p.start()\\n\\n\\ndef _remove_symbols(s):\\n    if isinstance(s, str):\\n        for c in '$%^&|':\\n            s = s.replace(c, '_')\\n    return s\\n\""}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/telemetry_upload.py'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport urllib.request as HTTPClient\\nimport sys\\nimport json\\n\\nfrom applicationinsights import TelemetryClient\\nfrom applicationinsights.exceptions import enable\\nfrom applicationinsights.channel import SynchronousSender, SynchronousQueue, TelemetryChannel\\nfrom iotedgehubdev import decorators\\n\\n\\nclass LimitedRetrySender(SynchronousSender):\\n    def __init__(self):\\n        super(LimitedRetrySender, self).__init__()\\n\\n    def send(self, data_to_send):\\n        \"\"\" Override the default resend mechanism in SenderBase. Stop resend when it fails.\"\"\"\\n        request_payload = json.dumps([a.write() for a in data_to_send])\\n\\n        request = HTTPClient.Request(self._service_endpoint_uri, bytearray(request_payload, \\'utf-8\\'),\\n                                     {\\'Accept\\': \\'application/json\\', \\'Content-Type\\': \\'application/json; charset=utf-8\\'})\\n        try:\\n            HTTPClient.urlopen(request, timeout=10)\\n        except Exception:  # pylint: disable=broad-except\\n            pass\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef upload(data_to_save):\\n    try:\\n        data_to_save = json.loads(data_to_save)\\n    except Exception:\\n        pass\\n\\n    for instrumentation_key in data_to_save:\\n        client = TelemetryClient(instrumentation_key=instrumentation_key,\\n                                 telemetry_channel=TelemetryChannel(queue=SynchronousQueue(LimitedRetrySender())))\\n        enable(instrumentation_key)\\n        for record in data_to_save[instrumentation_key]:\\n            name = record[\\'name\\']\\n            raw_properties = record[\\'properties\\']\\n            properties = {}\\n            measurements = {}\\n            for k, v in raw_properties.items():\\n                if isinstance(v, str):\\n                    properties[k] = v\\n                else:\\n                    measurements[k] = v\\n            client.track_event(name, properties, measurements)\\n        client.flush()\\n\\n\\nif __name__ == \\'__main__\\':\\n    # If user doesn\\'t agree to upload telemetry, this scripts won\\'t be executed. The caller should control.\\n    upload(sys.argv[1])\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/iotedgehubdev/iotedgehubdev/utils.py'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport errno\\nimport os\\nimport shutil\\nimport socket\\nimport stat\\nimport subprocess\\n\\n\\nfrom base64 import b64decode, b64encode\\nfrom hashlib import sha256\\nfrom hmac import HMAC\\nfrom time import time\\nfrom urllib.parse import urlencode, quote_plus\\nfrom .constants import EdgeConstants as EC\\nfrom .decorators import suppress_all_exceptions\\nfrom .errors import EdgeFileAccessError\\n\\n\\nclass Utils(object):\\n    @staticmethod\\n    def parse_connection_strs(device_conn_str, hub_conn_str=None):\\n        data = Utils._parse_device_connection_str(device_conn_str)\\n        data[EC.DEVICE_ACCESS_KEY_KEY] = data.pop(EC.ACCESS_KEY_KEY)\\n        if hub_conn_str is not None:\\n            hub_data = Utils._parse_hub_connection_str(hub_conn_str, data[EC.HOSTNAME_KEY])\\n            data[EC.HUB_ACCESS_KEY_KEY] = hub_data[EC.ACCESS_KEY_KEY]\\n            data[EC.ACCESS_KEY_NAME] = hub_data[EC.ACCESS_KEY_NAME]\\n        return data\\n\\n    @staticmethod\\n    def _parse_device_connection_str(connection_string):\\n        data = Utils._split_connection_string(connection_string)\\n        if len(data) > 0:\\n            if EC.HOSTNAME_KEY not in data or EC.DEVICE_ID_KEY not in data or EC.ACCESS_KEY_KEY not in data:\\n                if EC.ACCESS_KEY_NAME in data:\\n                    raise KeyError(\\'Please make sure you are using a device connection string \\'\\n                                   \\'instead of an IoT Hub connection string\\')\\n                else:\\n                    raise KeyError(\\'Error parsing connection string. \\'\\n                                   \\'Please make sure you wrap the connection string with double quotes when supplying it via CLI\\')\\n            return data\\n        else:\\n            raise KeyError(\\'Error parsing connection string\\')\\n\\n    @staticmethod\\n    def _parse_hub_connection_str(hub_connection_string, host_name):\\n        hub_data = Utils._split_connection_string(hub_connection_string)\\n        if len(hub_data) > 0:\\n            if EC.HOSTNAME_KEY not in hub_data or EC.ACCESS_KEY_NAME not in hub_data or EC.ACCESS_KEY_KEY not in hub_data:\\n                if EC.DEVICE_ID_KEY in hub_data:\\n                    raise KeyError(\\'Please make sure you are using a IoT Hub connection string \\'\\n                                   \\'instead of an device connection string\\')\\n                else:\\n                    raise KeyError(\\'Error parsing connection string. \\'\\n                                   \\'Please make sure you wrap the connection string with double quotes when supplying it via CLI\\')\\n            elif hub_data[EC.HOSTNAME_KEY] != host_name:\\n                raise KeyError(\\'Please make sure the device belongs to the IoT Hub\\')\\n            return hub_data\\n        else:\\n            raise KeyError(\\'Error parsing IoT Hub connection string\\')\\n\\n    @staticmethod\\n    def _split_connection_string(connection_string):\\n        data = dict()\\n        if connection_string is not None:\\n            parts = connection_string.split(\\';\\')\\n            for part in parts:\\n                if \"=\" in part:\\n                    subparts = [s.strip() for s in part.split(\"=\", 1)]\\n                    data[subparts[0]] = subparts[1]\\n        return data\\n\\n    @staticmethod\\n    def get_hostname():\\n        try:\\n            return socket.getfqdn()\\n        except IOError as ex:\\n            raise ex\\n\\n    @staticmethod\\n    def check_if_file_exists(file_path):\\n        if file_path is None \\\\\\n           or os.path.exists(file_path) is False \\\\\\n           or os.path.isfile(file_path) is False:\\n            return False\\n        return True\\n\\n    @staticmethod\\n    def check_if_directory_exists(dir_path):\\n        if dir_path is None \\\\\\n           or os.path.exists(dir_path) is False \\\\\\n           or os.path.isdir(dir_path) is False:\\n            return False\\n        return True\\n\\n    @staticmethod\\n    def delete_dir(dir_path):\\n        try:\\n            if os.path.exists(dir_path):\\n                shutil.rmtree(dir_path, onerror=Utils._remove_readonly_callback)\\n        except OSError as ex:\\n            raise ex\\n\\n    @staticmethod\\n    def mkdir_if_needed(dir_path):\\n        try:\\n            os.makedirs(dir_path)\\n        except OSError as ex:\\n            if ex.errno != errno.EEXIST:\\n                raise ex\\n\\n    @staticmethod\\n    def delete_file(file_path, file_type_diagnostic):\\n        try:\\n            if os.path.exists(file_path):\\n                os.unlink(file_path)\\n        except OSError as ex:\\n            msg = \\'Error deleteing {0}: {1}. \\' \\\\\\n                  \\'Errno: {2}, Error: {3}\\'.format(file_type_diagnostic,\\n                                                  file_path, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, file_path)\\n\\n    @staticmethod\\n    def create_file(file_path, data, file_type_diagnostic, mode=0o644):\\n        try:\\n            fd = os.open(file_path, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, mode)\\n            with os.fdopen(fd, \\'w\\') as output_file:\\n                output_file.write(data)\\n        except OSError as ex:\\n            msg = \\'Error creating {0}: {1}. \\' \\\\\\n                  \\'Errno: {2}, Error: {3}\\'.format(file_type_diagnostic,\\n                                                  file_path, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, file_path)\\n\\n    @staticmethod\\n    def get_iot_hub_sas_token(uri, key, policy_name, expiry=3600):\\n        ttl = time() + expiry\\n        sign_key = \"%s\\\\n%d\" % ((quote_plus(uri)), int(ttl))\\n        signature = b64encode(\\n            HMAC(b64decode(key), sign_key.encode(\"utf-8\"), sha256).digest())\\n\\n        rawtoken = {\\n            \"sr\": uri,\\n            \"sig\": signature,\\n            \"se\": str(int(ttl))\\n        }\\n\\n        if policy_name is not None:\\n            rawtoken[\"skn\"] = policy_name\\n\\n        return \"SharedAccessSignature \" + urlencode(rawtoken)\\n\\n    @staticmethod\\n    def copy_files(src_path, dst_path):\\n        try:\\n            shutil.copy2(src_path, dst_path)\\n        except OSError as ex:\\n            raise ex\\n\\n    @staticmethod\\n    def _remove_readonly_callback(func, path, excinfo):\\n        del func, excinfo\\n        os.chmod(path, stat.S_IWRITE)\\n        os.unlink(path)\\n\\n    @staticmethod\\n    def exe_proc(params, shell=False, cwd=None, suppress_out=False):\\n        try:\\n            subprocess.check_call(params, shell=shell, cwd=cwd)\\n        except KeyboardInterrupt:\\n            raise\\n        except Exception as e:\\n            raise Exception(\"Error while executing command: {0}. {1}\".format(\\' \\'.join(params), str(e)))\\n\\n    @staticmethod\\n    @suppress_all_exceptions()\\n    def hash_connection_str_hostname(hostname):\\n        \"\"\"Hash connection string hostname to count distint IoT Hub number\"\"\"\\n        if not hostname:\\n            return (\"\", \"\")\\n\\n        # get hostname suffix (e.g., azure-devices.net) to distinguish national clouds\\n        if \".\" in hostname:\\n            hostname_suffix = hostname[hostname.index(\".\") + 1:]\\n        else:\\n            hostname_suffix = \"\"\\n\\n        return (Utils.get_sha256_hash(hostname), hostname_suffix)\\n\\n    @staticmethod\\n    def get_sha256_hash(val):\\n        hash_object = sha256(val.encode(\\'utf-8\\'))\\n\\n        return str(hash_object.hexdigest()).lower()\\n\\n    @staticmethod\\n    def get_device_ca_file_paths(root_dir, cert_id):\\n        result = {}\\n        result[EC.CERT_SUFFIX] = os.path.join(root_dir, cert_id + EC.CERT_SUFFIX)\\n        result[EC.KEY_SUFFIX] = os.path.join(root_dir, cert_id + EC.KEY_SUFFIX)\\n        result[EC.CHAIN_CERT_SUFFIX] = os.path.join(root_dir, cert_id + EC.CHAIN_CERT_SUFFIX)\\n        return result\\n'"}]}, "source_encoding": {"line": 184, "args": [{"func_args": {"source": "b\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport pkg_resources\\n\\npkg_resources.declare_namespace(__name__)\\n\\n__author__ = 'Microsoft Corporation'\\n__version__ = '0.14.10'\\n__AIkey__ = '95b20d64-f54f-4de3-8ad5-165a75a6c6fe'\\n__production__ = 'iotedgehubdev'\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport os\\nfrom OpenSSL import crypto\\nfrom shutil import copy2\\nfrom datetime import datetime\\nfrom .errors import EdgeFileAccessError, EdgeInvalidArgument, EdgeValueError\\nfrom .constants import EdgeConstants as EC\\nfrom .utils import Utils\\n\\n\\nclass EdgeCertUtil(object):\\n\\n    TYPE_RSA = 0\\n    MIN_VALIDITY_DAYS = 1\\n    MAX_VALIDITY_DAYS = 1095  # 3 years\\n    MIN_PASSPHRASE_LENGTH = 4\\n    MAX_PASSPHRASE_LENGTH = 1023\\n    CA_KEY_LEN = 4096\\n    CA_INT_KEY_LEN = 4096\\n    SERVER_KEY_LEN = 2048\\n    MIN_COMMON_NAME_LEN = 1\\n    MAX_COMMON_NAME_LEN = 64\\n    DIGEST = \\'sha256\\'\\n    _type_dict = {TYPE_RSA: crypto.TYPE_RSA}\\n    _subject_validation_dict = {\\n        EC.SUBJECT_COUNTRY_KEY: {\\'MIN\\': 2, \\'MAX\\': 2},\\n        EC.SUBJECT_STATE_KEY: {\\'MIN\\': 0, \\'MAX\\': 128},\\n        EC.SUBJECT_LOCALITY_KEY: {\\'MIN\\': 0, \\'MAX\\': 128},\\n        EC.SUBJECT_ORGANIZATION_KEY: {\\'MIN\\': 0, \\'MAX\\': 64},\\n        EC.SUBJECT_ORGANIZATION_UNIT_KEY: {\\'MIN\\': 0, \\'MAX\\': 64},\\n        EC.SUBJECT_COMMON_NAME_KEY: {\\'MIN\\': MIN_COMMON_NAME_LEN,\\n                                     \\'MAX\\': MAX_COMMON_NAME_LEN}\\n    }\\n\\n    def __init__(self, serial_num=1000):\\n        self._cert_chain = {}\\n        self._serial_number = serial_num\\n\\n    def create_root_ca_cert(self, id_str, **kwargs):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Duplicate root CA certificate ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        validity_days_from_now = self._get_kwargs_validity(**kwargs)\\n        subj_dict = None\\n        if \\'subject_dict\\' in kwargs:\\n            subj_dict = kwargs[\\'subject_dict\\']\\n            if self.is_valid_certificate_subject(subj_dict) is False:\\n                msg = \\'Certificate subject dictionary is invalid.\\'\\n                raise EdgeValueError(msg)\\n        else:\\n            msg = \\'Certificate subject dictionary is required\\'\\n            raise EdgeValueError(msg)\\n        passphrase = self._get_kwargs_passphrase(**kwargs)\\n\\n        key_obj = self._create_key_pair(EdgeCertUtil.TYPE_RSA,\\n                                        EdgeCertUtil.CA_KEY_LEN)\\n        csr_obj = self._create_csr(key_obj,\\n                                   C=subj_dict[EC.SUBJECT_COUNTRY_KEY],\\n                                   ST=subj_dict[EC.SUBJECT_STATE_KEY],\\n                                   L=subj_dict[EC.SUBJECT_LOCALITY_KEY],\\n                                   O=subj_dict[EC.SUBJECT_ORGANIZATION_KEY],\\n                                   OU=subj_dict[EC.SUBJECT_ORGANIZATION_KEY],\\n                                   CN=subj_dict[EC.SUBJECT_COMMON_NAME_KEY])\\n\\n        validity_secs_from_now = validity_days_from_now * 24 * 60 * 60\\n        cert_obj = self._create_ca_cert(csr_obj,\\n                                        csr_obj,\\n                                        key_obj,\\n                                        (0, validity_secs_from_now),\\n                                        False)\\n        self._serial_number += 1\\n        cert_dict = {}\\n        cert_dict[\\'key_pair\\'] = key_obj\\n        cert_dict[\\'csr\\'] = csr_obj\\n        cert_dict[\\'cert\\'] = cert_obj\\n        cert_dict[\\'issuer_id\\'] = id_str\\n        cert_dict[\\'passphrase\\'] = passphrase\\n        self._cert_chain[id_str] = cert_dict\\n\\n    def create_intermediate_ca_cert(self, id_str, issuer_id_str, **kwargs):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Duplicate intermediate CA certificate ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        if issuer_id_str not in list(self._cert_chain.keys()):\\n            msg = \\'Invalid issuer certificate ID: {0}\\'.format(issuer_id_str)\\n            raise EdgeValueError(msg)\\n\\n        validity_days_from_now = self._get_kwargs_validity(**kwargs)\\n        passphrase = self._get_kwargs_passphrase(**kwargs)\\n\\n        min_length = self._subject_validation_dict[EC.SUBJECT_COMMON_NAME_KEY][\\'MIN\\']\\n        max_length = self._subject_validation_dict[EC.SUBJECT_COMMON_NAME_KEY][\\'MAX\\']\\n        common_name = self._get_kwargs_string(\\'common_name\\', min_length, max_length, **kwargs)\\n        if common_name is None:\\n            msg = \\'Invalid common name: {0}\\'.format(common_name)\\n            raise EdgeValueError(msg)\\n\\n        set_terminal_ca = True\\n        if \\'set_terminal_ca\\' in kwargs:\\n            set_terminal_ca = kwargs[\\'set_terminal_ca\\']\\n\\n        try:\\n            issuer_cert_dict = self._cert_chain[issuer_id_str]\\n            issuer_cert = issuer_cert_dict[\\'cert\\']\\n\\n            not_after_ts = issuer_cert.get_notAfter()\\n            valid_days = self._get_maximum_validity_days(not_after_ts,\\n                                                         validity_days_from_now)\\n\\n            issuer_key = issuer_cert_dict[\\'key_pair\\']\\n            key_obj = self._create_key_pair(EdgeCertUtil.TYPE_RSA, EdgeCertUtil.CA_KEY_LEN)\\n            csr_obj = self._create_csr(key_obj,\\n                                       C=issuer_cert.get_subject().countryName,\\n                                       ST=issuer_cert.get_subject().stateOrProvinceName,\\n                                       L=issuer_cert.get_subject().localityName,\\n                                       O=issuer_cert.get_subject().organizationName,\\n                                       OU=issuer_cert.get_subject().organizationalUnitName,\\n                                       CN=common_name)\\n\\n            validity_secs_from_now = valid_days * 24 * 60 * 60\\n            cert_obj = self._create_ca_cert(csr_obj,\\n                                            issuer_cert,\\n                                            issuer_key,\\n                                            (0, validity_secs_from_now),\\n                                            set_terminal_ca)\\n            self._serial_number += 1\\n            cert_dict = {}\\n            cert_dict[\\'key_pair\\'] = key_obj\\n            cert_dict[\\'csr\\'] = csr_obj\\n            cert_dict[\\'cert\\'] = cert_obj\\n            cert_dict[\\'issuer_id\\'] = issuer_id_str\\n            cert_dict[\\'passphrase\\'] = passphrase\\n            self._cert_chain[id_str] = cert_dict\\n        except EdgeValueError:\\n            msg = \\'Could not create intermediate certificate for {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n    def create_server_cert(self, id_str, issuer_id_str, **kwargs):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Duplicate intermediate CA certificate ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        if issuer_id_str not in list(self._cert_chain.keys()):\\n            msg = \\'Invalid issuer certificate ID: {0}\\'.format(issuer_id_str)\\n            raise EdgeValueError(msg)\\n\\n        validity_days_from_now = self._get_kwargs_validity(**kwargs)\\n\\n        passphrase = self._get_kwargs_passphrase(**kwargs)\\n\\n        max_length = self._subject_validation_dict[EC.SUBJECT_COMMON_NAME_KEY][\\'MAX\\']\\n        hostname = kwargs.get(\\'hostname\\', None)\\n        if hostname is None:\\n            msg = \\'Invalid hostname: {0}\\'.format(hostname)\\n            raise EdgeValueError(msg)\\n        # CN length is limited to 64. Since the certificate is used internally so just cut to 64.\\n        common_name = hostname if len(hostname) <= max_length else hostname[:max_length]\\n\\n        try:\\n            issuer_cert_dict = self._cert_chain[issuer_id_str]\\n            issuer_cert = issuer_cert_dict[\\'cert\\']\\n            issuer_key = issuer_cert_dict[\\'key_pair\\']\\n            key_obj = self._create_key_pair(EdgeCertUtil.TYPE_RSA, EdgeCertUtil.SERVER_KEY_LEN)\\n            csr_obj = self._create_csr(key_obj,\\n                                       C=issuer_cert.get_subject().countryName,\\n                                       ST=issuer_cert.get_subject().stateOrProvinceName,\\n                                       L=issuer_cert.get_subject().localityName,\\n                                       O=issuer_cert.get_subject().organizationName,\\n                                       OU=issuer_cert.get_subject().organizationalUnitName,\\n                                       CN=common_name)\\n            not_after_ts = issuer_cert.get_notAfter()\\n            valid_days = self._get_maximum_validity_days(not_after_ts,\\n                                                         validity_days_from_now)\\n            validity_secs_from_now = valid_days * 24 * 60 * 60\\n            cert_obj = self._create_server_cert(csr_obj,\\n                                                issuer_cert,\\n                                                issuer_key,\\n                                                (0, validity_secs_from_now),\\n                                                hostname)\\n            self._serial_number += 1\\n            cert_dict = {}\\n            cert_dict[\\'key_pair\\'] = key_obj\\n            cert_dict[\\'csr\\'] = csr_obj\\n            cert_dict[\\'cert\\'] = cert_obj\\n            cert_dict[\\'issuer_id\\'] = issuer_id_str\\n            cert_dict[\\'passphrase\\'] = passphrase\\n            self._cert_chain[id_str] = cert_dict\\n        except EdgeValueError:\\n            msg = \\'Could not create server certificate for {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n    def export_pfx_cert(self, id_str, dir_path):\\n        if id_str not in self._cert_chain:\\n            msg = \\'Invalid cert ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        try:\\n            cert_dict = self._cert_chain[id_str]\\n            cert_obj = cert_dict[\\'cert\\']\\n            key_obj = cert_dict[\\'key_pair\\']\\n            pfx = crypto.PKCS12()\\n            pfx.set_privatekey(key_obj)\\n            pfx.set_certificate(cert_obj)\\n            pfx_data = pfx.export()\\n            prefix = id_str\\n            path = os.path.realpath(dir_path)\\n            path = os.path.join(path, prefix)\\n            cert_dir = os.path.join(path, \\'cert\\')\\n            pfx_output_file_name = os.path.join(cert_dir, prefix + EC.PFX_SUFFIX)\\n            with open(pfx_output_file_name, \\'wb\\') as pfx_file:\\n                pfx_file.write(pfx_data)\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting PFX cert ID: {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(id_str, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, pfx_output_file_name)\\n\\n    @staticmethod\\n    def get_cert_file_path(id_str, dir_path):\\n        return os.path.join(dir_path, id_str, \\'cert\\', id_str + EC.CERT_SUFFIX)\\n\\n    @staticmethod\\n    def get_pfx_file_path(id_str, dir_path):\\n        return os.path.join(dir_path, id_str, \\'cert\\', id_str + EC.PFX_SUFFIX)\\n\\n    def load_cert_from_file(self, id_str, cert_path, key_path, key_passphrase):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Could not load cert from file. Certificate already in chain. ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n        cert_dict = {}\\n        # Load cert\\n        try:\\n            with open(cert_path, \\'r\\') as cert_file:\\n                cert_content = cert_file.read()\\n                cert_dict[\\'cert\\'] = crypto.load_certificate(crypto.FILETYPE_PEM, cert_content)\\n        except Exception as ex:\\n            raise EdgeInvalidArgument(\\'Failed to load cert from %s. Error: %s\\' % (cert_path, ex), ex)\\n        # Load key\\n        try:\\n            with open(key_path, \\'r\\') as key_file:\\n                key_content = key_file.read()\\n                cert_dict[\\'key_pair\\'] = crypto.load_privatekey(crypto.FILETYPE_PEM, key_content, key_passphrase)\\n        except Exception as ex:\\n            raise EdgeInvalidArgument(\\n                \\'Failed to load private key from %s. Please check your passphase first. Error: %s\\' % (key_path, ex), ex)\\n        self._cert_chain[id_str] = cert_dict\\n\\n    def export_simulator_cert_artifacts_to_dir(self, id_str, dir_path):\\n        if Utils.check_if_directory_exists(dir_path) is False:\\n            msg = \\'Invalid export directory {0}\\'.format(dir_path)\\n            raise EdgeValueError(msg)\\n\\n        cert_dict = self._get_cert_dict(id_str)\\n        prefix = id_str\\n        try:\\n            path = os.path.realpath(dir_path)\\n            path = os.path.join(path, prefix)\\n            Utils.delete_dir(path)\\n            Utils.mkdir_if_needed(path)\\n            priv_dir = os.path.join(path, \\'private\\')\\n            Utils.mkdir_if_needed(priv_dir)\\n            os.chmod(priv_dir, 0o700)\\n            cert_dir = os.path.join(path, \\'cert\\')\\n            Utils.mkdir_if_needed(cert_dir)\\n\\n            # export the private key\\n            priv_key_file_name = prefix + \\'.key.pem\\'\\n            priv_key_file = os.path.join(priv_dir, priv_key_file_name)\\n            self._dump_cert_key(cert_dict, priv_key_file)\\n\\n            # export the cert\\n            cert_file_name = prefix + EC.CERT_SUFFIX\\n            cert_file = os.path.join(cert_dir, cert_file_name)\\n            current_cert_file_path = cert_file\\n            self._dump_cert_content(cert_dict, cert_file)\\n\\n            # export any chain certs\\n            if \\'ca_chain\\' in list(cert_dict.keys()):\\n                src_chain_cert_file = cert_dict[\\'ca_chain\\']\\n                cert_file_name = prefix + \\'-chain.cert.pem\\'\\n                cert_file = os.path.join(cert_dir, cert_file_name)\\n                copy2(src_chain_cert_file, cert_file)\\n\\n            # check if this is the root cert in the chain, i.e. issuer is itself\\n            if cert_dict[\\'issuer_id\\'] == id_str:\\n                cert_file_name = prefix + \\'-root.cert.pem\\'\\n                cert_file = os.path.join(cert_dir, cert_file_name)\\n                if \\'ca_root\\' in list(cert_dict.keys()):\\n                    src_root_cert_file = cert_dict[\\'ca_root\\']\\n                else:\\n                    src_root_cert_file = current_cert_file_path\\n                copy2(src_root_cert_file, cert_file)\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting certs for ID: {0}.\\\\n\\' \\\\\\n                  \\' Error seen when copying/exporting file {1}.\\' \\\\\\n                  \\' Errno: {2} Error: {3}\\'.format(id_str, ex.filename, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, path)\\n\\n    def export_device_ca_cert_artifacts_to_dir(self, id_str, dir_path):\\n        output_files = Utils.get_device_ca_file_paths(dir_path, id_str)\\n        cert_path = output_files[EC.CERT_SUFFIX]\\n        key_path = output_files[EC.KEY_SUFFIX]\\n        cert_dict = self._get_cert_dict(id_str)\\n        self._dump_cert_content(cert_dict, cert_path)\\n        self._dump_cert_key(cert_dict, key_path)\\n\\n    def chain_simulator_ca_certs(self, output_prefix, prefixes, certs_dir):\\n        try:\\n            output_dir = os.path.join(certs_dir, output_prefix)\\n            Utils.delete_dir(output_dir)\\n            Utils.mkdir_if_needed(output_dir)\\n            output_dir = os.path.join(output_dir, \\'cert\\')\\n            Utils.mkdir_if_needed(output_dir)\\n            output_file_name = os.path.join(output_dir, output_prefix + EC.CERT_SUFFIX)\\n            self._chain_ca_certs(output_file_name, prefixes, certs_dir, self._simulator_cert_file_path_gen)\\n        except IOError as ex:\\n            msg = \\'IO Error when creating chain cert: {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(output_file_name, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_file_name)\\n\\n    def chain_device_ca_certs(self, output_prefix, id_strs, certs_dir):\\n        cert_files = Utils.get_device_ca_file_paths(certs_dir, output_prefix)\\n        chain_path = cert_files[EC.CHAIN_CERT_SUFFIX]\\n        self._chain_ca_certs(chain_path, id_strs, certs_dir, self._device_ca_cert_file_path_gen)\\n\\n    def is_valid_certificate_subject(self, subject_dict):\\n        result = True\\n        for key in list(EdgeCertUtil._subject_validation_dict.keys()):\\n            try:\\n                field = subject_dict[key]\\n                if field is not None:\\n                    length_field = len(field)\\n                    min_len = EdgeCertUtil._subject_validation_dict[key][\\'MIN\\']\\n                    max_len = EdgeCertUtil._subject_validation_dict[key][\\'MAX\\']\\n                    if length_field < min_len or length_field > max_len:\\n                        result = False\\n                else:\\n                    result = False\\n            except KeyError:\\n                result = False\\n\\n            if result is False:\\n                break\\n        return result\\n\\n    def _create_csr(self, key_pair, **kwargs):\\n        csr = crypto.X509Req()\\n        subj = csr.get_subject()\\n        for key, value in list(kwargs.items()):\\n            if value:\\n                setattr(subj, key, value)\\n        csr.set_pubkey(key_pair)\\n        csr.sign(key_pair, EdgeCertUtil.DIGEST)\\n        return csr\\n\\n    def _create_cert_common(self,\\n                            csr,\\n                            issuer_cert,\\n                            validity_period):\\n        not_before, not_after = validity_period\\n        cert = crypto.X509()\\n        cert.set_serial_number(self._serial_number)\\n        cert.gmtime_adj_notBefore(not_before)\\n        cert.gmtime_adj_notAfter(not_after)\\n        cert.set_issuer(issuer_cert.get_subject())\\n        cert.set_subject(csr.get_subject())\\n        cert.set_pubkey(csr.get_pubkey())\\n        cert.set_version(2)\\n        return cert\\n\\n    def _create_ca_cert(self,\\n                        csr,\\n                        issuer_cert,\\n                        issuer_key_pair,\\n                        validity_period,\\n                        path_len_zero):\\n        cert = self._create_cert_common(csr, issuer_cert, validity_period)\\n        val = b\\'CA:TRUE\\'\\n        if path_len_zero:\\n            val += b\\', pathlen:0\\'\\n        extensions = []\\n        extensions.append(crypto.X509Extension(b\\'basicConstraints\\',\\n                                               critical=True, value=val))\\n        extensions.append(crypto.X509Extension(b\\'subjectKeyIdentifier\\',\\n                                               False,\\n                                               b\\'hash\\',\\n                                               subject=cert))\\n        extensions.append(crypto.X509Extension(b\\'keyUsage\\',\\n                                               critical=True,\\n                                               value=b\\'digitalSignature, cRLSign, keyCertSign\\'))\\n        # authorityKeyIdentifier requires subjectKeyIdentifier in issuer cert, add it first\\n        cert.add_extensions(extensions)\\n\\n        del extensions[:]\\n        extensions.append(crypto.X509Extension(b\\'authorityKeyIdentifier\\',\\n                                               False,\\n                                               b\\'keyid:always,issuer:always\\',\\n                                               issuer=issuer_cert if isinstance(issuer_cert, crypto.X509) else cert))\\n        cert.add_extensions(extensions)\\n        cert.sign(issuer_key_pair, EdgeCertUtil.DIGEST)\\n        return cert\\n\\n    def _create_server_cert(self,\\n                            csr,\\n                            issuer_cert,\\n                            issuer_key_pair,\\n                            validity_period,\\n                            hostname):\\n        cert = self._create_cert_common(csr,\\n                                        issuer_cert,\\n                                        validity_period)\\n\\n        extensions = []\\n        extensions.append(crypto.X509Extension(b\\'basicConstraints\\',\\n                                               critical=False,\\n                                               value=b\\'CA:FALSE\\'))\\n        altDns = \\',\\'.join([\\'DNS:localhost\\', \\'DNS:{0}\\'.format(hostname)]).encode(\\'utf-8\\')\\n        extensions.append(crypto.X509Extension(b\\'subjectAltName\\',\\n                                               critical=False,\\n                                               value=altDns))\\n        cert.add_extensions(extensions)\\n        cert.sign(issuer_key_pair, EdgeCertUtil.DIGEST)\\n        return cert\\n\\n    def _create_key_pair(self, private_key_type, key_bit_len):\\n        key_pair = crypto.PKey()\\n        key_pair.generate_key(EdgeCertUtil._type_dict[private_key_type], key_bit_len)\\n        return key_pair\\n\\n    def _get_maximum_validity_days(self, not_after_ts_asn1, validity_days_from_now):\\n        result = 0\\n        try:\\n            expiration_date = datetime.strptime(not_after_ts_asn1.decode(\\'utf-8\\'), \"%Y%m%d%H%M%SZ\")\\n            expires_in = expiration_date - datetime.now()\\n            if expires_in.days > 0:\\n                result = min(expires_in.days, validity_days_from_now)\\n            return result\\n        except Exception:\\n            msg = \\'Certificate date format incompatible {0}\\'.format(not_after_ts_asn1)\\n            raise EdgeValueError(msg)\\n\\n    def _get_kwargs_validity(self, **kwargs):\\n        validity_days_from_now = 365\\n        min_validity = EdgeCertUtil.MIN_VALIDITY_DAYS\\n        max_validity = EdgeCertUtil.MAX_VALIDITY_DAYS\\n        kwarg_key = \\'validity_days_from_now\\'\\n        if kwarg_key in kwargs:\\n            validity_days_from_now = kwargs[kwarg_key]\\n\\n        if validity_days_from_now < min_validity or validity_days_from_now > max_validity:\\n            msg = \\'Certificate validity days needs to be greater than or equal to {0} \\' \\\\\\n                  \\'and less than {1} days. Value provided: {2}\\'. format(min_validity,\\n                                                                        max_validity,\\n                                                                        validity_days_from_now)\\n            raise EdgeValueError(msg)\\n\\n        return validity_days_from_now\\n\\n    def _validate_string_length(self, test_string, min_length, max_length):\\n        length = len(test_string)\\n        if min_length > length or length > max_length:\\n            return False\\n        return True\\n\\n    def _get_kwargs_passphrase(self, **kwargs):\\n        passphrase = None\\n        min_length = EdgeCertUtil.MIN_PASSPHRASE_LENGTH\\n        max_length = EdgeCertUtil.MAX_PASSPHRASE_LENGTH\\n        kwarg_key = \\'passphrase\\'\\n        if kwarg_key in kwargs:\\n            passphrase = kwargs[kwarg_key]\\n        if passphrase is not None:\\n            if self._validate_string_length(passphrase, min_length, max_length) is False:\\n                msg = \\'Private key passphrase needs to greater than or equal to {0} and less \\' \\\\\\n                      \\'than {1} characters.\\'.format(min_length, max_length)\\n                raise EdgeValueError(msg)\\n        return passphrase\\n\\n    def _get_kwargs_string(self, kwarg_key, min_length, max_length, default_str=None, **kwargs):\\n        result_str = default_str\\n        if kwarg_key in kwargs:\\n            result_str = kwargs[kwarg_key]\\n        if result_str is not None:\\n            if self._validate_string_length(result_str, min_length, max_length) is False:\\n                msg = \\'KWarg[{0}]:{1} string length needs to greater than or equal to {2} and \\' \\\\\\n                      \\'less than {3} characters.\\'.format(kwarg_key, result_str,\\n                                                         min_length, max_length)\\n                raise EdgeValueError(msg)\\n        return result_str\\n\\n    def _dump_cert_content(self, cert_dict, output_path):\\n        Utils.mkdir_if_needed(os.path.dirname(output_path))\\n        cert_obj = cert_dict[\\'cert\\']\\n        try:\\n            with open(output_path, \\'w\\') as output_file:\\n                output_file.write(crypto.dump_certificate(crypto.FILETYPE_PEM,\\n                                                          cert_obj).decode(\\'utf-8\\'))\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting certs.\\\\n\\' \\\\\\n                  \\' Error seen when exporting file {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(ex.filename, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_path)\\n\\n    def _dump_cert_key(self, cert_dict, output_path):\\n        Utils.mkdir_if_needed(os.path.dirname(output_path))\\n        try:\\n            if \\'key_file\\' in cert_dict:\\n                key_file_path = cert_dict[\\'key_file\\']\\n                copy2(key_file_path, output_path)\\n            else:\\n                key_obj = cert_dict[\\'key_pair\\']\\n                key_passphrase = cert_dict[\\'passphrase\\']\\n                passphrase = None\\n                if key_passphrase and key_passphrase != \\'\\':\\n                    passphrase = key_passphrase.encode(\\'utf-8\\')\\n                cipher = None\\n                if passphrase:\\n                    cipher = \\'aes256\\'\\n                with open(output_path, \\'w\\') as output_file:\\n                    output_file.write(crypto.dump_privatekey(crypto.FILETYPE_PEM,\\n                                                             key_obj,\\n                                                             cipher=cipher,\\n                                                             passphrase=passphrase).decode(\\'utf-8\\'))\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting certs.\\\\n\\' \\\\\\n                  \\' Error seen when exporting file {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(ex.filename, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_path)\\n\\n    def _get_cert_dict(self, id_str):\\n        if id_str not in list(self._cert_chain.keys()):\\n            msg = \\'Certificate not in chain. ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n        return self._cert_chain[id_str]\\n\\n    def _chain_ca_certs(self, output_path, id_strs, certs_dir, cert_file_path_gen):\\n        file_names = []\\n        for id_str in id_strs:\\n            cert_dict = self._get_cert_dict(id_str)\\n            if \\'ca_chain\\' in list(cert_dict.keys()):\\n                # this cert contains an existing certificate chain\\n                # pick the chain instead of the actual cert\\n                cert_file_name = id_str + \\'-chain.cert.pem\\'\\n            else:\\n                cert_file_name = id_str + EC.CERT_SUFFIX\\n            cert_file = cert_file_path_gen(id_str, cert_file_name, certs_dir)\\n            path = os.path.realpath(cert_file)\\n            file_names.append(path)\\n        try:\\n            with open(output_path, \\'wb\\') as output_file:\\n                for file_name in file_names:\\n                    with open(file_name, \\'rb\\') as input_file:\\n                        output_file.write(input_file.read())\\n        except IOError as ex:\\n            msg = \\'IO Error when creating chain cert: {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(output_path, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_path)\\n\\n    def _simulator_cert_file_path_gen(self, id_str, cert_file_name, certs_dir):\\n        return os.path.join(certs_dir, id_str, \\'cert\\', cert_file_name)\\n\\n    def _device_ca_cert_file_path_gen(self, id_str, cert_file_name, certs_dir):\\n        return os.path.join(certs_dir, cert_file_name)\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport json\\nimport os\\nimport sys\\nimport re\\nfrom functools import wraps\\n\\nimport click\\n\\nfrom . import configs, decorators, telemetry\\nfrom .constants import EdgeConstants\\nfrom .edgecert import EdgeCert\\nfrom .edgemanager import EdgeManager\\nfrom .hostplatform import HostPlatform\\nfrom .output import Output\\nfrom .utils import Utils\\nfrom .errors import EdgeError, InvalidConfigError\\n\\nCONTEXT_SETTINGS = dict(help_option_names=[\\'-h\\', \\'--help\\'], max_content_width=120)\\noutput = Output()\\n\\nCONN_STR = \\'connectionString\\'\\nCERT_PATH = \\'certPath\\'\\nGATEWAY_HOST = \\'gatewayhost\\'\\nDOCKER_HOST = \\'DOCKER_HOST\\'\\nHUB_CONN_STR = \\'iothubConnectionString\\'\\n\\n# a set of parameters whose value should be logged as given\\nPARAMS_WITH_VALUES = {\\'edge_runtime_version\\'}\\n\\n@decorators.suppress_all_exceptions()\\ndef _parse_params(*args, **kwargs):\\n    params = []\\n    for key, value in kwargs.items():\\n        if (value is None) or (key in PARAMS_WITH_VALUES):\\n            params.append(\\'{0}={1}\\'.format(key, value))\\n        else:\\n            params.append(\\'{0}!=None\\'.format(key))\\n    return params\\n\\n\\ndef _send_failed_telemetry(e):\\n    output.error(str(e))\\n    telemetry.fail(str(e), \\'Command failed\\')\\n    telemetry.flush()\\n\\n\\ndef _with_telemetry(func):\\n    @wraps(func)\\n    def _wrapper(*args, **kwargs):\\n        configs.check_firsttime()\\n        params = _parse_params(*args, **kwargs)\\n        telemetry.start(func.__name__, params)\\n        try:\\n            value = func(*args, **kwargs)\\n            telemetry.success()\\n            telemetry.flush()\\n            return value\\n        except InvalidConfigError as e:\\n            _send_failed_telemetry(e)\\n            sys.exit(2)\\n        except Exception as e:\\n            _send_failed_telemetry(e)\\n            sys.exit(1)\\n\\n    return _wrapper\\n\\n\\ndef _parse_config_json():\\n    try:\\n        config_file = HostPlatform.get_config_file_path()\\n\\n        if not Utils.check_if_file_exists(config_file):\\n            raise ValueError(\\'Cannot find config file. Please run `{0}` first.\\'.format(_get_setup_command()))\\n\\n        with open(config_file) as f:\\n            try:\\n                config_json = json.load(f)\\n\\n                connection_str = config_json[CONN_STR]\\n                cert_path = config_json[CERT_PATH]\\n                gatewayhost = config_json[GATEWAY_HOST]\\n                hub_conn_str = config_json.get(HUB_CONN_STR)\\n                return EdgeManager(connection_str, gatewayhost, cert_path, hub_conn_str)\\n\\n            except (ValueError, KeyError):\\n                raise ValueError(\\'Invalid config file. Please run `{0}` again.\\'.format(_get_setup_command()))\\n    except Exception as e:\\n        raise InvalidConfigError(str(e))\\n\\n\\ndef _get_setup_command():\\n    return \\'{0}iotedgehubdev setup -c \"<edge-device-connection-string>\"\\'.format(\\'\\' if os.name == \\'nt\\' else \\'sudo \\')\\n\\n\\n@click.group(context_settings=CONTEXT_SETTINGS, invoke_without_command=True)\\n@click.version_option()\\ndef main():\\n    ctx = click.get_current_context()\\n    if ctx.invoked_subcommand is None:\\n        click.echo(ctx.get_help())\\n        sys.exit(0)\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\\'Setup the IoT Edge Simulator. This must be done before starting.\\')\\n@click.option(\\'--connection-string\\',\\n              \\'-c\\',\\n              required=True,\\n              help=\\'Set Azure IoT Edge device connection string. Note: Use double quotes when supplying this input.\\')\\n@click.option(\\'--gateway-host\\',\\n              \\'-g\\',\\n              required=False,\\n              default=Utils.get_hostname(),\\n              show_default=True,\\n              help=\\'GatewayHostName value for the module to connect.\\')\\n@click.option(\\'--iothub-connection-string\\',\\n              \\'-i\\',\\n              required=False,\\n              help=\\'Set Azure IoT Hub connection string. Note: Use double quotes when supplying this input.\\')\\n@_with_telemetry\\ndef setup(connection_string, gateway_host, iothub_connection_string):\\n    try:\\n        gateway_host = gateway_host.lower()\\n        certDir = HostPlatform.get_default_cert_path()\\n        Utils.parse_connection_strs(connection_string, iothub_connection_string)\\n        if iothub_connection_string is None:\\n            configDict = {\\n                CONN_STR: connection_string,\\n                CERT_PATH: certDir,\\n                GATEWAY_HOST: gateway_host\\n            }\\n        else:\\n            configDict = {\\n                CONN_STR: connection_string,\\n                CERT_PATH: certDir,\\n                GATEWAY_HOST: gateway_host,\\n                HUB_CONN_STR: iothub_connection_string\\n            }\\n\\n        fileType = \\'edgehub.config\\'\\n        Utils.mkdir_if_needed(certDir)\\n        edgeCert = EdgeCert(certDir, gateway_host)\\n        edgeCert.generate_self_signed_certs()\\n        configFile = HostPlatform.get_config_file_path()\\n        Utils.delete_file(configFile, fileType)\\n        Utils.mkdir_if_needed(HostPlatform.get_config_path())\\n        configJson = json.dumps(configDict, indent=2, sort_keys=True)\\n        Utils.create_file(configFile, configJson, fileType)\\n\\n        dataDir = HostPlatform.get_share_data_path()\\n        Utils.mkdir_if_needed(dataDir)\\n        os.chmod(dataDir, 0o755)\\n\\n        with open(EdgeManager.COMPOSE_FILE, \\'w\\') as f:\\n            f.write(\\'version: \\\\\\'3.6\\\\\\'\\')\\n        os.chmod(EdgeManager.COMPOSE_FILE, 0o777)\\n        output.info(\\'Setup IoT Edge Simulator successfully.\\')\\n    except Exception as e:\\n        raise e\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               # short_help hack to prevent Click truncating help text (https://github.com/pallets/click/issues/486)\\n               short_help=\\'Get the module credentials such as connection string and certificate file path.\\',\\n               help=\\'Get the module credentials such as connection string and certificate file path.\\')\\n@click.option(\\'--modules\\',\\n              \\'-m\\',\\n              required=False,\\n              default=\\'target\\',\\n              show_default=True,\\n              help=\\'Specify the vertical-bar-separated (\"|\") module names to get credentials for, e.g., \"module1|module2\". \\'\\n                   \\'Note: Use double quotes when supplying this input.\\')\\n@click.option(\\'--local\\',\\n              \\'-l\\',\\n              required=False,\\n              is_flag=True,\\n              default=False,\\n              show_default=True,\\n              help=\\'Set `localhost` to `GatewayHostName` for module to run on host natively.\\')\\n@click.option(\\'--output-file\\',\\n              \\'-o\\',\\n              required=False,\\n              show_default=True,\\n              help=\\'Specify the output file to save the connection string. If the file exists, the content will be overwritten.\\')\\n@_with_telemetry\\ndef modulecred(modules, local, output_file):\\n    edge_manager = _parse_config_json()\\n\\n    if edge_manager:\\n        modules = [module.strip() for module in modules.strip().split(\\'|\\')]\\n        credential = edge_manager.outputModuleCred(modules, local, output_file)\\n        output.info(credential[0])\\n        output.info(credential[1])\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Start the IoT Edge Simulator.\")\\n@click.option(\\'--inputs\\',\\n              \\'-i\\',\\n              required=False,\\n              help=\\'Start IoT Edge Simulator in single module mode \\'\\n                   \\'using the specified comma-separated inputs of the target module, e.g., `input1,input2`.\\')\\n@click.option(\\'--port\\',\\n              \\'-p\\',\\n              required=False,\\n              default=53000,\\n              show_default=True,\\n              help=\\'Port of the service for sending message.\\')\\n@click.option(\\'--deployment\\',\\n              \\'-d\\',\\n              required=False,\\n              help=\\'Start IoT Edge Simulator in solution mode using the specified deployment manifest.\\')\\n@click.option(\\'--verbose\\',\\n              \\'-v\\',\\n              required=False,\\n              is_flag=True,\\n              default=False,\\n              show_default=True,\\n              help=\\'Show the solution container logs.\\')\\n@click.option(\\'--host\\',\\n              \\'-H\\',\\n              required=False,\\n              help=\\'Docker daemon socket to connect to.\\')\\n@click.option(\\'--environment\\',\\n              \\'-e\\',\\n              required=False,\\n              multiple=True,\\n              help=\\'Environment variables for single module mode, e.g., `-e \"Env1=Value1\" -e \"Env2=Value2\"`.\\')\\n@click.option(\\'--edge-runtime-version\\',\\n              \\'-er\\',\\n              required=False,\\n              multiple=False,\\n              default=\\'1.2\\',\\n              show_default=True,\\n              help=\\'EdgeHub image version. Currently supported tags 1.0x, 1.1x, or 1.2x\\')\\n@_with_telemetry\\ndef start(inputs, port, deployment, verbose, host, environment, edge_runtime_version):\\n    edge_manager = _parse_config_json()\\n\\n    if edge_manager:\\n        if host is not None:\\n            os.environ[DOCKER_HOST] = str(host)\\n\\n        hostname_hash, suffix = Utils.hash_connection_str_hostname(edge_manager.hostname)\\n        telemetry.add_extra_props({\\'iothubhostname\\': hostname_hash, \\'iothubhostnamesuffix\\': suffix})\\n\\n        if inputs is None and deployment is not None:\\n            if len(environment) > 0:\\n                output.info(\\'Environment variables are ignored in solution mode.\\')\\n\\n            if len(edge_runtime_version) > 0:\\n                output.info(\\'edgeHub image version is ignored in solution mode.\\')\\n\\n            with open(deployment) as json_file:\\n                json_data = json.load(json_file)\\n                if \\'modulesContent\\' in json_data:\\n                    module_content = json_data[\\'modulesContent\\']\\n                elif \\'moduleContent\\' in json_data:\\n                    module_content = json_data[\\'moduleContent\\']\\n            edge_manager.start_solution(module_content, verbose, output)\\n            if not verbose:\\n                output.info(\\'IoT Edge Simulator has been started in solution mode.\\')\\n        else:\\n            if edge_runtime_version is not None:\\n                # The only validated versions are 1.0, 1.1, and 1.2 variants, hence the current limitation\\n                if re.match(r\\'^(1\\\\.0)|(1\\\\.1)|(1\\\\.2)\\', edge_runtime_version) is None:\\n                    raise ValueError(\\'-edge-runtime-version `{0}` is not valid.\\'.format(edge_runtime_version))\\n\\n            if deployment is not None:\\n                output.info(\\'Deployment manifest is ignored when inputs are present.\\')\\n            if inputs is None:\\n                input_list = [\\'input1\\']\\n            else:\\n                input_list = [input_.strip() for input_ in inputs.strip().split(\\',\\')]\\n\\n            for env in environment:\\n                if re.match(r\\'^[a-zA-Z][a-zA-Z0-9_]*?=.*$\\', env) is None:\\n                    raise ValueError(\\'Environment variable: `{0}` is not valid.\\'.format(env))\\n\\n            edge_manager.start_singlemodule(input_list, port, environment, edge_runtime_version)\\n\\n            data = \\'--data \\\\\\'{{\"inputName\": \"{0}\",\"data\":\"hello world\"}}\\\\\\'\\'.format(input_list[0])\\n            url = \\'http://localhost:{0}/api/v1/messages\\'.format(port)\\n            curl_msg = \\'        curl --header \"Content-Type: application/json\" --request POST {0} {1}\\'.format(data, url)\\n            output.info(\\'IoT Edge Simulator has been started in single module mode.\\')\\n            output.info(\\'Please run `iotedgehubdev modulecred` to get credential to connect your module.\\')\\n            output.info(\\'And send message through:\\')\\n            output.line()\\n            output.echo(curl_msg, \\'green\\')\\n            output.line()\\n            output.info(\\n                \\'Please refer to https://github.com/Azure/iot-edge-testing-utility/blob/master/swagger.json\\'\\n                \\' for detail schema\\')\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Stop the IoT Edge Simulator.\")\\n@click.option(\\'--host\\',\\n              \\'-H\\',\\n              required=False,\\n              help=\\'Docker daemon socket to connect to\\')\\n@_with_telemetry\\ndef stop(host):\\n    if host is not None:\\n        os.environ[DOCKER_HOST] = str(host)\\n    EdgeManager.stop()\\n    output.info(\\'IoT Edge Simulator has been stopped successfully.\\')\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Determine whether config file is valid.\")\\n@_with_telemetry\\ndef validateconfig():\\n    _parse_config_json()\\n    output.info(\\'Config file is valid.\\')\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Create IoT Edge device CA\")\\n@click.option(\\'--output-dir\\',\\n              \\'-o\\',\\n              required=False,\\n              default=\".\",\\n              help=\\'The output folder of generated certs. \\'\\n              \\'The tool will create a certs folder under given path to store the certs.\\')\\n@click.option(\\'--valid-days\\',\\n              \\'-d\\',\\n              required=False,\\n              default=90,\\n              show_default=True,\\n              help=\\'Days before cert expires.\\')\\n@click.option(\\'--force\\',\\n              \\'-f\\',\\n              required=False,\\n              is_flag=True,\\n              default=False,\\n              show_default=True,\\n              help=\\'Whether overwrite existing cert files.\\')\\n@click.option(\\'--trusted-ca\\',\\n              \\'-c\\',\\n              required=False,\\n              help=\\'Path of your own trusted ca used to sign IoT Edge device ca. \\'\\n              \\'Please also provide trsuted ca private key and related passphase (if have).\\'\\n              )\\n@click.option(\\'--trusted-ca-key\\',\\n              \\'-k\\',\\n              required=False,\\n              help=\\'Path of your own trusted ca private key used to sign IoT Edge device ca. \\'\\n              \\'Please also provide trusted ca and related passphase (if have).\\')\\n@click.option(\\'--trusted-ca-key-passphase\\',\\n              \\'-p\\',\\n              required=False,\\n              help=\\'Passphase of your own trusted ca private key.\\')\\n@_with_telemetry\\ndef generatedeviceca(output_dir, valid_days, force, trusted_ca, trusted_ca_key, trusted_ca_key_passphase):\\n    try:\\n        output_dir = os.path.abspath(os.path.join(output_dir, EdgeConstants.CERT_FOLDER))\\n        if trusted_ca_key_passphase:\\n            trusted_ca_key_passphase = trusted_ca_key_passphase.encode()  # crypto requires byte string\\n        # Check whether create new trusted CA and generate files to be created\\n        output_files = list(Utils.get_device_ca_file_paths(output_dir, EdgeConstants.DEVICE_CA_ID).values())\\n        if trusted_ca and trusted_ca_key:\\n            output.info(\\'Trusted CA (certification authority) and trusted CA key were provided.\\'\\n                        \\' Load trusted CA from given files.\\')\\n        else:\\n            output.info(\\'Trusted CA (certification authority) and Trusted CA key were not provided.\\'\\n                        \\' Will create new trusted CA.\\')\\n            root_ca_files = Utils.get_device_ca_file_paths(output_dir, EdgeConstants.ROOT_CA_ID)\\n            output_files.append(root_ca_files[EdgeConstants.CERT_SUFFIX])\\n            output_files.append(root_ca_files[EdgeConstants.KEY_SUFFIX])\\n        # Check whether the output files exist\\n        existing_files = []\\n        for file in output_files:\\n            if os.path.exists(file):\\n                existing_files.append(file)\\n        if len(existing_files) > 0:\\n            if force:\\n                output.info(\\'Following cert files already exist and will be overwritten: %s\\' % existing_files)\\n            else:\\n                raise EdgeError(\\'Following cert files already exist. \\'\\n                                \\'You can use --force option to overwrite existing files: %s\\' % existing_files)\\n        # Generate certs\\n        edgeCert = EdgeCert(output_dir, \\'\\')\\n        edgeCert.generate_device_ca(valid_days, force, trusted_ca, trusted_ca_key, trusted_ca_key_passphase)\\n        output.info(\\'Successfully generated device CA. Please find the generated certs at %s\\' % output_dir)\\n    except Exception as e:\\n        raise e\\n\\n\\nmain.add_command(setup)\\nmain.add_command(modulecred)\\nmain.add_command(start)\\nmain.add_command(stop)\\nmain.add_command(validateconfig)\\nmain.add_command(generatedeviceca)\\n\\nif __name__ == \"__main__\":\\n    main()\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\nimport os\\nimport re\\n\\nfrom jsonpath_rw import parse\\n\\nfrom .constants import EdgeConstants\\n\\n\\nclass CreateOptionParser(object):\\n    def __init__(self, create_option):\\n        self.create_option = create_option\\n\\n    def parse_create_option(self):\\n        ret = {}\\n        for compose_key in COMPOSE_KEY_CREATE_OPTION_MAPPING:\\n            create_option_value = self.get_create_option_value(compose_key)\\n            if create_option_value:\\n                parser_func = COMPOSE_KEY_CREATE_OPTION_MAPPING[compose_key][\\'parser_func\\']\\n                ret[compose_key] = parser_func(create_option_value)\\n        return ret\\n\\n    def get_create_option_value(self, compose_key):\\n        create_option_value_dict = {}\\n        for API_key, API_jsonpath in COMPOSE_KEY_CREATE_OPTION_MAPPING[compose_key][\\'API_Info\\'].items():\\n            jsonpath_expr = parse(API_jsonpath)\\n            value_list = jsonpath_expr.find(self.create_option)\\n            if value_list:\\n                create_option_value_dict[API_key] = value_list[0].value\\n        return create_option_value_dict\\n\\n\\ndef service_parser_naive(create_options_details):\\n    return list(create_options_details.values())[0]\\n\\n\\ndef service_parser_expose(create_options_details):\\n    return list(create_options_details[\\'ExposedPorts\\'].keys())\\n\\n\\ndef service_parser_command(create_options_details):\\n    cmd = create_options_details[\\'Cmd\\']\\n    if not isinstance(cmd, list):\\n        return cmd\\n    return \\' \\'.join(cmd).strip()\\n\\n\\ndef service_parser_healthcheck(create_options_details):\\n    healthcheck_config = create_options_details[\\'Healthcheck\\']\\n    try:\\n        return {\\n            \\'test\\': healthcheck_config[\\'Test\\'],\\n            \\'interval\\': time_ns_ms(healthcheck_config[\\'Interval\\']),\\n            \\'timeout\\': time_ns_ms(healthcheck_config[\\'Timeout\\']),\\n            \\'retries\\': healthcheck_config[\\'Retries\\'],\\n            \\'start_period\\': time_ns_ms(healthcheck_config[\\'StartPeriod\\'])\\n        }\\n    except KeyError as err:\\n        raise KeyError(\\'Missing key : {0} in Healthcheck\\'.format(err))\\n\\n\\ndef service_parser_stop_timeout(create_options_details):\\n    try:\\n        return str(int(create_options_details[\\'StopTimeout\\'])) + \\'s\\'\\n    except TypeError:\\n        raise TypeError(\\'StopTimeout should be an integer.\\')\\n\\n\\ndef service_parser_hostconfig_devices(create_options_details):\\n    devices_list = []\\n    for device in create_options_details[\\'Devices\\']:\\n        try:\\n            devices_list.append(\"{0}:{1}:{2}\".format(device[\\'PathOnHost\\'],\\n                                                     device[\\'PathInContainer\\'], device[\\'CgroupPermissions\\']))\\n        except KeyError as err:\\n            raise KeyError(\\'Missing key : {0} in HostConfig.Devices.\\'.format(err))\\n    return devices_list\\n\\n\\ndef service_parser_hostconfig_restart(create_options_details):\\n    restart_config = create_options_details[\\'RestartPolicy\\']\\n    ret = \"\"\\n    if restart_config[\\'Name\\'] == \"\":\\n        ret = \"no\"\\n    elif restart_config[\\'Name\\'] == \"on-failure\":\\n        try:\\n            ret = \"on-failure:{0}\".format(restart_config[\\'MaximumRetryCount\\'])\\n        except KeyError as err:\\n            raise KeyError(\\'Missing key : {0} in HostConfig.RestartPolicy.\\'.format(err))\\n    elif restart_config[\\'Name\\'] == \"always\" or restart_config[\\'Name\\'] == \"unless-stopped\":\\n        ret = restart_config[\\'Name\\']\\n    else:\\n        raise ValueError(\"RestartPolicy Name should be one of \\'\\', \\'always\\', \\'unless-stopped\\', \\'on-failure\\'\")\\n    return ret\\n\\n\\ndef service_parser_hostconfig_ulimits(create_options_details):\\n    ulimits_dict = {}\\n    for ulimit in create_options_details[\\'Ulimits\\']:\\n        try:\\n            ulimits_dict[ulimit[\\'Name\\']] = {\\n                \\'soft\\': ulimit[\\'Soft\\'],\\n                \\'hard\\': ulimit[\\'Hard\\']\\n            }\\n        except KeyError as err:\\n            raise KeyError(\\'Missing key : {0} in HostConfig.Ulimits\\'.format(err))\\n    return ulimits_dict\\n\\n\\ndef service_parser_hostconfig_logging(create_options_details):\\n    try:\\n        logging_dict = {\\n            \\'driver\\': create_options_details[\\'LogConfig\\'][\\'Type\\'],\\n            \\'options\\': create_options_details[\\'LogConfig\\'][\\'Config\\']\\n        }\\n    except KeyError as err:\\n        raise KeyError(\\'Missing key : {0} in HostConfig.LogConfig\\'.format(err))\\n    return logging_dict\\n\\n\\ndef service_parser_hostconfig_ports(create_options_details):\\n    ports_list = []\\n    for container_port, host_ports in create_options_details[\\'PortBindings\\'].items():\\n        for host_port_info in host_ports:\\n            host_port = \"\"\\n            if \\'HostIp\\' in host_port_info and \\'HostPort\\' in host_port_info:\\n                host_port = \"{0}:{1}\".format(host_port_info[\\'HostIp\\'], host_port_info[\\'HostPort\\'])\\n            elif \\'HostIp\\' in host_port_info:\\n                host_port = host_port_info[\\'HostIp\\']\\n            elif \\'HostPort\\' in host_port_info:\\n                host_port = host_port_info[\\'HostPort\\']\\n            ports_list.append(\"{0}:{1}\".format(host_port, container_port))\\n    return ports_list\\n\\n\\ndef service_parser_networks(create_options_details):\\n    networks_dict = {}\\n    for nw, nw_config in create_options_details[\\'NetworkingConfig\\'].items():\\n        networks_dict[nw] = {}\\n        if \\'Aliases\\' in nw_config:\\n            networks_dict[nw][\\'aliases\\'] = nw_config[\\'Aliases\\']\\n        if \\'IPAMConfig\\' in nw_config:\\n            if \\'IPv4Address\\' in nw_config[\\'IPAMConfig\\']:\\n                networks_dict[nw][\\'ipv4_address\\'] = nw_config[\\'IPAMConfig\\'][\\'IPv4Address\\']\\n            if \\'IPv6Address\\' in nw_config[\\'IPAMConfig\\']:\\n                networks_dict[nw][\\'ipv6_address\\'] = nw_config[\\'IPAMConfig\\'][\\'IPv6Address\\']\\n    return networks_dict\\n\\n\\ndef service_parser_volumes(create_options_details):\\n    volumes_list = []\\n    for mount in create_options_details.get(\\'Mounts\\', []):\\n        try:\\n            volume_info = {\\n                \\'target\\': mount[\\'Target\\'],\\n                \\'type\\': mount[\\'Type\\']\\n            }\\n            if mount[\\'Type\\'] == \\'volume\\' or mount[\\'Type\\'] == \\'bind\\':\\n                volume_info[\\'source\\'] = mount[\\'Source\\']\\n            if \\'ReadOnly\\' in mount:\\n                volume_info[\\'read_only\\'] = mount[\\'ReadOnly\\']\\n\\n            if mount[\\'Type\\'] == \\'volume\\' and \\'VolumeOptions\\' in mount:\\n                if \\'NoCopy\\' in mount[\\'VolumeOptions\\']:\\n                    volume_info[\\'volume\\'] = {\\n                        \\'nocopy\\': mount[\\'VolumeOptions\\'][\\'NoCopy\\']\\n                    }\\n            if mount[\\'Type\\'] == \\'bind\\' and \\'BindOptions\\' in mount:\\n                if \\'Propagation\\' in mount[\\'BindOptions\\']:\\n                    volume_info[\\'bind\\'] = {\\n                        \\'propagation\\': mount[\\'BindOptions\\'][\\'Propagation\\']\\n                    }\\n            if mount[\\'Type\\'] == \\'tmpfs\\' and \\'TmpfsOptions\\' in mount:\\n                if \\'SizeBytes\\' in mount[\\'TmpfsOptions\\']:\\n                    volume_info[\\'tmpfs\\'] = {\\n                        \\'size\\': mount[\\'TmpfsOptions\\'][\\'SizeBytes\\']\\n                    }\\n        except KeyError as e:\\n            raise KeyError(\\'Missing key {0} in create option HostConfig Mounts.\\'.format(e))\\n        volumes_list.append(volume_info)\\n\\n    for bind in create_options_details.get(\\'Binds\\', []):\\n        target = None\\n\\n        # Binds should be in the format [source:]destination[:mode]\\n        # Windows format and LCOW format are more strict than Linux format due to colons in Windows paths,\\n        # so match with them first\\n        match = re.match(EdgeConstants.MOUNT_WIN_REGEX, bind) or re.match(EdgeConstants.MOUNT_LCOW_REGEX, bind)\\n        if match is not None:\\n            source = match.group(\\'source\\') or \\'\\'\\n            target = match.group(\\'destination\\')\\n            read_only = match.group(\\'mode\\') == \\'ro\\'\\n        else:\\n            # Port of Docker daemon\\n            # https://github.com/docker/docker-ce/blob/1c27a55b6259743f35549e96d06334a53d0c0549/components/engine/volume/mounts/linux_parser.go#L18-L28\\n            parts = bind.split(\\':\\')\\n            if len(parts) == 2 or (len(parts) == 3 and parts[2] in (\\'ro\\', \\'rw\\', \\'\\')):\\n                if parts[0] != \\'\\':\\n                    source = parts[0]\\n                    target = parts[1]\\n                    read_only = len(parts) == 3 and parts[2] == \\'ro\\'\\n\\n        if target is not None:\\n            volume_info = {\\n                \\'type\\': \\'bind\\' if source and os.path.isabs(source) else \\'volume\\',\\n                \\'source\\': source,\\n                \\'target\\': target\\n            }\\n            if read_only:\\n                volume_info[\\'read_only\\'] = True\\n            volumes_list.append(volume_info)\\n        else:\\n            raise ValueError(\\'Invalid create option Binds: {0}\\'.format(bind))\\n\\n    return volumes_list\\n\\n\\ndef time_ns_ms(ns):\\n    if ns != 0 and ns < 1000000:\\n        raise ValueError(\\'The time should be 0 or at least 1000000 (1 ms)\\')\\n    return str(int(ns / 1000000)) + \\'ms\\'\\n\\n\\n\\'\\'\\'\\nThe mapping relationship between docker compose key and create option API key\\n\\'docker compose key\\': {\\'API_Info\\': {\\'API key\\':\\'API jsonpath\\'}, \\'parser_func\\': parser_func},\\n\\'\\'\\'\\nCOMPOSE_KEY_CREATE_OPTION_MAPPING = {\\n    \\'hostname\\': {\\'API_Info\\': {\\'Hostname\\': \"$[\\'Hostname\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'domainname\\': {\\'API_Info\\': {\\'Domainname\\': \"$[\\'Domainname\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'user\\': {\\'API_Info\\': {\\'User\\': \"$[\\'User\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'expose\\': {\\'API_Info\\': {\\'ExposedPorts\\': \"$[\\'ExposedPorts\\']\"}, \\'parser_func\\': service_parser_expose},\\n    \\'tty\\': {\\'API_Info\\': {\\'Tty\\': \"$[\\'Tty\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'environment\\': {\\'API_Info\\': {\\'Env\\': \"$[\\'Env\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'command\\': {\\'API_Info\\': {\\'Cmd\\': \"$[\\'Cmd\\']\"}, \\'parser_func\\': service_parser_command},\\n    \\'healthcheck\\': {\\'API_Info\\': {\\'Healthcheck\\': \"$[\\'Healthcheck\\']\"}, \\'parser_func\\': service_parser_healthcheck},\\n    \\'image\\': {\\'API_Info\\': {\\'Image\\': \"$[\\'Image\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'working_dir\\': {\\'API_Info\\': {\\'WorkingDir\\': \"$[\\'WorkingDir\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'entrypoint\\': {\\'API_Info\\': {\\'Entrypoint\\': \"$[\\'Entrypoint\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'mac_address\\': {\\'API_Info\\': {\\'MacAddress\\': \"$[\\'MacAddress\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'labels\\': {\\'API_Info\\': {\\'Labels\\': \"$[\\'Labels\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'stop_signal\\': {\\'API_Info\\': {\\'StopSignal\\': \"$[\\'StopSignal\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'stop_grace_period\\': {\\'API_Info\\': {\\'StopTimeout\\': \"$[\\'StopTimeout\\']\"}, \\'parser_func\\': service_parser_stop_timeout},\\n\\n    # HostConfig\\n    \\'ports\\': {\\'API_Info\\': {\\'PortBindings\\': \"$[\\'HostConfig\\'][\\'PortBindings\\']\"}, \\'parser_func\\': service_parser_hostconfig_ports},\\n    \\'privileged\\': {\\'API_Info\\': {\\'Privileged\\': \"$[\\'HostConfig\\'][\\'Privileged\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'network_mode\\': {\\'API_Info\\': {\\'NetworkMode\\': \"$[\\'HostConfig\\'][\\'NetworkMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'devices\\': {\\'API_Info\\': {\\'Devices\\': \"$[\\'HostConfig\\'][\\'Devices\\']\"}, \\'parser_func\\': service_parser_hostconfig_devices},\\n    \\'dns\\': {\\'API_Info\\': {\\'Dns\\': \"$[\\'HostConfig\\'][\\'Dns\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'dns_search\\': {\\'API_Info\\': {\\'DnsSearch\\': \"$[\\'HostConfig\\'][\\'DnsSearch\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'restart\\': {\\n        \\'API_Info\\': {\\'RestartPolicy\\': \"$[\\'HostConfig\\'][\\'RestartPolicy\\']\"},\\n        \\'parser_func\\': service_parser_hostconfig_restart\\n    },\\n    \\'cap_add\\': {\\'API_Info\\': {\\'CapAdd\\': \"$[\\'HostConfig\\'][\\'CapAdd\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'cap_drop\\': {\\'API_Info\\': {\\'CapDrop\\': \"$[\\'HostConfig\\'][\\'CapDrop\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'ulimits\\': {\\'API_Info\\': {\\'Ulimits\\': \"$[\\'HostConfig\\'][\\'Ulimits\\']\"}, \\'parser_func\\': service_parser_hostconfig_ulimits},\\n    \\'logging\\': {\\'API_Info\\': {\\'LogConfig\\': \"$[\\'HostConfig\\'][\\'LogConfig\\']\"}, \\'parser_func\\': service_parser_hostconfig_logging},\\n    \\'extra_hosts\\': {\\'API_Info\\': {\\'ExtraHosts\\': \"$[\\'HostConfig\\'][\\'ExtraHosts\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'read_only\\': {\\'API_Info\\': {\\'ReadonlyRootfs\\': \"$[\\'HostConfig\\'][\\'ReadonlyRootfs\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'pid\\': {\\'API_Info\\': {\\'PidMode\\': \"$[\\'HostConfig\\'][\\'PidMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'security_opt\\': {\\'API_Info\\': {\\'SecurityOpt\\': \"$[\\'HostConfig\\'][\\'SecurityOpt\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'ipc\\': {\\'API_Info\\': {\\'IpcMode\\': \"$[\\'HostConfig\\'][\\'IpcMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'cgroup_parent\\': {\\'API_Info\\': {\\'CgroupParent\\': \"$[\\'HostConfig\\'][\\'CgroupParent\\']\"}, \\'parser_func\\': service_parser_naive},\\n    # \\'shm_size:\\':{\\'API_Info\\':\\'ShmSize\\',\\'parser_func\\':service_parser_naive},\\n    \\'sysctls\\': {\\'API_Info\\': {\\'Sysctls\\': \"$[\\'HostConfig\\'][\\'Sysctls\\']\"}, \\'parser_func\\': service_parser_naive},\\n    # \\'tmpfs:\\':{\\'API_Info\\':\\'Tmpfs\\',\\'parser_func\\':service_parser_naive},\\n    \\'userns_mode\\': {\\'API_Info\\': {\\'UsernsMode\\': \"$[\\'HostConfig\\'][\\'UsernsMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'isolation\\': {\\'API_Info\\': {\\'Isolation\\': \"$[\\'HostConfig\\'][\\'Isolation\\']\"}, \\'parser_func\\': service_parser_naive},\\n\\n    # Volumes\\n    \\'volumes\\': {\\n        \\'API_Info\\': {\\n            \\'Mounts\\': \"$[\\'HostConfig\\'][\\'Mounts\\']\",\\n            \\'Binds\\': \"$[\\'HostConfig\\'][\\'Binds\\']\"\\n        },\\n        \\'parser_func\\': service_parser_volumes\\n    },\\n\\n    # NetworkingConfig\\n    \\'networks\\': {\\n        \\'API_Info\\': {\\'NetworkingConfig\\': \"$[\\'NetworkingConfig\\'][\\'EndpointsConfig\\']\"},\\n        \\'parser_func\\': service_parser_networks\\n    }\\n}\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport json\\nimport os\\nimport sys\\nimport yaml\\n\\nfrom collections import OrderedDict\\nfrom io import StringIO\\nfrom .compose_parser import CreateOptionParser\\nfrom .output import Output\\n\\nCOMPOSE_VERSION = 3.6\\n\\nCREATE_OPTIONS_MAX_CHUNKS = 100\\n\\n\\nclass ComposeProject(object):\\n\\n    def __init__(self, module_content):\\n        self.module_content = module_content\\n        self.yaml_dict = OrderedDict()\\n        self.Services = OrderedDict()\\n        self.Networks = {}\\n        self.Volumes = {}\\n        self.edge_info = {}\\n\\n    def compose(self):\\n        modules = {\\n            self.edge_info[\\'hub_name\\']:\\n            self.module_content[\\'$edgeAgent\\'][\\'properties.desired\\'][\\'systemModules\\'][\\'edgeHub\\']\\n        }\\n        modules.update(self.module_content[\\'$edgeAgent\\'][\\'properties.desired\\'][\\'modules\\'])\\n        for service_name, config in modules.items():\\n            self.Services[service_name] = {}\\n            create_option_str = ComposeProject._join_create_options(config[\\'settings\\'])\\n            if create_option_str:\\n                create_option = json.loads(create_option_str)\\n                create_option_parser = CreateOptionParser(create_option)\\n                self.Services[service_name].update(create_option_parser.parse_create_option())\\n            self.Services[service_name][\\'image\\'] = config[\\'settings\\'][\\'image\\']\\n            self.Services[service_name][\\'container_name\\'] = service_name\\n\\n            if \\'networks\\' not in self.Services[service_name]:\\n                self.Services[service_name][\\'networks\\'] = {}\\n                self.Services[service_name][\\'networks\\'][self.edge_info[\\'network_info\\'][\\'NW_NAME\\']] = None\\n\\n            if \\'network_mode\\' in self.Services[service_name]:\\n                del self.Services[service_name][\\'network_mode\\']\\n\\n            if \\'host\\' in self.Services[service_name][\\'networks\\']:\\n                self.Services[service_name][\\'network_mode\\'] = \\'host\\'\\n                del self.Services[service_name][\\'networks\\']\\n\\n            if \\'labels\\' not in self.Services[service_name]:\\n                self.Services[service_name][\\'labels\\'] = {self.edge_info[\\'labels\\']: \"\"}\\n            else:\\n                self.Services[service_name][\\'labels\\'][self.edge_info[\\'labels\\']] = \"\"\\n\\n            try:\\n                # Default restart policy is \\'on-unhealthy\\'\\n                # https://github.com/Azure/iotedge/blob/8bd573590cdc149c014cf994dba58fc63f1a5c74/edge-agent/src/Microsoft.Azure.Devices.Edge.Agent.Core/Constants.cs#L18\\n                restart_policy = config.get(\\'restartPolicy\\', \\'on-unhealthy\\')\\n                self.Services[service_name][\\'restart\\'] = {\\n                    \\'never\\': \\'no\\',\\n                    \\'on-failure\\': \\'on-failure\\',\\n                    \\'always\\': \\'always\\',\\n                    \\'on-unhealthy\\': \\'always\\',\\n                    \\'unknown\\': \\'no\\'\\n                }[restart_policy]\\n\\n                if restart_policy == \\'on-unhealthy\\':\\n                    Output().warning(\\'Unsupported restart policy \\\\\\'{0}\\\\\\' in solution mode. Falling back to \\\\\\'always\\\\\\'.\\'\\n                                     .format(restart_policy))\\n            except KeyError as e:\\n                raise KeyError(\\'Unsupported restart policy {0} in solution mode.\\'.format(e))\\n\\n            if \\'env\\' in config:\\n                self.Services[service_name][\\'environment\\'] = self.config_env(\\n                    self.Services[service_name].get(\\'environment\\', []), config[\\'env\\'])\\n\\n            if service_name == self.edge_info[\\'hub_name\\']:\\n                self.config_edge_hub(service_name)\\n            else:\\n                self.config_modules(service_name)\\n\\n            if \\'networks\\' in self.Services[service_name]:\\n                for nw in self.Services[service_name][\\'networks\\']:\\n                    self.Networks[nw] = {\\n                        \\'external\\': True\\n                    }\\n\\n            for vol in self.Services[service_name][\\'volumes\\']:\\n                if vol[\\'type\\'] == \\'volume\\':\\n                    self.Volumes[vol[\\'source\\']] = {\\n                        \\'name\\': vol[\\'source\\']\\n                    }\\n\\n    def set_edge_info(self, info):\\n        self.edge_info = info\\n\\n    def config_modules(self, service_name):\\n        config = self.Services[service_name]\\n        if \\'volumes\\' not in config:\\n            config[\\'volumes\\'] = []\\n        config[\\'volumes\\'].append({\\n            \\'type\\': \\'volume\\',\\n            \\'source\\': self.edge_info[\\'volume_info\\'][\\'MODULE_VOLUME\\'],\\n            \\'target\\': self.edge_info[\\'volume_info\\'][\\'MODULE_MOUNT\\']\\n        })\\n\\n        if \\'environment\\' not in config:\\n            config[\\'environment\\'] = []\\n        for module_env in self.edge_info[\\'env_info\\'][\\'module_env\\']:\\n            config[\\'environment\\'].append(module_env)\\n        config[\\'environment\\'].append(\\n            \\'EdgeHubConnectionString=\\' + self.edge_info[\\'ConnStr_info\\'][service_name]\\n        )\\n\\n        if \\'depends_on\\' not in config:\\n            config[\\'depends_on\\'] = []\\n        config[\\'depends_on\\'].append(self.edge_info[\\'hub_name\\'])\\n\\n    def config_edge_hub(self, service_name):\\n        config = self.Services[service_name]\\n        if \\'volumes\\' not in config:\\n            config[\\'volumes\\'] = []\\n        config[\\'volumes\\'].append({\\n            \\'type\\': \\'volume\\',\\n            \\'source\\': self.edge_info[\\'volume_info\\'][\\'HUB_VOLUME\\'],\\n            \\'target\\': self.edge_info[\\'volume_info\\'][\\'HUB_MOUNT\\']\\n        })\\n\\n        config[\\'networks\\'][self.edge_info[\\'network_info\\'][\\'NW_NAME\\']] = {\\n            \\'aliases\\': [self.edge_info[\\'network_info\\'][\\'ALIASES\\']]\\n        }\\n\\n        if \\'environment\\' not in config:\\n            config[\\'environment\\'] = []\\n        routes_env = self.parse_routes()\\n        for e in routes_env:\\n            config[\\'environment\\'].append(e)\\n        config[\\'environment\\'].append(\\n            \\'IotHubConnectionString=\\' + self.edge_info[\\'ConnStr_info\\'][\\'$edgeHub\\'])\\n        config[\\'environment\\'].extend(self.edge_info[\\'env_info\\'][\\'hub_env\\'])\\n\\n    def config_env(self, env_list, env_section):\\n        env_dict = {}\\n        for env in env_list:\\n            if \\'=\\' in env:\\n                k, v = env.split(\\'=\\', 1)\\n            else:\\n                k, v = env, \\'\\'\\n            env_dict[k] = v\\n        for k, v in env_section.items():\\n            if \\'value\\' not in v:\\n                env_dict[k] = \\'\\'\\n            else:\\n                env_dict[k] = v[\\'value\\']\\n        ret = []\\n        for k, v in env_dict.items():\\n            ret.append(\"{0}={1}\".format(k, v))\\n        return ret\\n\\n    def parse_routes(self):\\n        routes = self.module_content[\\'$edgeHub\\'][\\'properties.desired\\'][\\'routes\\']\\n        schema_version = self.module_content[\\'$edgeHub\\'][\\'properties.desired\\'][\\'schemaVersion\\']\\n        routes_env = []\\n        route_id = 1\\n\\n        for route in routes.values():\\n            if isinstance(route, str):\\n                routes_env.append(\\'routes__r{0}={1}\\'.format(route_id, route))\\n            else:\\n                if schema_version >= \"1.1\":\\n                    routes_env.append(\\'routes__r{0}={1}\\'.format(route_id, route[\"route\"]))\\n                else:\\n                    raise Exception(\"Route priority/TTL is not supported in schema {0}.\".format(schema_version))\\n            route_id = route_id + 1\\n        return routes_env\\n\\n    def dump(self, target):\\n        def setup_yaml():\\n            def represent_dict_order(self, data):\\n                return self.represent_mapping(\\'tag:yaml.org,2002:map\\', data.items())\\n            yaml.add_representer(OrderedDict, represent_dict_order)\\n        setup_yaml()\\n\\n        def my_unicode_repr(self, data):\\n            return self.represent_str(data.encode(\\'utf-8\\'))\\n\\n        self.yaml_dict[\\'version\\'] = str(COMPOSE_VERSION)\\n        self.yaml_dict[\\'services\\'] = self.Services\\n        self.yaml_dict[\\'networks\\'] = self.Networks\\n        self.yaml_dict[\\'volumes\\'] = self.Volumes\\n\\n        if sys.version_info[0] < 3:\\n            # Add # noqa: F821 to ignore undefined name \\'unicode\\' error\\n            yaml.add_representer(unicode, my_unicode_repr)  # noqa: F821\\n        yml_stream = StringIO()\\n\\n        yaml.dump(self.yaml_dict, yml_stream, default_flow_style=False)\\n        yml_str = yml_stream.getvalue().replace(\\'$\\', \\'$$\\')\\n\\n        if not os.path.exists(os.path.dirname(target)):\\n            os.makedirs(os.path.dirname(target))\\n\\n        with open(target, \\'w\\') as f:\\n            f.write(yml_str)\\n\\n    @staticmethod\\n    def _join_create_options(settings):\\n        if \\'createOptions\\' not in settings:\\n            return \\'\\'\\n\\n        res = settings[\\'createOptions\\']\\n\\n        i = 0\\n        while True:\\n            i += 1\\n            key = \\'createOptions{0:0=2d}\\'.format(i)\\n            if i < CREATE_OPTIONS_MAX_CHUNKS and key in settings:\\n                res += settings[key]\\n            else:\\n                break\\n\\n        return res\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport os\\nimport configparser\\n\\nfrom . import decorators\\nfrom .hostplatform import HostPlatform\\n\\nPRIVACY_STATEMENT = \"\"\"\\nWelcome to iotedgehubdev!\\n-------------------------\\nTelemetry\\n---------\\nThe iotedgehubdev collects usage data in order to improve your experience.\\nThe data is anonymous and does not include commandline argument values.\\nThe data is collected by Microsoft.\\n\\nYou can change your telemetry settings by updating \\'collect_telemetry\\' to \\'no\\' in {0}\\n\"\"\"\\n\\n\\nclass ProductConfig(object):\\n    def __init__(self):\\n        self.config = configparser.ConfigParser({\\n            \\'firsttime\\': \\'yes\\'\\n        })\\n        self.setup_config()\\n\\n    @decorators.suppress_all_exceptions()\\n    def setup_config(self):\\n        try:\\n            configPath = HostPlatform.get_config_path()\\n            iniFilePath = HostPlatform.get_setting_ini_path()\\n            if not os.path.exists(configPath):\\n                os.makedirs(configPath)\\n            if not os.path.exists(iniFilePath):\\n                with open(iniFilePath, \\'w\\') as iniFile:\\n                    self.config.write(iniFile)\\n            else:\\n                with open(iniFilePath, \\'r\\') as iniFile:\\n                    self.config.read_file(iniFile)\\n                with open(iniFilePath, \\'w\\') as iniFile:\\n                    self.config.write(iniFile)\\n        except Exception:\\n            pass\\n\\n    @decorators.suppress_all_exceptions()\\n    def update_config(self):\\n        with open(HostPlatform.get_setting_ini_path(), \\'w\\') as iniFile:\\n            self.config.write(iniFile)\\n\\n    @decorators.suppress_all_exceptions()\\n    def set_val(self, direct, section, val):\\n        if val is not None:\\n            self.config.set(direct, section, val)\\n            self.update_config()\\n\\n\\n_prod_config = ProductConfig()\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef get_ini_config():\\n    return _prod_config.config\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef update_ini():\\n    _prod_config.update_config()\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef check_firsttime():\\n    if \\'no\\' != _prod_config.config.get(\\'DEFAULT\\', \\'firsttime\\'):\\n        config = _prod_config.config\\n        config.set(\\'DEFAULT\\', \\'firsttime\\', \\'no\\')\\n        print(PRIVACY_STATEMENT.format(HostPlatform.get_setting_ini_path()))\\n        config.set(\\'DEFAULT\\', \\'collect_telemetry\\', \\'yes\\')\\n        _prod_config.update_config()\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nclass EdgeConstants():\\n    HOSTNAME_KEY = \\'HostName\\'\\n    DEVICE_ID_KEY = \\'DeviceId\\'\\n    ACCESS_KEY_KEY = \\'SharedAccessKey\\'\\n    ACCESS_KEY_NAME = \\'SharedAccessKeyName\\'\\n    DEVICE_ACCESS_KEY_KEY = \\'Device_SharedAccessKey\\'\\n    HUB_ACCESS_KEY_KEY = \\'Hub_SharedAccessKey\\'\\n\\n    SUBJECT_COUNTRY_KEY = \\'countryCode\\'\\n    SUBJECT_STATE_KEY = \\'state\\'\\n    SUBJECT_LOCALITY_KEY = \\'locality\\'\\n    SUBJECT_ORGANIZATION_KEY = \\'organization\\'\\n    SUBJECT_ORGANIZATION_UNIT_KEY = \\'organizationUnit\\'\\n    SUBJECT_COMMON_NAME_KEY = \\'commonName\\'\\n\\n    EDGE_CHAIN_CA = \\'edge-chain-ca\\'\\n    EDGE_HUB_SERVER = \\'edge-hub-server\\'\\n    EDGE_DEVICE_CA = \\'edge-device-ca\\'\\n    EDGE_AGENT_CA = \\'edge-agent-ca\\'\\n    CERT_SUFFIX = \\'.cert.pem\\'\\n    CHAIN_CERT_SUFFIX = \\'-chain.cert.pem\\'\\n    PFX_SUFFIX = \\'.cert.pfx\\'\\n    KEY_SUFFIX = \\'.key.pem\\'\\n    ROOT_CA_ID = \\'azure-iot-test-only.root.ca\\'\\n    DEVICE_CA_ID = \\'iot-edge-device-ca\\'\\n    CERT_FOLDER = \\'certs\\'\\n\\n    CERT_DEFAULT_DICT = {\\n        SUBJECT_COUNTRY_KEY: \\'US\\',\\n        SUBJECT_STATE_KEY: \\'Washington\\',\\n        SUBJECT_LOCALITY_KEY: \\'Redmond\\',\\n        SUBJECT_ORGANIZATION_KEY: \\'Default Edge Organization\\',\\n        SUBJECT_ORGANIZATION_UNIT_KEY: \\'Edge Unit\\',\\n        SUBJECT_COMMON_NAME_KEY: \\'Edge Test Device CA\\'\\n    }\\n\\n    # Port of Docker daemon\\n    # https://github.com/docker/docker-ce/blob/f9756bfb29877236a83979170ef2c0aa35eb57c6/components/engine/volume/mounts/windows_parser.go#L19-L76\\n    MOUNT_HOST_DIR_REGEX = r\\'(?:\\\\\\\\\\\\\\\\\\\\?\\\\\\\\)?[a-z]:[\\\\\\\\/](?:[^\\\\\\\\/:*?\"<>|\\\\r\\\\n]+[\\\\\\\\/]?)*\\'\\n    MOUNT_NAME_REGEX = r\\'[^\\\\\\\\/:*?\"<>|\\\\r\\\\n]+\\'\\n    MOUNT_PIPE_REGEX = r\\'[/\\\\\\\\]{2}.[/\\\\\\\\]pipe[/\\\\\\\\][^:*?\"<>|\\\\r\\\\n]+\\'\\n    MOUNT_SOURCE_REGEX = r\\'((?P<source>((\\' + MOUNT_HOST_DIR_REGEX + r\\')|(\\' + \\\\\\n        MOUNT_NAME_REGEX + r\\')|(\\' + MOUNT_PIPE_REGEX + r\\'))):)?\\'\\n    MOUNT_MODE_REGEX = r\\'(:(?P<mode>(?i)ro|rw))?\\'\\n    MOUNT_WIN_DEST_REGEX = r\\'(?P<destination>((?:\\\\\\\\\\\\\\\\\\\\?\\\\\\\\)?([a-z]):((?:[\\\\\\\\/][^\\\\\\\\/:*?\"<>\\\\r\\\\n]+)*[\\\\\\\\/]?))|(\\' + \\\\\\n        MOUNT_PIPE_REGEX + r\\'))\\'\\n    MOUNT_LCOW_DEST_REGEX = r\\'(?P<destination>/(?:[^\\\\\\\\/:*?\"<>\\\\r\\\\n]+[/]?)*)\\'\\n    MOUNT_WIN_REGEX = r\\'^\\' + MOUNT_SOURCE_REGEX + MOUNT_WIN_DEST_REGEX + MOUNT_MODE_REGEX + r\\'$\\'\\n    MOUNT_LCOW_REGEX = r\\'^\\' + MOUNT_SOURCE_REGEX + MOUNT_LCOW_DEST_REGEX + MOUNT_MODE_REGEX + r\\'$\\'\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nfrom functools import wraps\\n\\n\\ndef suppress_all_exceptions(fallback_return=None):\\n    def _decorator(func):\\n        @wraps(func)\\n        def _wrapped_func(*args, **kwargs):\\n            try:\\n                return func(*args, **kwargs)\\n            except Exception:\\n                if fallback_return:\\n                    return fallback_return\\n                else:\\n                    pass\\n\\n        return _wrapped_func\\n\\n    return _decorator\\n\\n\\ndef hash256_result(func):\\n    \"\"\"Secure the return string of the annotated function with SHA256 algorithm. If the annotated\\n    function doesn\\'t return string or return None, raise ValueError.\"\"\"\\n    @wraps(func)\\n    def _decorator(*args, **kwargs):\\n        val = func(*args, **kwargs)\\n        if not val:\\n            raise ValueError(\\'Return value is None\\')\\n        elif not isinstance(val, str):\\n            raise ValueError(\\'Return value is not string\\')\\n\\n        from .utils import Utils\\n        return Utils.get_sha256_hash(val)\\n\\n    return _decorator\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\nfrom .certutils import EdgeCertUtil\\nfrom .constants import EdgeConstants\\n\\n\\nclass EdgeCert(object):\\n    def __init__(self, certs_dir, hostname):\\n        self.certs_dir = certs_dir\\n        self.hostname = hostname\\n\\n    def generate_self_signed_certs(self):\\n        cert_util = EdgeCertUtil()\\n        cert_util.create_root_ca_cert(EdgeConstants.EDGE_DEVICE_CA,\\n                                      validity_days_from_now=365,\\n                                      subject_dict=EdgeConstants.CERT_DEFAULT_DICT,\\n                                      passphrase=None)\\n        cert_util.export_simulator_cert_artifacts_to_dir(EdgeConstants.EDGE_DEVICE_CA, self.certs_dir)\\n\\n        cert_util.create_intermediate_ca_cert(EdgeConstants.EDGE_AGENT_CA,\\n                                              EdgeConstants.EDGE_DEVICE_CA,\\n                                              validity_days_from_now=365,\\n                                              common_name='Edge Agent CA',\\n                                              set_terminal_ca=False,\\n                                              passphrase=None)\\n        cert_util.export_simulator_cert_artifacts_to_dir(EdgeConstants.EDGE_AGENT_CA, self.certs_dir)\\n\\n        cert_util.create_server_cert(EdgeConstants.EDGE_HUB_SERVER,\\n                                     EdgeConstants.EDGE_AGENT_CA,\\n                                     validity_days_from_now=365,\\n                                     hostname=self.hostname)\\n        cert_util.export_simulator_cert_artifacts_to_dir(EdgeConstants.EDGE_HUB_SERVER, self.certs_dir)\\n        cert_util.export_pfx_cert(EdgeConstants.EDGE_HUB_SERVER, self.certs_dir)\\n\\n        prefixes = [EdgeConstants.EDGE_AGENT_CA, EdgeConstants.EDGE_DEVICE_CA]\\n        cert_util.chain_simulator_ca_certs(EdgeConstants.EDGE_CHAIN_CA, prefixes, self.certs_dir)\\n\\n    # Generate IoT Edge device CA to be configured in IoT Edge runtime\\n    def generate_device_ca(self, valid_days, overwrite_existing, trusted_ca, trusted_ca_key, trusted_ca_key_passphase):\\n        # Function level variables\\n        create_root_ca = not (trusted_ca and trusted_ca_key)\\n        # Generate certs\\n        cert_util = EdgeCertUtil()\\n        if create_root_ca:\\n            cert_util.create_root_ca_cert(EdgeConstants.ROOT_CA_ID,\\n                                          validity_days_from_now=valid_days,\\n                                          subject_dict=EdgeConstants.CERT_DEFAULT_DICT,\\n                                          passphrase=None)\\n            cert_util.export_device_ca_cert_artifacts_to_dir(EdgeConstants.ROOT_CA_ID, self.certs_dir)\\n        else:\\n            cert_util.load_cert_from_file(EdgeConstants.ROOT_CA_ID, trusted_ca, trusted_ca_key, trusted_ca_key_passphase)\\n\\n        cert_util.create_intermediate_ca_cert(EdgeConstants.DEVICE_CA_ID, EdgeConstants.ROOT_CA_ID,\\n                                              validity_days_from_now=valid_days,\\n                                              common_name='Edge Device CA',\\n                                              set_terminal_ca=False,\\n                                              passphrase=None)\\n        cert_util.export_device_ca_cert_artifacts_to_dir(EdgeConstants.DEVICE_CA_ID, self.certs_dir)\\n        cert_util.chain_device_ca_certs(EdgeConstants.DEVICE_CA_ID,\\n                                        [EdgeConstants.DEVICE_CA_ID, EdgeConstants.ROOT_CA_ID],\\n                                        self.certs_dir)\\n\\n    def get_cert_file_path(self, id_str):\\n        return EdgeCertUtil.get_cert_file_path(id_str, self.certs_dir)\\n\\n    def get_pfx_file_path(self, id_str):\\n        return EdgeCertUtil.get_pfx_file_path(id_str, self.certs_dir)\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport docker\\nimport os\\nimport time\\nimport tarfile\\nfrom io import BytesIO\\nfrom .errors import EdgeDeploymentError\\nfrom .utils import Utils\\n\\n\\nclass EdgeDockerClient(object):\\n    _DOCKER_INFO_OS_TYPE_KEY = \\'OSType\\'\\n\\n    def __init__(self, docker_client=None):\\n        if docker_client is not None:\\n            self._client = docker_client\\n        else:\\n            try:\\n                self._client = docker.DockerClient.from_env(version=\\'auto\\')\\n            except Exception as ex:\\n                msg = \\'Could not connect to Docker daemon. Please make sure Docker is running\\'\\n                raise EdgeDeploymentError(msg, ex)\\n\\n    def __enter__(self):\\n        return self\\n\\n    def __exit__(self, exc_type, exc_value, traceback):\\n        if self._client is not None:\\n            self._client.api.close()\\n\\n    def stop_remove_by_label(self, label):\\n        try:\\n            filter_dict = {\\'label\\': label}\\n            containers = self._client.containers.list(all=True, filters=filter_dict)\\n            for container in containers:\\n                container.stop()\\n                self.remove(container.name)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not stop and remove containers by label: {0}\\'.format(label)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def get_local_image_sha_id(self, image):\\n        local_id = None\\n        try:\\n            inspect_dict = self._client.api.inspect_image(image)\\n            local_id = inspect_dict[\\'Id\\']\\n        except docker.errors.APIError:\\n            local_id = None\\n        return local_id\\n\\n    def pull(self, image, username, password):\\n        old_id = self.get_local_image_sha_id(image)\\n        try:\\n            is_updated = True\\n            auth_dict = None\\n            if username is not None:\\n                auth_dict = {\\'username\\': username, \\'password\\': password}\\n            self._client.images.pull(image, auth_config=auth_dict)\\n            if old_id is not None:\\n                inspect_dict = self._client.api.inspect_image(image)\\n                new_id = inspect_dict[\\'Id\\']\\n                if new_id == old_id:\\n                    is_updated = False\\n\\n            return is_updated\\n        except docker.errors.APIError as ex:\\n            msg = \\'Error during pull for image {0}\\'.format(image)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def pullIfNotExist(self, image, username, password):\\n        imageId = self.get_local_image_sha_id(image)\\n        if imageId is None:\\n            return self.pull(image, username, password)\\n\\n    def status(self, container_name):\\n        try:\\n            containers = self._client.containers.list(all=True)\\n            for container in containers:\\n                if container_name == container.name:\\n                    return container.status\\n            return None\\n        except docker.errors.APIError as ex:\\n            msg = \\'Error while checking status for: {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def stop(self, container_name):\\n        self._exec_container_method(container_name, \\'stop\\')\\n\\n    def start(self, container_name):\\n        self._exec_container_method(container_name, \\'start\\')\\n\\n    def remove(self, container_name):\\n        self._exec_container_method(container_name, \\'remove\\')\\n\\n    def create_network(self, network_name):\\n        create_network = False\\n        try:\\n            networks = self._client.networks.list(names=[network_name])\\n            if networks:\\n                num_networks = len(networks)\\n                if num_networks == 0:\\n                    create_network = True\\n            else:\\n                create_network = True\\n            if create_network is True:\\n                os_name = self.get_os_type()\\n                if os_name == \\'windows\\':\\n                    return self._client.networks.create(network_name, driver=\\'nat\\')\\n                else:\\n                    return self._client.networks.create(network_name, driver=\\'bridge\\')\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not create docker network: {0}\\'.format(network_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def create_volume(self, volume_name):\\n        try:\\n            volume = self._get_volume_if_exists(volume_name)\\n            if volume is None:\\n                return self._client.volumes.create(volume_name)\\n        except docker .errors.APIError as ex:\\n            msg = \\'Docker volume create failed for: {0}\\'.format(volume_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def create_config_for_network(self, nw_name, *args, **kwargs):\\n        return self._client.api.create_networking_config({\\n            nw_name: self._client.api.create_endpoint_config(*args, **kwargs)\\n        })\\n\\n    def create_container(self, image, **kwargs):\\n        try:\\n            return self._client.api.create_container(image, **kwargs)\\n        except docker.errors.ContainerError as ex_ctr:\\n            msg = \\'Container exited with errors: {0}\\'.format(kwargs.get(\\'name\\', None))\\n            raise EdgeDeploymentError(msg, ex_ctr)\\n        except docker.errors.ImageNotFound as ex_img:\\n            msg = \\'Docker create failed. Image not found: {0}\\'.format(image)\\n            raise EdgeDeploymentError(msg, ex_img)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker create failed for image: {0}\\'.format(image)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def create_host_config(self, *args, **kwargs):\\n        try:\\n            return self._client.api.create_host_config(*args, **kwargs)\\n        except Exception as ex:\\n            msg = \\'docker create host config failed\\'\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def copy_file_to_volume(self,\\n                            container_name,\\n                            volume_name,\\n                            volume_dest_file_name,\\n                            volume_dest_dir_path,\\n                            host_src_file):\\n        if self.get_os_type() == \\'windows\\':\\n            self._insert_file_in_volume_mount(volume_name, host_src_file, volume_dest_file_name)\\n        else:\\n            self._insert_file_in_container(container_name,\\n                                           volume_dest_file_name,\\n                                           volume_dest_dir_path,\\n                                           host_src_file)\\n\\n    def get_os_type(self):\\n        try:\\n            info = self._client.info()\\n            return info[EdgeDockerClient._DOCKER_INFO_OS_TYPE_KEY].lower()\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker daemon returned error\\'\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def destroy_network(self, network_name):\\n        try:\\n            networks = self._client.networks.list(names=[network_name])\\n            if networks is not None:\\n                for network in networks:\\n                    if network.name == network_name:\\n                        network.remove()\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not remove docker network: {0}\\'.format(network_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def remove_volume(self, volume_name, force=False):\\n        try:\\n            volume = self._get_volume_if_exists(volume_name)\\n            if volume is not None:\\n                volume.remove(force)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker volume remove failed for: {0}, force flag: {1}\\'.format(volume_name, force)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _get_volume_if_exists(self, name):\\n        try:\\n            return self._client.volumes.get(name)\\n        except docker.errors.NotFound:\\n            return None\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker volume get failed for: {0}\\'.format(name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _exec_container_method(self, container_name, method, **kwargs):\\n        container = self._get_container_by_name(container_name)\\n        try:\\n            getattr(container, method)(**kwargs)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not {0} container: {1}\\'.format(method, container_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _get_container_by_name(self, container_name):\\n        try:\\n            return self._client.containers.get(container_name)\\n        except docker.errors.NotFound as nf_ex:\\n            msg = \\'Could not find container by name {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, nf_ex)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Error getting container by name: {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _insert_file_in_volume_mount(self, volume_name, host_src_file, volume_dest_file_name):\\n        try:\\n            volume_info = self._client.api.inspect_volume(volume_name)\\n            Utils.copy_files(host_src_file.replace(\\'\\\\\\\\\\\\\\\\\\', \\'\\\\\\\\\\'),\\n                             os.path.join(volume_info[\\'Mountpoint\\'].replace(\\'\\\\\\\\\\\\\\\\\\', \\'\\\\\\\\\\'), volume_dest_file_name))\\n        except docker.errors.APIError as docker_ex:\\n            msg = \\'Docker volume inspect failed for: {0}\\'.format(volume_name)\\n            raise EdgeDeploymentError(msg, docker_ex)\\n        except (OSError, IOError) as ex_os:\\n            msg = \\'File IO error seen copying files to volume: {0}. \\' \\\\\\n                  \\'Errno: {1}, Error {2}\\'.format(volume_name, str(ex_os.errno), ex_os.strerror)\\n            raise EdgeDeploymentError(msg, ex_os)\\n\\n    def _insert_file_in_container(self,\\n                                  container_name,\\n                                  volume_dest_file_name,\\n                                  volume_dest_dir_path,\\n                                  host_src_file):\\n        try:\\n            (tar_stream, dest_archive_info, container_tar_file) = \\\\\\n                EdgeDockerClient.create_tar_objects(volume_dest_file_name)\\n            file_data = open(host_src_file, \\'rb\\').read()\\n            dest_archive_info.size = len(file_data)\\n            dest_archive_info.mtime = time.time()\\n            dest_archive_info.mode = 0o444\\n            container_tar_file.addfile(dest_archive_info, BytesIO(file_data))\\n            container_tar_file.close()\\n            tar_stream.seek(0)\\n            container = self._get_container_by_name(container_name)\\n            container.put_archive(volume_dest_dir_path, tar_stream)\\n        except docker.errors.APIError as docker_ex:\\n            msg = \\'Container put_archive failed for container: {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, docker_ex)\\n        except (OSError, IOError) as ex_os:\\n            msg = \\'File IO error seen during put archive for container: {0}. \\' \\\\\\n                  \\'Errno: {1}, Error {2}\\'.format(container_name, str(ex_os.errno), ex_os.strerror)\\n            raise EdgeDeploymentError(msg, ex_os)\\n\\n    @staticmethod\\n    def create_tar_objects(container_dest_file_name):\\n        tar_stream = BytesIO()\\n        dest_archive_info = tarfile.TarInfo(name=container_dest_file_name)\\n        container_tar_file = tarfile.TarFile(fileobj=tar_stream, mode=\\'w\\')\\n        return (tar_stream, dest_archive_info, container_tar_file)\\n\\n    @classmethod\\n    def create_instance(cls, docker_client):\\n        \"\"\"\\n        Factory method useful in testing.\\n        \"\"\"\\n        return cls(docker_client)\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport json\\nimport os\\n\\nimport docker\\nimport requests\\n\\nfrom .composeproject import ComposeProject\\nfrom .constants import EdgeConstants as EC\\nfrom .edgecert import EdgeCert\\nfrom .edgedockerclient import EdgeDockerClient\\nfrom .errors import ResponseError, RegistriesLoginError\\nfrom .hostplatform import HostPlatform\\nfrom .utils import Utils\\n\\n\\nclass EdgeManager(object):\\n    LABEL = \\'iotedgehubdev\\'\\n    EDGEHUB_IMG = \\'mcr.microsoft.com/azureiotedge-hub:{0}\\'\\n    TESTUTILITY_IMG = \\'mcr.microsoft.com/azureiotedge-testing-utility:1.0.0\\'\\n    EDGEHUB_MODULE = \\'$edgeHub\\'\\n    EDGEHUB = \\'edgeHubDev\\'\\n    INPUT = \\'input\\'\\n    NW_NAME = \\'azure-iot-edge-dev\\'\\n    MOUNT_BASE = \\'mnt\\'\\n    HUB_VOLUME = \\'edgehubdev\\'\\n    HUB_MOUNT = \\'{0}/edgehub\\'\\n    MODULE_VOLUME = \\'edgemoduledev\\'\\n    MODULE_MOUNT = \\'{0}/edgemodule\\'\\n    HUB_CA_ENV = \\'EdgeModuleHubServerCAChainCertificateFile={0}/edgehub/edge-chain-ca.cert.pem\\'\\n    HUB_CERT_ENV = \\'EdgeModuleHubServerCertificateFile={0}/edgehub/edge-hub-server.cert.pfx\\'\\n    HUB_SRC_ENV = \\'configSource=local\\'\\n    MODULE_CA_ENV = \"EdgeModuleCACertificateFile={0}/edgemodule/edge-device-ca.cert.pem\"\\n    HUB_SSLPATH_ENV = \\'SSL_CERTIFICATE_PATH={0}/edgehub/\\'\\n    HUB_SSLCRT_ENV = \\'SSL_CERTIFICATE_NAME=edge-hub-server.cert.pfx\\'\\n    CERT_HELPER = \\'cert_helper\\'\\n    HELPER_IMG = \\'hello-world:latest\\'\\n    COMPOSE_FILE = os.path.join(HostPlatform.get_share_data_path(), \\'docker-compose.yml\\')\\n\\n    def __init__(self, connection_str, gatewayhost, cert_path, hub_conn_str=None):\\n        connection_str_dict = Utils.parse_connection_strs(connection_str, hub_conn_str)\\n        self._hostname = connection_str_dict[EC.HOSTNAME_KEY]\\n        self._device_id = connection_str_dict[EC.DEVICE_ID_KEY]\\n        self._access_key = connection_str_dict[EC.DEVICE_ACCESS_KEY_KEY]\\n        self._compose_file = None\\n        self._gatewayhost = gatewayhost\\n        self._device_uri = \\'{0}/devices/{1}\\'.format(self._hostname, self._device_id)\\n        self._cert_path = cert_path\\n        self._edge_cert = EdgeCert(self._cert_path, self._gatewayhost)\\n        self._hub_access_key = connection_str_dict.get(EC.HUB_ACCESS_KEY_KEY)\\n        self._hub_access_name = connection_str_dict.get(EC.ACCESS_KEY_NAME)\\n\\n    @property\\n    def hostname(self):\\n        return self._hostname\\n\\n    @staticmethod\\n    def stop(edgedockerclient=None):\\n        if edgedockerclient is None:\\n            edgedockerclient = EdgeDockerClient()\\n\\n        compose_err = None\\n        label_err = None\\n        try:\\n            if os.path.exists(EdgeManager.COMPOSE_FILE):\\n                cmd = \"docker-compose -f {0} down\".format(EdgeManager.COMPOSE_FILE)\\n                Utils.exe_proc(cmd.split())\\n        except Exception as e:\\n            compose_err = e\\n\\n        try:\\n            edgedockerclient.stop_remove_by_label(EdgeManager.LABEL)\\n        except Exception as e:\\n            label_err = e\\n\\n        if compose_err or label_err:\\n            raise Exception(\\'{0}{1}\\'.format(\\n                \\'\\' if compose_err is None else str(compose_err),\\n                \\'\\' if label_err is None else str(label_err)))\\n\\n    def start_singlemodule(self, inputs, port, envs, edgehub_image_version):\\n        edgedockerclient = EdgeDockerClient()\\n        mount_base = self._obtain_mount_path(edgedockerclient)\\n        if mount_base is None:\\n            raise Exception(\"OS Type is not supported\")\\n\\n        EdgeManager.stop(edgedockerclient)\\n        self._prepare(edgedockerclient)\\n\\n        edgeHubConnStr = self.getOrAddModule(EdgeManager.EDGEHUB_MODULE, False)\\n        inputConnStr = self.getOrAddModule(EdgeManager.INPUT, False)\\n        routes = self._generateRoutesEnvFromInputs(inputs)\\n        self._start_edge_hub(edgedockerclient, edgeHubConnStr, routes, mount_base, envs, edgehub_image_version)\\n\\n        module_mount = EdgeManager.MODULE_MOUNT.format(mount_base)\\n        edgedockerclient.pullIfNotExist(EdgeManager.TESTUTILITY_IMG, None, None)\\n        network_config = edgedockerclient.create_config_for_network(EdgeManager.NW_NAME)\\n        inputEnv = [EdgeManager.MODULE_CA_ENV.format(mount_base), \"EdgeHubConnectionString={0}\".format(inputConnStr)]\\n        input_host_config = edgedockerclient.create_host_config(\\n            mounts=[docker.types.Mount(module_mount, EdgeManager.MODULE_VOLUME)],\\n            port_bindings={\\n                \\'3000\\': port\\n            },\\n            restart_policy={\\n                \\'MaximumRetryCount\\': 3,\\n                \\'Name\\': \\'on-failure\\'\\n            }\\n        )\\n        inputContainer = edgedockerclient.create_container(\\n            EdgeManager.TESTUTILITY_IMG,\\n            name=EdgeManager.INPUT,\\n            volumes=[module_mount],\\n            host_config=input_host_config,\\n            networking_config=network_config,\\n            environment=inputEnv,\\n            labels=[EdgeManager.LABEL],\\n            ports=[(3000, \\'tcp\\')]\\n        )\\n\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.INPUT, EdgeManager.MODULE_VOLUME, self._device_cert(),\\n            module_mount,\\n            self._edge_cert.get_cert_file_path(EC.EDGE_DEVICE_CA))\\n        edgedockerclient.start(inputContainer.get(\\'Id\\'))\\n\\n    def config_solution(self, module_content, target, mount_base):\\n        module_names = [EdgeManager.EDGEHUB_MODULE]\\n        custom_modules = module_content[\\'$edgeAgent\\'][\\'properties.desired\\'][\\'modules\\']\\n        for module_name in custom_modules:\\n            module_names.append(module_name)\\n\\n        ConnStr_info = {}\\n        for module_name in module_names:\\n            ConnStr_info[module_name] = self.getOrAddModule(module_name, False)\\n\\n        env_info = {\\n            \\'hub_env\\': [\\n                EdgeManager.HUB_CA_ENV.format(mount_base),\\n                EdgeManager.HUB_CERT_ENV.format(mount_base),\\n                EdgeManager.HUB_SRC_ENV,\\n                EdgeManager.HUB_SSLPATH_ENV.format(mount_base),\\n                EdgeManager.HUB_SSLCRT_ENV\\n            ],\\n            \\'module_env\\': [\\n                EdgeManager.MODULE_CA_ENV.format(mount_base)\\n            ]\\n        }\\n\\n        volume_info = {\\n            \\'HUB_MOUNT\\': EdgeManager.HUB_MOUNT.format(mount_base),\\n            \\'HUB_VOLUME\\': EdgeManager.HUB_VOLUME,\\n            \\'MODULE_VOLUME\\': EdgeManager.MODULE_VOLUME,\\n            \\'MODULE_MOUNT\\': EdgeManager.MODULE_MOUNT.format(mount_base)\\n        }\\n\\n        network_info = {\\n            \\'NW_NAME\\': EdgeManager.NW_NAME,\\n            \\'ALIASES\\': self._gatewayhost\\n        }\\n\\n        compose_project = ComposeProject(module_content)\\n        compose_project.set_edge_info({\\n            \\'ConnStr_info\\': ConnStr_info,\\n            \\'env_info\\': env_info,\\n            \\'volume_info\\': volume_info,\\n            \\'network_info\\': network_info,\\n            \\'hub_name\\': EdgeManager.EDGEHUB,\\n            \\'labels\\': EdgeManager.LABEL\\n        })\\n\\n        compose_project.compose()\\n        compose_project.dump(target)\\n\\n    def start_solution(self, module_content, verbose, output):\\n        try:\\n            EdgeManager.login_registries(module_content)\\n        except RegistriesLoginError as e:\\n            output.warning(e.getmsg())\\n\\n        edgedockerclient = EdgeDockerClient()\\n        mount_base = self._obtain_mount_path(edgedockerclient)\\n        if not mount_base:\\n            raise Exception(\"OS Type is not supported\")\\n\\n        EdgeManager.stop(edgedockerclient)\\n        self._prepare(edgedockerclient)\\n        self._prepare_cert(edgedockerclient, mount_base)\\n\\n        self.config_solution(module_content, EdgeManager.COMPOSE_FILE, mount_base)\\n        try:\\n            self.update_module_twin(module_content)\\n        except Exception as e:\\n            output.warning(str(e))\\n\\n        cmd_pull = [\\'docker-compose\\', \\'-f\\', EdgeManager.COMPOSE_FILE, \\'pull\\', EdgeManager.EDGEHUB]\\n        Utils.exe_proc(cmd_pull)\\n        if verbose:\\n            cmd_up = [\\'docker-compose\\', \\'-f\\', EdgeManager.COMPOSE_FILE, \\'up\\']\\n        else:\\n            cmd_up = [\\'docker-compose\\', \\'-f\\', EdgeManager.COMPOSE_FILE, \\'up\\', \\'-d\\']\\n        Utils.exe_proc(cmd_up)\\n\\n    def update_module_twin(self, module_content):\\n        if self._hub_access_key is None:\\n            return\\n\\n        twinErrorMsg = \\'\\'\\n        sas = Utils.get_iot_hub_sas_token(self._hostname, self._hub_access_key, self._hub_access_name)\\n        for name in module_content:\\n            if name == \\'$edgeAgent\\' or name == \\'$edgeHub\\':\\n                continue\\n            twin = module_content.get(name).get(\\'properties.desired\\')\\n            uri = self._get_update_twin_uri(name)\\n            res = requests.patch(\\n                uri,\\n                headers={\\n                    \\'Authorization\\': sas,\\n                    \\'Content-Type\\': \"application/json\",\\n                    \\'If-Match\\': \\'\"*\"\\'\\n                },\\n                data=json.dumps({\\n                    \\'properties\\': {\\n                        \\'desired\\': twin\\n                    }\\n                })\\n            )\\n            if res.ok is not True:\\n                twinErrorMsg += \\'Fail to update {0} twin. Code:{1}. Detail:{2}\\'.format(name, res.status_code, res.text)\\n        if twinErrorMsg:\\n            raise Exception(twinErrorMsg)\\n\\n    @staticmethod\\n    def login_registries(module_content):\\n        registryCredentials = module_content.get(\\'$edgeAgent\\', {}).get(\\'properties.desired\\', {}).get(\\n            \\'runtime\\', {}).get(\\'settings\\', {}).get(\\'registryCredentials\\')\\n        if not registryCredentials:\\n            return\\n        failLogin = []\\n        errMsg = \\'\\'\\n        for key in registryCredentials:\\n            value = registryCredentials[key]\\n            try:\\n                cmd_login = [\\'docker\\', \\'login\\', \\'-u\\', value[\\'username\\'], \\'-p\\', value[\\'password\\'], value[\\'address\\']]\\n                Utils.exe_proc(cmd_login)\\n            except Exception as e:\\n                failLogin.append(key)\\n                errMsg += \\'{0}\\\\n\\'.format(str(e))\\n        if failLogin:\\n            raise RegistriesLoginError(failLogin, errMsg)\\n\\n    def _prepare_cert(self, edgedockerclient, mount_base):\\n        status = edgedockerclient.status(EdgeManager.CERT_HELPER)\\n        if status is not None:\\n            edgedockerclient.stop(EdgeManager.CERT_HELPER)\\n            edgedockerclient.remove(EdgeManager.CERT_HELPER)\\n\\n        hub_mount = EdgeManager.HUB_MOUNT.format(mount_base)\\n        module_mount = EdgeManager.MODULE_MOUNT.format(mount_base)\\n\\n        helper_host_config = edgedockerclient.create_host_config(\\n            mounts=[docker.types.Mount(hub_mount, EdgeManager.HUB_VOLUME),\\n                    docker.types.Mount(module_mount, EdgeManager.MODULE_VOLUME)]\\n        )\\n\\n        edgedockerclient.pull(EdgeManager.HELPER_IMG, None, None)\\n\\n        edgedockerclient.create_container(\\n            EdgeManager.HELPER_IMG,\\n            name=EdgeManager.CERT_HELPER,\\n            volumes=[hub_mount, module_mount],\\n            host_config=helper_host_config,\\n            labels=[EdgeManager.LABEL]\\n        )\\n\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.CERT_HELPER, EdgeManager.HUB_VOLUME, EdgeManager._chain_cert(),\\n            hub_mount, self._edge_cert.get_cert_file_path(EC.EDGE_CHAIN_CA))\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.CERT_HELPER, EdgeManager.HUB_VOLUME, EdgeManager._hubserver_pfx(),\\n            hub_mount, self._edge_cert.get_pfx_file_path(EC.EDGE_HUB_SERVER))\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.CERT_HELPER, EdgeManager.MODULE_VOLUME, self._device_cert(),\\n            module_mount, self._edge_cert.get_cert_file_path(EC.EDGE_DEVICE_CA))\\n\\n    def start(self, modulesDict, routes):\\n        return\\n\\n    def getOrAddModule(self, name, islocal):\\n        try:\\n            return self.getModule(name, islocal)\\n        except ResponseError as geterr:\\n            if geterr.status_code == 404:\\n                try:\\n                    return self.addModule(name, islocal)\\n                except ResponseError as adderr:\\n                    if adderr.status_code == 400:\\n                        raise ResponseError(400, adderr.value + \" Please make sure you are using an Edge device.\")\\n                    raise adderr\\n            else:\\n                raise geterr\\n\\n    def outputModuleCred(self, names, islocal, output_file):\\n        connstrENV = \\'EdgeHubConnectionString={0}\\'.format(\\'|\\'.join([self.getOrAddModule(name, islocal) for name in names]))\\n        deviceCAEnv = \\'EdgeModuleCACertificateFile={0}\\'.format(self._edge_cert.get_cert_file_path(EC.EDGE_DEVICE_CA))\\n        cred = [connstrENV, deviceCAEnv]\\n\\n        if output_file is not None:\\n            output_path = os.path.abspath(output_file)\\n            dir = os.path.dirname(output_path)\\n            if not os.path.exists(dir):\\n                os.makedirs(dir)\\n            with open(output_path, \\'w+\\') as envFile:\\n                envFile.writelines([\\'\\\\n\\', cred[0], \\'\\\\n\\', cred[1]])\\n        return cred\\n\\n    def getModule(self, name, islocal):\\n        moduleUri = self._getModuleReqUri(name)\\n        sas = Utils.get_iot_hub_sas_token(self._device_uri, self._access_key, None)\\n        res = requests.get(\\n            moduleUri,\\n            headers={\\n                \\'Authorization\\': sas,\\n                \\'Content-Type\\': \\'application/json\\'\\n            }\\n        )\\n        if res.ok is not True:\\n            raise ResponseError(res.status_code, res.text)\\n        else:\\n            jsonObj = res.json()\\n            auth = jsonObj[\\'authentication\\']\\n            if auth is not None:\\n                authType = auth[\\'type\\']\\n                authKey = auth[\\'symmetricKey\\']\\n                if authType == \\'sas\\' and authKey is not None and authKey[\\'primaryKey\\'] is not None:\\n                    return self._generateModuleConnectionStr(res, islocal)\\n            return self.updateModule(name, jsonObj[\\'etag\\'], islocal)\\n\\n    def updateModule(self, name, etag, islocal):\\n        moduleUri = self._getModuleReqUri(name)\\n        sas = Utils.get_iot_hub_sas_token(self._device_uri, self._access_key, None)\\n        res = requests.put(\\n            moduleUri,\\n            headers={\\n                \\'Authorization\\': sas,\\n                \\'Content-Type\\': \"application/json\",\\n                \\'If-Match\\': \\'\"*\"\\'\\n            },\\n            data=json.dumps({\\n                \\'moduleId\\': name,\\n                \\'deviceId\\': self._device_id,\\n                \\'authentication\\': {\\n                    \\'type\\': \\'sas\\'\\n                }\\n            })\\n        )\\n        if res.ok is not True:\\n            raise ResponseError(res.status_code, res.text)\\n        return self._generateModuleConnectionStr(res, islocal)\\n\\n    def addModule(self, name, islocal):\\n        moduleUri = self._getModuleReqUri(name)\\n        sas = Utils.get_iot_hub_sas_token(self._device_uri, self._access_key, None)\\n        res = requests.put(\\n            moduleUri,\\n            headers={\\n                \"Authorization\": sas,\\n                \"Content-Type\": \"application/json\"\\n            },\\n            data=json.dumps({\\n                \\'moduleId\\': name,\\n                \\'deviceId\\': self._device_id\\n            })\\n        )\\n        if res.ok is not True:\\n            raise ResponseError(res.status_code, res.text)\\n        return self._generateModuleConnectionStr(res, islocal)\\n\\n    def _getModuleReqUri(self, name):\\n        return \"https://{0}/devices/{1}/modules/{2}?api-version=2018-06-30\".format(\\n            self._hostname, self._device_id, name)\\n\\n    def _get_update_twin_uri(self, name):\\n        return \"https://{0}/twins/{1}/modules/{2}?api-version=2018-06-30\".format(\\n            self._hostname, self._device_id, name)\\n\\n    def _generateModuleConnectionStr(self, response, islocal):\\n        jsonObj = response.json()\\n        moduleId = jsonObj[\\'moduleId\\']\\n        deviceId = jsonObj[\\'deviceId\\']\\n        sasKey = jsonObj[\\'authentication\\'][\\'symmetricKey\\'][\\'primaryKey\\']\\n        hubTemplate = \\'HostName={0};DeviceId={1};ModuleId={2};SharedAccessKey={3}\\'\\n        moduleTemplate = \\'HostName={0};GatewayHostName={1};DeviceId={2};ModuleId={3};SharedAccessKey={4}\\'\\n        gatewayhost = self._gatewayhost\\n        if (islocal):\\n            gatewayhost = \\'localhost\\'\\n        if (moduleId == \\'$edgeHub\\'):\\n            return hubTemplate.format(self._hostname, deviceId, moduleId, sasKey)\\n        else:\\n            return moduleTemplate.format(self._hostname, gatewayhost, deviceId, moduleId, sasKey)\\n\\n    def _generateRoutesEnvFromInputs(self, inputs):\\n        routes = [\\n            \\'routes__output=FROM /messages/modules/target/outputs/* INTO BrokeredEndpoint(\"/modules/input/inputs/print\")\\'\\n        ]\\n        template = \\'routes__r{0}=FROM /messages/modules/input/outputs/{1} INTO BrokeredEndpoint(\"/modules/target/inputs/{2}\")\\'\\n        inputSet = set(inputs)\\n        for (idx, input) in enumerate(inputSet):\\n            routes.append(template.format(idx + 1, input, input))\\n        return routes\\n\\n    def _prepare(self, edgedockerclient):\\n        edgedockerclient.create_network(EdgeManager.NW_NAME)\\n        edgedockerclient.create_volume(EdgeManager.HUB_VOLUME)\\n        edgedockerclient.create_volume(EdgeManager.MODULE_VOLUME)\\n\\n    def _start_edge_hub(self, edgedockerclient, edgeHubConnStr, routes, mount_base, envs, edgehub_image_version):\\n        edgehub_image = EdgeManager.EDGEHUB_IMG.format(edgehub_image_version)\\n        edgedockerclient.pull(edgehub_image, None, None)\\n        network_config = edgedockerclient.create_config_for_network(EdgeManager.NW_NAME, aliases=[self._gatewayhost])\\n        hub_mount = EdgeManager.HUB_MOUNT.format(mount_base)\\n        hub_host_config = edgedockerclient.create_host_config(\\n            mounts=[docker.types.Mount(hub_mount, EdgeManager.HUB_VOLUME)],\\n            port_bindings={\\n                \\'8883\\': 8883,\\n                \\'443\\': 443,\\n                \\'5671\\': 5671\\n            }\\n        )\\n        hubEnv = [\\n            EdgeManager.HUB_CA_ENV.format(mount_base),\\n            EdgeManager.HUB_CERT_ENV.format(mount_base),\\n            EdgeManager.HUB_SRC_ENV,\\n            EdgeManager.HUB_SSLPATH_ENV.format(mount_base),\\n            EdgeManager.HUB_SSLCRT_ENV,\\n            \\'IotHubConnectionString={0}\\'.format(edgeHubConnStr)]\\n        hubEnv.extend(routes)\\n        hubEnv.extend(list(envs))\\n\\n        hubContainer = edgedockerclient.create_container(\\n            edgehub_image,\\n            name=EdgeManager.EDGEHUB,\\n            volumes=[hub_mount],\\n            host_config=hub_host_config,\\n            networking_config=network_config,\\n            environment=hubEnv,\\n            labels=[EdgeManager.LABEL],\\n            ports=[(8883, \\'tcp\\'), (443, \\'tcp\\'), (5671, \\'tcp\\')]\\n        )\\n\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.EDGEHUB, EdgeManager.HUB_VOLUME, EdgeManager._chain_cert(),\\n            hub_mount, self._edge_cert.get_cert_file_path(EC.EDGE_CHAIN_CA))\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.EDGEHUB, EdgeManager.HUB_VOLUME, EdgeManager._hubserver_pfx(),\\n            hub_mount, self._edge_cert.get_pfx_file_path(EC.EDGE_HUB_SERVER))\\n        edgedockerclient.start(hubContainer.get(\\'Id\\'))\\n\\n    def _obtain_mount_path(self, edgedockerclient):\\n        os_type = edgedockerclient.get_os_type().lower()\\n        if os_type == \\'linux\\':\\n            return \\'/{0}\\'.format(EdgeManager.MOUNT_BASE)\\n        elif os_type == \\'windows\\':\\n            return \\'c:/{0}\\'.format(EdgeManager.MOUNT_BASE)\\n\\n    @staticmethod\\n    def _chain_cert():\\n        return EC.EDGE_CHAIN_CA + EC.CERT_SUFFIX\\n\\n    @staticmethod\\n    def _hubserver_pfx():\\n        return EC.EDGE_HUB_SERVER + EC.PFX_SUFFIX\\n\\n    @staticmethod\\n    def _device_cert():\\n        return EC.EDGE_DEVICE_CA + EC.CERT_SUFFIX\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nclass EdgeError(Exception):\\n    def __init__(self, msg, ex=None):\\n        if ex:\\n            msg += ' : {0}'.format(str(ex))\\n        super(EdgeError, self).__init__(msg)\\n        self._ex = ex\\n\\n\\nclass EdgeInvalidArgument(EdgeError):\\n    def __init__(self, msg, ex=None):\\n        super(EdgeInvalidArgument, self).__init__(msg, ex)\\n\\n\\nclass EdgeValueError(EdgeError):\\n    def __init__(self, msg, ex=None):\\n        super(EdgeValueError, self).__init__(msg, ex)\\n\\n\\nclass EdgeFileAccessError(EdgeError):\\n    def __init__(self, msg, file_name, ex=None):\\n        msg += ': {0}'.format(file_name)\\n        super(EdgeFileAccessError, self).__init__(msg, ex)\\n        self.file_name = file_name\\n\\n\\nclass EdgeFileParseError(EdgeError):\\n    def __init__(self, msg, file_name, ex=None):\\n        msg += ': {0}'.format(file_name)\\n        super(EdgeFileParseError, self).__init__(msg, ex)\\n        self.file_name = file_name\\n\\n\\nclass EdgeDeploymentError(EdgeError):\\n    def __init__(self, msg, ex=None):\\n        super(EdgeDeploymentError, self).__init__(msg, ex)\\n\\n\\nclass ResponseError(EdgeError):\\n    def __init__(self, status_code, value):\\n        super(ResponseError, self).__init__('Code:{0}. Detail:{1}'.format(status_code, value))\\n        self.value = value\\n        self.status_code = status_code\\n\\n\\nclass RegistriesLoginError(EdgeError):\\n    def __init__(self, registries, errmsg):\\n        super(RegistriesLoginError, self).__init__(errmsg)\\n        self._registries = registries\\n        self._errmsg = errmsg\\n\\n    def getmsg(self):\\n        return ('Fail to login {0}. Detail: {1}').format(self._registries, self._errmsg)\\n\\n    def registries(self):\\n        return self._registries\\n\\n\\nclass InvalidConfigError(EdgeError):\\n    def __init__(self, msg):\\n        super(InvalidConfigError, self).__init__(msg)\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport os\\nimport platform\\nfrom .errors import EdgeInvalidArgument\\n\\n\\nclass HostPlatform(object):\\n    _edge_dir = 'iotedgehubdev'\\n    _edgehub_config = 'edgehub.json'\\n    _setting_ini = 'setting.ini'\\n    _certs = 'certs'\\n    _data = 'data'\\n    _windows_config_path = os.getenv('PROGRAMDATA', '%%PROGRAMDATA%%')\\n\\n    _platforms = {\\n        'linux': {\\n            'supported_deployments': ['docker'],\\n            'default_deployment': 'docker',\\n            'default_edge_conf_dir': '/etc/' + _edge_dir,\\n            'default_edge_data_dir': '/var/lib/' + _edge_dir,\\n            'default_edge_meta_dir_env': 'HOME',\\n            'deployment': {\\n                'docker': {\\n                    'linux': {\\n                        'default_uri': 'unix:///var/run/docker.sock'\\n                    },\\n                }\\n            }\\n        },\\n        'windows': {\\n            'supported_deployments': ['docker'],\\n            'default_deployment': 'docker',\\n            'default_edge_conf_dir': _windows_config_path + '\\\\\\\\' + _edge_dir + '\\\\\\\\config',\\n            'default_edge_data_dir': _windows_config_path + '\\\\\\\\' + _edge_dir + '\\\\\\\\data',\\n            'default_edge_meta_dir_env': 'USERPROFILE',\\n            'deployment': {\\n                'docker': {\\n                    'linux': {\\n                        'default_uri': 'unix:///var/run/docker.sock'\\n                    },\\n                    'windows': {\\n                        'default_uri': 'npipe://./pipe/docker_engine'\\n                    }\\n                }\\n            }\\n        },\\n        'darwin': {\\n            'supported_deployments': ['docker'],\\n            'default_deployment': 'docker',\\n            'default_edge_conf_dir': '/etc/' + _edge_dir,\\n            'default_edge_data_dir': '/var/lib/' + _edge_dir,\\n            'default_edge_meta_dir_env': 'HOME',\\n            'deployment': {\\n                'docker': {\\n                    'linux': {\\n                        'default_uri': 'unix:///var/run/docker.sock'\\n                    },\\n                }\\n            }\\n        }\\n    }\\n\\n    # @staticmethod\\n    # def is_host_supported(host):\\n    #     if host is None:\\n    #         raise EdgeInvalidArgument('host cannot be None')\\n\\n    #     host = host.lower()\\n    #     if host in _platforms:\\n    #         return True\\n    #     return False\\n\\n    @staticmethod\\n    def get_config_path():\\n        host = platform.system()\\n        if host is None:\\n            raise EdgeInvalidArgument('host cannot be None')\\n        host = host.lower()\\n        if host in HostPlatform._platforms:\\n            return HostPlatform._platforms[host]['default_edge_conf_dir']\\n        return None\\n\\n    @staticmethod\\n    def get_config_file_path():\\n        configPath = HostPlatform.get_config_path()\\n        if configPath is not None:\\n            return os.path.join(configPath, HostPlatform._edgehub_config)\\n        return None\\n\\n    @staticmethod\\n    def get_setting_ini_path():\\n        configPath = HostPlatform.get_config_path()\\n        if configPath is not None:\\n            return os.path.join(configPath, HostPlatform._setting_ini)\\n        return None\\n\\n    @staticmethod\\n    def get_default_cert_path():\\n        host = platform.system()\\n        if host is None:\\n            raise EdgeInvalidArgument('host cannot be None')\\n        host = host.lower()\\n        if host in HostPlatform._platforms:\\n            return os.path.join(HostPlatform._platforms[host]['default_edge_data_dir'], HostPlatform._certs)\\n        return None\\n\\n    @staticmethod\\n    def get_share_data_path():\\n        host = platform.system()\\n        if host is None:\\n            raise EdgeInvalidArgument('host cannot be None')\\n        host = host.lower()\\n        if host in HostPlatform._platforms:\\n            return os.path.join(HostPlatform._platforms[host]['default_edge_data_dir'], HostPlatform._data)\\n        return None\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport click\\n\\n\\nclass Output:\\n\\n    def info(self, text, suppress=False):\\n        if not suppress:\\n            self.echo(text, color=\\'yellow\\')\\n\\n    def status(self, text):\\n        self.info(text)\\n        self.line()\\n\\n    def prompt(self, text):\\n        self.echo(text, color=\\'white\\')\\n\\n    def warning(self, text):\\n        self.echo(\"WARNING: \" + text, color=\\'yellow\\')\\n\\n    def error(self, text):\\n        self.echo(\"ERROR: \" + text, color=\\'red\\', err=True)\\n\\n    def header(self, text, suppress=False):\\n\\n        if not suppress:\\n            self.line()\\n            s = \"======== {0} ========\".format(text).upper()\\n            m = \"=\" * len(s)\\n            self.echo(m, color=\\'white\\')\\n            self.echo(s, color=\\'white\\')\\n            self.echo(m, color=\\'white\\')\\n            self.line()\\n\\n    def param(self, text, value, status, suppress):\\n        if value and not suppress:\\n            self.header(\"SETTING \" + text)\\n            self.status(status)\\n\\n    def footer(self, text, suppress=False):\\n        if not suppress:\\n            self.info(text.upper())\\n            self.line()\\n\\n    def procout(self, text):\\n        self.echo(text, dim=True)\\n\\n    def line(self):\\n        self.echo(text=\"\")\\n\\n    def echo(self, text, color=\"\", dim=False, err=False):\\n        try:\\n            click.secho(text, fg=color, dim=dim, err=err)\\n        except Exception:\\n            print(text)\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport datetime\\nimport json\\nimport platform\\nimport uuid\\nimport multiprocessing\\n\\nfrom collections import defaultdict\\nfrom functools import wraps\\n\\n\\nfrom . import configs, decorators\\nfrom . import telemetry_upload as telemetry_core\\nfrom . import __production__ as production_name\\n\\nPRODUCT_NAME = production_name\\n\\n\\nclass TelemetrySession(object):\\n    def __init__(self, correlation_id=None):\\n        self.start_time = None\\n        self.end_time = None\\n        self.correlation_id = correlation_id or str(uuid.uuid4())\\n        self.command = 'command_name'\\n        self.parameters = []\\n        self.result = 'None'\\n        self.result_summary = None\\n        self.exception = None\\n        self.extra_props = {}\\n        self.machineId = self._get_hash_mac_address()\\n        self.events = defaultdict(list)\\n\\n    def generate_payload(self):\\n        props = {\\n            'EventId': str(uuid.uuid4()),\\n            'CorrelationId': self.correlation_id,\\n            'MachineId': self.machineId,\\n            'ProductName': PRODUCT_NAME,\\n            'ProductVersion': _get_core_version(),\\n            'CommandName': self.command,\\n            'OS.Type': platform.system().lower(),\\n            'OS.Version': platform.version().lower(),\\n            'Result': self.result,\\n            'StartTime': str(self.start_time),\\n            'EndTime': str(self.end_time),\\n            'Parameters': ','.join(self.parameters)\\n        }\\n\\n        if self.result_summary:\\n            props['ResultSummary'] = self.result_summary\\n\\n        if self.exception:\\n            props['Exception'] = self.exception\\n\\n        props.update(self.extra_props)\\n\\n        self.events[_get_AI_key()].append({\\n            'name': '{}/command'.format(PRODUCT_NAME),\\n            'properties': props\\n        })\\n\\n        payload = json.dumps(self.events)\\n        return _remove_symbols(payload)\\n\\n    @decorators.suppress_all_exceptions()\\n    @decorators.hash256_result\\n    def _get_hash_mac_address(self):\\n        s = ''\\n        for index, c in enumerate(hex(uuid.getnode())[2:].upper()):\\n            s += c\\n            if index % 2:\\n                s += '-'\\n\\n        s = s.strip('-')\\n        return s\\n\\n\\n_session = TelemetrySession()\\n\\n\\ndef _user_agrees_to_telemetry(func):\\n    @wraps(func)\\n    def _wrapper(*args, **kwargs):\\n        if not configs.get_ini_config().getboolean('DEFAULT', 'collect_telemetry'):\\n            return None\\n        return func(*args, **kwargs)\\n\\n    return _wrapper\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef start(cmdname, params=[]):\\n    _session.command = cmdname\\n    _session.start_time = datetime.datetime.utcnow()\\n    if params is not None:\\n        _session.parameters.extend(params)\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef success():\\n    _session.result = 'Success'\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef fail(exception, summary):\\n    _session.exception = exception\\n    _session.result = 'Fail'\\n    _session.result_summary = summary\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef add_extra_props(props):\\n    if props is not None:\\n        _session.extra_props.update(props)\\n\\n\\n@_user_agrees_to_telemetry\\n@decorators.suppress_all_exceptions()\\ndef flush():\\n    # flush out current information\\n    _session.end_time = datetime.datetime.utcnow()\\n\\n    payload = _session.generate_payload()\\n    if payload:\\n        _upload_telemetry_with_user_agreement(payload)\\n\\n    # reset session fields, retaining correlation id and application\\n    _session.__init__(correlation_id=_session.correlation_id)\\n\\n\\n@decorators.suppress_all_exceptions(fallback_return=None)\\ndef _get_core_version():\\n    from iotedgehubdev import __version__ as core_version\\n    return core_version\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef _get_AI_key():\\n    from iotedgehubdev import __AIkey__ as key\\n    return key\\n\\n\\n# This includes a final user-agreement-check; ALL methods sending telemetry MUST call this.\\n@_user_agrees_to_telemetry\\n@decorators.suppress_all_exceptions()\\ndef _upload_telemetry_with_user_agreement(payload):\\n    p = multiprocessing.Process(target=telemetry_core.upload, args=(payload,))\\n    p.start()\\n\\n\\ndef _remove_symbols(s):\\n    if isinstance(s, str):\\n        for c in '$%^&|':\\n            s = s.replace(c, '_')\\n    return s\\n\""}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport urllib.request as HTTPClient\\nimport sys\\nimport json\\n\\nfrom applicationinsights import TelemetryClient\\nfrom applicationinsights.exceptions import enable\\nfrom applicationinsights.channel import SynchronousSender, SynchronousQueue, TelemetryChannel\\nfrom iotedgehubdev import decorators\\n\\n\\nclass LimitedRetrySender(SynchronousSender):\\n    def __init__(self):\\n        super(LimitedRetrySender, self).__init__()\\n\\n    def send(self, data_to_send):\\n        \"\"\" Override the default resend mechanism in SenderBase. Stop resend when it fails.\"\"\"\\n        request_payload = json.dumps([a.write() for a in data_to_send])\\n\\n        request = HTTPClient.Request(self._service_endpoint_uri, bytearray(request_payload, \\'utf-8\\'),\\n                                     {\\'Accept\\': \\'application/json\\', \\'Content-Type\\': \\'application/json; charset=utf-8\\'})\\n        try:\\n            HTTPClient.urlopen(request, timeout=10)\\n        except Exception:  # pylint: disable=broad-except\\n            pass\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef upload(data_to_save):\\n    try:\\n        data_to_save = json.loads(data_to_save)\\n    except Exception:\\n        pass\\n\\n    for instrumentation_key in data_to_save:\\n        client = TelemetryClient(instrumentation_key=instrumentation_key,\\n                                 telemetry_channel=TelemetryChannel(queue=SynchronousQueue(LimitedRetrySender())))\\n        enable(instrumentation_key)\\n        for record in data_to_save[instrumentation_key]:\\n            name = record[\\'name\\']\\n            raw_properties = record[\\'properties\\']\\n            properties = {}\\n            measurements = {}\\n            for k, v in raw_properties.items():\\n                if isinstance(v, str):\\n                    properties[k] = v\\n                else:\\n                    measurements[k] = v\\n            client.track_event(name, properties, measurements)\\n        client.flush()\\n\\n\\nif __name__ == \\'__main__\\':\\n    # If user doesn\\'t agree to upload telemetry, this scripts won\\'t be executed. The caller should control.\\n    upload(sys.argv[1])\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport errno\\nimport os\\nimport shutil\\nimport socket\\nimport stat\\nimport subprocess\\n\\n\\nfrom base64 import b64decode, b64encode\\nfrom hashlib import sha256\\nfrom hmac import HMAC\\nfrom time import time\\nfrom urllib.parse import urlencode, quote_plus\\nfrom .constants import EdgeConstants as EC\\nfrom .decorators import suppress_all_exceptions\\nfrom .errors import EdgeFileAccessError\\n\\n\\nclass Utils(object):\\n    @staticmethod\\n    def parse_connection_strs(device_conn_str, hub_conn_str=None):\\n        data = Utils._parse_device_connection_str(device_conn_str)\\n        data[EC.DEVICE_ACCESS_KEY_KEY] = data.pop(EC.ACCESS_KEY_KEY)\\n        if hub_conn_str is not None:\\n            hub_data = Utils._parse_hub_connection_str(hub_conn_str, data[EC.HOSTNAME_KEY])\\n            data[EC.HUB_ACCESS_KEY_KEY] = hub_data[EC.ACCESS_KEY_KEY]\\n            data[EC.ACCESS_KEY_NAME] = hub_data[EC.ACCESS_KEY_NAME]\\n        return data\\n\\n    @staticmethod\\n    def _parse_device_connection_str(connection_string):\\n        data = Utils._split_connection_string(connection_string)\\n        if len(data) > 0:\\n            if EC.HOSTNAME_KEY not in data or EC.DEVICE_ID_KEY not in data or EC.ACCESS_KEY_KEY not in data:\\n                if EC.ACCESS_KEY_NAME in data:\\n                    raise KeyError(\\'Please make sure you are using a device connection string \\'\\n                                   \\'instead of an IoT Hub connection string\\')\\n                else:\\n                    raise KeyError(\\'Error parsing connection string. \\'\\n                                   \\'Please make sure you wrap the connection string with double quotes when supplying it via CLI\\')\\n            return data\\n        else:\\n            raise KeyError(\\'Error parsing connection string\\')\\n\\n    @staticmethod\\n    def _parse_hub_connection_str(hub_connection_string, host_name):\\n        hub_data = Utils._split_connection_string(hub_connection_string)\\n        if len(hub_data) > 0:\\n            if EC.HOSTNAME_KEY not in hub_data or EC.ACCESS_KEY_NAME not in hub_data or EC.ACCESS_KEY_KEY not in hub_data:\\n                if EC.DEVICE_ID_KEY in hub_data:\\n                    raise KeyError(\\'Please make sure you are using a IoT Hub connection string \\'\\n                                   \\'instead of an device connection string\\')\\n                else:\\n                    raise KeyError(\\'Error parsing connection string. \\'\\n                                   \\'Please make sure you wrap the connection string with double quotes when supplying it via CLI\\')\\n            elif hub_data[EC.HOSTNAME_KEY] != host_name:\\n                raise KeyError(\\'Please make sure the device belongs to the IoT Hub\\')\\n            return hub_data\\n        else:\\n            raise KeyError(\\'Error parsing IoT Hub connection string\\')\\n\\n    @staticmethod\\n    def _split_connection_string(connection_string):\\n        data = dict()\\n        if connection_string is not None:\\n            parts = connection_string.split(\\';\\')\\n            for part in parts:\\n                if \"=\" in part:\\n                    subparts = [s.strip() for s in part.split(\"=\", 1)]\\n                    data[subparts[0]] = subparts[1]\\n        return data\\n\\n    @staticmethod\\n    def get_hostname():\\n        try:\\n            return socket.getfqdn()\\n        except IOError as ex:\\n            raise ex\\n\\n    @staticmethod\\n    def check_if_file_exists(file_path):\\n        if file_path is None \\\\\\n           or os.path.exists(file_path) is False \\\\\\n           or os.path.isfile(file_path) is False:\\n            return False\\n        return True\\n\\n    @staticmethod\\n    def check_if_directory_exists(dir_path):\\n        if dir_path is None \\\\\\n           or os.path.exists(dir_path) is False \\\\\\n           or os.path.isdir(dir_path) is False:\\n            return False\\n        return True\\n\\n    @staticmethod\\n    def delete_dir(dir_path):\\n        try:\\n            if os.path.exists(dir_path):\\n                shutil.rmtree(dir_path, onerror=Utils._remove_readonly_callback)\\n        except OSError as ex:\\n            raise ex\\n\\n    @staticmethod\\n    def mkdir_if_needed(dir_path):\\n        try:\\n            os.makedirs(dir_path)\\n        except OSError as ex:\\n            if ex.errno != errno.EEXIST:\\n                raise ex\\n\\n    @staticmethod\\n    def delete_file(file_path, file_type_diagnostic):\\n        try:\\n            if os.path.exists(file_path):\\n                os.unlink(file_path)\\n        except OSError as ex:\\n            msg = \\'Error deleteing {0}: {1}. \\' \\\\\\n                  \\'Errno: {2}, Error: {3}\\'.format(file_type_diagnostic,\\n                                                  file_path, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, file_path)\\n\\n    @staticmethod\\n    def create_file(file_path, data, file_type_diagnostic, mode=0o644):\\n        try:\\n            fd = os.open(file_path, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, mode)\\n            with os.fdopen(fd, \\'w\\') as output_file:\\n                output_file.write(data)\\n        except OSError as ex:\\n            msg = \\'Error creating {0}: {1}. \\' \\\\\\n                  \\'Errno: {2}, Error: {3}\\'.format(file_type_diagnostic,\\n                                                  file_path, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, file_path)\\n\\n    @staticmethod\\n    def get_iot_hub_sas_token(uri, key, policy_name, expiry=3600):\\n        ttl = time() + expiry\\n        sign_key = \"%s\\\\n%d\" % ((quote_plus(uri)), int(ttl))\\n        signature = b64encode(\\n            HMAC(b64decode(key), sign_key.encode(\"utf-8\"), sha256).digest())\\n\\n        rawtoken = {\\n            \"sr\": uri,\\n            \"sig\": signature,\\n            \"se\": str(int(ttl))\\n        }\\n\\n        if policy_name is not None:\\n            rawtoken[\"skn\"] = policy_name\\n\\n        return \"SharedAccessSignature \" + urlencode(rawtoken)\\n\\n    @staticmethod\\n    def copy_files(src_path, dst_path):\\n        try:\\n            shutil.copy2(src_path, dst_path)\\n        except OSError as ex:\\n            raise ex\\n\\n    @staticmethod\\n    def _remove_readonly_callback(func, path, excinfo):\\n        del func, excinfo\\n        os.chmod(path, stat.S_IWRITE)\\n        os.unlink(path)\\n\\n    @staticmethod\\n    def exe_proc(params, shell=False, cwd=None, suppress_out=False):\\n        try:\\n            subprocess.check_call(params, shell=shell, cwd=cwd)\\n        except KeyboardInterrupt:\\n            raise\\n        except Exception as e:\\n            raise Exception(\"Error while executing command: {0}. {1}\".format(\\' \\'.join(params), str(e)))\\n\\n    @staticmethod\\n    @suppress_all_exceptions()\\n    def hash_connection_str_hostname(hostname):\\n        \"\"\"Hash connection string hostname to count distint IoT Hub number\"\"\"\\n        if not hostname:\\n            return (\"\", \"\")\\n\\n        # get hostname suffix (e.g., azure-devices.net) to distinguish national clouds\\n        if \".\" in hostname:\\n            hostname_suffix = hostname[hostname.index(\".\") + 1:]\\n        else:\\n            hostname_suffix = \"\"\\n\\n        return (Utils.get_sha256_hash(hostname), hostname_suffix)\\n\\n    @staticmethod\\n    def get_sha256_hash(val):\\n        hash_object = sha256(val.encode(\\'utf-8\\'))\\n\\n        return str(hash_object.hexdigest()).lower()\\n\\n    @staticmethod\\n    def get_device_ca_file_paths(root_dir, cert_id):\\n        result = {}\\n        result[EC.CERT_SUFFIX] = os.path.join(root_dir, cert_id + EC.CERT_SUFFIX)\\n        result[EC.KEY_SUFFIX] = os.path.join(root_dir, cert_id + EC.KEY_SUFFIX)\\n        result[EC.CHAIN_CERT_SUFFIX] = os.path.join(root_dir, cert_id + EC.CHAIN_CERT_SUFFIX)\\n        return result\\n'"}, "return_value": "'utf-8'"}]}, "neuter_encoding_declaration": {"line": 214, "args": [{"func_args": {"source": "\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport pkg_resources\\n\\npkg_resources.declare_namespace(__name__)\\n\\n__author__ = 'Microsoft Corporation'\\n__version__ = '0.14.10'\\n__AIkey__ = '95b20d64-f54f-4de3-8ad5-165a75a6c6fe'\\n__production__ = 'iotedgehubdev'\\n\""}, "return_value": "\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport pkg_resources\\n\\npkg_resources.declare_namespace(__name__)\\n\\n__author__ = 'Microsoft Corporation'\\n__version__ = '0.14.10'\\n__AIkey__ = '95b20d64-f54f-4de3-8ad5-165a75a6c6fe'\\n__production__ = 'iotedgehubdev'\\n\""}, {"func_args": {"source": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport os\\nfrom OpenSSL import crypto\\nfrom shutil import copy2\\nfrom datetime import datetime\\nfrom .errors import EdgeFileAccessError, EdgeInvalidArgument, EdgeValueError\\nfrom .constants import EdgeConstants as EC\\nfrom .utils import Utils\\n\\n\\nclass EdgeCertUtil(object):\\n\\n    TYPE_RSA = 0\\n    MIN_VALIDITY_DAYS = 1\\n    MAX_VALIDITY_DAYS = 1095  # 3 years\\n    MIN_PASSPHRASE_LENGTH = 4\\n    MAX_PASSPHRASE_LENGTH = 1023\\n    CA_KEY_LEN = 4096\\n    CA_INT_KEY_LEN = 4096\\n    SERVER_KEY_LEN = 2048\\n    MIN_COMMON_NAME_LEN = 1\\n    MAX_COMMON_NAME_LEN = 64\\n    DIGEST = \\'sha256\\'\\n    _type_dict = {TYPE_RSA: crypto.TYPE_RSA}\\n    _subject_validation_dict = {\\n        EC.SUBJECT_COUNTRY_KEY: {\\'MIN\\': 2, \\'MAX\\': 2},\\n        EC.SUBJECT_STATE_KEY: {\\'MIN\\': 0, \\'MAX\\': 128},\\n        EC.SUBJECT_LOCALITY_KEY: {\\'MIN\\': 0, \\'MAX\\': 128},\\n        EC.SUBJECT_ORGANIZATION_KEY: {\\'MIN\\': 0, \\'MAX\\': 64},\\n        EC.SUBJECT_ORGANIZATION_UNIT_KEY: {\\'MIN\\': 0, \\'MAX\\': 64},\\n        EC.SUBJECT_COMMON_NAME_KEY: {\\'MIN\\': MIN_COMMON_NAME_LEN,\\n                                     \\'MAX\\': MAX_COMMON_NAME_LEN}\\n    }\\n\\n    def __init__(self, serial_num=1000):\\n        self._cert_chain = {}\\n        self._serial_number = serial_num\\n\\n    def create_root_ca_cert(self, id_str, **kwargs):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Duplicate root CA certificate ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        validity_days_from_now = self._get_kwargs_validity(**kwargs)\\n        subj_dict = None\\n        if \\'subject_dict\\' in kwargs:\\n            subj_dict = kwargs[\\'subject_dict\\']\\n            if self.is_valid_certificate_subject(subj_dict) is False:\\n                msg = \\'Certificate subject dictionary is invalid.\\'\\n                raise EdgeValueError(msg)\\n        else:\\n            msg = \\'Certificate subject dictionary is required\\'\\n            raise EdgeValueError(msg)\\n        passphrase = self._get_kwargs_passphrase(**kwargs)\\n\\n        key_obj = self._create_key_pair(EdgeCertUtil.TYPE_RSA,\\n                                        EdgeCertUtil.CA_KEY_LEN)\\n        csr_obj = self._create_csr(key_obj,\\n                                   C=subj_dict[EC.SUBJECT_COUNTRY_KEY],\\n                                   ST=subj_dict[EC.SUBJECT_STATE_KEY],\\n                                   L=subj_dict[EC.SUBJECT_LOCALITY_KEY],\\n                                   O=subj_dict[EC.SUBJECT_ORGANIZATION_KEY],\\n                                   OU=subj_dict[EC.SUBJECT_ORGANIZATION_KEY],\\n                                   CN=subj_dict[EC.SUBJECT_COMMON_NAME_KEY])\\n\\n        validity_secs_from_now = validity_days_from_now * 24 * 60 * 60\\n        cert_obj = self._create_ca_cert(csr_obj,\\n                                        csr_obj,\\n                                        key_obj,\\n                                        (0, validity_secs_from_now),\\n                                        False)\\n        self._serial_number += 1\\n        cert_dict = {}\\n        cert_dict[\\'key_pair\\'] = key_obj\\n        cert_dict[\\'csr\\'] = csr_obj\\n        cert_dict[\\'cert\\'] = cert_obj\\n        cert_dict[\\'issuer_id\\'] = id_str\\n        cert_dict[\\'passphrase\\'] = passphrase\\n        self._cert_chain[id_str] = cert_dict\\n\\n    def create_intermediate_ca_cert(self, id_str, issuer_id_str, **kwargs):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Duplicate intermediate CA certificate ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        if issuer_id_str not in list(self._cert_chain.keys()):\\n            msg = \\'Invalid issuer certificate ID: {0}\\'.format(issuer_id_str)\\n            raise EdgeValueError(msg)\\n\\n        validity_days_from_now = self._get_kwargs_validity(**kwargs)\\n        passphrase = self._get_kwargs_passphrase(**kwargs)\\n\\n        min_length = self._subject_validation_dict[EC.SUBJECT_COMMON_NAME_KEY][\\'MIN\\']\\n        max_length = self._subject_validation_dict[EC.SUBJECT_COMMON_NAME_KEY][\\'MAX\\']\\n        common_name = self._get_kwargs_string(\\'common_name\\', min_length, max_length, **kwargs)\\n        if common_name is None:\\n            msg = \\'Invalid common name: {0}\\'.format(common_name)\\n            raise EdgeValueError(msg)\\n\\n        set_terminal_ca = True\\n        if \\'set_terminal_ca\\' in kwargs:\\n            set_terminal_ca = kwargs[\\'set_terminal_ca\\']\\n\\n        try:\\n            issuer_cert_dict = self._cert_chain[issuer_id_str]\\n            issuer_cert = issuer_cert_dict[\\'cert\\']\\n\\n            not_after_ts = issuer_cert.get_notAfter()\\n            valid_days = self._get_maximum_validity_days(not_after_ts,\\n                                                         validity_days_from_now)\\n\\n            issuer_key = issuer_cert_dict[\\'key_pair\\']\\n            key_obj = self._create_key_pair(EdgeCertUtil.TYPE_RSA, EdgeCertUtil.CA_KEY_LEN)\\n            csr_obj = self._create_csr(key_obj,\\n                                       C=issuer_cert.get_subject().countryName,\\n                                       ST=issuer_cert.get_subject().stateOrProvinceName,\\n                                       L=issuer_cert.get_subject().localityName,\\n                                       O=issuer_cert.get_subject().organizationName,\\n                                       OU=issuer_cert.get_subject().organizationalUnitName,\\n                                       CN=common_name)\\n\\n            validity_secs_from_now = valid_days * 24 * 60 * 60\\n            cert_obj = self._create_ca_cert(csr_obj,\\n                                            issuer_cert,\\n                                            issuer_key,\\n                                            (0, validity_secs_from_now),\\n                                            set_terminal_ca)\\n            self._serial_number += 1\\n            cert_dict = {}\\n            cert_dict[\\'key_pair\\'] = key_obj\\n            cert_dict[\\'csr\\'] = csr_obj\\n            cert_dict[\\'cert\\'] = cert_obj\\n            cert_dict[\\'issuer_id\\'] = issuer_id_str\\n            cert_dict[\\'passphrase\\'] = passphrase\\n            self._cert_chain[id_str] = cert_dict\\n        except EdgeValueError:\\n            msg = \\'Could not create intermediate certificate for {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n    def create_server_cert(self, id_str, issuer_id_str, **kwargs):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Duplicate intermediate CA certificate ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        if issuer_id_str not in list(self._cert_chain.keys()):\\n            msg = \\'Invalid issuer certificate ID: {0}\\'.format(issuer_id_str)\\n            raise EdgeValueError(msg)\\n\\n        validity_days_from_now = self._get_kwargs_validity(**kwargs)\\n\\n        passphrase = self._get_kwargs_passphrase(**kwargs)\\n\\n        max_length = self._subject_validation_dict[EC.SUBJECT_COMMON_NAME_KEY][\\'MAX\\']\\n        hostname = kwargs.get(\\'hostname\\', None)\\n        if hostname is None:\\n            msg = \\'Invalid hostname: {0}\\'.format(hostname)\\n            raise EdgeValueError(msg)\\n        # CN length is limited to 64. Since the certificate is used internally so just cut to 64.\\n        common_name = hostname if len(hostname) <= max_length else hostname[:max_length]\\n\\n        try:\\n            issuer_cert_dict = self._cert_chain[issuer_id_str]\\n            issuer_cert = issuer_cert_dict[\\'cert\\']\\n            issuer_key = issuer_cert_dict[\\'key_pair\\']\\n            key_obj = self._create_key_pair(EdgeCertUtil.TYPE_RSA, EdgeCertUtil.SERVER_KEY_LEN)\\n            csr_obj = self._create_csr(key_obj,\\n                                       C=issuer_cert.get_subject().countryName,\\n                                       ST=issuer_cert.get_subject().stateOrProvinceName,\\n                                       L=issuer_cert.get_subject().localityName,\\n                                       O=issuer_cert.get_subject().organizationName,\\n                                       OU=issuer_cert.get_subject().organizationalUnitName,\\n                                       CN=common_name)\\n            not_after_ts = issuer_cert.get_notAfter()\\n            valid_days = self._get_maximum_validity_days(not_after_ts,\\n                                                         validity_days_from_now)\\n            validity_secs_from_now = valid_days * 24 * 60 * 60\\n            cert_obj = self._create_server_cert(csr_obj,\\n                                                issuer_cert,\\n                                                issuer_key,\\n                                                (0, validity_secs_from_now),\\n                                                hostname)\\n            self._serial_number += 1\\n            cert_dict = {}\\n            cert_dict[\\'key_pair\\'] = key_obj\\n            cert_dict[\\'csr\\'] = csr_obj\\n            cert_dict[\\'cert\\'] = cert_obj\\n            cert_dict[\\'issuer_id\\'] = issuer_id_str\\n            cert_dict[\\'passphrase\\'] = passphrase\\n            self._cert_chain[id_str] = cert_dict\\n        except EdgeValueError:\\n            msg = \\'Could not create server certificate for {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n    def export_pfx_cert(self, id_str, dir_path):\\n        if id_str not in self._cert_chain:\\n            msg = \\'Invalid cert ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        try:\\n            cert_dict = self._cert_chain[id_str]\\n            cert_obj = cert_dict[\\'cert\\']\\n            key_obj = cert_dict[\\'key_pair\\']\\n            pfx = crypto.PKCS12()\\n            pfx.set_privatekey(key_obj)\\n            pfx.set_certificate(cert_obj)\\n            pfx_data = pfx.export()\\n            prefix = id_str\\n            path = os.path.realpath(dir_path)\\n            path = os.path.join(path, prefix)\\n            cert_dir = os.path.join(path, \\'cert\\')\\n            pfx_output_file_name = os.path.join(cert_dir, prefix + EC.PFX_SUFFIX)\\n            with open(pfx_output_file_name, \\'wb\\') as pfx_file:\\n                pfx_file.write(pfx_data)\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting PFX cert ID: {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(id_str, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, pfx_output_file_name)\\n\\n    @staticmethod\\n    def get_cert_file_path(id_str, dir_path):\\n        return os.path.join(dir_path, id_str, \\'cert\\', id_str + EC.CERT_SUFFIX)\\n\\n    @staticmethod\\n    def get_pfx_file_path(id_str, dir_path):\\n        return os.path.join(dir_path, id_str, \\'cert\\', id_str + EC.PFX_SUFFIX)\\n\\n    def load_cert_from_file(self, id_str, cert_path, key_path, key_passphrase):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Could not load cert from file. Certificate already in chain. ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n        cert_dict = {}\\n        # Load cert\\n        try:\\n            with open(cert_path, \\'r\\') as cert_file:\\n                cert_content = cert_file.read()\\n                cert_dict[\\'cert\\'] = crypto.load_certificate(crypto.FILETYPE_PEM, cert_content)\\n        except Exception as ex:\\n            raise EdgeInvalidArgument(\\'Failed to load cert from %s. Error: %s\\' % (cert_path, ex), ex)\\n        # Load key\\n        try:\\n            with open(key_path, \\'r\\') as key_file:\\n                key_content = key_file.read()\\n                cert_dict[\\'key_pair\\'] = crypto.load_privatekey(crypto.FILETYPE_PEM, key_content, key_passphrase)\\n        except Exception as ex:\\n            raise EdgeInvalidArgument(\\n                \\'Failed to load private key from %s. Please check your passphase first. Error: %s\\' % (key_path, ex), ex)\\n        self._cert_chain[id_str] = cert_dict\\n\\n    def export_simulator_cert_artifacts_to_dir(self, id_str, dir_path):\\n        if Utils.check_if_directory_exists(dir_path) is False:\\n            msg = \\'Invalid export directory {0}\\'.format(dir_path)\\n            raise EdgeValueError(msg)\\n\\n        cert_dict = self._get_cert_dict(id_str)\\n        prefix = id_str\\n        try:\\n            path = os.path.realpath(dir_path)\\n            path = os.path.join(path, prefix)\\n            Utils.delete_dir(path)\\n            Utils.mkdir_if_needed(path)\\n            priv_dir = os.path.join(path, \\'private\\')\\n            Utils.mkdir_if_needed(priv_dir)\\n            os.chmod(priv_dir, 0o700)\\n            cert_dir = os.path.join(path, \\'cert\\')\\n            Utils.mkdir_if_needed(cert_dir)\\n\\n            # export the private key\\n            priv_key_file_name = prefix + \\'.key.pem\\'\\n            priv_key_file = os.path.join(priv_dir, priv_key_file_name)\\n            self._dump_cert_key(cert_dict, priv_key_file)\\n\\n            # export the cert\\n            cert_file_name = prefix + EC.CERT_SUFFIX\\n            cert_file = os.path.join(cert_dir, cert_file_name)\\n            current_cert_file_path = cert_file\\n            self._dump_cert_content(cert_dict, cert_file)\\n\\n            # export any chain certs\\n            if \\'ca_chain\\' in list(cert_dict.keys()):\\n                src_chain_cert_file = cert_dict[\\'ca_chain\\']\\n                cert_file_name = prefix + \\'-chain.cert.pem\\'\\n                cert_file = os.path.join(cert_dir, cert_file_name)\\n                copy2(src_chain_cert_file, cert_file)\\n\\n            # check if this is the root cert in the chain, i.e. issuer is itself\\n            if cert_dict[\\'issuer_id\\'] == id_str:\\n                cert_file_name = prefix + \\'-root.cert.pem\\'\\n                cert_file = os.path.join(cert_dir, cert_file_name)\\n                if \\'ca_root\\' in list(cert_dict.keys()):\\n                    src_root_cert_file = cert_dict[\\'ca_root\\']\\n                else:\\n                    src_root_cert_file = current_cert_file_path\\n                copy2(src_root_cert_file, cert_file)\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting certs for ID: {0}.\\\\n\\' \\\\\\n                  \\' Error seen when copying/exporting file {1}.\\' \\\\\\n                  \\' Errno: {2} Error: {3}\\'.format(id_str, ex.filename, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, path)\\n\\n    def export_device_ca_cert_artifacts_to_dir(self, id_str, dir_path):\\n        output_files = Utils.get_device_ca_file_paths(dir_path, id_str)\\n        cert_path = output_files[EC.CERT_SUFFIX]\\n        key_path = output_files[EC.KEY_SUFFIX]\\n        cert_dict = self._get_cert_dict(id_str)\\n        self._dump_cert_content(cert_dict, cert_path)\\n        self._dump_cert_key(cert_dict, key_path)\\n\\n    def chain_simulator_ca_certs(self, output_prefix, prefixes, certs_dir):\\n        try:\\n            output_dir = os.path.join(certs_dir, output_prefix)\\n            Utils.delete_dir(output_dir)\\n            Utils.mkdir_if_needed(output_dir)\\n            output_dir = os.path.join(output_dir, \\'cert\\')\\n            Utils.mkdir_if_needed(output_dir)\\n            output_file_name = os.path.join(output_dir, output_prefix + EC.CERT_SUFFIX)\\n            self._chain_ca_certs(output_file_name, prefixes, certs_dir, self._simulator_cert_file_path_gen)\\n        except IOError as ex:\\n            msg = \\'IO Error when creating chain cert: {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(output_file_name, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_file_name)\\n\\n    def chain_device_ca_certs(self, output_prefix, id_strs, certs_dir):\\n        cert_files = Utils.get_device_ca_file_paths(certs_dir, output_prefix)\\n        chain_path = cert_files[EC.CHAIN_CERT_SUFFIX]\\n        self._chain_ca_certs(chain_path, id_strs, certs_dir, self._device_ca_cert_file_path_gen)\\n\\n    def is_valid_certificate_subject(self, subject_dict):\\n        result = True\\n        for key in list(EdgeCertUtil._subject_validation_dict.keys()):\\n            try:\\n                field = subject_dict[key]\\n                if field is not None:\\n                    length_field = len(field)\\n                    min_len = EdgeCertUtil._subject_validation_dict[key][\\'MIN\\']\\n                    max_len = EdgeCertUtil._subject_validation_dict[key][\\'MAX\\']\\n                    if length_field < min_len or length_field > max_len:\\n                        result = False\\n                else:\\n                    result = False\\n            except KeyError:\\n                result = False\\n\\n            if result is False:\\n                break\\n        return result\\n\\n    def _create_csr(self, key_pair, **kwargs):\\n        csr = crypto.X509Req()\\n        subj = csr.get_subject()\\n        for key, value in list(kwargs.items()):\\n            if value:\\n                setattr(subj, key, value)\\n        csr.set_pubkey(key_pair)\\n        csr.sign(key_pair, EdgeCertUtil.DIGEST)\\n        return csr\\n\\n    def _create_cert_common(self,\\n                            csr,\\n                            issuer_cert,\\n                            validity_period):\\n        not_before, not_after = validity_period\\n        cert = crypto.X509()\\n        cert.set_serial_number(self._serial_number)\\n        cert.gmtime_adj_notBefore(not_before)\\n        cert.gmtime_adj_notAfter(not_after)\\n        cert.set_issuer(issuer_cert.get_subject())\\n        cert.set_subject(csr.get_subject())\\n        cert.set_pubkey(csr.get_pubkey())\\n        cert.set_version(2)\\n        return cert\\n\\n    def _create_ca_cert(self,\\n                        csr,\\n                        issuer_cert,\\n                        issuer_key_pair,\\n                        validity_period,\\n                        path_len_zero):\\n        cert = self._create_cert_common(csr, issuer_cert, validity_period)\\n        val = b\\'CA:TRUE\\'\\n        if path_len_zero:\\n            val += b\\', pathlen:0\\'\\n        extensions = []\\n        extensions.append(crypto.X509Extension(b\\'basicConstraints\\',\\n                                               critical=True, value=val))\\n        extensions.append(crypto.X509Extension(b\\'subjectKeyIdentifier\\',\\n                                               False,\\n                                               b\\'hash\\',\\n                                               subject=cert))\\n        extensions.append(crypto.X509Extension(b\\'keyUsage\\',\\n                                               critical=True,\\n                                               value=b\\'digitalSignature, cRLSign, keyCertSign\\'))\\n        # authorityKeyIdentifier requires subjectKeyIdentifier in issuer cert, add it first\\n        cert.add_extensions(extensions)\\n\\n        del extensions[:]\\n        extensions.append(crypto.X509Extension(b\\'authorityKeyIdentifier\\',\\n                                               False,\\n                                               b\\'keyid:always,issuer:always\\',\\n                                               issuer=issuer_cert if isinstance(issuer_cert, crypto.X509) else cert))\\n        cert.add_extensions(extensions)\\n        cert.sign(issuer_key_pair, EdgeCertUtil.DIGEST)\\n        return cert\\n\\n    def _create_server_cert(self,\\n                            csr,\\n                            issuer_cert,\\n                            issuer_key_pair,\\n                            validity_period,\\n                            hostname):\\n        cert = self._create_cert_common(csr,\\n                                        issuer_cert,\\n                                        validity_period)\\n\\n        extensions = []\\n        extensions.append(crypto.X509Extension(b\\'basicConstraints\\',\\n                                               critical=False,\\n                                               value=b\\'CA:FALSE\\'))\\n        altDns = \\',\\'.join([\\'DNS:localhost\\', \\'DNS:{0}\\'.format(hostname)]).encode(\\'utf-8\\')\\n        extensions.append(crypto.X509Extension(b\\'subjectAltName\\',\\n                                               critical=False,\\n                                               value=altDns))\\n        cert.add_extensions(extensions)\\n        cert.sign(issuer_key_pair, EdgeCertUtil.DIGEST)\\n        return cert\\n\\n    def _create_key_pair(self, private_key_type, key_bit_len):\\n        key_pair = crypto.PKey()\\n        key_pair.generate_key(EdgeCertUtil._type_dict[private_key_type], key_bit_len)\\n        return key_pair\\n\\n    def _get_maximum_validity_days(self, not_after_ts_asn1, validity_days_from_now):\\n        result = 0\\n        try:\\n            expiration_date = datetime.strptime(not_after_ts_asn1.decode(\\'utf-8\\'), \"%Y%m%d%H%M%SZ\")\\n            expires_in = expiration_date - datetime.now()\\n            if expires_in.days > 0:\\n                result = min(expires_in.days, validity_days_from_now)\\n            return result\\n        except Exception:\\n            msg = \\'Certificate date format incompatible {0}\\'.format(not_after_ts_asn1)\\n            raise EdgeValueError(msg)\\n\\n    def _get_kwargs_validity(self, **kwargs):\\n        validity_days_from_now = 365\\n        min_validity = EdgeCertUtil.MIN_VALIDITY_DAYS\\n        max_validity = EdgeCertUtil.MAX_VALIDITY_DAYS\\n        kwarg_key = \\'validity_days_from_now\\'\\n        if kwarg_key in kwargs:\\n            validity_days_from_now = kwargs[kwarg_key]\\n\\n        if validity_days_from_now < min_validity or validity_days_from_now > max_validity:\\n            msg = \\'Certificate validity days needs to be greater than or equal to {0} \\' \\\\\\n                  \\'and less than {1} days. Value provided: {2}\\'. format(min_validity,\\n                                                                        max_validity,\\n                                                                        validity_days_from_now)\\n            raise EdgeValueError(msg)\\n\\n        return validity_days_from_now\\n\\n    def _validate_string_length(self, test_string, min_length, max_length):\\n        length = len(test_string)\\n        if min_length > length or length > max_length:\\n            return False\\n        return True\\n\\n    def _get_kwargs_passphrase(self, **kwargs):\\n        passphrase = None\\n        min_length = EdgeCertUtil.MIN_PASSPHRASE_LENGTH\\n        max_length = EdgeCertUtil.MAX_PASSPHRASE_LENGTH\\n        kwarg_key = \\'passphrase\\'\\n        if kwarg_key in kwargs:\\n            passphrase = kwargs[kwarg_key]\\n        if passphrase is not None:\\n            if self._validate_string_length(passphrase, min_length, max_length) is False:\\n                msg = \\'Private key passphrase needs to greater than or equal to {0} and less \\' \\\\\\n                      \\'than {1} characters.\\'.format(min_length, max_length)\\n                raise EdgeValueError(msg)\\n        return passphrase\\n\\n    def _get_kwargs_string(self, kwarg_key, min_length, max_length, default_str=None, **kwargs):\\n        result_str = default_str\\n        if kwarg_key in kwargs:\\n            result_str = kwargs[kwarg_key]\\n        if result_str is not None:\\n            if self._validate_string_length(result_str, min_length, max_length) is False:\\n                msg = \\'KWarg[{0}]:{1} string length needs to greater than or equal to {2} and \\' \\\\\\n                      \\'less than {3} characters.\\'.format(kwarg_key, result_str,\\n                                                         min_length, max_length)\\n                raise EdgeValueError(msg)\\n        return result_str\\n\\n    def _dump_cert_content(self, cert_dict, output_path):\\n        Utils.mkdir_if_needed(os.path.dirname(output_path))\\n        cert_obj = cert_dict[\\'cert\\']\\n        try:\\n            with open(output_path, \\'w\\') as output_file:\\n                output_file.write(crypto.dump_certificate(crypto.FILETYPE_PEM,\\n                                                          cert_obj).decode(\\'utf-8\\'))\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting certs.\\\\n\\' \\\\\\n                  \\' Error seen when exporting file {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(ex.filename, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_path)\\n\\n    def _dump_cert_key(self, cert_dict, output_path):\\n        Utils.mkdir_if_needed(os.path.dirname(output_path))\\n        try:\\n            if \\'key_file\\' in cert_dict:\\n                key_file_path = cert_dict[\\'key_file\\']\\n                copy2(key_file_path, output_path)\\n            else:\\n                key_obj = cert_dict[\\'key_pair\\']\\n                key_passphrase = cert_dict[\\'passphrase\\']\\n                passphrase = None\\n                if key_passphrase and key_passphrase != \\'\\':\\n                    passphrase = key_passphrase.encode(\\'utf-8\\')\\n                cipher = None\\n                if passphrase:\\n                    cipher = \\'aes256\\'\\n                with open(output_path, \\'w\\') as output_file:\\n                    output_file.write(crypto.dump_privatekey(crypto.FILETYPE_PEM,\\n                                                             key_obj,\\n                                                             cipher=cipher,\\n                                                             passphrase=passphrase).decode(\\'utf-8\\'))\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting certs.\\\\n\\' \\\\\\n                  \\' Error seen when exporting file {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(ex.filename, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_path)\\n\\n    def _get_cert_dict(self, id_str):\\n        if id_str not in list(self._cert_chain.keys()):\\n            msg = \\'Certificate not in chain. ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n        return self._cert_chain[id_str]\\n\\n    def _chain_ca_certs(self, output_path, id_strs, certs_dir, cert_file_path_gen):\\n        file_names = []\\n        for id_str in id_strs:\\n            cert_dict = self._get_cert_dict(id_str)\\n            if \\'ca_chain\\' in list(cert_dict.keys()):\\n                # this cert contains an existing certificate chain\\n                # pick the chain instead of the actual cert\\n                cert_file_name = id_str + \\'-chain.cert.pem\\'\\n            else:\\n                cert_file_name = id_str + EC.CERT_SUFFIX\\n            cert_file = cert_file_path_gen(id_str, cert_file_name, certs_dir)\\n            path = os.path.realpath(cert_file)\\n            file_names.append(path)\\n        try:\\n            with open(output_path, \\'wb\\') as output_file:\\n                for file_name in file_names:\\n                    with open(file_name, \\'rb\\') as input_file:\\n                        output_file.write(input_file.read())\\n        except IOError as ex:\\n            msg = \\'IO Error when creating chain cert: {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(output_path, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_path)\\n\\n    def _simulator_cert_file_path_gen(self, id_str, cert_file_name, certs_dir):\\n        return os.path.join(certs_dir, id_str, \\'cert\\', cert_file_name)\\n\\n    def _device_ca_cert_file_path_gen(self, id_str, cert_file_name, certs_dir):\\n        return os.path.join(certs_dir, cert_file_name)\\n'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport os\\nfrom OpenSSL import crypto\\nfrom shutil import copy2\\nfrom datetime import datetime\\nfrom .errors import EdgeFileAccessError, EdgeInvalidArgument, EdgeValueError\\nfrom .constants import EdgeConstants as EC\\nfrom .utils import Utils\\n\\n\\nclass EdgeCertUtil(object):\\n\\n    TYPE_RSA = 0\\n    MIN_VALIDITY_DAYS = 1\\n    MAX_VALIDITY_DAYS = 1095  # 3 years\\n    MIN_PASSPHRASE_LENGTH = 4\\n    MAX_PASSPHRASE_LENGTH = 1023\\n    CA_KEY_LEN = 4096\\n    CA_INT_KEY_LEN = 4096\\n    SERVER_KEY_LEN = 2048\\n    MIN_COMMON_NAME_LEN = 1\\n    MAX_COMMON_NAME_LEN = 64\\n    DIGEST = \\'sha256\\'\\n    _type_dict = {TYPE_RSA: crypto.TYPE_RSA}\\n    _subject_validation_dict = {\\n        EC.SUBJECT_COUNTRY_KEY: {\\'MIN\\': 2, \\'MAX\\': 2},\\n        EC.SUBJECT_STATE_KEY: {\\'MIN\\': 0, \\'MAX\\': 128},\\n        EC.SUBJECT_LOCALITY_KEY: {\\'MIN\\': 0, \\'MAX\\': 128},\\n        EC.SUBJECT_ORGANIZATION_KEY: {\\'MIN\\': 0, \\'MAX\\': 64},\\n        EC.SUBJECT_ORGANIZATION_UNIT_KEY: {\\'MIN\\': 0, \\'MAX\\': 64},\\n        EC.SUBJECT_COMMON_NAME_KEY: {\\'MIN\\': MIN_COMMON_NAME_LEN,\\n                                     \\'MAX\\': MAX_COMMON_NAME_LEN}\\n    }\\n\\n    def __init__(self, serial_num=1000):\\n        self._cert_chain = {}\\n        self._serial_number = serial_num\\n\\n    def create_root_ca_cert(self, id_str, **kwargs):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Duplicate root CA certificate ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        validity_days_from_now = self._get_kwargs_validity(**kwargs)\\n        subj_dict = None\\n        if \\'subject_dict\\' in kwargs:\\n            subj_dict = kwargs[\\'subject_dict\\']\\n            if self.is_valid_certificate_subject(subj_dict) is False:\\n                msg = \\'Certificate subject dictionary is invalid.\\'\\n                raise EdgeValueError(msg)\\n        else:\\n            msg = \\'Certificate subject dictionary is required\\'\\n            raise EdgeValueError(msg)\\n        passphrase = self._get_kwargs_passphrase(**kwargs)\\n\\n        key_obj = self._create_key_pair(EdgeCertUtil.TYPE_RSA,\\n                                        EdgeCertUtil.CA_KEY_LEN)\\n        csr_obj = self._create_csr(key_obj,\\n                                   C=subj_dict[EC.SUBJECT_COUNTRY_KEY],\\n                                   ST=subj_dict[EC.SUBJECT_STATE_KEY],\\n                                   L=subj_dict[EC.SUBJECT_LOCALITY_KEY],\\n                                   O=subj_dict[EC.SUBJECT_ORGANIZATION_KEY],\\n                                   OU=subj_dict[EC.SUBJECT_ORGANIZATION_KEY],\\n                                   CN=subj_dict[EC.SUBJECT_COMMON_NAME_KEY])\\n\\n        validity_secs_from_now = validity_days_from_now * 24 * 60 * 60\\n        cert_obj = self._create_ca_cert(csr_obj,\\n                                        csr_obj,\\n                                        key_obj,\\n                                        (0, validity_secs_from_now),\\n                                        False)\\n        self._serial_number += 1\\n        cert_dict = {}\\n        cert_dict[\\'key_pair\\'] = key_obj\\n        cert_dict[\\'csr\\'] = csr_obj\\n        cert_dict[\\'cert\\'] = cert_obj\\n        cert_dict[\\'issuer_id\\'] = id_str\\n        cert_dict[\\'passphrase\\'] = passphrase\\n        self._cert_chain[id_str] = cert_dict\\n\\n    def create_intermediate_ca_cert(self, id_str, issuer_id_str, **kwargs):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Duplicate intermediate CA certificate ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        if issuer_id_str not in list(self._cert_chain.keys()):\\n            msg = \\'Invalid issuer certificate ID: {0}\\'.format(issuer_id_str)\\n            raise EdgeValueError(msg)\\n\\n        validity_days_from_now = self._get_kwargs_validity(**kwargs)\\n        passphrase = self._get_kwargs_passphrase(**kwargs)\\n\\n        min_length = self._subject_validation_dict[EC.SUBJECT_COMMON_NAME_KEY][\\'MIN\\']\\n        max_length = self._subject_validation_dict[EC.SUBJECT_COMMON_NAME_KEY][\\'MAX\\']\\n        common_name = self._get_kwargs_string(\\'common_name\\', min_length, max_length, **kwargs)\\n        if common_name is None:\\n            msg = \\'Invalid common name: {0}\\'.format(common_name)\\n            raise EdgeValueError(msg)\\n\\n        set_terminal_ca = True\\n        if \\'set_terminal_ca\\' in kwargs:\\n            set_terminal_ca = kwargs[\\'set_terminal_ca\\']\\n\\n        try:\\n            issuer_cert_dict = self._cert_chain[issuer_id_str]\\n            issuer_cert = issuer_cert_dict[\\'cert\\']\\n\\n            not_after_ts = issuer_cert.get_notAfter()\\n            valid_days = self._get_maximum_validity_days(not_after_ts,\\n                                                         validity_days_from_now)\\n\\n            issuer_key = issuer_cert_dict[\\'key_pair\\']\\n            key_obj = self._create_key_pair(EdgeCertUtil.TYPE_RSA, EdgeCertUtil.CA_KEY_LEN)\\n            csr_obj = self._create_csr(key_obj,\\n                                       C=issuer_cert.get_subject().countryName,\\n                                       ST=issuer_cert.get_subject().stateOrProvinceName,\\n                                       L=issuer_cert.get_subject().localityName,\\n                                       O=issuer_cert.get_subject().organizationName,\\n                                       OU=issuer_cert.get_subject().organizationalUnitName,\\n                                       CN=common_name)\\n\\n            validity_secs_from_now = valid_days * 24 * 60 * 60\\n            cert_obj = self._create_ca_cert(csr_obj,\\n                                            issuer_cert,\\n                                            issuer_key,\\n                                            (0, validity_secs_from_now),\\n                                            set_terminal_ca)\\n            self._serial_number += 1\\n            cert_dict = {}\\n            cert_dict[\\'key_pair\\'] = key_obj\\n            cert_dict[\\'csr\\'] = csr_obj\\n            cert_dict[\\'cert\\'] = cert_obj\\n            cert_dict[\\'issuer_id\\'] = issuer_id_str\\n            cert_dict[\\'passphrase\\'] = passphrase\\n            self._cert_chain[id_str] = cert_dict\\n        except EdgeValueError:\\n            msg = \\'Could not create intermediate certificate for {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n    def create_server_cert(self, id_str, issuer_id_str, **kwargs):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Duplicate intermediate CA certificate ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        if issuer_id_str not in list(self._cert_chain.keys()):\\n            msg = \\'Invalid issuer certificate ID: {0}\\'.format(issuer_id_str)\\n            raise EdgeValueError(msg)\\n\\n        validity_days_from_now = self._get_kwargs_validity(**kwargs)\\n\\n        passphrase = self._get_kwargs_passphrase(**kwargs)\\n\\n        max_length = self._subject_validation_dict[EC.SUBJECT_COMMON_NAME_KEY][\\'MAX\\']\\n        hostname = kwargs.get(\\'hostname\\', None)\\n        if hostname is None:\\n            msg = \\'Invalid hostname: {0}\\'.format(hostname)\\n            raise EdgeValueError(msg)\\n        # CN length is limited to 64. Since the certificate is used internally so just cut to 64.\\n        common_name = hostname if len(hostname) <= max_length else hostname[:max_length]\\n\\n        try:\\n            issuer_cert_dict = self._cert_chain[issuer_id_str]\\n            issuer_cert = issuer_cert_dict[\\'cert\\']\\n            issuer_key = issuer_cert_dict[\\'key_pair\\']\\n            key_obj = self._create_key_pair(EdgeCertUtil.TYPE_RSA, EdgeCertUtil.SERVER_KEY_LEN)\\n            csr_obj = self._create_csr(key_obj,\\n                                       C=issuer_cert.get_subject().countryName,\\n                                       ST=issuer_cert.get_subject().stateOrProvinceName,\\n                                       L=issuer_cert.get_subject().localityName,\\n                                       O=issuer_cert.get_subject().organizationName,\\n                                       OU=issuer_cert.get_subject().organizationalUnitName,\\n                                       CN=common_name)\\n            not_after_ts = issuer_cert.get_notAfter()\\n            valid_days = self._get_maximum_validity_days(not_after_ts,\\n                                                         validity_days_from_now)\\n            validity_secs_from_now = valid_days * 24 * 60 * 60\\n            cert_obj = self._create_server_cert(csr_obj,\\n                                                issuer_cert,\\n                                                issuer_key,\\n                                                (0, validity_secs_from_now),\\n                                                hostname)\\n            self._serial_number += 1\\n            cert_dict = {}\\n            cert_dict[\\'key_pair\\'] = key_obj\\n            cert_dict[\\'csr\\'] = csr_obj\\n            cert_dict[\\'cert\\'] = cert_obj\\n            cert_dict[\\'issuer_id\\'] = issuer_id_str\\n            cert_dict[\\'passphrase\\'] = passphrase\\n            self._cert_chain[id_str] = cert_dict\\n        except EdgeValueError:\\n            msg = \\'Could not create server certificate for {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n    def export_pfx_cert(self, id_str, dir_path):\\n        if id_str not in self._cert_chain:\\n            msg = \\'Invalid cert ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n\\n        try:\\n            cert_dict = self._cert_chain[id_str]\\n            cert_obj = cert_dict[\\'cert\\']\\n            key_obj = cert_dict[\\'key_pair\\']\\n            pfx = crypto.PKCS12()\\n            pfx.set_privatekey(key_obj)\\n            pfx.set_certificate(cert_obj)\\n            pfx_data = pfx.export()\\n            prefix = id_str\\n            path = os.path.realpath(dir_path)\\n            path = os.path.join(path, prefix)\\n            cert_dir = os.path.join(path, \\'cert\\')\\n            pfx_output_file_name = os.path.join(cert_dir, prefix + EC.PFX_SUFFIX)\\n            with open(pfx_output_file_name, \\'wb\\') as pfx_file:\\n                pfx_file.write(pfx_data)\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting PFX cert ID: {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(id_str, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, pfx_output_file_name)\\n\\n    @staticmethod\\n    def get_cert_file_path(id_str, dir_path):\\n        return os.path.join(dir_path, id_str, \\'cert\\', id_str + EC.CERT_SUFFIX)\\n\\n    @staticmethod\\n    def get_pfx_file_path(id_str, dir_path):\\n        return os.path.join(dir_path, id_str, \\'cert\\', id_str + EC.PFX_SUFFIX)\\n\\n    def load_cert_from_file(self, id_str, cert_path, key_path, key_passphrase):\\n        if id_str in list(self._cert_chain.keys()):\\n            msg = \\'Could not load cert from file. Certificate already in chain. ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n        cert_dict = {}\\n        # Load cert\\n        try:\\n            with open(cert_path, \\'r\\') as cert_file:\\n                cert_content = cert_file.read()\\n                cert_dict[\\'cert\\'] = crypto.load_certificate(crypto.FILETYPE_PEM, cert_content)\\n        except Exception as ex:\\n            raise EdgeInvalidArgument(\\'Failed to load cert from %s. Error: %s\\' % (cert_path, ex), ex)\\n        # Load key\\n        try:\\n            with open(key_path, \\'r\\') as key_file:\\n                key_content = key_file.read()\\n                cert_dict[\\'key_pair\\'] = crypto.load_privatekey(crypto.FILETYPE_PEM, key_content, key_passphrase)\\n        except Exception as ex:\\n            raise EdgeInvalidArgument(\\n                \\'Failed to load private key from %s. Please check your passphase first. Error: %s\\' % (key_path, ex), ex)\\n        self._cert_chain[id_str] = cert_dict\\n\\n    def export_simulator_cert_artifacts_to_dir(self, id_str, dir_path):\\n        if Utils.check_if_directory_exists(dir_path) is False:\\n            msg = \\'Invalid export directory {0}\\'.format(dir_path)\\n            raise EdgeValueError(msg)\\n\\n        cert_dict = self._get_cert_dict(id_str)\\n        prefix = id_str\\n        try:\\n            path = os.path.realpath(dir_path)\\n            path = os.path.join(path, prefix)\\n            Utils.delete_dir(path)\\n            Utils.mkdir_if_needed(path)\\n            priv_dir = os.path.join(path, \\'private\\')\\n            Utils.mkdir_if_needed(priv_dir)\\n            os.chmod(priv_dir, 0o700)\\n            cert_dir = os.path.join(path, \\'cert\\')\\n            Utils.mkdir_if_needed(cert_dir)\\n\\n            # export the private key\\n            priv_key_file_name = prefix + \\'.key.pem\\'\\n            priv_key_file = os.path.join(priv_dir, priv_key_file_name)\\n            self._dump_cert_key(cert_dict, priv_key_file)\\n\\n            # export the cert\\n            cert_file_name = prefix + EC.CERT_SUFFIX\\n            cert_file = os.path.join(cert_dir, cert_file_name)\\n            current_cert_file_path = cert_file\\n            self._dump_cert_content(cert_dict, cert_file)\\n\\n            # export any chain certs\\n            if \\'ca_chain\\' in list(cert_dict.keys()):\\n                src_chain_cert_file = cert_dict[\\'ca_chain\\']\\n                cert_file_name = prefix + \\'-chain.cert.pem\\'\\n                cert_file = os.path.join(cert_dir, cert_file_name)\\n                copy2(src_chain_cert_file, cert_file)\\n\\n            # check if this is the root cert in the chain, i.e. issuer is itself\\n            if cert_dict[\\'issuer_id\\'] == id_str:\\n                cert_file_name = prefix + \\'-root.cert.pem\\'\\n                cert_file = os.path.join(cert_dir, cert_file_name)\\n                if \\'ca_root\\' in list(cert_dict.keys()):\\n                    src_root_cert_file = cert_dict[\\'ca_root\\']\\n                else:\\n                    src_root_cert_file = current_cert_file_path\\n                copy2(src_root_cert_file, cert_file)\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting certs for ID: {0}.\\\\n\\' \\\\\\n                  \\' Error seen when copying/exporting file {1}.\\' \\\\\\n                  \\' Errno: {2} Error: {3}\\'.format(id_str, ex.filename, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, path)\\n\\n    def export_device_ca_cert_artifacts_to_dir(self, id_str, dir_path):\\n        output_files = Utils.get_device_ca_file_paths(dir_path, id_str)\\n        cert_path = output_files[EC.CERT_SUFFIX]\\n        key_path = output_files[EC.KEY_SUFFIX]\\n        cert_dict = self._get_cert_dict(id_str)\\n        self._dump_cert_content(cert_dict, cert_path)\\n        self._dump_cert_key(cert_dict, key_path)\\n\\n    def chain_simulator_ca_certs(self, output_prefix, prefixes, certs_dir):\\n        try:\\n            output_dir = os.path.join(certs_dir, output_prefix)\\n            Utils.delete_dir(output_dir)\\n            Utils.mkdir_if_needed(output_dir)\\n            output_dir = os.path.join(output_dir, \\'cert\\')\\n            Utils.mkdir_if_needed(output_dir)\\n            output_file_name = os.path.join(output_dir, output_prefix + EC.CERT_SUFFIX)\\n            self._chain_ca_certs(output_file_name, prefixes, certs_dir, self._simulator_cert_file_path_gen)\\n        except IOError as ex:\\n            msg = \\'IO Error when creating chain cert: {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(output_file_name, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_file_name)\\n\\n    def chain_device_ca_certs(self, output_prefix, id_strs, certs_dir):\\n        cert_files = Utils.get_device_ca_file_paths(certs_dir, output_prefix)\\n        chain_path = cert_files[EC.CHAIN_CERT_SUFFIX]\\n        self._chain_ca_certs(chain_path, id_strs, certs_dir, self._device_ca_cert_file_path_gen)\\n\\n    def is_valid_certificate_subject(self, subject_dict):\\n        result = True\\n        for key in list(EdgeCertUtil._subject_validation_dict.keys()):\\n            try:\\n                field = subject_dict[key]\\n                if field is not None:\\n                    length_field = len(field)\\n                    min_len = EdgeCertUtil._subject_validation_dict[key][\\'MIN\\']\\n                    max_len = EdgeCertUtil._subject_validation_dict[key][\\'MAX\\']\\n                    if length_field < min_len or length_field > max_len:\\n                        result = False\\n                else:\\n                    result = False\\n            except KeyError:\\n                result = False\\n\\n            if result is False:\\n                break\\n        return result\\n\\n    def _create_csr(self, key_pair, **kwargs):\\n        csr = crypto.X509Req()\\n        subj = csr.get_subject()\\n        for key, value in list(kwargs.items()):\\n            if value:\\n                setattr(subj, key, value)\\n        csr.set_pubkey(key_pair)\\n        csr.sign(key_pair, EdgeCertUtil.DIGEST)\\n        return csr\\n\\n    def _create_cert_common(self,\\n                            csr,\\n                            issuer_cert,\\n                            validity_period):\\n        not_before, not_after = validity_period\\n        cert = crypto.X509()\\n        cert.set_serial_number(self._serial_number)\\n        cert.gmtime_adj_notBefore(not_before)\\n        cert.gmtime_adj_notAfter(not_after)\\n        cert.set_issuer(issuer_cert.get_subject())\\n        cert.set_subject(csr.get_subject())\\n        cert.set_pubkey(csr.get_pubkey())\\n        cert.set_version(2)\\n        return cert\\n\\n    def _create_ca_cert(self,\\n                        csr,\\n                        issuer_cert,\\n                        issuer_key_pair,\\n                        validity_period,\\n                        path_len_zero):\\n        cert = self._create_cert_common(csr, issuer_cert, validity_period)\\n        val = b\\'CA:TRUE\\'\\n        if path_len_zero:\\n            val += b\\', pathlen:0\\'\\n        extensions = []\\n        extensions.append(crypto.X509Extension(b\\'basicConstraints\\',\\n                                               critical=True, value=val))\\n        extensions.append(crypto.X509Extension(b\\'subjectKeyIdentifier\\',\\n                                               False,\\n                                               b\\'hash\\',\\n                                               subject=cert))\\n        extensions.append(crypto.X509Extension(b\\'keyUsage\\',\\n                                               critical=True,\\n                                               value=b\\'digitalSignature, cRLSign, keyCertSign\\'))\\n        # authorityKeyIdentifier requires subjectKeyIdentifier in issuer cert, add it first\\n        cert.add_extensions(extensions)\\n\\n        del extensions[:]\\n        extensions.append(crypto.X509Extension(b\\'authorityKeyIdentifier\\',\\n                                               False,\\n                                               b\\'keyid:always,issuer:always\\',\\n                                               issuer=issuer_cert if isinstance(issuer_cert, crypto.X509) else cert))\\n        cert.add_extensions(extensions)\\n        cert.sign(issuer_key_pair, EdgeCertUtil.DIGEST)\\n        return cert\\n\\n    def _create_server_cert(self,\\n                            csr,\\n                            issuer_cert,\\n                            issuer_key_pair,\\n                            validity_period,\\n                            hostname):\\n        cert = self._create_cert_common(csr,\\n                                        issuer_cert,\\n                                        validity_period)\\n\\n        extensions = []\\n        extensions.append(crypto.X509Extension(b\\'basicConstraints\\',\\n                                               critical=False,\\n                                               value=b\\'CA:FALSE\\'))\\n        altDns = \\',\\'.join([\\'DNS:localhost\\', \\'DNS:{0}\\'.format(hostname)]).encode(\\'utf-8\\')\\n        extensions.append(crypto.X509Extension(b\\'subjectAltName\\',\\n                                               critical=False,\\n                                               value=altDns))\\n        cert.add_extensions(extensions)\\n        cert.sign(issuer_key_pair, EdgeCertUtil.DIGEST)\\n        return cert\\n\\n    def _create_key_pair(self, private_key_type, key_bit_len):\\n        key_pair = crypto.PKey()\\n        key_pair.generate_key(EdgeCertUtil._type_dict[private_key_type], key_bit_len)\\n        return key_pair\\n\\n    def _get_maximum_validity_days(self, not_after_ts_asn1, validity_days_from_now):\\n        result = 0\\n        try:\\n            expiration_date = datetime.strptime(not_after_ts_asn1.decode(\\'utf-8\\'), \"%Y%m%d%H%M%SZ\")\\n            expires_in = expiration_date - datetime.now()\\n            if expires_in.days > 0:\\n                result = min(expires_in.days, validity_days_from_now)\\n            return result\\n        except Exception:\\n            msg = \\'Certificate date format incompatible {0}\\'.format(not_after_ts_asn1)\\n            raise EdgeValueError(msg)\\n\\n    def _get_kwargs_validity(self, **kwargs):\\n        validity_days_from_now = 365\\n        min_validity = EdgeCertUtil.MIN_VALIDITY_DAYS\\n        max_validity = EdgeCertUtil.MAX_VALIDITY_DAYS\\n        kwarg_key = \\'validity_days_from_now\\'\\n        if kwarg_key in kwargs:\\n            validity_days_from_now = kwargs[kwarg_key]\\n\\n        if validity_days_from_now < min_validity or validity_days_from_now > max_validity:\\n            msg = \\'Certificate validity days needs to be greater than or equal to {0} \\' \\\\\\n                  \\'and less than {1} days. Value provided: {2}\\'. format(min_validity,\\n                                                                        max_validity,\\n                                                                        validity_days_from_now)\\n            raise EdgeValueError(msg)\\n\\n        return validity_days_from_now\\n\\n    def _validate_string_length(self, test_string, min_length, max_length):\\n        length = len(test_string)\\n        if min_length > length or length > max_length:\\n            return False\\n        return True\\n\\n    def _get_kwargs_passphrase(self, **kwargs):\\n        passphrase = None\\n        min_length = EdgeCertUtil.MIN_PASSPHRASE_LENGTH\\n        max_length = EdgeCertUtil.MAX_PASSPHRASE_LENGTH\\n        kwarg_key = \\'passphrase\\'\\n        if kwarg_key in kwargs:\\n            passphrase = kwargs[kwarg_key]\\n        if passphrase is not None:\\n            if self._validate_string_length(passphrase, min_length, max_length) is False:\\n                msg = \\'Private key passphrase needs to greater than or equal to {0} and less \\' \\\\\\n                      \\'than {1} characters.\\'.format(min_length, max_length)\\n                raise EdgeValueError(msg)\\n        return passphrase\\n\\n    def _get_kwargs_string(self, kwarg_key, min_length, max_length, default_str=None, **kwargs):\\n        result_str = default_str\\n        if kwarg_key in kwargs:\\n            result_str = kwargs[kwarg_key]\\n        if result_str is not None:\\n            if self._validate_string_length(result_str, min_length, max_length) is False:\\n                msg = \\'KWarg[{0}]:{1} string length needs to greater than or equal to {2} and \\' \\\\\\n                      \\'less than {3} characters.\\'.format(kwarg_key, result_str,\\n                                                         min_length, max_length)\\n                raise EdgeValueError(msg)\\n        return result_str\\n\\n    def _dump_cert_content(self, cert_dict, output_path):\\n        Utils.mkdir_if_needed(os.path.dirname(output_path))\\n        cert_obj = cert_dict[\\'cert\\']\\n        try:\\n            with open(output_path, \\'w\\') as output_file:\\n                output_file.write(crypto.dump_certificate(crypto.FILETYPE_PEM,\\n                                                          cert_obj).decode(\\'utf-8\\'))\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting certs.\\\\n\\' \\\\\\n                  \\' Error seen when exporting file {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(ex.filename, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_path)\\n\\n    def _dump_cert_key(self, cert_dict, output_path):\\n        Utils.mkdir_if_needed(os.path.dirname(output_path))\\n        try:\\n            if \\'key_file\\' in cert_dict:\\n                key_file_path = cert_dict[\\'key_file\\']\\n                copy2(key_file_path, output_path)\\n            else:\\n                key_obj = cert_dict[\\'key_pair\\']\\n                key_passphrase = cert_dict[\\'passphrase\\']\\n                passphrase = None\\n                if key_passphrase and key_passphrase != \\'\\':\\n                    passphrase = key_passphrase.encode(\\'utf-8\\')\\n                cipher = None\\n                if passphrase:\\n                    cipher = \\'aes256\\'\\n                with open(output_path, \\'w\\') as output_file:\\n                    output_file.write(crypto.dump_privatekey(crypto.FILETYPE_PEM,\\n                                                             key_obj,\\n                                                             cipher=cipher,\\n                                                             passphrase=passphrase).decode(\\'utf-8\\'))\\n        except IOError as ex:\\n            msg = \\'IO Error when exporting certs.\\\\n\\' \\\\\\n                  \\' Error seen when exporting file {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(ex.filename, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_path)\\n\\n    def _get_cert_dict(self, id_str):\\n        if id_str not in list(self._cert_chain.keys()):\\n            msg = \\'Certificate not in chain. ID: {0}\\'.format(id_str)\\n            raise EdgeValueError(msg)\\n        return self._cert_chain[id_str]\\n\\n    def _chain_ca_certs(self, output_path, id_strs, certs_dir, cert_file_path_gen):\\n        file_names = []\\n        for id_str in id_strs:\\n            cert_dict = self._get_cert_dict(id_str)\\n            if \\'ca_chain\\' in list(cert_dict.keys()):\\n                # this cert contains an existing certificate chain\\n                # pick the chain instead of the actual cert\\n                cert_file_name = id_str + \\'-chain.cert.pem\\'\\n            else:\\n                cert_file_name = id_str + EC.CERT_SUFFIX\\n            cert_file = cert_file_path_gen(id_str, cert_file_name, certs_dir)\\n            path = os.path.realpath(cert_file)\\n            file_names.append(path)\\n        try:\\n            with open(output_path, \\'wb\\') as output_file:\\n                for file_name in file_names:\\n                    with open(file_name, \\'rb\\') as input_file:\\n                        output_file.write(input_file.read())\\n        except IOError as ex:\\n            msg = \\'IO Error when creating chain cert: {0}.\\' \\\\\\n                  \\' Errno: {1} Error: {2}\\'.format(output_path, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, output_path)\\n\\n    def _simulator_cert_file_path_gen(self, id_str, cert_file_name, certs_dir):\\n        return os.path.join(certs_dir, id_str, \\'cert\\', cert_file_name)\\n\\n    def _device_ca_cert_file_path_gen(self, id_str, cert_file_name, certs_dir):\\n        return os.path.join(certs_dir, cert_file_name)\\n'"}, {"func_args": {"source": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport json\\nimport os\\nimport sys\\nimport re\\nfrom functools import wraps\\n\\nimport click\\n\\nfrom . import configs, decorators, telemetry\\nfrom .constants import EdgeConstants\\nfrom .edgecert import EdgeCert\\nfrom .edgemanager import EdgeManager\\nfrom .hostplatform import HostPlatform\\nfrom .output import Output\\nfrom .utils import Utils\\nfrom .errors import EdgeError, InvalidConfigError\\n\\nCONTEXT_SETTINGS = dict(help_option_names=[\\'-h\\', \\'--help\\'], max_content_width=120)\\noutput = Output()\\n\\nCONN_STR = \\'connectionString\\'\\nCERT_PATH = \\'certPath\\'\\nGATEWAY_HOST = \\'gatewayhost\\'\\nDOCKER_HOST = \\'DOCKER_HOST\\'\\nHUB_CONN_STR = \\'iothubConnectionString\\'\\n\\n# a set of parameters whose value should be logged as given\\nPARAMS_WITH_VALUES = {\\'edge_runtime_version\\'}\\n\\n@decorators.suppress_all_exceptions()\\ndef _parse_params(*args, **kwargs):\\n    params = []\\n    for key, value in kwargs.items():\\n        if (value is None) or (key in PARAMS_WITH_VALUES):\\n            params.append(\\'{0}={1}\\'.format(key, value))\\n        else:\\n            params.append(\\'{0}!=None\\'.format(key))\\n    return params\\n\\n\\ndef _send_failed_telemetry(e):\\n    output.error(str(e))\\n    telemetry.fail(str(e), \\'Command failed\\')\\n    telemetry.flush()\\n\\n\\ndef _with_telemetry(func):\\n    @wraps(func)\\n    def _wrapper(*args, **kwargs):\\n        configs.check_firsttime()\\n        params = _parse_params(*args, **kwargs)\\n        telemetry.start(func.__name__, params)\\n        try:\\n            value = func(*args, **kwargs)\\n            telemetry.success()\\n            telemetry.flush()\\n            return value\\n        except InvalidConfigError as e:\\n            _send_failed_telemetry(e)\\n            sys.exit(2)\\n        except Exception as e:\\n            _send_failed_telemetry(e)\\n            sys.exit(1)\\n\\n    return _wrapper\\n\\n\\ndef _parse_config_json():\\n    try:\\n        config_file = HostPlatform.get_config_file_path()\\n\\n        if not Utils.check_if_file_exists(config_file):\\n            raise ValueError(\\'Cannot find config file. Please run `{0}` first.\\'.format(_get_setup_command()))\\n\\n        with open(config_file) as f:\\n            try:\\n                config_json = json.load(f)\\n\\n                connection_str = config_json[CONN_STR]\\n                cert_path = config_json[CERT_PATH]\\n                gatewayhost = config_json[GATEWAY_HOST]\\n                hub_conn_str = config_json.get(HUB_CONN_STR)\\n                return EdgeManager(connection_str, gatewayhost, cert_path, hub_conn_str)\\n\\n            except (ValueError, KeyError):\\n                raise ValueError(\\'Invalid config file. Please run `{0}` again.\\'.format(_get_setup_command()))\\n    except Exception as e:\\n        raise InvalidConfigError(str(e))\\n\\n\\ndef _get_setup_command():\\n    return \\'{0}iotedgehubdev setup -c \"<edge-device-connection-string>\"\\'.format(\\'\\' if os.name == \\'nt\\' else \\'sudo \\')\\n\\n\\n@click.group(context_settings=CONTEXT_SETTINGS, invoke_without_command=True)\\n@click.version_option()\\ndef main():\\n    ctx = click.get_current_context()\\n    if ctx.invoked_subcommand is None:\\n        click.echo(ctx.get_help())\\n        sys.exit(0)\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\\'Setup the IoT Edge Simulator. This must be done before starting.\\')\\n@click.option(\\'--connection-string\\',\\n              \\'-c\\',\\n              required=True,\\n              help=\\'Set Azure IoT Edge device connection string. Note: Use double quotes when supplying this input.\\')\\n@click.option(\\'--gateway-host\\',\\n              \\'-g\\',\\n              required=False,\\n              default=Utils.get_hostname(),\\n              show_default=True,\\n              help=\\'GatewayHostName value for the module to connect.\\')\\n@click.option(\\'--iothub-connection-string\\',\\n              \\'-i\\',\\n              required=False,\\n              help=\\'Set Azure IoT Hub connection string. Note: Use double quotes when supplying this input.\\')\\n@_with_telemetry\\ndef setup(connection_string, gateway_host, iothub_connection_string):\\n    try:\\n        gateway_host = gateway_host.lower()\\n        certDir = HostPlatform.get_default_cert_path()\\n        Utils.parse_connection_strs(connection_string, iothub_connection_string)\\n        if iothub_connection_string is None:\\n            configDict = {\\n                CONN_STR: connection_string,\\n                CERT_PATH: certDir,\\n                GATEWAY_HOST: gateway_host\\n            }\\n        else:\\n            configDict = {\\n                CONN_STR: connection_string,\\n                CERT_PATH: certDir,\\n                GATEWAY_HOST: gateway_host,\\n                HUB_CONN_STR: iothub_connection_string\\n            }\\n\\n        fileType = \\'edgehub.config\\'\\n        Utils.mkdir_if_needed(certDir)\\n        edgeCert = EdgeCert(certDir, gateway_host)\\n        edgeCert.generate_self_signed_certs()\\n        configFile = HostPlatform.get_config_file_path()\\n        Utils.delete_file(configFile, fileType)\\n        Utils.mkdir_if_needed(HostPlatform.get_config_path())\\n        configJson = json.dumps(configDict, indent=2, sort_keys=True)\\n        Utils.create_file(configFile, configJson, fileType)\\n\\n        dataDir = HostPlatform.get_share_data_path()\\n        Utils.mkdir_if_needed(dataDir)\\n        os.chmod(dataDir, 0o755)\\n\\n        with open(EdgeManager.COMPOSE_FILE, \\'w\\') as f:\\n            f.write(\\'version: \\\\\\'3.6\\\\\\'\\')\\n        os.chmod(EdgeManager.COMPOSE_FILE, 0o777)\\n        output.info(\\'Setup IoT Edge Simulator successfully.\\')\\n    except Exception as e:\\n        raise e\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               # short_help hack to prevent Click truncating help text (https://github.com/pallets/click/issues/486)\\n               short_help=\\'Get the module credentials such as connection string and certificate file path.\\',\\n               help=\\'Get the module credentials such as connection string and certificate file path.\\')\\n@click.option(\\'--modules\\',\\n              \\'-m\\',\\n              required=False,\\n              default=\\'target\\',\\n              show_default=True,\\n              help=\\'Specify the vertical-bar-separated (\"|\") module names to get credentials for, e.g., \"module1|module2\". \\'\\n                   \\'Note: Use double quotes when supplying this input.\\')\\n@click.option(\\'--local\\',\\n              \\'-l\\',\\n              required=False,\\n              is_flag=True,\\n              default=False,\\n              show_default=True,\\n              help=\\'Set `localhost` to `GatewayHostName` for module to run on host natively.\\')\\n@click.option(\\'--output-file\\',\\n              \\'-o\\',\\n              required=False,\\n              show_default=True,\\n              help=\\'Specify the output file to save the connection string. If the file exists, the content will be overwritten.\\')\\n@_with_telemetry\\ndef modulecred(modules, local, output_file):\\n    edge_manager = _parse_config_json()\\n\\n    if edge_manager:\\n        modules = [module.strip() for module in modules.strip().split(\\'|\\')]\\n        credential = edge_manager.outputModuleCred(modules, local, output_file)\\n        output.info(credential[0])\\n        output.info(credential[1])\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Start the IoT Edge Simulator.\")\\n@click.option(\\'--inputs\\',\\n              \\'-i\\',\\n              required=False,\\n              help=\\'Start IoT Edge Simulator in single module mode \\'\\n                   \\'using the specified comma-separated inputs of the target module, e.g., `input1,input2`.\\')\\n@click.option(\\'--port\\',\\n              \\'-p\\',\\n              required=False,\\n              default=53000,\\n              show_default=True,\\n              help=\\'Port of the service for sending message.\\')\\n@click.option(\\'--deployment\\',\\n              \\'-d\\',\\n              required=False,\\n              help=\\'Start IoT Edge Simulator in solution mode using the specified deployment manifest.\\')\\n@click.option(\\'--verbose\\',\\n              \\'-v\\',\\n              required=False,\\n              is_flag=True,\\n              default=False,\\n              show_default=True,\\n              help=\\'Show the solution container logs.\\')\\n@click.option(\\'--host\\',\\n              \\'-H\\',\\n              required=False,\\n              help=\\'Docker daemon socket to connect to.\\')\\n@click.option(\\'--environment\\',\\n              \\'-e\\',\\n              required=False,\\n              multiple=True,\\n              help=\\'Environment variables for single module mode, e.g., `-e \"Env1=Value1\" -e \"Env2=Value2\"`.\\')\\n@click.option(\\'--edge-runtime-version\\',\\n              \\'-er\\',\\n              required=False,\\n              multiple=False,\\n              default=\\'1.2\\',\\n              show_default=True,\\n              help=\\'EdgeHub image version. Currently supported tags 1.0x, 1.1x, or 1.2x\\')\\n@_with_telemetry\\ndef start(inputs, port, deployment, verbose, host, environment, edge_runtime_version):\\n    edge_manager = _parse_config_json()\\n\\n    if edge_manager:\\n        if host is not None:\\n            os.environ[DOCKER_HOST] = str(host)\\n\\n        hostname_hash, suffix = Utils.hash_connection_str_hostname(edge_manager.hostname)\\n        telemetry.add_extra_props({\\'iothubhostname\\': hostname_hash, \\'iothubhostnamesuffix\\': suffix})\\n\\n        if inputs is None and deployment is not None:\\n            if len(environment) > 0:\\n                output.info(\\'Environment variables are ignored in solution mode.\\')\\n\\n            if len(edge_runtime_version) > 0:\\n                output.info(\\'edgeHub image version is ignored in solution mode.\\')\\n\\n            with open(deployment) as json_file:\\n                json_data = json.load(json_file)\\n                if \\'modulesContent\\' in json_data:\\n                    module_content = json_data[\\'modulesContent\\']\\n                elif \\'moduleContent\\' in json_data:\\n                    module_content = json_data[\\'moduleContent\\']\\n            edge_manager.start_solution(module_content, verbose, output)\\n            if not verbose:\\n                output.info(\\'IoT Edge Simulator has been started in solution mode.\\')\\n        else:\\n            if edge_runtime_version is not None:\\n                # The only validated versions are 1.0, 1.1, and 1.2 variants, hence the current limitation\\n                if re.match(r\\'^(1\\\\.0)|(1\\\\.1)|(1\\\\.2)\\', edge_runtime_version) is None:\\n                    raise ValueError(\\'-edge-runtime-version `{0}` is not valid.\\'.format(edge_runtime_version))\\n\\n            if deployment is not None:\\n                output.info(\\'Deployment manifest is ignored when inputs are present.\\')\\n            if inputs is None:\\n                input_list = [\\'input1\\']\\n            else:\\n                input_list = [input_.strip() for input_ in inputs.strip().split(\\',\\')]\\n\\n            for env in environment:\\n                if re.match(r\\'^[a-zA-Z][a-zA-Z0-9_]*?=.*$\\', env) is None:\\n                    raise ValueError(\\'Environment variable: `{0}` is not valid.\\'.format(env))\\n\\n            edge_manager.start_singlemodule(input_list, port, environment, edge_runtime_version)\\n\\n            data = \\'--data \\\\\\'{{\"inputName\": \"{0}\",\"data\":\"hello world\"}}\\\\\\'\\'.format(input_list[0])\\n            url = \\'http://localhost:{0}/api/v1/messages\\'.format(port)\\n            curl_msg = \\'        curl --header \"Content-Type: application/json\" --request POST {0} {1}\\'.format(data, url)\\n            output.info(\\'IoT Edge Simulator has been started in single module mode.\\')\\n            output.info(\\'Please run `iotedgehubdev modulecred` to get credential to connect your module.\\')\\n            output.info(\\'And send message through:\\')\\n            output.line()\\n            output.echo(curl_msg, \\'green\\')\\n            output.line()\\n            output.info(\\n                \\'Please refer to https://github.com/Azure/iot-edge-testing-utility/blob/master/swagger.json\\'\\n                \\' for detail schema\\')\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Stop the IoT Edge Simulator.\")\\n@click.option(\\'--host\\',\\n              \\'-H\\',\\n              required=False,\\n              help=\\'Docker daemon socket to connect to\\')\\n@_with_telemetry\\ndef stop(host):\\n    if host is not None:\\n        os.environ[DOCKER_HOST] = str(host)\\n    EdgeManager.stop()\\n    output.info(\\'IoT Edge Simulator has been stopped successfully.\\')\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Determine whether config file is valid.\")\\n@_with_telemetry\\ndef validateconfig():\\n    _parse_config_json()\\n    output.info(\\'Config file is valid.\\')\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Create IoT Edge device CA\")\\n@click.option(\\'--output-dir\\',\\n              \\'-o\\',\\n              required=False,\\n              default=\".\",\\n              help=\\'The output folder of generated certs. \\'\\n              \\'The tool will create a certs folder under given path to store the certs.\\')\\n@click.option(\\'--valid-days\\',\\n              \\'-d\\',\\n              required=False,\\n              default=90,\\n              show_default=True,\\n              help=\\'Days before cert expires.\\')\\n@click.option(\\'--force\\',\\n              \\'-f\\',\\n              required=False,\\n              is_flag=True,\\n              default=False,\\n              show_default=True,\\n              help=\\'Whether overwrite existing cert files.\\')\\n@click.option(\\'--trusted-ca\\',\\n              \\'-c\\',\\n              required=False,\\n              help=\\'Path of your own trusted ca used to sign IoT Edge device ca. \\'\\n              \\'Please also provide trsuted ca private key and related passphase (if have).\\'\\n              )\\n@click.option(\\'--trusted-ca-key\\',\\n              \\'-k\\',\\n              required=False,\\n              help=\\'Path of your own trusted ca private key used to sign IoT Edge device ca. \\'\\n              \\'Please also provide trusted ca and related passphase (if have).\\')\\n@click.option(\\'--trusted-ca-key-passphase\\',\\n              \\'-p\\',\\n              required=False,\\n              help=\\'Passphase of your own trusted ca private key.\\')\\n@_with_telemetry\\ndef generatedeviceca(output_dir, valid_days, force, trusted_ca, trusted_ca_key, trusted_ca_key_passphase):\\n    try:\\n        output_dir = os.path.abspath(os.path.join(output_dir, EdgeConstants.CERT_FOLDER))\\n        if trusted_ca_key_passphase:\\n            trusted_ca_key_passphase = trusted_ca_key_passphase.encode()  # crypto requires byte string\\n        # Check whether create new trusted CA and generate files to be created\\n        output_files = list(Utils.get_device_ca_file_paths(output_dir, EdgeConstants.DEVICE_CA_ID).values())\\n        if trusted_ca and trusted_ca_key:\\n            output.info(\\'Trusted CA (certification authority) and trusted CA key were provided.\\'\\n                        \\' Load trusted CA from given files.\\')\\n        else:\\n            output.info(\\'Trusted CA (certification authority) and Trusted CA key were not provided.\\'\\n                        \\' Will create new trusted CA.\\')\\n            root_ca_files = Utils.get_device_ca_file_paths(output_dir, EdgeConstants.ROOT_CA_ID)\\n            output_files.append(root_ca_files[EdgeConstants.CERT_SUFFIX])\\n            output_files.append(root_ca_files[EdgeConstants.KEY_SUFFIX])\\n        # Check whether the output files exist\\n        existing_files = []\\n        for file in output_files:\\n            if os.path.exists(file):\\n                existing_files.append(file)\\n        if len(existing_files) > 0:\\n            if force:\\n                output.info(\\'Following cert files already exist and will be overwritten: %s\\' % existing_files)\\n            else:\\n                raise EdgeError(\\'Following cert files already exist. \\'\\n                                \\'You can use --force option to overwrite existing files: %s\\' % existing_files)\\n        # Generate certs\\n        edgeCert = EdgeCert(output_dir, \\'\\')\\n        edgeCert.generate_device_ca(valid_days, force, trusted_ca, trusted_ca_key, trusted_ca_key_passphase)\\n        output.info(\\'Successfully generated device CA. Please find the generated certs at %s\\' % output_dir)\\n    except Exception as e:\\n        raise e\\n\\n\\nmain.add_command(setup)\\nmain.add_command(modulecred)\\nmain.add_command(start)\\nmain.add_command(stop)\\nmain.add_command(validateconfig)\\nmain.add_command(generatedeviceca)\\n\\nif __name__ == \"__main__\":\\n    main()\\n'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport json\\nimport os\\nimport sys\\nimport re\\nfrom functools import wraps\\n\\nimport click\\n\\nfrom . import configs, decorators, telemetry\\nfrom .constants import EdgeConstants\\nfrom .edgecert import EdgeCert\\nfrom .edgemanager import EdgeManager\\nfrom .hostplatform import HostPlatform\\nfrom .output import Output\\nfrom .utils import Utils\\nfrom .errors import EdgeError, InvalidConfigError\\n\\nCONTEXT_SETTINGS = dict(help_option_names=[\\'-h\\', \\'--help\\'], max_content_width=120)\\noutput = Output()\\n\\nCONN_STR = \\'connectionString\\'\\nCERT_PATH = \\'certPath\\'\\nGATEWAY_HOST = \\'gatewayhost\\'\\nDOCKER_HOST = \\'DOCKER_HOST\\'\\nHUB_CONN_STR = \\'iothubConnectionString\\'\\n\\n# a set of parameters whose value should be logged as given\\nPARAMS_WITH_VALUES = {\\'edge_runtime_version\\'}\\n\\n@decorators.suppress_all_exceptions()\\ndef _parse_params(*args, **kwargs):\\n    params = []\\n    for key, value in kwargs.items():\\n        if (value is None) or (key in PARAMS_WITH_VALUES):\\n            params.append(\\'{0}={1}\\'.format(key, value))\\n        else:\\n            params.append(\\'{0}!=None\\'.format(key))\\n    return params\\n\\n\\ndef _send_failed_telemetry(e):\\n    output.error(str(e))\\n    telemetry.fail(str(e), \\'Command failed\\')\\n    telemetry.flush()\\n\\n\\ndef _with_telemetry(func):\\n    @wraps(func)\\n    def _wrapper(*args, **kwargs):\\n        configs.check_firsttime()\\n        params = _parse_params(*args, **kwargs)\\n        telemetry.start(func.__name__, params)\\n        try:\\n            value = func(*args, **kwargs)\\n            telemetry.success()\\n            telemetry.flush()\\n            return value\\n        except InvalidConfigError as e:\\n            _send_failed_telemetry(e)\\n            sys.exit(2)\\n        except Exception as e:\\n            _send_failed_telemetry(e)\\n            sys.exit(1)\\n\\n    return _wrapper\\n\\n\\ndef _parse_config_json():\\n    try:\\n        config_file = HostPlatform.get_config_file_path()\\n\\n        if not Utils.check_if_file_exists(config_file):\\n            raise ValueError(\\'Cannot find config file. Please run `{0}` first.\\'.format(_get_setup_command()))\\n\\n        with open(config_file) as f:\\n            try:\\n                config_json = json.load(f)\\n\\n                connection_str = config_json[CONN_STR]\\n                cert_path = config_json[CERT_PATH]\\n                gatewayhost = config_json[GATEWAY_HOST]\\n                hub_conn_str = config_json.get(HUB_CONN_STR)\\n                return EdgeManager(connection_str, gatewayhost, cert_path, hub_conn_str)\\n\\n            except (ValueError, KeyError):\\n                raise ValueError(\\'Invalid config file. Please run `{0}` again.\\'.format(_get_setup_command()))\\n    except Exception as e:\\n        raise InvalidConfigError(str(e))\\n\\n\\ndef _get_setup_command():\\n    return \\'{0}iotedgehubdev setup -c \"<edge-device-connection-string>\"\\'.format(\\'\\' if os.name == \\'nt\\' else \\'sudo \\')\\n\\n\\n@click.group(context_settings=CONTEXT_SETTINGS, invoke_without_command=True)\\n@click.version_option()\\ndef main():\\n    ctx = click.get_current_context()\\n    if ctx.invoked_subcommand is None:\\n        click.echo(ctx.get_help())\\n        sys.exit(0)\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\\'Setup the IoT Edge Simulator. This must be done before starting.\\')\\n@click.option(\\'--connection-string\\',\\n              \\'-c\\',\\n              required=True,\\n              help=\\'Set Azure IoT Edge device connection string. Note: Use double quotes when supplying this input.\\')\\n@click.option(\\'--gateway-host\\',\\n              \\'-g\\',\\n              required=False,\\n              default=Utils.get_hostname(),\\n              show_default=True,\\n              help=\\'GatewayHostName value for the module to connect.\\')\\n@click.option(\\'--iothub-connection-string\\',\\n              \\'-i\\',\\n              required=False,\\n              help=\\'Set Azure IoT Hub connection string. Note: Use double quotes when supplying this input.\\')\\n@_with_telemetry\\ndef setup(connection_string, gateway_host, iothub_connection_string):\\n    try:\\n        gateway_host = gateway_host.lower()\\n        certDir = HostPlatform.get_default_cert_path()\\n        Utils.parse_connection_strs(connection_string, iothub_connection_string)\\n        if iothub_connection_string is None:\\n            configDict = {\\n                CONN_STR: connection_string,\\n                CERT_PATH: certDir,\\n                GATEWAY_HOST: gateway_host\\n            }\\n        else:\\n            configDict = {\\n                CONN_STR: connection_string,\\n                CERT_PATH: certDir,\\n                GATEWAY_HOST: gateway_host,\\n                HUB_CONN_STR: iothub_connection_string\\n            }\\n\\n        fileType = \\'edgehub.config\\'\\n        Utils.mkdir_if_needed(certDir)\\n        edgeCert = EdgeCert(certDir, gateway_host)\\n        edgeCert.generate_self_signed_certs()\\n        configFile = HostPlatform.get_config_file_path()\\n        Utils.delete_file(configFile, fileType)\\n        Utils.mkdir_if_needed(HostPlatform.get_config_path())\\n        configJson = json.dumps(configDict, indent=2, sort_keys=True)\\n        Utils.create_file(configFile, configJson, fileType)\\n\\n        dataDir = HostPlatform.get_share_data_path()\\n        Utils.mkdir_if_needed(dataDir)\\n        os.chmod(dataDir, 0o755)\\n\\n        with open(EdgeManager.COMPOSE_FILE, \\'w\\') as f:\\n            f.write(\\'version: \\\\\\'3.6\\\\\\'\\')\\n        os.chmod(EdgeManager.COMPOSE_FILE, 0o777)\\n        output.info(\\'Setup IoT Edge Simulator successfully.\\')\\n    except Exception as e:\\n        raise e\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               # short_help hack to prevent Click truncating help text (https://github.com/pallets/click/issues/486)\\n               short_help=\\'Get the module credentials such as connection string and certificate file path.\\',\\n               help=\\'Get the module credentials such as connection string and certificate file path.\\')\\n@click.option(\\'--modules\\',\\n              \\'-m\\',\\n              required=False,\\n              default=\\'target\\',\\n              show_default=True,\\n              help=\\'Specify the vertical-bar-separated (\"|\") module names to get credentials for, e.g., \"module1|module2\". \\'\\n                   \\'Note: Use double quotes when supplying this input.\\')\\n@click.option(\\'--local\\',\\n              \\'-l\\',\\n              required=False,\\n              is_flag=True,\\n              default=False,\\n              show_default=True,\\n              help=\\'Set `localhost` to `GatewayHostName` for module to run on host natively.\\')\\n@click.option(\\'--output-file\\',\\n              \\'-o\\',\\n              required=False,\\n              show_default=True,\\n              help=\\'Specify the output file to save the connection string. If the file exists, the content will be overwritten.\\')\\n@_with_telemetry\\ndef modulecred(modules, local, output_file):\\n    edge_manager = _parse_config_json()\\n\\n    if edge_manager:\\n        modules = [module.strip() for module in modules.strip().split(\\'|\\')]\\n        credential = edge_manager.outputModuleCred(modules, local, output_file)\\n        output.info(credential[0])\\n        output.info(credential[1])\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Start the IoT Edge Simulator.\")\\n@click.option(\\'--inputs\\',\\n              \\'-i\\',\\n              required=False,\\n              help=\\'Start IoT Edge Simulator in single module mode \\'\\n                   \\'using the specified comma-separated inputs of the target module, e.g., `input1,input2`.\\')\\n@click.option(\\'--port\\',\\n              \\'-p\\',\\n              required=False,\\n              default=53000,\\n              show_default=True,\\n              help=\\'Port of the service for sending message.\\')\\n@click.option(\\'--deployment\\',\\n              \\'-d\\',\\n              required=False,\\n              help=\\'Start IoT Edge Simulator in solution mode using the specified deployment manifest.\\')\\n@click.option(\\'--verbose\\',\\n              \\'-v\\',\\n              required=False,\\n              is_flag=True,\\n              default=False,\\n              show_default=True,\\n              help=\\'Show the solution container logs.\\')\\n@click.option(\\'--host\\',\\n              \\'-H\\',\\n              required=False,\\n              help=\\'Docker daemon socket to connect to.\\')\\n@click.option(\\'--environment\\',\\n              \\'-e\\',\\n              required=False,\\n              multiple=True,\\n              help=\\'Environment variables for single module mode, e.g., `-e \"Env1=Value1\" -e \"Env2=Value2\"`.\\')\\n@click.option(\\'--edge-runtime-version\\',\\n              \\'-er\\',\\n              required=False,\\n              multiple=False,\\n              default=\\'1.2\\',\\n              show_default=True,\\n              help=\\'EdgeHub image version. Currently supported tags 1.0x, 1.1x, or 1.2x\\')\\n@_with_telemetry\\ndef start(inputs, port, deployment, verbose, host, environment, edge_runtime_version):\\n    edge_manager = _parse_config_json()\\n\\n    if edge_manager:\\n        if host is not None:\\n            os.environ[DOCKER_HOST] = str(host)\\n\\n        hostname_hash, suffix = Utils.hash_connection_str_hostname(edge_manager.hostname)\\n        telemetry.add_extra_props({\\'iothubhostname\\': hostname_hash, \\'iothubhostnamesuffix\\': suffix})\\n\\n        if inputs is None and deployment is not None:\\n            if len(environment) > 0:\\n                output.info(\\'Environment variables are ignored in solution mode.\\')\\n\\n            if len(edge_runtime_version) > 0:\\n                output.info(\\'edgeHub image version is ignored in solution mode.\\')\\n\\n            with open(deployment) as json_file:\\n                json_data = json.load(json_file)\\n                if \\'modulesContent\\' in json_data:\\n                    module_content = json_data[\\'modulesContent\\']\\n                elif \\'moduleContent\\' in json_data:\\n                    module_content = json_data[\\'moduleContent\\']\\n            edge_manager.start_solution(module_content, verbose, output)\\n            if not verbose:\\n                output.info(\\'IoT Edge Simulator has been started in solution mode.\\')\\n        else:\\n            if edge_runtime_version is not None:\\n                # The only validated versions are 1.0, 1.1, and 1.2 variants, hence the current limitation\\n                if re.match(r\\'^(1\\\\.0)|(1\\\\.1)|(1\\\\.2)\\', edge_runtime_version) is None:\\n                    raise ValueError(\\'-edge-runtime-version `{0}` is not valid.\\'.format(edge_runtime_version))\\n\\n            if deployment is not None:\\n                output.info(\\'Deployment manifest is ignored when inputs are present.\\')\\n            if inputs is None:\\n                input_list = [\\'input1\\']\\n            else:\\n                input_list = [input_.strip() for input_ in inputs.strip().split(\\',\\')]\\n\\n            for env in environment:\\n                if re.match(r\\'^[a-zA-Z][a-zA-Z0-9_]*?=.*$\\', env) is None:\\n                    raise ValueError(\\'Environment variable: `{0}` is not valid.\\'.format(env))\\n\\n            edge_manager.start_singlemodule(input_list, port, environment, edge_runtime_version)\\n\\n            data = \\'--data \\\\\\'{{\"inputName\": \"{0}\",\"data\":\"hello world\"}}\\\\\\'\\'.format(input_list[0])\\n            url = \\'http://localhost:{0}/api/v1/messages\\'.format(port)\\n            curl_msg = \\'        curl --header \"Content-Type: application/json\" --request POST {0} {1}\\'.format(data, url)\\n            output.info(\\'IoT Edge Simulator has been started in single module mode.\\')\\n            output.info(\\'Please run `iotedgehubdev modulecred` to get credential to connect your module.\\')\\n            output.info(\\'And send message through:\\')\\n            output.line()\\n            output.echo(curl_msg, \\'green\\')\\n            output.line()\\n            output.info(\\n                \\'Please refer to https://github.com/Azure/iot-edge-testing-utility/blob/master/swagger.json\\'\\n                \\' for detail schema\\')\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Stop the IoT Edge Simulator.\")\\n@click.option(\\'--host\\',\\n              \\'-H\\',\\n              required=False,\\n              help=\\'Docker daemon socket to connect to\\')\\n@_with_telemetry\\ndef stop(host):\\n    if host is not None:\\n        os.environ[DOCKER_HOST] = str(host)\\n    EdgeManager.stop()\\n    output.info(\\'IoT Edge Simulator has been stopped successfully.\\')\\n\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Determine whether config file is valid.\")\\n@_with_telemetry\\ndef validateconfig():\\n    _parse_config_json()\\n    output.info(\\'Config file is valid.\\')\\n\\n@click.command(context_settings=CONTEXT_SETTINGS,\\n               help=\"Create IoT Edge device CA\")\\n@click.option(\\'--output-dir\\',\\n              \\'-o\\',\\n              required=False,\\n              default=\".\",\\n              help=\\'The output folder of generated certs. \\'\\n              \\'The tool will create a certs folder under given path to store the certs.\\')\\n@click.option(\\'--valid-days\\',\\n              \\'-d\\',\\n              required=False,\\n              default=90,\\n              show_default=True,\\n              help=\\'Days before cert expires.\\')\\n@click.option(\\'--force\\',\\n              \\'-f\\',\\n              required=False,\\n              is_flag=True,\\n              default=False,\\n              show_default=True,\\n              help=\\'Whether overwrite existing cert files.\\')\\n@click.option(\\'--trusted-ca\\',\\n              \\'-c\\',\\n              required=False,\\n              help=\\'Path of your own trusted ca used to sign IoT Edge device ca. \\'\\n              \\'Please also provide trsuted ca private key and related passphase (if have).\\'\\n              )\\n@click.option(\\'--trusted-ca-key\\',\\n              \\'-k\\',\\n              required=False,\\n              help=\\'Path of your own trusted ca private key used to sign IoT Edge device ca. \\'\\n              \\'Please also provide trusted ca and related passphase (if have).\\')\\n@click.option(\\'--trusted-ca-key-passphase\\',\\n              \\'-p\\',\\n              required=False,\\n              help=\\'Passphase of your own trusted ca private key.\\')\\n@_with_telemetry\\ndef generatedeviceca(output_dir, valid_days, force, trusted_ca, trusted_ca_key, trusted_ca_key_passphase):\\n    try:\\n        output_dir = os.path.abspath(os.path.join(output_dir, EdgeConstants.CERT_FOLDER))\\n        if trusted_ca_key_passphase:\\n            trusted_ca_key_passphase = trusted_ca_key_passphase.encode()  # crypto requires byte string\\n        # Check whether create new trusted CA and generate files to be created\\n        output_files = list(Utils.get_device_ca_file_paths(output_dir, EdgeConstants.DEVICE_CA_ID).values())\\n        if trusted_ca and trusted_ca_key:\\n            output.info(\\'Trusted CA (certification authority) and trusted CA key were provided.\\'\\n                        \\' Load trusted CA from given files.\\')\\n        else:\\n            output.info(\\'Trusted CA (certification authority) and Trusted CA key were not provided.\\'\\n                        \\' Will create new trusted CA.\\')\\n            root_ca_files = Utils.get_device_ca_file_paths(output_dir, EdgeConstants.ROOT_CA_ID)\\n            output_files.append(root_ca_files[EdgeConstants.CERT_SUFFIX])\\n            output_files.append(root_ca_files[EdgeConstants.KEY_SUFFIX])\\n        # Check whether the output files exist\\n        existing_files = []\\n        for file in output_files:\\n            if os.path.exists(file):\\n                existing_files.append(file)\\n        if len(existing_files) > 0:\\n            if force:\\n                output.info(\\'Following cert files already exist and will be overwritten: %s\\' % existing_files)\\n            else:\\n                raise EdgeError(\\'Following cert files already exist. \\'\\n                                \\'You can use --force option to overwrite existing files: %s\\' % existing_files)\\n        # Generate certs\\n        edgeCert = EdgeCert(output_dir, \\'\\')\\n        edgeCert.generate_device_ca(valid_days, force, trusted_ca, trusted_ca_key, trusted_ca_key_passphase)\\n        output.info(\\'Successfully generated device CA. Please find the generated certs at %s\\' % output_dir)\\n    except Exception as e:\\n        raise e\\n\\n\\nmain.add_command(setup)\\nmain.add_command(modulecred)\\nmain.add_command(start)\\nmain.add_command(stop)\\nmain.add_command(validateconfig)\\nmain.add_command(generatedeviceca)\\n\\nif __name__ == \"__main__\":\\n    main()\\n'"}, {"func_args": {"source": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\nimport os\\nimport re\\n\\nfrom jsonpath_rw import parse\\n\\nfrom .constants import EdgeConstants\\n\\n\\nclass CreateOptionParser(object):\\n    def __init__(self, create_option):\\n        self.create_option = create_option\\n\\n    def parse_create_option(self):\\n        ret = {}\\n        for compose_key in COMPOSE_KEY_CREATE_OPTION_MAPPING:\\n            create_option_value = self.get_create_option_value(compose_key)\\n            if create_option_value:\\n                parser_func = COMPOSE_KEY_CREATE_OPTION_MAPPING[compose_key][\\'parser_func\\']\\n                ret[compose_key] = parser_func(create_option_value)\\n        return ret\\n\\n    def get_create_option_value(self, compose_key):\\n        create_option_value_dict = {}\\n        for API_key, API_jsonpath in COMPOSE_KEY_CREATE_OPTION_MAPPING[compose_key][\\'API_Info\\'].items():\\n            jsonpath_expr = parse(API_jsonpath)\\n            value_list = jsonpath_expr.find(self.create_option)\\n            if value_list:\\n                create_option_value_dict[API_key] = value_list[0].value\\n        return create_option_value_dict\\n\\n\\ndef service_parser_naive(create_options_details):\\n    return list(create_options_details.values())[0]\\n\\n\\ndef service_parser_expose(create_options_details):\\n    return list(create_options_details[\\'ExposedPorts\\'].keys())\\n\\n\\ndef service_parser_command(create_options_details):\\n    cmd = create_options_details[\\'Cmd\\']\\n    if not isinstance(cmd, list):\\n        return cmd\\n    return \\' \\'.join(cmd).strip()\\n\\n\\ndef service_parser_healthcheck(create_options_details):\\n    healthcheck_config = create_options_details[\\'Healthcheck\\']\\n    try:\\n        return {\\n            \\'test\\': healthcheck_config[\\'Test\\'],\\n            \\'interval\\': time_ns_ms(healthcheck_config[\\'Interval\\']),\\n            \\'timeout\\': time_ns_ms(healthcheck_config[\\'Timeout\\']),\\n            \\'retries\\': healthcheck_config[\\'Retries\\'],\\n            \\'start_period\\': time_ns_ms(healthcheck_config[\\'StartPeriod\\'])\\n        }\\n    except KeyError as err:\\n        raise KeyError(\\'Missing key : {0} in Healthcheck\\'.format(err))\\n\\n\\ndef service_parser_stop_timeout(create_options_details):\\n    try:\\n        return str(int(create_options_details[\\'StopTimeout\\'])) + \\'s\\'\\n    except TypeError:\\n        raise TypeError(\\'StopTimeout should be an integer.\\')\\n\\n\\ndef service_parser_hostconfig_devices(create_options_details):\\n    devices_list = []\\n    for device in create_options_details[\\'Devices\\']:\\n        try:\\n            devices_list.append(\"{0}:{1}:{2}\".format(device[\\'PathOnHost\\'],\\n                                                     device[\\'PathInContainer\\'], device[\\'CgroupPermissions\\']))\\n        except KeyError as err:\\n            raise KeyError(\\'Missing key : {0} in HostConfig.Devices.\\'.format(err))\\n    return devices_list\\n\\n\\ndef service_parser_hostconfig_restart(create_options_details):\\n    restart_config = create_options_details[\\'RestartPolicy\\']\\n    ret = \"\"\\n    if restart_config[\\'Name\\'] == \"\":\\n        ret = \"no\"\\n    elif restart_config[\\'Name\\'] == \"on-failure\":\\n        try:\\n            ret = \"on-failure:{0}\".format(restart_config[\\'MaximumRetryCount\\'])\\n        except KeyError as err:\\n            raise KeyError(\\'Missing key : {0} in HostConfig.RestartPolicy.\\'.format(err))\\n    elif restart_config[\\'Name\\'] == \"always\" or restart_config[\\'Name\\'] == \"unless-stopped\":\\n        ret = restart_config[\\'Name\\']\\n    else:\\n        raise ValueError(\"RestartPolicy Name should be one of \\'\\', \\'always\\', \\'unless-stopped\\', \\'on-failure\\'\")\\n    return ret\\n\\n\\ndef service_parser_hostconfig_ulimits(create_options_details):\\n    ulimits_dict = {}\\n    for ulimit in create_options_details[\\'Ulimits\\']:\\n        try:\\n            ulimits_dict[ulimit[\\'Name\\']] = {\\n                \\'soft\\': ulimit[\\'Soft\\'],\\n                \\'hard\\': ulimit[\\'Hard\\']\\n            }\\n        except KeyError as err:\\n            raise KeyError(\\'Missing key : {0} in HostConfig.Ulimits\\'.format(err))\\n    return ulimits_dict\\n\\n\\ndef service_parser_hostconfig_logging(create_options_details):\\n    try:\\n        logging_dict = {\\n            \\'driver\\': create_options_details[\\'LogConfig\\'][\\'Type\\'],\\n            \\'options\\': create_options_details[\\'LogConfig\\'][\\'Config\\']\\n        }\\n    except KeyError as err:\\n        raise KeyError(\\'Missing key : {0} in HostConfig.LogConfig\\'.format(err))\\n    return logging_dict\\n\\n\\ndef service_parser_hostconfig_ports(create_options_details):\\n    ports_list = []\\n    for container_port, host_ports in create_options_details[\\'PortBindings\\'].items():\\n        for host_port_info in host_ports:\\n            host_port = \"\"\\n            if \\'HostIp\\' in host_port_info and \\'HostPort\\' in host_port_info:\\n                host_port = \"{0}:{1}\".format(host_port_info[\\'HostIp\\'], host_port_info[\\'HostPort\\'])\\n            elif \\'HostIp\\' in host_port_info:\\n                host_port = host_port_info[\\'HostIp\\']\\n            elif \\'HostPort\\' in host_port_info:\\n                host_port = host_port_info[\\'HostPort\\']\\n            ports_list.append(\"{0}:{1}\".format(host_port, container_port))\\n    return ports_list\\n\\n\\ndef service_parser_networks(create_options_details):\\n    networks_dict = {}\\n    for nw, nw_config in create_options_details[\\'NetworkingConfig\\'].items():\\n        networks_dict[nw] = {}\\n        if \\'Aliases\\' in nw_config:\\n            networks_dict[nw][\\'aliases\\'] = nw_config[\\'Aliases\\']\\n        if \\'IPAMConfig\\' in nw_config:\\n            if \\'IPv4Address\\' in nw_config[\\'IPAMConfig\\']:\\n                networks_dict[nw][\\'ipv4_address\\'] = nw_config[\\'IPAMConfig\\'][\\'IPv4Address\\']\\n            if \\'IPv6Address\\' in nw_config[\\'IPAMConfig\\']:\\n                networks_dict[nw][\\'ipv6_address\\'] = nw_config[\\'IPAMConfig\\'][\\'IPv6Address\\']\\n    return networks_dict\\n\\n\\ndef service_parser_volumes(create_options_details):\\n    volumes_list = []\\n    for mount in create_options_details.get(\\'Mounts\\', []):\\n        try:\\n            volume_info = {\\n                \\'target\\': mount[\\'Target\\'],\\n                \\'type\\': mount[\\'Type\\']\\n            }\\n            if mount[\\'Type\\'] == \\'volume\\' or mount[\\'Type\\'] == \\'bind\\':\\n                volume_info[\\'source\\'] = mount[\\'Source\\']\\n            if \\'ReadOnly\\' in mount:\\n                volume_info[\\'read_only\\'] = mount[\\'ReadOnly\\']\\n\\n            if mount[\\'Type\\'] == \\'volume\\' and \\'VolumeOptions\\' in mount:\\n                if \\'NoCopy\\' in mount[\\'VolumeOptions\\']:\\n                    volume_info[\\'volume\\'] = {\\n                        \\'nocopy\\': mount[\\'VolumeOptions\\'][\\'NoCopy\\']\\n                    }\\n            if mount[\\'Type\\'] == \\'bind\\' and \\'BindOptions\\' in mount:\\n                if \\'Propagation\\' in mount[\\'BindOptions\\']:\\n                    volume_info[\\'bind\\'] = {\\n                        \\'propagation\\': mount[\\'BindOptions\\'][\\'Propagation\\']\\n                    }\\n            if mount[\\'Type\\'] == \\'tmpfs\\' and \\'TmpfsOptions\\' in mount:\\n                if \\'SizeBytes\\' in mount[\\'TmpfsOptions\\']:\\n                    volume_info[\\'tmpfs\\'] = {\\n                        \\'size\\': mount[\\'TmpfsOptions\\'][\\'SizeBytes\\']\\n                    }\\n        except KeyError as e:\\n            raise KeyError(\\'Missing key {0} in create option HostConfig Mounts.\\'.format(e))\\n        volumes_list.append(volume_info)\\n\\n    for bind in create_options_details.get(\\'Binds\\', []):\\n        target = None\\n\\n        # Binds should be in the format [source:]destination[:mode]\\n        # Windows format and LCOW format are more strict than Linux format due to colons in Windows paths,\\n        # so match with them first\\n        match = re.match(EdgeConstants.MOUNT_WIN_REGEX, bind) or re.match(EdgeConstants.MOUNT_LCOW_REGEX, bind)\\n        if match is not None:\\n            source = match.group(\\'source\\') or \\'\\'\\n            target = match.group(\\'destination\\')\\n            read_only = match.group(\\'mode\\') == \\'ro\\'\\n        else:\\n            # Port of Docker daemon\\n            # https://github.com/docker/docker-ce/blob/1c27a55b6259743f35549e96d06334a53d0c0549/components/engine/volume/mounts/linux_parser.go#L18-L28\\n            parts = bind.split(\\':\\')\\n            if len(parts) == 2 or (len(parts) == 3 and parts[2] in (\\'ro\\', \\'rw\\', \\'\\')):\\n                if parts[0] != \\'\\':\\n                    source = parts[0]\\n                    target = parts[1]\\n                    read_only = len(parts) == 3 and parts[2] == \\'ro\\'\\n\\n        if target is not None:\\n            volume_info = {\\n                \\'type\\': \\'bind\\' if source and os.path.isabs(source) else \\'volume\\',\\n                \\'source\\': source,\\n                \\'target\\': target\\n            }\\n            if read_only:\\n                volume_info[\\'read_only\\'] = True\\n            volumes_list.append(volume_info)\\n        else:\\n            raise ValueError(\\'Invalid create option Binds: {0}\\'.format(bind))\\n\\n    return volumes_list\\n\\n\\ndef time_ns_ms(ns):\\n    if ns != 0 and ns < 1000000:\\n        raise ValueError(\\'The time should be 0 or at least 1000000 (1 ms)\\')\\n    return str(int(ns / 1000000)) + \\'ms\\'\\n\\n\\n\\'\\'\\'\\nThe mapping relationship between docker compose key and create option API key\\n\\'docker compose key\\': {\\'API_Info\\': {\\'API key\\':\\'API jsonpath\\'}, \\'parser_func\\': parser_func},\\n\\'\\'\\'\\nCOMPOSE_KEY_CREATE_OPTION_MAPPING = {\\n    \\'hostname\\': {\\'API_Info\\': {\\'Hostname\\': \"$[\\'Hostname\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'domainname\\': {\\'API_Info\\': {\\'Domainname\\': \"$[\\'Domainname\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'user\\': {\\'API_Info\\': {\\'User\\': \"$[\\'User\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'expose\\': {\\'API_Info\\': {\\'ExposedPorts\\': \"$[\\'ExposedPorts\\']\"}, \\'parser_func\\': service_parser_expose},\\n    \\'tty\\': {\\'API_Info\\': {\\'Tty\\': \"$[\\'Tty\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'environment\\': {\\'API_Info\\': {\\'Env\\': \"$[\\'Env\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'command\\': {\\'API_Info\\': {\\'Cmd\\': \"$[\\'Cmd\\']\"}, \\'parser_func\\': service_parser_command},\\n    \\'healthcheck\\': {\\'API_Info\\': {\\'Healthcheck\\': \"$[\\'Healthcheck\\']\"}, \\'parser_func\\': service_parser_healthcheck},\\n    \\'image\\': {\\'API_Info\\': {\\'Image\\': \"$[\\'Image\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'working_dir\\': {\\'API_Info\\': {\\'WorkingDir\\': \"$[\\'WorkingDir\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'entrypoint\\': {\\'API_Info\\': {\\'Entrypoint\\': \"$[\\'Entrypoint\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'mac_address\\': {\\'API_Info\\': {\\'MacAddress\\': \"$[\\'MacAddress\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'labels\\': {\\'API_Info\\': {\\'Labels\\': \"$[\\'Labels\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'stop_signal\\': {\\'API_Info\\': {\\'StopSignal\\': \"$[\\'StopSignal\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'stop_grace_period\\': {\\'API_Info\\': {\\'StopTimeout\\': \"$[\\'StopTimeout\\']\"}, \\'parser_func\\': service_parser_stop_timeout},\\n\\n    # HostConfig\\n    \\'ports\\': {\\'API_Info\\': {\\'PortBindings\\': \"$[\\'HostConfig\\'][\\'PortBindings\\']\"}, \\'parser_func\\': service_parser_hostconfig_ports},\\n    \\'privileged\\': {\\'API_Info\\': {\\'Privileged\\': \"$[\\'HostConfig\\'][\\'Privileged\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'network_mode\\': {\\'API_Info\\': {\\'NetworkMode\\': \"$[\\'HostConfig\\'][\\'NetworkMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'devices\\': {\\'API_Info\\': {\\'Devices\\': \"$[\\'HostConfig\\'][\\'Devices\\']\"}, \\'parser_func\\': service_parser_hostconfig_devices},\\n    \\'dns\\': {\\'API_Info\\': {\\'Dns\\': \"$[\\'HostConfig\\'][\\'Dns\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'dns_search\\': {\\'API_Info\\': {\\'DnsSearch\\': \"$[\\'HostConfig\\'][\\'DnsSearch\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'restart\\': {\\n        \\'API_Info\\': {\\'RestartPolicy\\': \"$[\\'HostConfig\\'][\\'RestartPolicy\\']\"},\\n        \\'parser_func\\': service_parser_hostconfig_restart\\n    },\\n    \\'cap_add\\': {\\'API_Info\\': {\\'CapAdd\\': \"$[\\'HostConfig\\'][\\'CapAdd\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'cap_drop\\': {\\'API_Info\\': {\\'CapDrop\\': \"$[\\'HostConfig\\'][\\'CapDrop\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'ulimits\\': {\\'API_Info\\': {\\'Ulimits\\': \"$[\\'HostConfig\\'][\\'Ulimits\\']\"}, \\'parser_func\\': service_parser_hostconfig_ulimits},\\n    \\'logging\\': {\\'API_Info\\': {\\'LogConfig\\': \"$[\\'HostConfig\\'][\\'LogConfig\\']\"}, \\'parser_func\\': service_parser_hostconfig_logging},\\n    \\'extra_hosts\\': {\\'API_Info\\': {\\'ExtraHosts\\': \"$[\\'HostConfig\\'][\\'ExtraHosts\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'read_only\\': {\\'API_Info\\': {\\'ReadonlyRootfs\\': \"$[\\'HostConfig\\'][\\'ReadonlyRootfs\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'pid\\': {\\'API_Info\\': {\\'PidMode\\': \"$[\\'HostConfig\\'][\\'PidMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'security_opt\\': {\\'API_Info\\': {\\'SecurityOpt\\': \"$[\\'HostConfig\\'][\\'SecurityOpt\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'ipc\\': {\\'API_Info\\': {\\'IpcMode\\': \"$[\\'HostConfig\\'][\\'IpcMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'cgroup_parent\\': {\\'API_Info\\': {\\'CgroupParent\\': \"$[\\'HostConfig\\'][\\'CgroupParent\\']\"}, \\'parser_func\\': service_parser_naive},\\n    # \\'shm_size:\\':{\\'API_Info\\':\\'ShmSize\\',\\'parser_func\\':service_parser_naive},\\n    \\'sysctls\\': {\\'API_Info\\': {\\'Sysctls\\': \"$[\\'HostConfig\\'][\\'Sysctls\\']\"}, \\'parser_func\\': service_parser_naive},\\n    # \\'tmpfs:\\':{\\'API_Info\\':\\'Tmpfs\\',\\'parser_func\\':service_parser_naive},\\n    \\'userns_mode\\': {\\'API_Info\\': {\\'UsernsMode\\': \"$[\\'HostConfig\\'][\\'UsernsMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'isolation\\': {\\'API_Info\\': {\\'Isolation\\': \"$[\\'HostConfig\\'][\\'Isolation\\']\"}, \\'parser_func\\': service_parser_naive},\\n\\n    # Volumes\\n    \\'volumes\\': {\\n        \\'API_Info\\': {\\n            \\'Mounts\\': \"$[\\'HostConfig\\'][\\'Mounts\\']\",\\n            \\'Binds\\': \"$[\\'HostConfig\\'][\\'Binds\\']\"\\n        },\\n        \\'parser_func\\': service_parser_volumes\\n    },\\n\\n    # NetworkingConfig\\n    \\'networks\\': {\\n        \\'API_Info\\': {\\'NetworkingConfig\\': \"$[\\'NetworkingConfig\\'][\\'EndpointsConfig\\']\"},\\n        \\'parser_func\\': service_parser_networks\\n    }\\n}\\n'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\nimport os\\nimport re\\n\\nfrom jsonpath_rw import parse\\n\\nfrom .constants import EdgeConstants\\n\\n\\nclass CreateOptionParser(object):\\n    def __init__(self, create_option):\\n        self.create_option = create_option\\n\\n    def parse_create_option(self):\\n        ret = {}\\n        for compose_key in COMPOSE_KEY_CREATE_OPTION_MAPPING:\\n            create_option_value = self.get_create_option_value(compose_key)\\n            if create_option_value:\\n                parser_func = COMPOSE_KEY_CREATE_OPTION_MAPPING[compose_key][\\'parser_func\\']\\n                ret[compose_key] = parser_func(create_option_value)\\n        return ret\\n\\n    def get_create_option_value(self, compose_key):\\n        create_option_value_dict = {}\\n        for API_key, API_jsonpath in COMPOSE_KEY_CREATE_OPTION_MAPPING[compose_key][\\'API_Info\\'].items():\\n            jsonpath_expr = parse(API_jsonpath)\\n            value_list = jsonpath_expr.find(self.create_option)\\n            if value_list:\\n                create_option_value_dict[API_key] = value_list[0].value\\n        return create_option_value_dict\\n\\n\\ndef service_parser_naive(create_options_details):\\n    return list(create_options_details.values())[0]\\n\\n\\ndef service_parser_expose(create_options_details):\\n    return list(create_options_details[\\'ExposedPorts\\'].keys())\\n\\n\\ndef service_parser_command(create_options_details):\\n    cmd = create_options_details[\\'Cmd\\']\\n    if not isinstance(cmd, list):\\n        return cmd\\n    return \\' \\'.join(cmd).strip()\\n\\n\\ndef service_parser_healthcheck(create_options_details):\\n    healthcheck_config = create_options_details[\\'Healthcheck\\']\\n    try:\\n        return {\\n            \\'test\\': healthcheck_config[\\'Test\\'],\\n            \\'interval\\': time_ns_ms(healthcheck_config[\\'Interval\\']),\\n            \\'timeout\\': time_ns_ms(healthcheck_config[\\'Timeout\\']),\\n            \\'retries\\': healthcheck_config[\\'Retries\\'],\\n            \\'start_period\\': time_ns_ms(healthcheck_config[\\'StartPeriod\\'])\\n        }\\n    except KeyError as err:\\n        raise KeyError(\\'Missing key : {0} in Healthcheck\\'.format(err))\\n\\n\\ndef service_parser_stop_timeout(create_options_details):\\n    try:\\n        return str(int(create_options_details[\\'StopTimeout\\'])) + \\'s\\'\\n    except TypeError:\\n        raise TypeError(\\'StopTimeout should be an integer.\\')\\n\\n\\ndef service_parser_hostconfig_devices(create_options_details):\\n    devices_list = []\\n    for device in create_options_details[\\'Devices\\']:\\n        try:\\n            devices_list.append(\"{0}:{1}:{2}\".format(device[\\'PathOnHost\\'],\\n                                                     device[\\'PathInContainer\\'], device[\\'CgroupPermissions\\']))\\n        except KeyError as err:\\n            raise KeyError(\\'Missing key : {0} in HostConfig.Devices.\\'.format(err))\\n    return devices_list\\n\\n\\ndef service_parser_hostconfig_restart(create_options_details):\\n    restart_config = create_options_details[\\'RestartPolicy\\']\\n    ret = \"\"\\n    if restart_config[\\'Name\\'] == \"\":\\n        ret = \"no\"\\n    elif restart_config[\\'Name\\'] == \"on-failure\":\\n        try:\\n            ret = \"on-failure:{0}\".format(restart_config[\\'MaximumRetryCount\\'])\\n        except KeyError as err:\\n            raise KeyError(\\'Missing key : {0} in HostConfig.RestartPolicy.\\'.format(err))\\n    elif restart_config[\\'Name\\'] == \"always\" or restart_config[\\'Name\\'] == \"unless-stopped\":\\n        ret = restart_config[\\'Name\\']\\n    else:\\n        raise ValueError(\"RestartPolicy Name should be one of \\'\\', \\'always\\', \\'unless-stopped\\', \\'on-failure\\'\")\\n    return ret\\n\\n\\ndef service_parser_hostconfig_ulimits(create_options_details):\\n    ulimits_dict = {}\\n    for ulimit in create_options_details[\\'Ulimits\\']:\\n        try:\\n            ulimits_dict[ulimit[\\'Name\\']] = {\\n                \\'soft\\': ulimit[\\'Soft\\'],\\n                \\'hard\\': ulimit[\\'Hard\\']\\n            }\\n        except KeyError as err:\\n            raise KeyError(\\'Missing key : {0} in HostConfig.Ulimits\\'.format(err))\\n    return ulimits_dict\\n\\n\\ndef service_parser_hostconfig_logging(create_options_details):\\n    try:\\n        logging_dict = {\\n            \\'driver\\': create_options_details[\\'LogConfig\\'][\\'Type\\'],\\n            \\'options\\': create_options_details[\\'LogConfig\\'][\\'Config\\']\\n        }\\n    except KeyError as err:\\n        raise KeyError(\\'Missing key : {0} in HostConfig.LogConfig\\'.format(err))\\n    return logging_dict\\n\\n\\ndef service_parser_hostconfig_ports(create_options_details):\\n    ports_list = []\\n    for container_port, host_ports in create_options_details[\\'PortBindings\\'].items():\\n        for host_port_info in host_ports:\\n            host_port = \"\"\\n            if \\'HostIp\\' in host_port_info and \\'HostPort\\' in host_port_info:\\n                host_port = \"{0}:{1}\".format(host_port_info[\\'HostIp\\'], host_port_info[\\'HostPort\\'])\\n            elif \\'HostIp\\' in host_port_info:\\n                host_port = host_port_info[\\'HostIp\\']\\n            elif \\'HostPort\\' in host_port_info:\\n                host_port = host_port_info[\\'HostPort\\']\\n            ports_list.append(\"{0}:{1}\".format(host_port, container_port))\\n    return ports_list\\n\\n\\ndef service_parser_networks(create_options_details):\\n    networks_dict = {}\\n    for nw, nw_config in create_options_details[\\'NetworkingConfig\\'].items():\\n        networks_dict[nw] = {}\\n        if \\'Aliases\\' in nw_config:\\n            networks_dict[nw][\\'aliases\\'] = nw_config[\\'Aliases\\']\\n        if \\'IPAMConfig\\' in nw_config:\\n            if \\'IPv4Address\\' in nw_config[\\'IPAMConfig\\']:\\n                networks_dict[nw][\\'ipv4_address\\'] = nw_config[\\'IPAMConfig\\'][\\'IPv4Address\\']\\n            if \\'IPv6Address\\' in nw_config[\\'IPAMConfig\\']:\\n                networks_dict[nw][\\'ipv6_address\\'] = nw_config[\\'IPAMConfig\\'][\\'IPv6Address\\']\\n    return networks_dict\\n\\n\\ndef service_parser_volumes(create_options_details):\\n    volumes_list = []\\n    for mount in create_options_details.get(\\'Mounts\\', []):\\n        try:\\n            volume_info = {\\n                \\'target\\': mount[\\'Target\\'],\\n                \\'type\\': mount[\\'Type\\']\\n            }\\n            if mount[\\'Type\\'] == \\'volume\\' or mount[\\'Type\\'] == \\'bind\\':\\n                volume_info[\\'source\\'] = mount[\\'Source\\']\\n            if \\'ReadOnly\\' in mount:\\n                volume_info[\\'read_only\\'] = mount[\\'ReadOnly\\']\\n\\n            if mount[\\'Type\\'] == \\'volume\\' and \\'VolumeOptions\\' in mount:\\n                if \\'NoCopy\\' in mount[\\'VolumeOptions\\']:\\n                    volume_info[\\'volume\\'] = {\\n                        \\'nocopy\\': mount[\\'VolumeOptions\\'][\\'NoCopy\\']\\n                    }\\n            if mount[\\'Type\\'] == \\'bind\\' and \\'BindOptions\\' in mount:\\n                if \\'Propagation\\' in mount[\\'BindOptions\\']:\\n                    volume_info[\\'bind\\'] = {\\n                        \\'propagation\\': mount[\\'BindOptions\\'][\\'Propagation\\']\\n                    }\\n            if mount[\\'Type\\'] == \\'tmpfs\\' and \\'TmpfsOptions\\' in mount:\\n                if \\'SizeBytes\\' in mount[\\'TmpfsOptions\\']:\\n                    volume_info[\\'tmpfs\\'] = {\\n                        \\'size\\': mount[\\'TmpfsOptions\\'][\\'SizeBytes\\']\\n                    }\\n        except KeyError as e:\\n            raise KeyError(\\'Missing key {0} in create option HostConfig Mounts.\\'.format(e))\\n        volumes_list.append(volume_info)\\n\\n    for bind in create_options_details.get(\\'Binds\\', []):\\n        target = None\\n\\n        # Binds should be in the format [source:]destination[:mode]\\n        # Windows format and LCOW format are more strict than Linux format due to colons in Windows paths,\\n        # so match with them first\\n        match = re.match(EdgeConstants.MOUNT_WIN_REGEX, bind) or re.match(EdgeConstants.MOUNT_LCOW_REGEX, bind)\\n        if match is not None:\\n            source = match.group(\\'source\\') or \\'\\'\\n            target = match.group(\\'destination\\')\\n            read_only = match.group(\\'mode\\') == \\'ro\\'\\n        else:\\n            # Port of Docker daemon\\n            # https://github.com/docker/docker-ce/blob/1c27a55b6259743f35549e96d06334a53d0c0549/components/engine/volume/mounts/linux_parser.go#L18-L28\\n            parts = bind.split(\\':\\')\\n            if len(parts) == 2 or (len(parts) == 3 and parts[2] in (\\'ro\\', \\'rw\\', \\'\\')):\\n                if parts[0] != \\'\\':\\n                    source = parts[0]\\n                    target = parts[1]\\n                    read_only = len(parts) == 3 and parts[2] == \\'ro\\'\\n\\n        if target is not None:\\n            volume_info = {\\n                \\'type\\': \\'bind\\' if source and os.path.isabs(source) else \\'volume\\',\\n                \\'source\\': source,\\n                \\'target\\': target\\n            }\\n            if read_only:\\n                volume_info[\\'read_only\\'] = True\\n            volumes_list.append(volume_info)\\n        else:\\n            raise ValueError(\\'Invalid create option Binds: {0}\\'.format(bind))\\n\\n    return volumes_list\\n\\n\\ndef time_ns_ms(ns):\\n    if ns != 0 and ns < 1000000:\\n        raise ValueError(\\'The time should be 0 or at least 1000000 (1 ms)\\')\\n    return str(int(ns / 1000000)) + \\'ms\\'\\n\\n\\n\\'\\'\\'\\nThe mapping relationship between docker compose key and create option API key\\n\\'docker compose key\\': {\\'API_Info\\': {\\'API key\\':\\'API jsonpath\\'}, \\'parser_func\\': parser_func},\\n\\'\\'\\'\\nCOMPOSE_KEY_CREATE_OPTION_MAPPING = {\\n    \\'hostname\\': {\\'API_Info\\': {\\'Hostname\\': \"$[\\'Hostname\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'domainname\\': {\\'API_Info\\': {\\'Domainname\\': \"$[\\'Domainname\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'user\\': {\\'API_Info\\': {\\'User\\': \"$[\\'User\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'expose\\': {\\'API_Info\\': {\\'ExposedPorts\\': \"$[\\'ExposedPorts\\']\"}, \\'parser_func\\': service_parser_expose},\\n    \\'tty\\': {\\'API_Info\\': {\\'Tty\\': \"$[\\'Tty\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'environment\\': {\\'API_Info\\': {\\'Env\\': \"$[\\'Env\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'command\\': {\\'API_Info\\': {\\'Cmd\\': \"$[\\'Cmd\\']\"}, \\'parser_func\\': service_parser_command},\\n    \\'healthcheck\\': {\\'API_Info\\': {\\'Healthcheck\\': \"$[\\'Healthcheck\\']\"}, \\'parser_func\\': service_parser_healthcheck},\\n    \\'image\\': {\\'API_Info\\': {\\'Image\\': \"$[\\'Image\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'working_dir\\': {\\'API_Info\\': {\\'WorkingDir\\': \"$[\\'WorkingDir\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'entrypoint\\': {\\'API_Info\\': {\\'Entrypoint\\': \"$[\\'Entrypoint\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'mac_address\\': {\\'API_Info\\': {\\'MacAddress\\': \"$[\\'MacAddress\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'labels\\': {\\'API_Info\\': {\\'Labels\\': \"$[\\'Labels\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'stop_signal\\': {\\'API_Info\\': {\\'StopSignal\\': \"$[\\'StopSignal\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'stop_grace_period\\': {\\'API_Info\\': {\\'StopTimeout\\': \"$[\\'StopTimeout\\']\"}, \\'parser_func\\': service_parser_stop_timeout},\\n\\n    # HostConfig\\n    \\'ports\\': {\\'API_Info\\': {\\'PortBindings\\': \"$[\\'HostConfig\\'][\\'PortBindings\\']\"}, \\'parser_func\\': service_parser_hostconfig_ports},\\n    \\'privileged\\': {\\'API_Info\\': {\\'Privileged\\': \"$[\\'HostConfig\\'][\\'Privileged\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'network_mode\\': {\\'API_Info\\': {\\'NetworkMode\\': \"$[\\'HostConfig\\'][\\'NetworkMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'devices\\': {\\'API_Info\\': {\\'Devices\\': \"$[\\'HostConfig\\'][\\'Devices\\']\"}, \\'parser_func\\': service_parser_hostconfig_devices},\\n    \\'dns\\': {\\'API_Info\\': {\\'Dns\\': \"$[\\'HostConfig\\'][\\'Dns\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'dns_search\\': {\\'API_Info\\': {\\'DnsSearch\\': \"$[\\'HostConfig\\'][\\'DnsSearch\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'restart\\': {\\n        \\'API_Info\\': {\\'RestartPolicy\\': \"$[\\'HostConfig\\'][\\'RestartPolicy\\']\"},\\n        \\'parser_func\\': service_parser_hostconfig_restart\\n    },\\n    \\'cap_add\\': {\\'API_Info\\': {\\'CapAdd\\': \"$[\\'HostConfig\\'][\\'CapAdd\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'cap_drop\\': {\\'API_Info\\': {\\'CapDrop\\': \"$[\\'HostConfig\\'][\\'CapDrop\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'ulimits\\': {\\'API_Info\\': {\\'Ulimits\\': \"$[\\'HostConfig\\'][\\'Ulimits\\']\"}, \\'parser_func\\': service_parser_hostconfig_ulimits},\\n    \\'logging\\': {\\'API_Info\\': {\\'LogConfig\\': \"$[\\'HostConfig\\'][\\'LogConfig\\']\"}, \\'parser_func\\': service_parser_hostconfig_logging},\\n    \\'extra_hosts\\': {\\'API_Info\\': {\\'ExtraHosts\\': \"$[\\'HostConfig\\'][\\'ExtraHosts\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'read_only\\': {\\'API_Info\\': {\\'ReadonlyRootfs\\': \"$[\\'HostConfig\\'][\\'ReadonlyRootfs\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'pid\\': {\\'API_Info\\': {\\'PidMode\\': \"$[\\'HostConfig\\'][\\'PidMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'security_opt\\': {\\'API_Info\\': {\\'SecurityOpt\\': \"$[\\'HostConfig\\'][\\'SecurityOpt\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'ipc\\': {\\'API_Info\\': {\\'IpcMode\\': \"$[\\'HostConfig\\'][\\'IpcMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'cgroup_parent\\': {\\'API_Info\\': {\\'CgroupParent\\': \"$[\\'HostConfig\\'][\\'CgroupParent\\']\"}, \\'parser_func\\': service_parser_naive},\\n    # \\'shm_size:\\':{\\'API_Info\\':\\'ShmSize\\',\\'parser_func\\':service_parser_naive},\\n    \\'sysctls\\': {\\'API_Info\\': {\\'Sysctls\\': \"$[\\'HostConfig\\'][\\'Sysctls\\']\"}, \\'parser_func\\': service_parser_naive},\\n    # \\'tmpfs:\\':{\\'API_Info\\':\\'Tmpfs\\',\\'parser_func\\':service_parser_naive},\\n    \\'userns_mode\\': {\\'API_Info\\': {\\'UsernsMode\\': \"$[\\'HostConfig\\'][\\'UsernsMode\\']\"}, \\'parser_func\\': service_parser_naive},\\n    \\'isolation\\': {\\'API_Info\\': {\\'Isolation\\': \"$[\\'HostConfig\\'][\\'Isolation\\']\"}, \\'parser_func\\': service_parser_naive},\\n\\n    # Volumes\\n    \\'volumes\\': {\\n        \\'API_Info\\': {\\n            \\'Mounts\\': \"$[\\'HostConfig\\'][\\'Mounts\\']\",\\n            \\'Binds\\': \"$[\\'HostConfig\\'][\\'Binds\\']\"\\n        },\\n        \\'parser_func\\': service_parser_volumes\\n    },\\n\\n    # NetworkingConfig\\n    \\'networks\\': {\\n        \\'API_Info\\': {\\'NetworkingConfig\\': \"$[\\'NetworkingConfig\\'][\\'EndpointsConfig\\']\"},\\n        \\'parser_func\\': service_parser_networks\\n    }\\n}\\n'"}, {"func_args": {"source": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport json\\nimport os\\nimport sys\\nimport yaml\\n\\nfrom collections import OrderedDict\\nfrom io import StringIO\\nfrom .compose_parser import CreateOptionParser\\nfrom .output import Output\\n\\nCOMPOSE_VERSION = 3.6\\n\\nCREATE_OPTIONS_MAX_CHUNKS = 100\\n\\n\\nclass ComposeProject(object):\\n\\n    def __init__(self, module_content):\\n        self.module_content = module_content\\n        self.yaml_dict = OrderedDict()\\n        self.Services = OrderedDict()\\n        self.Networks = {}\\n        self.Volumes = {}\\n        self.edge_info = {}\\n\\n    def compose(self):\\n        modules = {\\n            self.edge_info[\\'hub_name\\']:\\n            self.module_content[\\'$edgeAgent\\'][\\'properties.desired\\'][\\'systemModules\\'][\\'edgeHub\\']\\n        }\\n        modules.update(self.module_content[\\'$edgeAgent\\'][\\'properties.desired\\'][\\'modules\\'])\\n        for service_name, config in modules.items():\\n            self.Services[service_name] = {}\\n            create_option_str = ComposeProject._join_create_options(config[\\'settings\\'])\\n            if create_option_str:\\n                create_option = json.loads(create_option_str)\\n                create_option_parser = CreateOptionParser(create_option)\\n                self.Services[service_name].update(create_option_parser.parse_create_option())\\n            self.Services[service_name][\\'image\\'] = config[\\'settings\\'][\\'image\\']\\n            self.Services[service_name][\\'container_name\\'] = service_name\\n\\n            if \\'networks\\' not in self.Services[service_name]:\\n                self.Services[service_name][\\'networks\\'] = {}\\n                self.Services[service_name][\\'networks\\'][self.edge_info[\\'network_info\\'][\\'NW_NAME\\']] = None\\n\\n            if \\'network_mode\\' in self.Services[service_name]:\\n                del self.Services[service_name][\\'network_mode\\']\\n\\n            if \\'host\\' in self.Services[service_name][\\'networks\\']:\\n                self.Services[service_name][\\'network_mode\\'] = \\'host\\'\\n                del self.Services[service_name][\\'networks\\']\\n\\n            if \\'labels\\' not in self.Services[service_name]:\\n                self.Services[service_name][\\'labels\\'] = {self.edge_info[\\'labels\\']: \"\"}\\n            else:\\n                self.Services[service_name][\\'labels\\'][self.edge_info[\\'labels\\']] = \"\"\\n\\n            try:\\n                # Default restart policy is \\'on-unhealthy\\'\\n                # https://github.com/Azure/iotedge/blob/8bd573590cdc149c014cf994dba58fc63f1a5c74/edge-agent/src/Microsoft.Azure.Devices.Edge.Agent.Core/Constants.cs#L18\\n                restart_policy = config.get(\\'restartPolicy\\', \\'on-unhealthy\\')\\n                self.Services[service_name][\\'restart\\'] = {\\n                    \\'never\\': \\'no\\',\\n                    \\'on-failure\\': \\'on-failure\\',\\n                    \\'always\\': \\'always\\',\\n                    \\'on-unhealthy\\': \\'always\\',\\n                    \\'unknown\\': \\'no\\'\\n                }[restart_policy]\\n\\n                if restart_policy == \\'on-unhealthy\\':\\n                    Output().warning(\\'Unsupported restart policy \\\\\\'{0}\\\\\\' in solution mode. Falling back to \\\\\\'always\\\\\\'.\\'\\n                                     .format(restart_policy))\\n            except KeyError as e:\\n                raise KeyError(\\'Unsupported restart policy {0} in solution mode.\\'.format(e))\\n\\n            if \\'env\\' in config:\\n                self.Services[service_name][\\'environment\\'] = self.config_env(\\n                    self.Services[service_name].get(\\'environment\\', []), config[\\'env\\'])\\n\\n            if service_name == self.edge_info[\\'hub_name\\']:\\n                self.config_edge_hub(service_name)\\n            else:\\n                self.config_modules(service_name)\\n\\n            if \\'networks\\' in self.Services[service_name]:\\n                for nw in self.Services[service_name][\\'networks\\']:\\n                    self.Networks[nw] = {\\n                        \\'external\\': True\\n                    }\\n\\n            for vol in self.Services[service_name][\\'volumes\\']:\\n                if vol[\\'type\\'] == \\'volume\\':\\n                    self.Volumes[vol[\\'source\\']] = {\\n                        \\'name\\': vol[\\'source\\']\\n                    }\\n\\n    def set_edge_info(self, info):\\n        self.edge_info = info\\n\\n    def config_modules(self, service_name):\\n        config = self.Services[service_name]\\n        if \\'volumes\\' not in config:\\n            config[\\'volumes\\'] = []\\n        config[\\'volumes\\'].append({\\n            \\'type\\': \\'volume\\',\\n            \\'source\\': self.edge_info[\\'volume_info\\'][\\'MODULE_VOLUME\\'],\\n            \\'target\\': self.edge_info[\\'volume_info\\'][\\'MODULE_MOUNT\\']\\n        })\\n\\n        if \\'environment\\' not in config:\\n            config[\\'environment\\'] = []\\n        for module_env in self.edge_info[\\'env_info\\'][\\'module_env\\']:\\n            config[\\'environment\\'].append(module_env)\\n        config[\\'environment\\'].append(\\n            \\'EdgeHubConnectionString=\\' + self.edge_info[\\'ConnStr_info\\'][service_name]\\n        )\\n\\n        if \\'depends_on\\' not in config:\\n            config[\\'depends_on\\'] = []\\n        config[\\'depends_on\\'].append(self.edge_info[\\'hub_name\\'])\\n\\n    def config_edge_hub(self, service_name):\\n        config = self.Services[service_name]\\n        if \\'volumes\\' not in config:\\n            config[\\'volumes\\'] = []\\n        config[\\'volumes\\'].append({\\n            \\'type\\': \\'volume\\',\\n            \\'source\\': self.edge_info[\\'volume_info\\'][\\'HUB_VOLUME\\'],\\n            \\'target\\': self.edge_info[\\'volume_info\\'][\\'HUB_MOUNT\\']\\n        })\\n\\n        config[\\'networks\\'][self.edge_info[\\'network_info\\'][\\'NW_NAME\\']] = {\\n            \\'aliases\\': [self.edge_info[\\'network_info\\'][\\'ALIASES\\']]\\n        }\\n\\n        if \\'environment\\' not in config:\\n            config[\\'environment\\'] = []\\n        routes_env = self.parse_routes()\\n        for e in routes_env:\\n            config[\\'environment\\'].append(e)\\n        config[\\'environment\\'].append(\\n            \\'IotHubConnectionString=\\' + self.edge_info[\\'ConnStr_info\\'][\\'$edgeHub\\'])\\n        config[\\'environment\\'].extend(self.edge_info[\\'env_info\\'][\\'hub_env\\'])\\n\\n    def config_env(self, env_list, env_section):\\n        env_dict = {}\\n        for env in env_list:\\n            if \\'=\\' in env:\\n                k, v = env.split(\\'=\\', 1)\\n            else:\\n                k, v = env, \\'\\'\\n            env_dict[k] = v\\n        for k, v in env_section.items():\\n            if \\'value\\' not in v:\\n                env_dict[k] = \\'\\'\\n            else:\\n                env_dict[k] = v[\\'value\\']\\n        ret = []\\n        for k, v in env_dict.items():\\n            ret.append(\"{0}={1}\".format(k, v))\\n        return ret\\n\\n    def parse_routes(self):\\n        routes = self.module_content[\\'$edgeHub\\'][\\'properties.desired\\'][\\'routes\\']\\n        schema_version = self.module_content[\\'$edgeHub\\'][\\'properties.desired\\'][\\'schemaVersion\\']\\n        routes_env = []\\n        route_id = 1\\n\\n        for route in routes.values():\\n            if isinstance(route, str):\\n                routes_env.append(\\'routes__r{0}={1}\\'.format(route_id, route))\\n            else:\\n                if schema_version >= \"1.1\":\\n                    routes_env.append(\\'routes__r{0}={1}\\'.format(route_id, route[\"route\"]))\\n                else:\\n                    raise Exception(\"Route priority/TTL is not supported in schema {0}.\".format(schema_version))\\n            route_id = route_id + 1\\n        return routes_env\\n\\n    def dump(self, target):\\n        def setup_yaml():\\n            def represent_dict_order(self, data):\\n                return self.represent_mapping(\\'tag:yaml.org,2002:map\\', data.items())\\n            yaml.add_representer(OrderedDict, represent_dict_order)\\n        setup_yaml()\\n\\n        def my_unicode_repr(self, data):\\n            return self.represent_str(data.encode(\\'utf-8\\'))\\n\\n        self.yaml_dict[\\'version\\'] = str(COMPOSE_VERSION)\\n        self.yaml_dict[\\'services\\'] = self.Services\\n        self.yaml_dict[\\'networks\\'] = self.Networks\\n        self.yaml_dict[\\'volumes\\'] = self.Volumes\\n\\n        if sys.version_info[0] < 3:\\n            # Add # noqa: F821 to ignore undefined name \\'unicode\\' error\\n            yaml.add_representer(unicode, my_unicode_repr)  # noqa: F821\\n        yml_stream = StringIO()\\n\\n        yaml.dump(self.yaml_dict, yml_stream, default_flow_style=False)\\n        yml_str = yml_stream.getvalue().replace(\\'$\\', \\'$$\\')\\n\\n        if not os.path.exists(os.path.dirname(target)):\\n            os.makedirs(os.path.dirname(target))\\n\\n        with open(target, \\'w\\') as f:\\n            f.write(yml_str)\\n\\n    @staticmethod\\n    def _join_create_options(settings):\\n        if \\'createOptions\\' not in settings:\\n            return \\'\\'\\n\\n        res = settings[\\'createOptions\\']\\n\\n        i = 0\\n        while True:\\n            i += 1\\n            key = \\'createOptions{0:0=2d}\\'.format(i)\\n            if i < CREATE_OPTIONS_MAX_CHUNKS and key in settings:\\n                res += settings[key]\\n            else:\\n                break\\n\\n        return res\\n'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport json\\nimport os\\nimport sys\\nimport yaml\\n\\nfrom collections import OrderedDict\\nfrom io import StringIO\\nfrom .compose_parser import CreateOptionParser\\nfrom .output import Output\\n\\nCOMPOSE_VERSION = 3.6\\n\\nCREATE_OPTIONS_MAX_CHUNKS = 100\\n\\n\\nclass ComposeProject(object):\\n\\n    def __init__(self, module_content):\\n        self.module_content = module_content\\n        self.yaml_dict = OrderedDict()\\n        self.Services = OrderedDict()\\n        self.Networks = {}\\n        self.Volumes = {}\\n        self.edge_info = {}\\n\\n    def compose(self):\\n        modules = {\\n            self.edge_info[\\'hub_name\\']:\\n            self.module_content[\\'$edgeAgent\\'][\\'properties.desired\\'][\\'systemModules\\'][\\'edgeHub\\']\\n        }\\n        modules.update(self.module_content[\\'$edgeAgent\\'][\\'properties.desired\\'][\\'modules\\'])\\n        for service_name, config in modules.items():\\n            self.Services[service_name] = {}\\n            create_option_str = ComposeProject._join_create_options(config[\\'settings\\'])\\n            if create_option_str:\\n                create_option = json.loads(create_option_str)\\n                create_option_parser = CreateOptionParser(create_option)\\n                self.Services[service_name].update(create_option_parser.parse_create_option())\\n            self.Services[service_name][\\'image\\'] = config[\\'settings\\'][\\'image\\']\\n            self.Services[service_name][\\'container_name\\'] = service_name\\n\\n            if \\'networks\\' not in self.Services[service_name]:\\n                self.Services[service_name][\\'networks\\'] = {}\\n                self.Services[service_name][\\'networks\\'][self.edge_info[\\'network_info\\'][\\'NW_NAME\\']] = None\\n\\n            if \\'network_mode\\' in self.Services[service_name]:\\n                del self.Services[service_name][\\'network_mode\\']\\n\\n            if \\'host\\' in self.Services[service_name][\\'networks\\']:\\n                self.Services[service_name][\\'network_mode\\'] = \\'host\\'\\n                del self.Services[service_name][\\'networks\\']\\n\\n            if \\'labels\\' not in self.Services[service_name]:\\n                self.Services[service_name][\\'labels\\'] = {self.edge_info[\\'labels\\']: \"\"}\\n            else:\\n                self.Services[service_name][\\'labels\\'][self.edge_info[\\'labels\\']] = \"\"\\n\\n            try:\\n                # Default restart policy is \\'on-unhealthy\\'\\n                # https://github.com/Azure/iotedge/blob/8bd573590cdc149c014cf994dba58fc63f1a5c74/edge-agent/src/Microsoft.Azure.Devices.Edge.Agent.Core/Constants.cs#L18\\n                restart_policy = config.get(\\'restartPolicy\\', \\'on-unhealthy\\')\\n                self.Services[service_name][\\'restart\\'] = {\\n                    \\'never\\': \\'no\\',\\n                    \\'on-failure\\': \\'on-failure\\',\\n                    \\'always\\': \\'always\\',\\n                    \\'on-unhealthy\\': \\'always\\',\\n                    \\'unknown\\': \\'no\\'\\n                }[restart_policy]\\n\\n                if restart_policy == \\'on-unhealthy\\':\\n                    Output().warning(\\'Unsupported restart policy \\\\\\'{0}\\\\\\' in solution mode. Falling back to \\\\\\'always\\\\\\'.\\'\\n                                     .format(restart_policy))\\n            except KeyError as e:\\n                raise KeyError(\\'Unsupported restart policy {0} in solution mode.\\'.format(e))\\n\\n            if \\'env\\' in config:\\n                self.Services[service_name][\\'environment\\'] = self.config_env(\\n                    self.Services[service_name].get(\\'environment\\', []), config[\\'env\\'])\\n\\n            if service_name == self.edge_info[\\'hub_name\\']:\\n                self.config_edge_hub(service_name)\\n            else:\\n                self.config_modules(service_name)\\n\\n            if \\'networks\\' in self.Services[service_name]:\\n                for nw in self.Services[service_name][\\'networks\\']:\\n                    self.Networks[nw] = {\\n                        \\'external\\': True\\n                    }\\n\\n            for vol in self.Services[service_name][\\'volumes\\']:\\n                if vol[\\'type\\'] == \\'volume\\':\\n                    self.Volumes[vol[\\'source\\']] = {\\n                        \\'name\\': vol[\\'source\\']\\n                    }\\n\\n    def set_edge_info(self, info):\\n        self.edge_info = info\\n\\n    def config_modules(self, service_name):\\n        config = self.Services[service_name]\\n        if \\'volumes\\' not in config:\\n            config[\\'volumes\\'] = []\\n        config[\\'volumes\\'].append({\\n            \\'type\\': \\'volume\\',\\n            \\'source\\': self.edge_info[\\'volume_info\\'][\\'MODULE_VOLUME\\'],\\n            \\'target\\': self.edge_info[\\'volume_info\\'][\\'MODULE_MOUNT\\']\\n        })\\n\\n        if \\'environment\\' not in config:\\n            config[\\'environment\\'] = []\\n        for module_env in self.edge_info[\\'env_info\\'][\\'module_env\\']:\\n            config[\\'environment\\'].append(module_env)\\n        config[\\'environment\\'].append(\\n            \\'EdgeHubConnectionString=\\' + self.edge_info[\\'ConnStr_info\\'][service_name]\\n        )\\n\\n        if \\'depends_on\\' not in config:\\n            config[\\'depends_on\\'] = []\\n        config[\\'depends_on\\'].append(self.edge_info[\\'hub_name\\'])\\n\\n    def config_edge_hub(self, service_name):\\n        config = self.Services[service_name]\\n        if \\'volumes\\' not in config:\\n            config[\\'volumes\\'] = []\\n        config[\\'volumes\\'].append({\\n            \\'type\\': \\'volume\\',\\n            \\'source\\': self.edge_info[\\'volume_info\\'][\\'HUB_VOLUME\\'],\\n            \\'target\\': self.edge_info[\\'volume_info\\'][\\'HUB_MOUNT\\']\\n        })\\n\\n        config[\\'networks\\'][self.edge_info[\\'network_info\\'][\\'NW_NAME\\']] = {\\n            \\'aliases\\': [self.edge_info[\\'network_info\\'][\\'ALIASES\\']]\\n        }\\n\\n        if \\'environment\\' not in config:\\n            config[\\'environment\\'] = []\\n        routes_env = self.parse_routes()\\n        for e in routes_env:\\n            config[\\'environment\\'].append(e)\\n        config[\\'environment\\'].append(\\n            \\'IotHubConnectionString=\\' + self.edge_info[\\'ConnStr_info\\'][\\'$edgeHub\\'])\\n        config[\\'environment\\'].extend(self.edge_info[\\'env_info\\'][\\'hub_env\\'])\\n\\n    def config_env(self, env_list, env_section):\\n        env_dict = {}\\n        for env in env_list:\\n            if \\'=\\' in env:\\n                k, v = env.split(\\'=\\', 1)\\n            else:\\n                k, v = env, \\'\\'\\n            env_dict[k] = v\\n        for k, v in env_section.items():\\n            if \\'value\\' not in v:\\n                env_dict[k] = \\'\\'\\n            else:\\n                env_dict[k] = v[\\'value\\']\\n        ret = []\\n        for k, v in env_dict.items():\\n            ret.append(\"{0}={1}\".format(k, v))\\n        return ret\\n\\n    def parse_routes(self):\\n        routes = self.module_content[\\'$edgeHub\\'][\\'properties.desired\\'][\\'routes\\']\\n        schema_version = self.module_content[\\'$edgeHub\\'][\\'properties.desired\\'][\\'schemaVersion\\']\\n        routes_env = []\\n        route_id = 1\\n\\n        for route in routes.values():\\n            if isinstance(route, str):\\n                routes_env.append(\\'routes__r{0}={1}\\'.format(route_id, route))\\n            else:\\n                if schema_version >= \"1.1\":\\n                    routes_env.append(\\'routes__r{0}={1}\\'.format(route_id, route[\"route\"]))\\n                else:\\n                    raise Exception(\"Route priority/TTL is not supported in schema {0}.\".format(schema_version))\\n            route_id = route_id + 1\\n        return routes_env\\n\\n    def dump(self, target):\\n        def setup_yaml():\\n            def represent_dict_order(self, data):\\n                return self.represent_mapping(\\'tag:yaml.org,2002:map\\', data.items())\\n            yaml.add_representer(OrderedDict, represent_dict_order)\\n        setup_yaml()\\n\\n        def my_unicode_repr(self, data):\\n            return self.represent_str(data.encode(\\'utf-8\\'))\\n\\n        self.yaml_dict[\\'version\\'] = str(COMPOSE_VERSION)\\n        self.yaml_dict[\\'services\\'] = self.Services\\n        self.yaml_dict[\\'networks\\'] = self.Networks\\n        self.yaml_dict[\\'volumes\\'] = self.Volumes\\n\\n        if sys.version_info[0] < 3:\\n            # Add # noqa: F821 to ignore undefined name \\'unicode\\' error\\n            yaml.add_representer(unicode, my_unicode_repr)  # noqa: F821\\n        yml_stream = StringIO()\\n\\n        yaml.dump(self.yaml_dict, yml_stream, default_flow_style=False)\\n        yml_str = yml_stream.getvalue().replace(\\'$\\', \\'$$\\')\\n\\n        if not os.path.exists(os.path.dirname(target)):\\n            os.makedirs(os.path.dirname(target))\\n\\n        with open(target, \\'w\\') as f:\\n            f.write(yml_str)\\n\\n    @staticmethod\\n    def _join_create_options(settings):\\n        if \\'createOptions\\' not in settings:\\n            return \\'\\'\\n\\n        res = settings[\\'createOptions\\']\\n\\n        i = 0\\n        while True:\\n            i += 1\\n            key = \\'createOptions{0:0=2d}\\'.format(i)\\n            if i < CREATE_OPTIONS_MAX_CHUNKS and key in settings:\\n                res += settings[key]\\n            else:\\n                break\\n\\n        return res\\n'"}, {"func_args": {"source": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport os\\nimport configparser\\n\\nfrom . import decorators\\nfrom .hostplatform import HostPlatform\\n\\nPRIVACY_STATEMENT = \"\"\"\\nWelcome to iotedgehubdev!\\n-------------------------\\nTelemetry\\n---------\\nThe iotedgehubdev collects usage data in order to improve your experience.\\nThe data is anonymous and does not include commandline argument values.\\nThe data is collected by Microsoft.\\n\\nYou can change your telemetry settings by updating \\'collect_telemetry\\' to \\'no\\' in {0}\\n\"\"\"\\n\\n\\nclass ProductConfig(object):\\n    def __init__(self):\\n        self.config = configparser.ConfigParser({\\n            \\'firsttime\\': \\'yes\\'\\n        })\\n        self.setup_config()\\n\\n    @decorators.suppress_all_exceptions()\\n    def setup_config(self):\\n        try:\\n            configPath = HostPlatform.get_config_path()\\n            iniFilePath = HostPlatform.get_setting_ini_path()\\n            if not os.path.exists(configPath):\\n                os.makedirs(configPath)\\n            if not os.path.exists(iniFilePath):\\n                with open(iniFilePath, \\'w\\') as iniFile:\\n                    self.config.write(iniFile)\\n            else:\\n                with open(iniFilePath, \\'r\\') as iniFile:\\n                    self.config.read_file(iniFile)\\n                with open(iniFilePath, \\'w\\') as iniFile:\\n                    self.config.write(iniFile)\\n        except Exception:\\n            pass\\n\\n    @decorators.suppress_all_exceptions()\\n    def update_config(self):\\n        with open(HostPlatform.get_setting_ini_path(), \\'w\\') as iniFile:\\n            self.config.write(iniFile)\\n\\n    @decorators.suppress_all_exceptions()\\n    def set_val(self, direct, section, val):\\n        if val is not None:\\n            self.config.set(direct, section, val)\\n            self.update_config()\\n\\n\\n_prod_config = ProductConfig()\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef get_ini_config():\\n    return _prod_config.config\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef update_ini():\\n    _prod_config.update_config()\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef check_firsttime():\\n    if \\'no\\' != _prod_config.config.get(\\'DEFAULT\\', \\'firsttime\\'):\\n        config = _prod_config.config\\n        config.set(\\'DEFAULT\\', \\'firsttime\\', \\'no\\')\\n        print(PRIVACY_STATEMENT.format(HostPlatform.get_setting_ini_path()))\\n        config.set(\\'DEFAULT\\', \\'collect_telemetry\\', \\'yes\\')\\n        _prod_config.update_config()\\n'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport os\\nimport configparser\\n\\nfrom . import decorators\\nfrom .hostplatform import HostPlatform\\n\\nPRIVACY_STATEMENT = \"\"\"\\nWelcome to iotedgehubdev!\\n-------------------------\\nTelemetry\\n---------\\nThe iotedgehubdev collects usage data in order to improve your experience.\\nThe data is anonymous and does not include commandline argument values.\\nThe data is collected by Microsoft.\\n\\nYou can change your telemetry settings by updating \\'collect_telemetry\\' to \\'no\\' in {0}\\n\"\"\"\\n\\n\\nclass ProductConfig(object):\\n    def __init__(self):\\n        self.config = configparser.ConfigParser({\\n            \\'firsttime\\': \\'yes\\'\\n        })\\n        self.setup_config()\\n\\n    @decorators.suppress_all_exceptions()\\n    def setup_config(self):\\n        try:\\n            configPath = HostPlatform.get_config_path()\\n            iniFilePath = HostPlatform.get_setting_ini_path()\\n            if not os.path.exists(configPath):\\n                os.makedirs(configPath)\\n            if not os.path.exists(iniFilePath):\\n                with open(iniFilePath, \\'w\\') as iniFile:\\n                    self.config.write(iniFile)\\n            else:\\n                with open(iniFilePath, \\'r\\') as iniFile:\\n                    self.config.read_file(iniFile)\\n                with open(iniFilePath, \\'w\\') as iniFile:\\n                    self.config.write(iniFile)\\n        except Exception:\\n            pass\\n\\n    @decorators.suppress_all_exceptions()\\n    def update_config(self):\\n        with open(HostPlatform.get_setting_ini_path(), \\'w\\') as iniFile:\\n            self.config.write(iniFile)\\n\\n    @decorators.suppress_all_exceptions()\\n    def set_val(self, direct, section, val):\\n        if val is not None:\\n            self.config.set(direct, section, val)\\n            self.update_config()\\n\\n\\n_prod_config = ProductConfig()\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef get_ini_config():\\n    return _prod_config.config\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef update_ini():\\n    _prod_config.update_config()\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef check_firsttime():\\n    if \\'no\\' != _prod_config.config.get(\\'DEFAULT\\', \\'firsttime\\'):\\n        config = _prod_config.config\\n        config.set(\\'DEFAULT\\', \\'firsttime\\', \\'no\\')\\n        print(PRIVACY_STATEMENT.format(HostPlatform.get_setting_ini_path()))\\n        config.set(\\'DEFAULT\\', \\'collect_telemetry\\', \\'yes\\')\\n        _prod_config.update_config()\\n'"}, {"func_args": {"source": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nclass EdgeConstants():\\n    HOSTNAME_KEY = \\'HostName\\'\\n    DEVICE_ID_KEY = \\'DeviceId\\'\\n    ACCESS_KEY_KEY = \\'SharedAccessKey\\'\\n    ACCESS_KEY_NAME = \\'SharedAccessKeyName\\'\\n    DEVICE_ACCESS_KEY_KEY = \\'Device_SharedAccessKey\\'\\n    HUB_ACCESS_KEY_KEY = \\'Hub_SharedAccessKey\\'\\n\\n    SUBJECT_COUNTRY_KEY = \\'countryCode\\'\\n    SUBJECT_STATE_KEY = \\'state\\'\\n    SUBJECT_LOCALITY_KEY = \\'locality\\'\\n    SUBJECT_ORGANIZATION_KEY = \\'organization\\'\\n    SUBJECT_ORGANIZATION_UNIT_KEY = \\'organizationUnit\\'\\n    SUBJECT_COMMON_NAME_KEY = \\'commonName\\'\\n\\n    EDGE_CHAIN_CA = \\'edge-chain-ca\\'\\n    EDGE_HUB_SERVER = \\'edge-hub-server\\'\\n    EDGE_DEVICE_CA = \\'edge-device-ca\\'\\n    EDGE_AGENT_CA = \\'edge-agent-ca\\'\\n    CERT_SUFFIX = \\'.cert.pem\\'\\n    CHAIN_CERT_SUFFIX = \\'-chain.cert.pem\\'\\n    PFX_SUFFIX = \\'.cert.pfx\\'\\n    KEY_SUFFIX = \\'.key.pem\\'\\n    ROOT_CA_ID = \\'azure-iot-test-only.root.ca\\'\\n    DEVICE_CA_ID = \\'iot-edge-device-ca\\'\\n    CERT_FOLDER = \\'certs\\'\\n\\n    CERT_DEFAULT_DICT = {\\n        SUBJECT_COUNTRY_KEY: \\'US\\',\\n        SUBJECT_STATE_KEY: \\'Washington\\',\\n        SUBJECT_LOCALITY_KEY: \\'Redmond\\',\\n        SUBJECT_ORGANIZATION_KEY: \\'Default Edge Organization\\',\\n        SUBJECT_ORGANIZATION_UNIT_KEY: \\'Edge Unit\\',\\n        SUBJECT_COMMON_NAME_KEY: \\'Edge Test Device CA\\'\\n    }\\n\\n    # Port of Docker daemon\\n    # https://github.com/docker/docker-ce/blob/f9756bfb29877236a83979170ef2c0aa35eb57c6/components/engine/volume/mounts/windows_parser.go#L19-L76\\n    MOUNT_HOST_DIR_REGEX = r\\'(?:\\\\\\\\\\\\\\\\\\\\?\\\\\\\\)?[a-z]:[\\\\\\\\/](?:[^\\\\\\\\/:*?\"<>|\\\\r\\\\n]+[\\\\\\\\/]?)*\\'\\n    MOUNT_NAME_REGEX = r\\'[^\\\\\\\\/:*?\"<>|\\\\r\\\\n]+\\'\\n    MOUNT_PIPE_REGEX = r\\'[/\\\\\\\\]{2}.[/\\\\\\\\]pipe[/\\\\\\\\][^:*?\"<>|\\\\r\\\\n]+\\'\\n    MOUNT_SOURCE_REGEX = r\\'((?P<source>((\\' + MOUNT_HOST_DIR_REGEX + r\\')|(\\' + \\\\\\n        MOUNT_NAME_REGEX + r\\')|(\\' + MOUNT_PIPE_REGEX + r\\'))):)?\\'\\n    MOUNT_MODE_REGEX = r\\'(:(?P<mode>(?i)ro|rw))?\\'\\n    MOUNT_WIN_DEST_REGEX = r\\'(?P<destination>((?:\\\\\\\\\\\\\\\\\\\\?\\\\\\\\)?([a-z]):((?:[\\\\\\\\/][^\\\\\\\\/:*?\"<>\\\\r\\\\n]+)*[\\\\\\\\/]?))|(\\' + \\\\\\n        MOUNT_PIPE_REGEX + r\\'))\\'\\n    MOUNT_LCOW_DEST_REGEX = r\\'(?P<destination>/(?:[^\\\\\\\\/:*?\"<>\\\\r\\\\n]+[/]?)*)\\'\\n    MOUNT_WIN_REGEX = r\\'^\\' + MOUNT_SOURCE_REGEX + MOUNT_WIN_DEST_REGEX + MOUNT_MODE_REGEX + r\\'$\\'\\n    MOUNT_LCOW_REGEX = r\\'^\\' + MOUNT_SOURCE_REGEX + MOUNT_LCOW_DEST_REGEX + MOUNT_MODE_REGEX + r\\'$\\'\\n'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nclass EdgeConstants():\\n    HOSTNAME_KEY = \\'HostName\\'\\n    DEVICE_ID_KEY = \\'DeviceId\\'\\n    ACCESS_KEY_KEY = \\'SharedAccessKey\\'\\n    ACCESS_KEY_NAME = \\'SharedAccessKeyName\\'\\n    DEVICE_ACCESS_KEY_KEY = \\'Device_SharedAccessKey\\'\\n    HUB_ACCESS_KEY_KEY = \\'Hub_SharedAccessKey\\'\\n\\n    SUBJECT_COUNTRY_KEY = \\'countryCode\\'\\n    SUBJECT_STATE_KEY = \\'state\\'\\n    SUBJECT_LOCALITY_KEY = \\'locality\\'\\n    SUBJECT_ORGANIZATION_KEY = \\'organization\\'\\n    SUBJECT_ORGANIZATION_UNIT_KEY = \\'organizationUnit\\'\\n    SUBJECT_COMMON_NAME_KEY = \\'commonName\\'\\n\\n    EDGE_CHAIN_CA = \\'edge-chain-ca\\'\\n    EDGE_HUB_SERVER = \\'edge-hub-server\\'\\n    EDGE_DEVICE_CA = \\'edge-device-ca\\'\\n    EDGE_AGENT_CA = \\'edge-agent-ca\\'\\n    CERT_SUFFIX = \\'.cert.pem\\'\\n    CHAIN_CERT_SUFFIX = \\'-chain.cert.pem\\'\\n    PFX_SUFFIX = \\'.cert.pfx\\'\\n    KEY_SUFFIX = \\'.key.pem\\'\\n    ROOT_CA_ID = \\'azure-iot-test-only.root.ca\\'\\n    DEVICE_CA_ID = \\'iot-edge-device-ca\\'\\n    CERT_FOLDER = \\'certs\\'\\n\\n    CERT_DEFAULT_DICT = {\\n        SUBJECT_COUNTRY_KEY: \\'US\\',\\n        SUBJECT_STATE_KEY: \\'Washington\\',\\n        SUBJECT_LOCALITY_KEY: \\'Redmond\\',\\n        SUBJECT_ORGANIZATION_KEY: \\'Default Edge Organization\\',\\n        SUBJECT_ORGANIZATION_UNIT_KEY: \\'Edge Unit\\',\\n        SUBJECT_COMMON_NAME_KEY: \\'Edge Test Device CA\\'\\n    }\\n\\n    # Port of Docker daemon\\n    # https://github.com/docker/docker-ce/blob/f9756bfb29877236a83979170ef2c0aa35eb57c6/components/engine/volume/mounts/windows_parser.go#L19-L76\\n    MOUNT_HOST_DIR_REGEX = r\\'(?:\\\\\\\\\\\\\\\\\\\\?\\\\\\\\)?[a-z]:[\\\\\\\\/](?:[^\\\\\\\\/:*?\"<>|\\\\r\\\\n]+[\\\\\\\\/]?)*\\'\\n    MOUNT_NAME_REGEX = r\\'[^\\\\\\\\/:*?\"<>|\\\\r\\\\n]+\\'\\n    MOUNT_PIPE_REGEX = r\\'[/\\\\\\\\]{2}.[/\\\\\\\\]pipe[/\\\\\\\\][^:*?\"<>|\\\\r\\\\n]+\\'\\n    MOUNT_SOURCE_REGEX = r\\'((?P<source>((\\' + MOUNT_HOST_DIR_REGEX + r\\')|(\\' + \\\\\\n        MOUNT_NAME_REGEX + r\\')|(\\' + MOUNT_PIPE_REGEX + r\\'))):)?\\'\\n    MOUNT_MODE_REGEX = r\\'(:(?P<mode>(?i)ro|rw))?\\'\\n    MOUNT_WIN_DEST_REGEX = r\\'(?P<destination>((?:\\\\\\\\\\\\\\\\\\\\?\\\\\\\\)?([a-z]):((?:[\\\\\\\\/][^\\\\\\\\/:*?\"<>\\\\r\\\\n]+)*[\\\\\\\\/]?))|(\\' + \\\\\\n        MOUNT_PIPE_REGEX + r\\'))\\'\\n    MOUNT_LCOW_DEST_REGEX = r\\'(?P<destination>/(?:[^\\\\\\\\/:*?\"<>\\\\r\\\\n]+[/]?)*)\\'\\n    MOUNT_WIN_REGEX = r\\'^\\' + MOUNT_SOURCE_REGEX + MOUNT_WIN_DEST_REGEX + MOUNT_MODE_REGEX + r\\'$\\'\\n    MOUNT_LCOW_REGEX = r\\'^\\' + MOUNT_SOURCE_REGEX + MOUNT_LCOW_DEST_REGEX + MOUNT_MODE_REGEX + r\\'$\\'\\n'"}, {"func_args": {"source": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nfrom functools import wraps\\n\\n\\ndef suppress_all_exceptions(fallback_return=None):\\n    def _decorator(func):\\n        @wraps(func)\\n        def _wrapped_func(*args, **kwargs):\\n            try:\\n                return func(*args, **kwargs)\\n            except Exception:\\n                if fallback_return:\\n                    return fallback_return\\n                else:\\n                    pass\\n\\n        return _wrapped_func\\n\\n    return _decorator\\n\\n\\ndef hash256_result(func):\\n    \"\"\"Secure the return string of the annotated function with SHA256 algorithm. If the annotated\\n    function doesn\\'t return string or return None, raise ValueError.\"\"\"\\n    @wraps(func)\\n    def _decorator(*args, **kwargs):\\n        val = func(*args, **kwargs)\\n        if not val:\\n            raise ValueError(\\'Return value is None\\')\\n        elif not isinstance(val, str):\\n            raise ValueError(\\'Return value is not string\\')\\n\\n        from .utils import Utils\\n        return Utils.get_sha256_hash(val)\\n\\n    return _decorator\\n'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nfrom functools import wraps\\n\\n\\ndef suppress_all_exceptions(fallback_return=None):\\n    def _decorator(func):\\n        @wraps(func)\\n        def _wrapped_func(*args, **kwargs):\\n            try:\\n                return func(*args, **kwargs)\\n            except Exception:\\n                if fallback_return:\\n                    return fallback_return\\n                else:\\n                    pass\\n\\n        return _wrapped_func\\n\\n    return _decorator\\n\\n\\ndef hash256_result(func):\\n    \"\"\"Secure the return string of the annotated function with SHA256 algorithm. If the annotated\\n    function doesn\\'t return string or return None, raise ValueError.\"\"\"\\n    @wraps(func)\\n    def _decorator(*args, **kwargs):\\n        val = func(*args, **kwargs)\\n        if not val:\\n            raise ValueError(\\'Return value is None\\')\\n        elif not isinstance(val, str):\\n            raise ValueError(\\'Return value is not string\\')\\n\\n        from .utils import Utils\\n        return Utils.get_sha256_hash(val)\\n\\n    return _decorator\\n'"}, {"func_args": {"source": "\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\nfrom .certutils import EdgeCertUtil\\nfrom .constants import EdgeConstants\\n\\n\\nclass EdgeCert(object):\\n    def __init__(self, certs_dir, hostname):\\n        self.certs_dir = certs_dir\\n        self.hostname = hostname\\n\\n    def generate_self_signed_certs(self):\\n        cert_util = EdgeCertUtil()\\n        cert_util.create_root_ca_cert(EdgeConstants.EDGE_DEVICE_CA,\\n                                      validity_days_from_now=365,\\n                                      subject_dict=EdgeConstants.CERT_DEFAULT_DICT,\\n                                      passphrase=None)\\n        cert_util.export_simulator_cert_artifacts_to_dir(EdgeConstants.EDGE_DEVICE_CA, self.certs_dir)\\n\\n        cert_util.create_intermediate_ca_cert(EdgeConstants.EDGE_AGENT_CA,\\n                                              EdgeConstants.EDGE_DEVICE_CA,\\n                                              validity_days_from_now=365,\\n                                              common_name='Edge Agent CA',\\n                                              set_terminal_ca=False,\\n                                              passphrase=None)\\n        cert_util.export_simulator_cert_artifacts_to_dir(EdgeConstants.EDGE_AGENT_CA, self.certs_dir)\\n\\n        cert_util.create_server_cert(EdgeConstants.EDGE_HUB_SERVER,\\n                                     EdgeConstants.EDGE_AGENT_CA,\\n                                     validity_days_from_now=365,\\n                                     hostname=self.hostname)\\n        cert_util.export_simulator_cert_artifacts_to_dir(EdgeConstants.EDGE_HUB_SERVER, self.certs_dir)\\n        cert_util.export_pfx_cert(EdgeConstants.EDGE_HUB_SERVER, self.certs_dir)\\n\\n        prefixes = [EdgeConstants.EDGE_AGENT_CA, EdgeConstants.EDGE_DEVICE_CA]\\n        cert_util.chain_simulator_ca_certs(EdgeConstants.EDGE_CHAIN_CA, prefixes, self.certs_dir)\\n\\n    # Generate IoT Edge device CA to be configured in IoT Edge runtime\\n    def generate_device_ca(self, valid_days, overwrite_existing, trusted_ca, trusted_ca_key, trusted_ca_key_passphase):\\n        # Function level variables\\n        create_root_ca = not (trusted_ca and trusted_ca_key)\\n        # Generate certs\\n        cert_util = EdgeCertUtil()\\n        if create_root_ca:\\n            cert_util.create_root_ca_cert(EdgeConstants.ROOT_CA_ID,\\n                                          validity_days_from_now=valid_days,\\n                                          subject_dict=EdgeConstants.CERT_DEFAULT_DICT,\\n                                          passphrase=None)\\n            cert_util.export_device_ca_cert_artifacts_to_dir(EdgeConstants.ROOT_CA_ID, self.certs_dir)\\n        else:\\n            cert_util.load_cert_from_file(EdgeConstants.ROOT_CA_ID, trusted_ca, trusted_ca_key, trusted_ca_key_passphase)\\n\\n        cert_util.create_intermediate_ca_cert(EdgeConstants.DEVICE_CA_ID, EdgeConstants.ROOT_CA_ID,\\n                                              validity_days_from_now=valid_days,\\n                                              common_name='Edge Device CA',\\n                                              set_terminal_ca=False,\\n                                              passphrase=None)\\n        cert_util.export_device_ca_cert_artifacts_to_dir(EdgeConstants.DEVICE_CA_ID, self.certs_dir)\\n        cert_util.chain_device_ca_certs(EdgeConstants.DEVICE_CA_ID,\\n                                        [EdgeConstants.DEVICE_CA_ID, EdgeConstants.ROOT_CA_ID],\\n                                        self.certs_dir)\\n\\n    def get_cert_file_path(self, id_str):\\n        return EdgeCertUtil.get_cert_file_path(id_str, self.certs_dir)\\n\\n    def get_pfx_file_path(self, id_str):\\n        return EdgeCertUtil.get_pfx_file_path(id_str, self.certs_dir)\\n\""}, "return_value": "\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\nfrom .certutils import EdgeCertUtil\\nfrom .constants import EdgeConstants\\n\\n\\nclass EdgeCert(object):\\n    def __init__(self, certs_dir, hostname):\\n        self.certs_dir = certs_dir\\n        self.hostname = hostname\\n\\n    def generate_self_signed_certs(self):\\n        cert_util = EdgeCertUtil()\\n        cert_util.create_root_ca_cert(EdgeConstants.EDGE_DEVICE_CA,\\n                                      validity_days_from_now=365,\\n                                      subject_dict=EdgeConstants.CERT_DEFAULT_DICT,\\n                                      passphrase=None)\\n        cert_util.export_simulator_cert_artifacts_to_dir(EdgeConstants.EDGE_DEVICE_CA, self.certs_dir)\\n\\n        cert_util.create_intermediate_ca_cert(EdgeConstants.EDGE_AGENT_CA,\\n                                              EdgeConstants.EDGE_DEVICE_CA,\\n                                              validity_days_from_now=365,\\n                                              common_name='Edge Agent CA',\\n                                              set_terminal_ca=False,\\n                                              passphrase=None)\\n        cert_util.export_simulator_cert_artifacts_to_dir(EdgeConstants.EDGE_AGENT_CA, self.certs_dir)\\n\\n        cert_util.create_server_cert(EdgeConstants.EDGE_HUB_SERVER,\\n                                     EdgeConstants.EDGE_AGENT_CA,\\n                                     validity_days_from_now=365,\\n                                     hostname=self.hostname)\\n        cert_util.export_simulator_cert_artifacts_to_dir(EdgeConstants.EDGE_HUB_SERVER, self.certs_dir)\\n        cert_util.export_pfx_cert(EdgeConstants.EDGE_HUB_SERVER, self.certs_dir)\\n\\n        prefixes = [EdgeConstants.EDGE_AGENT_CA, EdgeConstants.EDGE_DEVICE_CA]\\n        cert_util.chain_simulator_ca_certs(EdgeConstants.EDGE_CHAIN_CA, prefixes, self.certs_dir)\\n\\n    # Generate IoT Edge device CA to be configured in IoT Edge runtime\\n    def generate_device_ca(self, valid_days, overwrite_existing, trusted_ca, trusted_ca_key, trusted_ca_key_passphase):\\n        # Function level variables\\n        create_root_ca = not (trusted_ca and trusted_ca_key)\\n        # Generate certs\\n        cert_util = EdgeCertUtil()\\n        if create_root_ca:\\n            cert_util.create_root_ca_cert(EdgeConstants.ROOT_CA_ID,\\n                                          validity_days_from_now=valid_days,\\n                                          subject_dict=EdgeConstants.CERT_DEFAULT_DICT,\\n                                          passphrase=None)\\n            cert_util.export_device_ca_cert_artifacts_to_dir(EdgeConstants.ROOT_CA_ID, self.certs_dir)\\n        else:\\n            cert_util.load_cert_from_file(EdgeConstants.ROOT_CA_ID, trusted_ca, trusted_ca_key, trusted_ca_key_passphase)\\n\\n        cert_util.create_intermediate_ca_cert(EdgeConstants.DEVICE_CA_ID, EdgeConstants.ROOT_CA_ID,\\n                                              validity_days_from_now=valid_days,\\n                                              common_name='Edge Device CA',\\n                                              set_terminal_ca=False,\\n                                              passphrase=None)\\n        cert_util.export_device_ca_cert_artifacts_to_dir(EdgeConstants.DEVICE_CA_ID, self.certs_dir)\\n        cert_util.chain_device_ca_certs(EdgeConstants.DEVICE_CA_ID,\\n                                        [EdgeConstants.DEVICE_CA_ID, EdgeConstants.ROOT_CA_ID],\\n                                        self.certs_dir)\\n\\n    def get_cert_file_path(self, id_str):\\n        return EdgeCertUtil.get_cert_file_path(id_str, self.certs_dir)\\n\\n    def get_pfx_file_path(self, id_str):\\n        return EdgeCertUtil.get_pfx_file_path(id_str, self.certs_dir)\\n\""}, {"func_args": {"source": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport docker\\nimport os\\nimport time\\nimport tarfile\\nfrom io import BytesIO\\nfrom .errors import EdgeDeploymentError\\nfrom .utils import Utils\\n\\n\\nclass EdgeDockerClient(object):\\n    _DOCKER_INFO_OS_TYPE_KEY = \\'OSType\\'\\n\\n    def __init__(self, docker_client=None):\\n        if docker_client is not None:\\n            self._client = docker_client\\n        else:\\n            try:\\n                self._client = docker.DockerClient.from_env(version=\\'auto\\')\\n            except Exception as ex:\\n                msg = \\'Could not connect to Docker daemon. Please make sure Docker is running\\'\\n                raise EdgeDeploymentError(msg, ex)\\n\\n    def __enter__(self):\\n        return self\\n\\n    def __exit__(self, exc_type, exc_value, traceback):\\n        if self._client is not None:\\n            self._client.api.close()\\n\\n    def stop_remove_by_label(self, label):\\n        try:\\n            filter_dict = {\\'label\\': label}\\n            containers = self._client.containers.list(all=True, filters=filter_dict)\\n            for container in containers:\\n                container.stop()\\n                self.remove(container.name)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not stop and remove containers by label: {0}\\'.format(label)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def get_local_image_sha_id(self, image):\\n        local_id = None\\n        try:\\n            inspect_dict = self._client.api.inspect_image(image)\\n            local_id = inspect_dict[\\'Id\\']\\n        except docker.errors.APIError:\\n            local_id = None\\n        return local_id\\n\\n    def pull(self, image, username, password):\\n        old_id = self.get_local_image_sha_id(image)\\n        try:\\n            is_updated = True\\n            auth_dict = None\\n            if username is not None:\\n                auth_dict = {\\'username\\': username, \\'password\\': password}\\n            self._client.images.pull(image, auth_config=auth_dict)\\n            if old_id is not None:\\n                inspect_dict = self._client.api.inspect_image(image)\\n                new_id = inspect_dict[\\'Id\\']\\n                if new_id == old_id:\\n                    is_updated = False\\n\\n            return is_updated\\n        except docker.errors.APIError as ex:\\n            msg = \\'Error during pull for image {0}\\'.format(image)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def pullIfNotExist(self, image, username, password):\\n        imageId = self.get_local_image_sha_id(image)\\n        if imageId is None:\\n            return self.pull(image, username, password)\\n\\n    def status(self, container_name):\\n        try:\\n            containers = self._client.containers.list(all=True)\\n            for container in containers:\\n                if container_name == container.name:\\n                    return container.status\\n            return None\\n        except docker.errors.APIError as ex:\\n            msg = \\'Error while checking status for: {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def stop(self, container_name):\\n        self._exec_container_method(container_name, \\'stop\\')\\n\\n    def start(self, container_name):\\n        self._exec_container_method(container_name, \\'start\\')\\n\\n    def remove(self, container_name):\\n        self._exec_container_method(container_name, \\'remove\\')\\n\\n    def create_network(self, network_name):\\n        create_network = False\\n        try:\\n            networks = self._client.networks.list(names=[network_name])\\n            if networks:\\n                num_networks = len(networks)\\n                if num_networks == 0:\\n                    create_network = True\\n            else:\\n                create_network = True\\n            if create_network is True:\\n                os_name = self.get_os_type()\\n                if os_name == \\'windows\\':\\n                    return self._client.networks.create(network_name, driver=\\'nat\\')\\n                else:\\n                    return self._client.networks.create(network_name, driver=\\'bridge\\')\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not create docker network: {0}\\'.format(network_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def create_volume(self, volume_name):\\n        try:\\n            volume = self._get_volume_if_exists(volume_name)\\n            if volume is None:\\n                return self._client.volumes.create(volume_name)\\n        except docker .errors.APIError as ex:\\n            msg = \\'Docker volume create failed for: {0}\\'.format(volume_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def create_config_for_network(self, nw_name, *args, **kwargs):\\n        return self._client.api.create_networking_config({\\n            nw_name: self._client.api.create_endpoint_config(*args, **kwargs)\\n        })\\n\\n    def create_container(self, image, **kwargs):\\n        try:\\n            return self._client.api.create_container(image, **kwargs)\\n        except docker.errors.ContainerError as ex_ctr:\\n            msg = \\'Container exited with errors: {0}\\'.format(kwargs.get(\\'name\\', None))\\n            raise EdgeDeploymentError(msg, ex_ctr)\\n        except docker.errors.ImageNotFound as ex_img:\\n            msg = \\'Docker create failed. Image not found: {0}\\'.format(image)\\n            raise EdgeDeploymentError(msg, ex_img)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker create failed for image: {0}\\'.format(image)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def create_host_config(self, *args, **kwargs):\\n        try:\\n            return self._client.api.create_host_config(*args, **kwargs)\\n        except Exception as ex:\\n            msg = \\'docker create host config failed\\'\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def copy_file_to_volume(self,\\n                            container_name,\\n                            volume_name,\\n                            volume_dest_file_name,\\n                            volume_dest_dir_path,\\n                            host_src_file):\\n        if self.get_os_type() == \\'windows\\':\\n            self._insert_file_in_volume_mount(volume_name, host_src_file, volume_dest_file_name)\\n        else:\\n            self._insert_file_in_container(container_name,\\n                                           volume_dest_file_name,\\n                                           volume_dest_dir_path,\\n                                           host_src_file)\\n\\n    def get_os_type(self):\\n        try:\\n            info = self._client.info()\\n            return info[EdgeDockerClient._DOCKER_INFO_OS_TYPE_KEY].lower()\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker daemon returned error\\'\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def destroy_network(self, network_name):\\n        try:\\n            networks = self._client.networks.list(names=[network_name])\\n            if networks is not None:\\n                for network in networks:\\n                    if network.name == network_name:\\n                        network.remove()\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not remove docker network: {0}\\'.format(network_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def remove_volume(self, volume_name, force=False):\\n        try:\\n            volume = self._get_volume_if_exists(volume_name)\\n            if volume is not None:\\n                volume.remove(force)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker volume remove failed for: {0}, force flag: {1}\\'.format(volume_name, force)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _get_volume_if_exists(self, name):\\n        try:\\n            return self._client.volumes.get(name)\\n        except docker.errors.NotFound:\\n            return None\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker volume get failed for: {0}\\'.format(name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _exec_container_method(self, container_name, method, **kwargs):\\n        container = self._get_container_by_name(container_name)\\n        try:\\n            getattr(container, method)(**kwargs)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not {0} container: {1}\\'.format(method, container_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _get_container_by_name(self, container_name):\\n        try:\\n            return self._client.containers.get(container_name)\\n        except docker.errors.NotFound as nf_ex:\\n            msg = \\'Could not find container by name {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, nf_ex)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Error getting container by name: {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _insert_file_in_volume_mount(self, volume_name, host_src_file, volume_dest_file_name):\\n        try:\\n            volume_info = self._client.api.inspect_volume(volume_name)\\n            Utils.copy_files(host_src_file.replace(\\'\\\\\\\\\\\\\\\\\\', \\'\\\\\\\\\\'),\\n                             os.path.join(volume_info[\\'Mountpoint\\'].replace(\\'\\\\\\\\\\\\\\\\\\', \\'\\\\\\\\\\'), volume_dest_file_name))\\n        except docker.errors.APIError as docker_ex:\\n            msg = \\'Docker volume inspect failed for: {0}\\'.format(volume_name)\\n            raise EdgeDeploymentError(msg, docker_ex)\\n        except (OSError, IOError) as ex_os:\\n            msg = \\'File IO error seen copying files to volume: {0}. \\' \\\\\\n                  \\'Errno: {1}, Error {2}\\'.format(volume_name, str(ex_os.errno), ex_os.strerror)\\n            raise EdgeDeploymentError(msg, ex_os)\\n\\n    def _insert_file_in_container(self,\\n                                  container_name,\\n                                  volume_dest_file_name,\\n                                  volume_dest_dir_path,\\n                                  host_src_file):\\n        try:\\n            (tar_stream, dest_archive_info, container_tar_file) = \\\\\\n                EdgeDockerClient.create_tar_objects(volume_dest_file_name)\\n            file_data = open(host_src_file, \\'rb\\').read()\\n            dest_archive_info.size = len(file_data)\\n            dest_archive_info.mtime = time.time()\\n            dest_archive_info.mode = 0o444\\n            container_tar_file.addfile(dest_archive_info, BytesIO(file_data))\\n            container_tar_file.close()\\n            tar_stream.seek(0)\\n            container = self._get_container_by_name(container_name)\\n            container.put_archive(volume_dest_dir_path, tar_stream)\\n        except docker.errors.APIError as docker_ex:\\n            msg = \\'Container put_archive failed for container: {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, docker_ex)\\n        except (OSError, IOError) as ex_os:\\n            msg = \\'File IO error seen during put archive for container: {0}. \\' \\\\\\n                  \\'Errno: {1}, Error {2}\\'.format(container_name, str(ex_os.errno), ex_os.strerror)\\n            raise EdgeDeploymentError(msg, ex_os)\\n\\n    @staticmethod\\n    def create_tar_objects(container_dest_file_name):\\n        tar_stream = BytesIO()\\n        dest_archive_info = tarfile.TarInfo(name=container_dest_file_name)\\n        container_tar_file = tarfile.TarFile(fileobj=tar_stream, mode=\\'w\\')\\n        return (tar_stream, dest_archive_info, container_tar_file)\\n\\n    @classmethod\\n    def create_instance(cls, docker_client):\\n        \"\"\"\\n        Factory method useful in testing.\\n        \"\"\"\\n        return cls(docker_client)\\n'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport docker\\nimport os\\nimport time\\nimport tarfile\\nfrom io import BytesIO\\nfrom .errors import EdgeDeploymentError\\nfrom .utils import Utils\\n\\n\\nclass EdgeDockerClient(object):\\n    _DOCKER_INFO_OS_TYPE_KEY = \\'OSType\\'\\n\\n    def __init__(self, docker_client=None):\\n        if docker_client is not None:\\n            self._client = docker_client\\n        else:\\n            try:\\n                self._client = docker.DockerClient.from_env(version=\\'auto\\')\\n            except Exception as ex:\\n                msg = \\'Could not connect to Docker daemon. Please make sure Docker is running\\'\\n                raise EdgeDeploymentError(msg, ex)\\n\\n    def __enter__(self):\\n        return self\\n\\n    def __exit__(self, exc_type, exc_value, traceback):\\n        if self._client is not None:\\n            self._client.api.close()\\n\\n    def stop_remove_by_label(self, label):\\n        try:\\n            filter_dict = {\\'label\\': label}\\n            containers = self._client.containers.list(all=True, filters=filter_dict)\\n            for container in containers:\\n                container.stop()\\n                self.remove(container.name)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not stop and remove containers by label: {0}\\'.format(label)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def get_local_image_sha_id(self, image):\\n        local_id = None\\n        try:\\n            inspect_dict = self._client.api.inspect_image(image)\\n            local_id = inspect_dict[\\'Id\\']\\n        except docker.errors.APIError:\\n            local_id = None\\n        return local_id\\n\\n    def pull(self, image, username, password):\\n        old_id = self.get_local_image_sha_id(image)\\n        try:\\n            is_updated = True\\n            auth_dict = None\\n            if username is not None:\\n                auth_dict = {\\'username\\': username, \\'password\\': password}\\n            self._client.images.pull(image, auth_config=auth_dict)\\n            if old_id is not None:\\n                inspect_dict = self._client.api.inspect_image(image)\\n                new_id = inspect_dict[\\'Id\\']\\n                if new_id == old_id:\\n                    is_updated = False\\n\\n            return is_updated\\n        except docker.errors.APIError as ex:\\n            msg = \\'Error during pull for image {0}\\'.format(image)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def pullIfNotExist(self, image, username, password):\\n        imageId = self.get_local_image_sha_id(image)\\n        if imageId is None:\\n            return self.pull(image, username, password)\\n\\n    def status(self, container_name):\\n        try:\\n            containers = self._client.containers.list(all=True)\\n            for container in containers:\\n                if container_name == container.name:\\n                    return container.status\\n            return None\\n        except docker.errors.APIError as ex:\\n            msg = \\'Error while checking status for: {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def stop(self, container_name):\\n        self._exec_container_method(container_name, \\'stop\\')\\n\\n    def start(self, container_name):\\n        self._exec_container_method(container_name, \\'start\\')\\n\\n    def remove(self, container_name):\\n        self._exec_container_method(container_name, \\'remove\\')\\n\\n    def create_network(self, network_name):\\n        create_network = False\\n        try:\\n            networks = self._client.networks.list(names=[network_name])\\n            if networks:\\n                num_networks = len(networks)\\n                if num_networks == 0:\\n                    create_network = True\\n            else:\\n                create_network = True\\n            if create_network is True:\\n                os_name = self.get_os_type()\\n                if os_name == \\'windows\\':\\n                    return self._client.networks.create(network_name, driver=\\'nat\\')\\n                else:\\n                    return self._client.networks.create(network_name, driver=\\'bridge\\')\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not create docker network: {0}\\'.format(network_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def create_volume(self, volume_name):\\n        try:\\n            volume = self._get_volume_if_exists(volume_name)\\n            if volume is None:\\n                return self._client.volumes.create(volume_name)\\n        except docker .errors.APIError as ex:\\n            msg = \\'Docker volume create failed for: {0}\\'.format(volume_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def create_config_for_network(self, nw_name, *args, **kwargs):\\n        return self._client.api.create_networking_config({\\n            nw_name: self._client.api.create_endpoint_config(*args, **kwargs)\\n        })\\n\\n    def create_container(self, image, **kwargs):\\n        try:\\n            return self._client.api.create_container(image, **kwargs)\\n        except docker.errors.ContainerError as ex_ctr:\\n            msg = \\'Container exited with errors: {0}\\'.format(kwargs.get(\\'name\\', None))\\n            raise EdgeDeploymentError(msg, ex_ctr)\\n        except docker.errors.ImageNotFound as ex_img:\\n            msg = \\'Docker create failed. Image not found: {0}\\'.format(image)\\n            raise EdgeDeploymentError(msg, ex_img)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker create failed for image: {0}\\'.format(image)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def create_host_config(self, *args, **kwargs):\\n        try:\\n            return self._client.api.create_host_config(*args, **kwargs)\\n        except Exception as ex:\\n            msg = \\'docker create host config failed\\'\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def copy_file_to_volume(self,\\n                            container_name,\\n                            volume_name,\\n                            volume_dest_file_name,\\n                            volume_dest_dir_path,\\n                            host_src_file):\\n        if self.get_os_type() == \\'windows\\':\\n            self._insert_file_in_volume_mount(volume_name, host_src_file, volume_dest_file_name)\\n        else:\\n            self._insert_file_in_container(container_name,\\n                                           volume_dest_file_name,\\n                                           volume_dest_dir_path,\\n                                           host_src_file)\\n\\n    def get_os_type(self):\\n        try:\\n            info = self._client.info()\\n            return info[EdgeDockerClient._DOCKER_INFO_OS_TYPE_KEY].lower()\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker daemon returned error\\'\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def destroy_network(self, network_name):\\n        try:\\n            networks = self._client.networks.list(names=[network_name])\\n            if networks is not None:\\n                for network in networks:\\n                    if network.name == network_name:\\n                        network.remove()\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not remove docker network: {0}\\'.format(network_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def remove_volume(self, volume_name, force=False):\\n        try:\\n            volume = self._get_volume_if_exists(volume_name)\\n            if volume is not None:\\n                volume.remove(force)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker volume remove failed for: {0}, force flag: {1}\\'.format(volume_name, force)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _get_volume_if_exists(self, name):\\n        try:\\n            return self._client.volumes.get(name)\\n        except docker.errors.NotFound:\\n            return None\\n        except docker.errors.APIError as ex:\\n            msg = \\'Docker volume get failed for: {0}\\'.format(name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _exec_container_method(self, container_name, method, **kwargs):\\n        container = self._get_container_by_name(container_name)\\n        try:\\n            getattr(container, method)(**kwargs)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Could not {0} container: {1}\\'.format(method, container_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _get_container_by_name(self, container_name):\\n        try:\\n            return self._client.containers.get(container_name)\\n        except docker.errors.NotFound as nf_ex:\\n            msg = \\'Could not find container by name {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, nf_ex)\\n        except docker.errors.APIError as ex:\\n            msg = \\'Error getting container by name: {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, ex)\\n\\n    def _insert_file_in_volume_mount(self, volume_name, host_src_file, volume_dest_file_name):\\n        try:\\n            volume_info = self._client.api.inspect_volume(volume_name)\\n            Utils.copy_files(host_src_file.replace(\\'\\\\\\\\\\\\\\\\\\', \\'\\\\\\\\\\'),\\n                             os.path.join(volume_info[\\'Mountpoint\\'].replace(\\'\\\\\\\\\\\\\\\\\\', \\'\\\\\\\\\\'), volume_dest_file_name))\\n        except docker.errors.APIError as docker_ex:\\n            msg = \\'Docker volume inspect failed for: {0}\\'.format(volume_name)\\n            raise EdgeDeploymentError(msg, docker_ex)\\n        except (OSError, IOError) as ex_os:\\n            msg = \\'File IO error seen copying files to volume: {0}. \\' \\\\\\n                  \\'Errno: {1}, Error {2}\\'.format(volume_name, str(ex_os.errno), ex_os.strerror)\\n            raise EdgeDeploymentError(msg, ex_os)\\n\\n    def _insert_file_in_container(self,\\n                                  container_name,\\n                                  volume_dest_file_name,\\n                                  volume_dest_dir_path,\\n                                  host_src_file):\\n        try:\\n            (tar_stream, dest_archive_info, container_tar_file) = \\\\\\n                EdgeDockerClient.create_tar_objects(volume_dest_file_name)\\n            file_data = open(host_src_file, \\'rb\\').read()\\n            dest_archive_info.size = len(file_data)\\n            dest_archive_info.mtime = time.time()\\n            dest_archive_info.mode = 0o444\\n            container_tar_file.addfile(dest_archive_info, BytesIO(file_data))\\n            container_tar_file.close()\\n            tar_stream.seek(0)\\n            container = self._get_container_by_name(container_name)\\n            container.put_archive(volume_dest_dir_path, tar_stream)\\n        except docker.errors.APIError as docker_ex:\\n            msg = \\'Container put_archive failed for container: {0}\\'.format(container_name)\\n            raise EdgeDeploymentError(msg, docker_ex)\\n        except (OSError, IOError) as ex_os:\\n            msg = \\'File IO error seen during put archive for container: {0}. \\' \\\\\\n                  \\'Errno: {1}, Error {2}\\'.format(container_name, str(ex_os.errno), ex_os.strerror)\\n            raise EdgeDeploymentError(msg, ex_os)\\n\\n    @staticmethod\\n    def create_tar_objects(container_dest_file_name):\\n        tar_stream = BytesIO()\\n        dest_archive_info = tarfile.TarInfo(name=container_dest_file_name)\\n        container_tar_file = tarfile.TarFile(fileobj=tar_stream, mode=\\'w\\')\\n        return (tar_stream, dest_archive_info, container_tar_file)\\n\\n    @classmethod\\n    def create_instance(cls, docker_client):\\n        \"\"\"\\n        Factory method useful in testing.\\n        \"\"\"\\n        return cls(docker_client)\\n'"}, {"func_args": {"source": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport json\\nimport os\\n\\nimport docker\\nimport requests\\n\\nfrom .composeproject import ComposeProject\\nfrom .constants import EdgeConstants as EC\\nfrom .edgecert import EdgeCert\\nfrom .edgedockerclient import EdgeDockerClient\\nfrom .errors import ResponseError, RegistriesLoginError\\nfrom .hostplatform import HostPlatform\\nfrom .utils import Utils\\n\\n\\nclass EdgeManager(object):\\n    LABEL = \\'iotedgehubdev\\'\\n    EDGEHUB_IMG = \\'mcr.microsoft.com/azureiotedge-hub:{0}\\'\\n    TESTUTILITY_IMG = \\'mcr.microsoft.com/azureiotedge-testing-utility:1.0.0\\'\\n    EDGEHUB_MODULE = \\'$edgeHub\\'\\n    EDGEHUB = \\'edgeHubDev\\'\\n    INPUT = \\'input\\'\\n    NW_NAME = \\'azure-iot-edge-dev\\'\\n    MOUNT_BASE = \\'mnt\\'\\n    HUB_VOLUME = \\'edgehubdev\\'\\n    HUB_MOUNT = \\'{0}/edgehub\\'\\n    MODULE_VOLUME = \\'edgemoduledev\\'\\n    MODULE_MOUNT = \\'{0}/edgemodule\\'\\n    HUB_CA_ENV = \\'EdgeModuleHubServerCAChainCertificateFile={0}/edgehub/edge-chain-ca.cert.pem\\'\\n    HUB_CERT_ENV = \\'EdgeModuleHubServerCertificateFile={0}/edgehub/edge-hub-server.cert.pfx\\'\\n    HUB_SRC_ENV = \\'configSource=local\\'\\n    MODULE_CA_ENV = \"EdgeModuleCACertificateFile={0}/edgemodule/edge-device-ca.cert.pem\"\\n    HUB_SSLPATH_ENV = \\'SSL_CERTIFICATE_PATH={0}/edgehub/\\'\\n    HUB_SSLCRT_ENV = \\'SSL_CERTIFICATE_NAME=edge-hub-server.cert.pfx\\'\\n    CERT_HELPER = \\'cert_helper\\'\\n    HELPER_IMG = \\'hello-world:latest\\'\\n    COMPOSE_FILE = os.path.join(HostPlatform.get_share_data_path(), \\'docker-compose.yml\\')\\n\\n    def __init__(self, connection_str, gatewayhost, cert_path, hub_conn_str=None):\\n        connection_str_dict = Utils.parse_connection_strs(connection_str, hub_conn_str)\\n        self._hostname = connection_str_dict[EC.HOSTNAME_KEY]\\n        self._device_id = connection_str_dict[EC.DEVICE_ID_KEY]\\n        self._access_key = connection_str_dict[EC.DEVICE_ACCESS_KEY_KEY]\\n        self._compose_file = None\\n        self._gatewayhost = gatewayhost\\n        self._device_uri = \\'{0}/devices/{1}\\'.format(self._hostname, self._device_id)\\n        self._cert_path = cert_path\\n        self._edge_cert = EdgeCert(self._cert_path, self._gatewayhost)\\n        self._hub_access_key = connection_str_dict.get(EC.HUB_ACCESS_KEY_KEY)\\n        self._hub_access_name = connection_str_dict.get(EC.ACCESS_KEY_NAME)\\n\\n    @property\\n    def hostname(self):\\n        return self._hostname\\n\\n    @staticmethod\\n    def stop(edgedockerclient=None):\\n        if edgedockerclient is None:\\n            edgedockerclient = EdgeDockerClient()\\n\\n        compose_err = None\\n        label_err = None\\n        try:\\n            if os.path.exists(EdgeManager.COMPOSE_FILE):\\n                cmd = \"docker-compose -f {0} down\".format(EdgeManager.COMPOSE_FILE)\\n                Utils.exe_proc(cmd.split())\\n        except Exception as e:\\n            compose_err = e\\n\\n        try:\\n            edgedockerclient.stop_remove_by_label(EdgeManager.LABEL)\\n        except Exception as e:\\n            label_err = e\\n\\n        if compose_err or label_err:\\n            raise Exception(\\'{0}{1}\\'.format(\\n                \\'\\' if compose_err is None else str(compose_err),\\n                \\'\\' if label_err is None else str(label_err)))\\n\\n    def start_singlemodule(self, inputs, port, envs, edgehub_image_version):\\n        edgedockerclient = EdgeDockerClient()\\n        mount_base = self._obtain_mount_path(edgedockerclient)\\n        if mount_base is None:\\n            raise Exception(\"OS Type is not supported\")\\n\\n        EdgeManager.stop(edgedockerclient)\\n        self._prepare(edgedockerclient)\\n\\n        edgeHubConnStr = self.getOrAddModule(EdgeManager.EDGEHUB_MODULE, False)\\n        inputConnStr = self.getOrAddModule(EdgeManager.INPUT, False)\\n        routes = self._generateRoutesEnvFromInputs(inputs)\\n        self._start_edge_hub(edgedockerclient, edgeHubConnStr, routes, mount_base, envs, edgehub_image_version)\\n\\n        module_mount = EdgeManager.MODULE_MOUNT.format(mount_base)\\n        edgedockerclient.pullIfNotExist(EdgeManager.TESTUTILITY_IMG, None, None)\\n        network_config = edgedockerclient.create_config_for_network(EdgeManager.NW_NAME)\\n        inputEnv = [EdgeManager.MODULE_CA_ENV.format(mount_base), \"EdgeHubConnectionString={0}\".format(inputConnStr)]\\n        input_host_config = edgedockerclient.create_host_config(\\n            mounts=[docker.types.Mount(module_mount, EdgeManager.MODULE_VOLUME)],\\n            port_bindings={\\n                \\'3000\\': port\\n            },\\n            restart_policy={\\n                \\'MaximumRetryCount\\': 3,\\n                \\'Name\\': \\'on-failure\\'\\n            }\\n        )\\n        inputContainer = edgedockerclient.create_container(\\n            EdgeManager.TESTUTILITY_IMG,\\n            name=EdgeManager.INPUT,\\n            volumes=[module_mount],\\n            host_config=input_host_config,\\n            networking_config=network_config,\\n            environment=inputEnv,\\n            labels=[EdgeManager.LABEL],\\n            ports=[(3000, \\'tcp\\')]\\n        )\\n\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.INPUT, EdgeManager.MODULE_VOLUME, self._device_cert(),\\n            module_mount,\\n            self._edge_cert.get_cert_file_path(EC.EDGE_DEVICE_CA))\\n        edgedockerclient.start(inputContainer.get(\\'Id\\'))\\n\\n    def config_solution(self, module_content, target, mount_base):\\n        module_names = [EdgeManager.EDGEHUB_MODULE]\\n        custom_modules = module_content[\\'$edgeAgent\\'][\\'properties.desired\\'][\\'modules\\']\\n        for module_name in custom_modules:\\n            module_names.append(module_name)\\n\\n        ConnStr_info = {}\\n        for module_name in module_names:\\n            ConnStr_info[module_name] = self.getOrAddModule(module_name, False)\\n\\n        env_info = {\\n            \\'hub_env\\': [\\n                EdgeManager.HUB_CA_ENV.format(mount_base),\\n                EdgeManager.HUB_CERT_ENV.format(mount_base),\\n                EdgeManager.HUB_SRC_ENV,\\n                EdgeManager.HUB_SSLPATH_ENV.format(mount_base),\\n                EdgeManager.HUB_SSLCRT_ENV\\n            ],\\n            \\'module_env\\': [\\n                EdgeManager.MODULE_CA_ENV.format(mount_base)\\n            ]\\n        }\\n\\n        volume_info = {\\n            \\'HUB_MOUNT\\': EdgeManager.HUB_MOUNT.format(mount_base),\\n            \\'HUB_VOLUME\\': EdgeManager.HUB_VOLUME,\\n            \\'MODULE_VOLUME\\': EdgeManager.MODULE_VOLUME,\\n            \\'MODULE_MOUNT\\': EdgeManager.MODULE_MOUNT.format(mount_base)\\n        }\\n\\n        network_info = {\\n            \\'NW_NAME\\': EdgeManager.NW_NAME,\\n            \\'ALIASES\\': self._gatewayhost\\n        }\\n\\n        compose_project = ComposeProject(module_content)\\n        compose_project.set_edge_info({\\n            \\'ConnStr_info\\': ConnStr_info,\\n            \\'env_info\\': env_info,\\n            \\'volume_info\\': volume_info,\\n            \\'network_info\\': network_info,\\n            \\'hub_name\\': EdgeManager.EDGEHUB,\\n            \\'labels\\': EdgeManager.LABEL\\n        })\\n\\n        compose_project.compose()\\n        compose_project.dump(target)\\n\\n    def start_solution(self, module_content, verbose, output):\\n        try:\\n            EdgeManager.login_registries(module_content)\\n        except RegistriesLoginError as e:\\n            output.warning(e.getmsg())\\n\\n        edgedockerclient = EdgeDockerClient()\\n        mount_base = self._obtain_mount_path(edgedockerclient)\\n        if not mount_base:\\n            raise Exception(\"OS Type is not supported\")\\n\\n        EdgeManager.stop(edgedockerclient)\\n        self._prepare(edgedockerclient)\\n        self._prepare_cert(edgedockerclient, mount_base)\\n\\n        self.config_solution(module_content, EdgeManager.COMPOSE_FILE, mount_base)\\n        try:\\n            self.update_module_twin(module_content)\\n        except Exception as e:\\n            output.warning(str(e))\\n\\n        cmd_pull = [\\'docker-compose\\', \\'-f\\', EdgeManager.COMPOSE_FILE, \\'pull\\', EdgeManager.EDGEHUB]\\n        Utils.exe_proc(cmd_pull)\\n        if verbose:\\n            cmd_up = [\\'docker-compose\\', \\'-f\\', EdgeManager.COMPOSE_FILE, \\'up\\']\\n        else:\\n            cmd_up = [\\'docker-compose\\', \\'-f\\', EdgeManager.COMPOSE_FILE, \\'up\\', \\'-d\\']\\n        Utils.exe_proc(cmd_up)\\n\\n    def update_module_twin(self, module_content):\\n        if self._hub_access_key is None:\\n            return\\n\\n        twinErrorMsg = \\'\\'\\n        sas = Utils.get_iot_hub_sas_token(self._hostname, self._hub_access_key, self._hub_access_name)\\n        for name in module_content:\\n            if name == \\'$edgeAgent\\' or name == \\'$edgeHub\\':\\n                continue\\n            twin = module_content.get(name).get(\\'properties.desired\\')\\n            uri = self._get_update_twin_uri(name)\\n            res = requests.patch(\\n                uri,\\n                headers={\\n                    \\'Authorization\\': sas,\\n                    \\'Content-Type\\': \"application/json\",\\n                    \\'If-Match\\': \\'\"*\"\\'\\n                },\\n                data=json.dumps({\\n                    \\'properties\\': {\\n                        \\'desired\\': twin\\n                    }\\n                })\\n            )\\n            if res.ok is not True:\\n                twinErrorMsg += \\'Fail to update {0} twin. Code:{1}. Detail:{2}\\'.format(name, res.status_code, res.text)\\n        if twinErrorMsg:\\n            raise Exception(twinErrorMsg)\\n\\n    @staticmethod\\n    def login_registries(module_content):\\n        registryCredentials = module_content.get(\\'$edgeAgent\\', {}).get(\\'properties.desired\\', {}).get(\\n            \\'runtime\\', {}).get(\\'settings\\', {}).get(\\'registryCredentials\\')\\n        if not registryCredentials:\\n            return\\n        failLogin = []\\n        errMsg = \\'\\'\\n        for key in registryCredentials:\\n            value = registryCredentials[key]\\n            try:\\n                cmd_login = [\\'docker\\', \\'login\\', \\'-u\\', value[\\'username\\'], \\'-p\\', value[\\'password\\'], value[\\'address\\']]\\n                Utils.exe_proc(cmd_login)\\n            except Exception as e:\\n                failLogin.append(key)\\n                errMsg += \\'{0}\\\\n\\'.format(str(e))\\n        if failLogin:\\n            raise RegistriesLoginError(failLogin, errMsg)\\n\\n    def _prepare_cert(self, edgedockerclient, mount_base):\\n        status = edgedockerclient.status(EdgeManager.CERT_HELPER)\\n        if status is not None:\\n            edgedockerclient.stop(EdgeManager.CERT_HELPER)\\n            edgedockerclient.remove(EdgeManager.CERT_HELPER)\\n\\n        hub_mount = EdgeManager.HUB_MOUNT.format(mount_base)\\n        module_mount = EdgeManager.MODULE_MOUNT.format(mount_base)\\n\\n        helper_host_config = edgedockerclient.create_host_config(\\n            mounts=[docker.types.Mount(hub_mount, EdgeManager.HUB_VOLUME),\\n                    docker.types.Mount(module_mount, EdgeManager.MODULE_VOLUME)]\\n        )\\n\\n        edgedockerclient.pull(EdgeManager.HELPER_IMG, None, None)\\n\\n        edgedockerclient.create_container(\\n            EdgeManager.HELPER_IMG,\\n            name=EdgeManager.CERT_HELPER,\\n            volumes=[hub_mount, module_mount],\\n            host_config=helper_host_config,\\n            labels=[EdgeManager.LABEL]\\n        )\\n\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.CERT_HELPER, EdgeManager.HUB_VOLUME, EdgeManager._chain_cert(),\\n            hub_mount, self._edge_cert.get_cert_file_path(EC.EDGE_CHAIN_CA))\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.CERT_HELPER, EdgeManager.HUB_VOLUME, EdgeManager._hubserver_pfx(),\\n            hub_mount, self._edge_cert.get_pfx_file_path(EC.EDGE_HUB_SERVER))\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.CERT_HELPER, EdgeManager.MODULE_VOLUME, self._device_cert(),\\n            module_mount, self._edge_cert.get_cert_file_path(EC.EDGE_DEVICE_CA))\\n\\n    def start(self, modulesDict, routes):\\n        return\\n\\n    def getOrAddModule(self, name, islocal):\\n        try:\\n            return self.getModule(name, islocal)\\n        except ResponseError as geterr:\\n            if geterr.status_code == 404:\\n                try:\\n                    return self.addModule(name, islocal)\\n                except ResponseError as adderr:\\n                    if adderr.status_code == 400:\\n                        raise ResponseError(400, adderr.value + \" Please make sure you are using an Edge device.\")\\n                    raise adderr\\n            else:\\n                raise geterr\\n\\n    def outputModuleCred(self, names, islocal, output_file):\\n        connstrENV = \\'EdgeHubConnectionString={0}\\'.format(\\'|\\'.join([self.getOrAddModule(name, islocal) for name in names]))\\n        deviceCAEnv = \\'EdgeModuleCACertificateFile={0}\\'.format(self._edge_cert.get_cert_file_path(EC.EDGE_DEVICE_CA))\\n        cred = [connstrENV, deviceCAEnv]\\n\\n        if output_file is not None:\\n            output_path = os.path.abspath(output_file)\\n            dir = os.path.dirname(output_path)\\n            if not os.path.exists(dir):\\n                os.makedirs(dir)\\n            with open(output_path, \\'w+\\') as envFile:\\n                envFile.writelines([\\'\\\\n\\', cred[0], \\'\\\\n\\', cred[1]])\\n        return cred\\n\\n    def getModule(self, name, islocal):\\n        moduleUri = self._getModuleReqUri(name)\\n        sas = Utils.get_iot_hub_sas_token(self._device_uri, self._access_key, None)\\n        res = requests.get(\\n            moduleUri,\\n            headers={\\n                \\'Authorization\\': sas,\\n                \\'Content-Type\\': \\'application/json\\'\\n            }\\n        )\\n        if res.ok is not True:\\n            raise ResponseError(res.status_code, res.text)\\n        else:\\n            jsonObj = res.json()\\n            auth = jsonObj[\\'authentication\\']\\n            if auth is not None:\\n                authType = auth[\\'type\\']\\n                authKey = auth[\\'symmetricKey\\']\\n                if authType == \\'sas\\' and authKey is not None and authKey[\\'primaryKey\\'] is not None:\\n                    return self._generateModuleConnectionStr(res, islocal)\\n            return self.updateModule(name, jsonObj[\\'etag\\'], islocal)\\n\\n    def updateModule(self, name, etag, islocal):\\n        moduleUri = self._getModuleReqUri(name)\\n        sas = Utils.get_iot_hub_sas_token(self._device_uri, self._access_key, None)\\n        res = requests.put(\\n            moduleUri,\\n            headers={\\n                \\'Authorization\\': sas,\\n                \\'Content-Type\\': \"application/json\",\\n                \\'If-Match\\': \\'\"*\"\\'\\n            },\\n            data=json.dumps({\\n                \\'moduleId\\': name,\\n                \\'deviceId\\': self._device_id,\\n                \\'authentication\\': {\\n                    \\'type\\': \\'sas\\'\\n                }\\n            })\\n        )\\n        if res.ok is not True:\\n            raise ResponseError(res.status_code, res.text)\\n        return self._generateModuleConnectionStr(res, islocal)\\n\\n    def addModule(self, name, islocal):\\n        moduleUri = self._getModuleReqUri(name)\\n        sas = Utils.get_iot_hub_sas_token(self._device_uri, self._access_key, None)\\n        res = requests.put(\\n            moduleUri,\\n            headers={\\n                \"Authorization\": sas,\\n                \"Content-Type\": \"application/json\"\\n            },\\n            data=json.dumps({\\n                \\'moduleId\\': name,\\n                \\'deviceId\\': self._device_id\\n            })\\n        )\\n        if res.ok is not True:\\n            raise ResponseError(res.status_code, res.text)\\n        return self._generateModuleConnectionStr(res, islocal)\\n\\n    def _getModuleReqUri(self, name):\\n        return \"https://{0}/devices/{1}/modules/{2}?api-version=2018-06-30\".format(\\n            self._hostname, self._device_id, name)\\n\\n    def _get_update_twin_uri(self, name):\\n        return \"https://{0}/twins/{1}/modules/{2}?api-version=2018-06-30\".format(\\n            self._hostname, self._device_id, name)\\n\\n    def _generateModuleConnectionStr(self, response, islocal):\\n        jsonObj = response.json()\\n        moduleId = jsonObj[\\'moduleId\\']\\n        deviceId = jsonObj[\\'deviceId\\']\\n        sasKey = jsonObj[\\'authentication\\'][\\'symmetricKey\\'][\\'primaryKey\\']\\n        hubTemplate = \\'HostName={0};DeviceId={1};ModuleId={2};SharedAccessKey={3}\\'\\n        moduleTemplate = \\'HostName={0};GatewayHostName={1};DeviceId={2};ModuleId={3};SharedAccessKey={4}\\'\\n        gatewayhost = self._gatewayhost\\n        if (islocal):\\n            gatewayhost = \\'localhost\\'\\n        if (moduleId == \\'$edgeHub\\'):\\n            return hubTemplate.format(self._hostname, deviceId, moduleId, sasKey)\\n        else:\\n            return moduleTemplate.format(self._hostname, gatewayhost, deviceId, moduleId, sasKey)\\n\\n    def _generateRoutesEnvFromInputs(self, inputs):\\n        routes = [\\n            \\'routes__output=FROM /messages/modules/target/outputs/* INTO BrokeredEndpoint(\"/modules/input/inputs/print\")\\'\\n        ]\\n        template = \\'routes__r{0}=FROM /messages/modules/input/outputs/{1} INTO BrokeredEndpoint(\"/modules/target/inputs/{2}\")\\'\\n        inputSet = set(inputs)\\n        for (idx, input) in enumerate(inputSet):\\n            routes.append(template.format(idx + 1, input, input))\\n        return routes\\n\\n    def _prepare(self, edgedockerclient):\\n        edgedockerclient.create_network(EdgeManager.NW_NAME)\\n        edgedockerclient.create_volume(EdgeManager.HUB_VOLUME)\\n        edgedockerclient.create_volume(EdgeManager.MODULE_VOLUME)\\n\\n    def _start_edge_hub(self, edgedockerclient, edgeHubConnStr, routes, mount_base, envs, edgehub_image_version):\\n        edgehub_image = EdgeManager.EDGEHUB_IMG.format(edgehub_image_version)\\n        edgedockerclient.pull(edgehub_image, None, None)\\n        network_config = edgedockerclient.create_config_for_network(EdgeManager.NW_NAME, aliases=[self._gatewayhost])\\n        hub_mount = EdgeManager.HUB_MOUNT.format(mount_base)\\n        hub_host_config = edgedockerclient.create_host_config(\\n            mounts=[docker.types.Mount(hub_mount, EdgeManager.HUB_VOLUME)],\\n            port_bindings={\\n                \\'8883\\': 8883,\\n                \\'443\\': 443,\\n                \\'5671\\': 5671\\n            }\\n        )\\n        hubEnv = [\\n            EdgeManager.HUB_CA_ENV.format(mount_base),\\n            EdgeManager.HUB_CERT_ENV.format(mount_base),\\n            EdgeManager.HUB_SRC_ENV,\\n            EdgeManager.HUB_SSLPATH_ENV.format(mount_base),\\n            EdgeManager.HUB_SSLCRT_ENV,\\n            \\'IotHubConnectionString={0}\\'.format(edgeHubConnStr)]\\n        hubEnv.extend(routes)\\n        hubEnv.extend(list(envs))\\n\\n        hubContainer = edgedockerclient.create_container(\\n            edgehub_image,\\n            name=EdgeManager.EDGEHUB,\\n            volumes=[hub_mount],\\n            host_config=hub_host_config,\\n            networking_config=network_config,\\n            environment=hubEnv,\\n            labels=[EdgeManager.LABEL],\\n            ports=[(8883, \\'tcp\\'), (443, \\'tcp\\'), (5671, \\'tcp\\')]\\n        )\\n\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.EDGEHUB, EdgeManager.HUB_VOLUME, EdgeManager._chain_cert(),\\n            hub_mount, self._edge_cert.get_cert_file_path(EC.EDGE_CHAIN_CA))\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.EDGEHUB, EdgeManager.HUB_VOLUME, EdgeManager._hubserver_pfx(),\\n            hub_mount, self._edge_cert.get_pfx_file_path(EC.EDGE_HUB_SERVER))\\n        edgedockerclient.start(hubContainer.get(\\'Id\\'))\\n\\n    def _obtain_mount_path(self, edgedockerclient):\\n        os_type = edgedockerclient.get_os_type().lower()\\n        if os_type == \\'linux\\':\\n            return \\'/{0}\\'.format(EdgeManager.MOUNT_BASE)\\n        elif os_type == \\'windows\\':\\n            return \\'c:/{0}\\'.format(EdgeManager.MOUNT_BASE)\\n\\n    @staticmethod\\n    def _chain_cert():\\n        return EC.EDGE_CHAIN_CA + EC.CERT_SUFFIX\\n\\n    @staticmethod\\n    def _hubserver_pfx():\\n        return EC.EDGE_HUB_SERVER + EC.PFX_SUFFIX\\n\\n    @staticmethod\\n    def _device_cert():\\n        return EC.EDGE_DEVICE_CA + EC.CERT_SUFFIX\\n'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport json\\nimport os\\n\\nimport docker\\nimport requests\\n\\nfrom .composeproject import ComposeProject\\nfrom .constants import EdgeConstants as EC\\nfrom .edgecert import EdgeCert\\nfrom .edgedockerclient import EdgeDockerClient\\nfrom .errors import ResponseError, RegistriesLoginError\\nfrom .hostplatform import HostPlatform\\nfrom .utils import Utils\\n\\n\\nclass EdgeManager(object):\\n    LABEL = \\'iotedgehubdev\\'\\n    EDGEHUB_IMG = \\'mcr.microsoft.com/azureiotedge-hub:{0}\\'\\n    TESTUTILITY_IMG = \\'mcr.microsoft.com/azureiotedge-testing-utility:1.0.0\\'\\n    EDGEHUB_MODULE = \\'$edgeHub\\'\\n    EDGEHUB = \\'edgeHubDev\\'\\n    INPUT = \\'input\\'\\n    NW_NAME = \\'azure-iot-edge-dev\\'\\n    MOUNT_BASE = \\'mnt\\'\\n    HUB_VOLUME = \\'edgehubdev\\'\\n    HUB_MOUNT = \\'{0}/edgehub\\'\\n    MODULE_VOLUME = \\'edgemoduledev\\'\\n    MODULE_MOUNT = \\'{0}/edgemodule\\'\\n    HUB_CA_ENV = \\'EdgeModuleHubServerCAChainCertificateFile={0}/edgehub/edge-chain-ca.cert.pem\\'\\n    HUB_CERT_ENV = \\'EdgeModuleHubServerCertificateFile={0}/edgehub/edge-hub-server.cert.pfx\\'\\n    HUB_SRC_ENV = \\'configSource=local\\'\\n    MODULE_CA_ENV = \"EdgeModuleCACertificateFile={0}/edgemodule/edge-device-ca.cert.pem\"\\n    HUB_SSLPATH_ENV = \\'SSL_CERTIFICATE_PATH={0}/edgehub/\\'\\n    HUB_SSLCRT_ENV = \\'SSL_CERTIFICATE_NAME=edge-hub-server.cert.pfx\\'\\n    CERT_HELPER = \\'cert_helper\\'\\n    HELPER_IMG = \\'hello-world:latest\\'\\n    COMPOSE_FILE = os.path.join(HostPlatform.get_share_data_path(), \\'docker-compose.yml\\')\\n\\n    def __init__(self, connection_str, gatewayhost, cert_path, hub_conn_str=None):\\n        connection_str_dict = Utils.parse_connection_strs(connection_str, hub_conn_str)\\n        self._hostname = connection_str_dict[EC.HOSTNAME_KEY]\\n        self._device_id = connection_str_dict[EC.DEVICE_ID_KEY]\\n        self._access_key = connection_str_dict[EC.DEVICE_ACCESS_KEY_KEY]\\n        self._compose_file = None\\n        self._gatewayhost = gatewayhost\\n        self._device_uri = \\'{0}/devices/{1}\\'.format(self._hostname, self._device_id)\\n        self._cert_path = cert_path\\n        self._edge_cert = EdgeCert(self._cert_path, self._gatewayhost)\\n        self._hub_access_key = connection_str_dict.get(EC.HUB_ACCESS_KEY_KEY)\\n        self._hub_access_name = connection_str_dict.get(EC.ACCESS_KEY_NAME)\\n\\n    @property\\n    def hostname(self):\\n        return self._hostname\\n\\n    @staticmethod\\n    def stop(edgedockerclient=None):\\n        if edgedockerclient is None:\\n            edgedockerclient = EdgeDockerClient()\\n\\n        compose_err = None\\n        label_err = None\\n        try:\\n            if os.path.exists(EdgeManager.COMPOSE_FILE):\\n                cmd = \"docker-compose -f {0} down\".format(EdgeManager.COMPOSE_FILE)\\n                Utils.exe_proc(cmd.split())\\n        except Exception as e:\\n            compose_err = e\\n\\n        try:\\n            edgedockerclient.stop_remove_by_label(EdgeManager.LABEL)\\n        except Exception as e:\\n            label_err = e\\n\\n        if compose_err or label_err:\\n            raise Exception(\\'{0}{1}\\'.format(\\n                \\'\\' if compose_err is None else str(compose_err),\\n                \\'\\' if label_err is None else str(label_err)))\\n\\n    def start_singlemodule(self, inputs, port, envs, edgehub_image_version):\\n        edgedockerclient = EdgeDockerClient()\\n        mount_base = self._obtain_mount_path(edgedockerclient)\\n        if mount_base is None:\\n            raise Exception(\"OS Type is not supported\")\\n\\n        EdgeManager.stop(edgedockerclient)\\n        self._prepare(edgedockerclient)\\n\\n        edgeHubConnStr = self.getOrAddModule(EdgeManager.EDGEHUB_MODULE, False)\\n        inputConnStr = self.getOrAddModule(EdgeManager.INPUT, False)\\n        routes = self._generateRoutesEnvFromInputs(inputs)\\n        self._start_edge_hub(edgedockerclient, edgeHubConnStr, routes, mount_base, envs, edgehub_image_version)\\n\\n        module_mount = EdgeManager.MODULE_MOUNT.format(mount_base)\\n        edgedockerclient.pullIfNotExist(EdgeManager.TESTUTILITY_IMG, None, None)\\n        network_config = edgedockerclient.create_config_for_network(EdgeManager.NW_NAME)\\n        inputEnv = [EdgeManager.MODULE_CA_ENV.format(mount_base), \"EdgeHubConnectionString={0}\".format(inputConnStr)]\\n        input_host_config = edgedockerclient.create_host_config(\\n            mounts=[docker.types.Mount(module_mount, EdgeManager.MODULE_VOLUME)],\\n            port_bindings={\\n                \\'3000\\': port\\n            },\\n            restart_policy={\\n                \\'MaximumRetryCount\\': 3,\\n                \\'Name\\': \\'on-failure\\'\\n            }\\n        )\\n        inputContainer = edgedockerclient.create_container(\\n            EdgeManager.TESTUTILITY_IMG,\\n            name=EdgeManager.INPUT,\\n            volumes=[module_mount],\\n            host_config=input_host_config,\\n            networking_config=network_config,\\n            environment=inputEnv,\\n            labels=[EdgeManager.LABEL],\\n            ports=[(3000, \\'tcp\\')]\\n        )\\n\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.INPUT, EdgeManager.MODULE_VOLUME, self._device_cert(),\\n            module_mount,\\n            self._edge_cert.get_cert_file_path(EC.EDGE_DEVICE_CA))\\n        edgedockerclient.start(inputContainer.get(\\'Id\\'))\\n\\n    def config_solution(self, module_content, target, mount_base):\\n        module_names = [EdgeManager.EDGEHUB_MODULE]\\n        custom_modules = module_content[\\'$edgeAgent\\'][\\'properties.desired\\'][\\'modules\\']\\n        for module_name in custom_modules:\\n            module_names.append(module_name)\\n\\n        ConnStr_info = {}\\n        for module_name in module_names:\\n            ConnStr_info[module_name] = self.getOrAddModule(module_name, False)\\n\\n        env_info = {\\n            \\'hub_env\\': [\\n                EdgeManager.HUB_CA_ENV.format(mount_base),\\n                EdgeManager.HUB_CERT_ENV.format(mount_base),\\n                EdgeManager.HUB_SRC_ENV,\\n                EdgeManager.HUB_SSLPATH_ENV.format(mount_base),\\n                EdgeManager.HUB_SSLCRT_ENV\\n            ],\\n            \\'module_env\\': [\\n                EdgeManager.MODULE_CA_ENV.format(mount_base)\\n            ]\\n        }\\n\\n        volume_info = {\\n            \\'HUB_MOUNT\\': EdgeManager.HUB_MOUNT.format(mount_base),\\n            \\'HUB_VOLUME\\': EdgeManager.HUB_VOLUME,\\n            \\'MODULE_VOLUME\\': EdgeManager.MODULE_VOLUME,\\n            \\'MODULE_MOUNT\\': EdgeManager.MODULE_MOUNT.format(mount_base)\\n        }\\n\\n        network_info = {\\n            \\'NW_NAME\\': EdgeManager.NW_NAME,\\n            \\'ALIASES\\': self._gatewayhost\\n        }\\n\\n        compose_project = ComposeProject(module_content)\\n        compose_project.set_edge_info({\\n            \\'ConnStr_info\\': ConnStr_info,\\n            \\'env_info\\': env_info,\\n            \\'volume_info\\': volume_info,\\n            \\'network_info\\': network_info,\\n            \\'hub_name\\': EdgeManager.EDGEHUB,\\n            \\'labels\\': EdgeManager.LABEL\\n        })\\n\\n        compose_project.compose()\\n        compose_project.dump(target)\\n\\n    def start_solution(self, module_content, verbose, output):\\n        try:\\n            EdgeManager.login_registries(module_content)\\n        except RegistriesLoginError as e:\\n            output.warning(e.getmsg())\\n\\n        edgedockerclient = EdgeDockerClient()\\n        mount_base = self._obtain_mount_path(edgedockerclient)\\n        if not mount_base:\\n            raise Exception(\"OS Type is not supported\")\\n\\n        EdgeManager.stop(edgedockerclient)\\n        self._prepare(edgedockerclient)\\n        self._prepare_cert(edgedockerclient, mount_base)\\n\\n        self.config_solution(module_content, EdgeManager.COMPOSE_FILE, mount_base)\\n        try:\\n            self.update_module_twin(module_content)\\n        except Exception as e:\\n            output.warning(str(e))\\n\\n        cmd_pull = [\\'docker-compose\\', \\'-f\\', EdgeManager.COMPOSE_FILE, \\'pull\\', EdgeManager.EDGEHUB]\\n        Utils.exe_proc(cmd_pull)\\n        if verbose:\\n            cmd_up = [\\'docker-compose\\', \\'-f\\', EdgeManager.COMPOSE_FILE, \\'up\\']\\n        else:\\n            cmd_up = [\\'docker-compose\\', \\'-f\\', EdgeManager.COMPOSE_FILE, \\'up\\', \\'-d\\']\\n        Utils.exe_proc(cmd_up)\\n\\n    def update_module_twin(self, module_content):\\n        if self._hub_access_key is None:\\n            return\\n\\n        twinErrorMsg = \\'\\'\\n        sas = Utils.get_iot_hub_sas_token(self._hostname, self._hub_access_key, self._hub_access_name)\\n        for name in module_content:\\n            if name == \\'$edgeAgent\\' or name == \\'$edgeHub\\':\\n                continue\\n            twin = module_content.get(name).get(\\'properties.desired\\')\\n            uri = self._get_update_twin_uri(name)\\n            res = requests.patch(\\n                uri,\\n                headers={\\n                    \\'Authorization\\': sas,\\n                    \\'Content-Type\\': \"application/json\",\\n                    \\'If-Match\\': \\'\"*\"\\'\\n                },\\n                data=json.dumps({\\n                    \\'properties\\': {\\n                        \\'desired\\': twin\\n                    }\\n                })\\n            )\\n            if res.ok is not True:\\n                twinErrorMsg += \\'Fail to update {0} twin. Code:{1}. Detail:{2}\\'.format(name, res.status_code, res.text)\\n        if twinErrorMsg:\\n            raise Exception(twinErrorMsg)\\n\\n    @staticmethod\\n    def login_registries(module_content):\\n        registryCredentials = module_content.get(\\'$edgeAgent\\', {}).get(\\'properties.desired\\', {}).get(\\n            \\'runtime\\', {}).get(\\'settings\\', {}).get(\\'registryCredentials\\')\\n        if not registryCredentials:\\n            return\\n        failLogin = []\\n        errMsg = \\'\\'\\n        for key in registryCredentials:\\n            value = registryCredentials[key]\\n            try:\\n                cmd_login = [\\'docker\\', \\'login\\', \\'-u\\', value[\\'username\\'], \\'-p\\', value[\\'password\\'], value[\\'address\\']]\\n                Utils.exe_proc(cmd_login)\\n            except Exception as e:\\n                failLogin.append(key)\\n                errMsg += \\'{0}\\\\n\\'.format(str(e))\\n        if failLogin:\\n            raise RegistriesLoginError(failLogin, errMsg)\\n\\n    def _prepare_cert(self, edgedockerclient, mount_base):\\n        status = edgedockerclient.status(EdgeManager.CERT_HELPER)\\n        if status is not None:\\n            edgedockerclient.stop(EdgeManager.CERT_HELPER)\\n            edgedockerclient.remove(EdgeManager.CERT_HELPER)\\n\\n        hub_mount = EdgeManager.HUB_MOUNT.format(mount_base)\\n        module_mount = EdgeManager.MODULE_MOUNT.format(mount_base)\\n\\n        helper_host_config = edgedockerclient.create_host_config(\\n            mounts=[docker.types.Mount(hub_mount, EdgeManager.HUB_VOLUME),\\n                    docker.types.Mount(module_mount, EdgeManager.MODULE_VOLUME)]\\n        )\\n\\n        edgedockerclient.pull(EdgeManager.HELPER_IMG, None, None)\\n\\n        edgedockerclient.create_container(\\n            EdgeManager.HELPER_IMG,\\n            name=EdgeManager.CERT_HELPER,\\n            volumes=[hub_mount, module_mount],\\n            host_config=helper_host_config,\\n            labels=[EdgeManager.LABEL]\\n        )\\n\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.CERT_HELPER, EdgeManager.HUB_VOLUME, EdgeManager._chain_cert(),\\n            hub_mount, self._edge_cert.get_cert_file_path(EC.EDGE_CHAIN_CA))\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.CERT_HELPER, EdgeManager.HUB_VOLUME, EdgeManager._hubserver_pfx(),\\n            hub_mount, self._edge_cert.get_pfx_file_path(EC.EDGE_HUB_SERVER))\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.CERT_HELPER, EdgeManager.MODULE_VOLUME, self._device_cert(),\\n            module_mount, self._edge_cert.get_cert_file_path(EC.EDGE_DEVICE_CA))\\n\\n    def start(self, modulesDict, routes):\\n        return\\n\\n    def getOrAddModule(self, name, islocal):\\n        try:\\n            return self.getModule(name, islocal)\\n        except ResponseError as geterr:\\n            if geterr.status_code == 404:\\n                try:\\n                    return self.addModule(name, islocal)\\n                except ResponseError as adderr:\\n                    if adderr.status_code == 400:\\n                        raise ResponseError(400, adderr.value + \" Please make sure you are using an Edge device.\")\\n                    raise adderr\\n            else:\\n                raise geterr\\n\\n    def outputModuleCred(self, names, islocal, output_file):\\n        connstrENV = \\'EdgeHubConnectionString={0}\\'.format(\\'|\\'.join([self.getOrAddModule(name, islocal) for name in names]))\\n        deviceCAEnv = \\'EdgeModuleCACertificateFile={0}\\'.format(self._edge_cert.get_cert_file_path(EC.EDGE_DEVICE_CA))\\n        cred = [connstrENV, deviceCAEnv]\\n\\n        if output_file is not None:\\n            output_path = os.path.abspath(output_file)\\n            dir = os.path.dirname(output_path)\\n            if not os.path.exists(dir):\\n                os.makedirs(dir)\\n            with open(output_path, \\'w+\\') as envFile:\\n                envFile.writelines([\\'\\\\n\\', cred[0], \\'\\\\n\\', cred[1]])\\n        return cred\\n\\n    def getModule(self, name, islocal):\\n        moduleUri = self._getModuleReqUri(name)\\n        sas = Utils.get_iot_hub_sas_token(self._device_uri, self._access_key, None)\\n        res = requests.get(\\n            moduleUri,\\n            headers={\\n                \\'Authorization\\': sas,\\n                \\'Content-Type\\': \\'application/json\\'\\n            }\\n        )\\n        if res.ok is not True:\\n            raise ResponseError(res.status_code, res.text)\\n        else:\\n            jsonObj = res.json()\\n            auth = jsonObj[\\'authentication\\']\\n            if auth is not None:\\n                authType = auth[\\'type\\']\\n                authKey = auth[\\'symmetricKey\\']\\n                if authType == \\'sas\\' and authKey is not None and authKey[\\'primaryKey\\'] is not None:\\n                    return self._generateModuleConnectionStr(res, islocal)\\n            return self.updateModule(name, jsonObj[\\'etag\\'], islocal)\\n\\n    def updateModule(self, name, etag, islocal):\\n        moduleUri = self._getModuleReqUri(name)\\n        sas = Utils.get_iot_hub_sas_token(self._device_uri, self._access_key, None)\\n        res = requests.put(\\n            moduleUri,\\n            headers={\\n                \\'Authorization\\': sas,\\n                \\'Content-Type\\': \"application/json\",\\n                \\'If-Match\\': \\'\"*\"\\'\\n            },\\n            data=json.dumps({\\n                \\'moduleId\\': name,\\n                \\'deviceId\\': self._device_id,\\n                \\'authentication\\': {\\n                    \\'type\\': \\'sas\\'\\n                }\\n            })\\n        )\\n        if res.ok is not True:\\n            raise ResponseError(res.status_code, res.text)\\n        return self._generateModuleConnectionStr(res, islocal)\\n\\n    def addModule(self, name, islocal):\\n        moduleUri = self._getModuleReqUri(name)\\n        sas = Utils.get_iot_hub_sas_token(self._device_uri, self._access_key, None)\\n        res = requests.put(\\n            moduleUri,\\n            headers={\\n                \"Authorization\": sas,\\n                \"Content-Type\": \"application/json\"\\n            },\\n            data=json.dumps({\\n                \\'moduleId\\': name,\\n                \\'deviceId\\': self._device_id\\n            })\\n        )\\n        if res.ok is not True:\\n            raise ResponseError(res.status_code, res.text)\\n        return self._generateModuleConnectionStr(res, islocal)\\n\\n    def _getModuleReqUri(self, name):\\n        return \"https://{0}/devices/{1}/modules/{2}?api-version=2018-06-30\".format(\\n            self._hostname, self._device_id, name)\\n\\n    def _get_update_twin_uri(self, name):\\n        return \"https://{0}/twins/{1}/modules/{2}?api-version=2018-06-30\".format(\\n            self._hostname, self._device_id, name)\\n\\n    def _generateModuleConnectionStr(self, response, islocal):\\n        jsonObj = response.json()\\n        moduleId = jsonObj[\\'moduleId\\']\\n        deviceId = jsonObj[\\'deviceId\\']\\n        sasKey = jsonObj[\\'authentication\\'][\\'symmetricKey\\'][\\'primaryKey\\']\\n        hubTemplate = \\'HostName={0};DeviceId={1};ModuleId={2};SharedAccessKey={3}\\'\\n        moduleTemplate = \\'HostName={0};GatewayHostName={1};DeviceId={2};ModuleId={3};SharedAccessKey={4}\\'\\n        gatewayhost = self._gatewayhost\\n        if (islocal):\\n            gatewayhost = \\'localhost\\'\\n        if (moduleId == \\'$edgeHub\\'):\\n            return hubTemplate.format(self._hostname, deviceId, moduleId, sasKey)\\n        else:\\n            return moduleTemplate.format(self._hostname, gatewayhost, deviceId, moduleId, sasKey)\\n\\n    def _generateRoutesEnvFromInputs(self, inputs):\\n        routes = [\\n            \\'routes__output=FROM /messages/modules/target/outputs/* INTO BrokeredEndpoint(\"/modules/input/inputs/print\")\\'\\n        ]\\n        template = \\'routes__r{0}=FROM /messages/modules/input/outputs/{1} INTO BrokeredEndpoint(\"/modules/target/inputs/{2}\")\\'\\n        inputSet = set(inputs)\\n        for (idx, input) in enumerate(inputSet):\\n            routes.append(template.format(idx + 1, input, input))\\n        return routes\\n\\n    def _prepare(self, edgedockerclient):\\n        edgedockerclient.create_network(EdgeManager.NW_NAME)\\n        edgedockerclient.create_volume(EdgeManager.HUB_VOLUME)\\n        edgedockerclient.create_volume(EdgeManager.MODULE_VOLUME)\\n\\n    def _start_edge_hub(self, edgedockerclient, edgeHubConnStr, routes, mount_base, envs, edgehub_image_version):\\n        edgehub_image = EdgeManager.EDGEHUB_IMG.format(edgehub_image_version)\\n        edgedockerclient.pull(edgehub_image, None, None)\\n        network_config = edgedockerclient.create_config_for_network(EdgeManager.NW_NAME, aliases=[self._gatewayhost])\\n        hub_mount = EdgeManager.HUB_MOUNT.format(mount_base)\\n        hub_host_config = edgedockerclient.create_host_config(\\n            mounts=[docker.types.Mount(hub_mount, EdgeManager.HUB_VOLUME)],\\n            port_bindings={\\n                \\'8883\\': 8883,\\n                \\'443\\': 443,\\n                \\'5671\\': 5671\\n            }\\n        )\\n        hubEnv = [\\n            EdgeManager.HUB_CA_ENV.format(mount_base),\\n            EdgeManager.HUB_CERT_ENV.format(mount_base),\\n            EdgeManager.HUB_SRC_ENV,\\n            EdgeManager.HUB_SSLPATH_ENV.format(mount_base),\\n            EdgeManager.HUB_SSLCRT_ENV,\\n            \\'IotHubConnectionString={0}\\'.format(edgeHubConnStr)]\\n        hubEnv.extend(routes)\\n        hubEnv.extend(list(envs))\\n\\n        hubContainer = edgedockerclient.create_container(\\n            edgehub_image,\\n            name=EdgeManager.EDGEHUB,\\n            volumes=[hub_mount],\\n            host_config=hub_host_config,\\n            networking_config=network_config,\\n            environment=hubEnv,\\n            labels=[EdgeManager.LABEL],\\n            ports=[(8883, \\'tcp\\'), (443, \\'tcp\\'), (5671, \\'tcp\\')]\\n        )\\n\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.EDGEHUB, EdgeManager.HUB_VOLUME, EdgeManager._chain_cert(),\\n            hub_mount, self._edge_cert.get_cert_file_path(EC.EDGE_CHAIN_CA))\\n        edgedockerclient.copy_file_to_volume(\\n            EdgeManager.EDGEHUB, EdgeManager.HUB_VOLUME, EdgeManager._hubserver_pfx(),\\n            hub_mount, self._edge_cert.get_pfx_file_path(EC.EDGE_HUB_SERVER))\\n        edgedockerclient.start(hubContainer.get(\\'Id\\'))\\n\\n    def _obtain_mount_path(self, edgedockerclient):\\n        os_type = edgedockerclient.get_os_type().lower()\\n        if os_type == \\'linux\\':\\n            return \\'/{0}\\'.format(EdgeManager.MOUNT_BASE)\\n        elif os_type == \\'windows\\':\\n            return \\'c:/{0}\\'.format(EdgeManager.MOUNT_BASE)\\n\\n    @staticmethod\\n    def _chain_cert():\\n        return EC.EDGE_CHAIN_CA + EC.CERT_SUFFIX\\n\\n    @staticmethod\\n    def _hubserver_pfx():\\n        return EC.EDGE_HUB_SERVER + EC.PFX_SUFFIX\\n\\n    @staticmethod\\n    def _device_cert():\\n        return EC.EDGE_DEVICE_CA + EC.CERT_SUFFIX\\n'"}, {"func_args": {"source": "\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nclass EdgeError(Exception):\\n    def __init__(self, msg, ex=None):\\n        if ex:\\n            msg += ' : {0}'.format(str(ex))\\n        super(EdgeError, self).__init__(msg)\\n        self._ex = ex\\n\\n\\nclass EdgeInvalidArgument(EdgeError):\\n    def __init__(self, msg, ex=None):\\n        super(EdgeInvalidArgument, self).__init__(msg, ex)\\n\\n\\nclass EdgeValueError(EdgeError):\\n    def __init__(self, msg, ex=None):\\n        super(EdgeValueError, self).__init__(msg, ex)\\n\\n\\nclass EdgeFileAccessError(EdgeError):\\n    def __init__(self, msg, file_name, ex=None):\\n        msg += ': {0}'.format(file_name)\\n        super(EdgeFileAccessError, self).__init__(msg, ex)\\n        self.file_name = file_name\\n\\n\\nclass EdgeFileParseError(EdgeError):\\n    def __init__(self, msg, file_name, ex=None):\\n        msg += ': {0}'.format(file_name)\\n        super(EdgeFileParseError, self).__init__(msg, ex)\\n        self.file_name = file_name\\n\\n\\nclass EdgeDeploymentError(EdgeError):\\n    def __init__(self, msg, ex=None):\\n        super(EdgeDeploymentError, self).__init__(msg, ex)\\n\\n\\nclass ResponseError(EdgeError):\\n    def __init__(self, status_code, value):\\n        super(ResponseError, self).__init__('Code:{0}. Detail:{1}'.format(status_code, value))\\n        self.value = value\\n        self.status_code = status_code\\n\\n\\nclass RegistriesLoginError(EdgeError):\\n    def __init__(self, registries, errmsg):\\n        super(RegistriesLoginError, self).__init__(errmsg)\\n        self._registries = registries\\n        self._errmsg = errmsg\\n\\n    def getmsg(self):\\n        return ('Fail to login {0}. Detail: {1}').format(self._registries, self._errmsg)\\n\\n    def registries(self):\\n        return self._registries\\n\\n\\nclass InvalidConfigError(EdgeError):\\n    def __init__(self, msg):\\n        super(InvalidConfigError, self).__init__(msg)\\n\""}, "return_value": "\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nclass EdgeError(Exception):\\n    def __init__(self, msg, ex=None):\\n        if ex:\\n            msg += ' : {0}'.format(str(ex))\\n        super(EdgeError, self).__init__(msg)\\n        self._ex = ex\\n\\n\\nclass EdgeInvalidArgument(EdgeError):\\n    def __init__(self, msg, ex=None):\\n        super(EdgeInvalidArgument, self).__init__(msg, ex)\\n\\n\\nclass EdgeValueError(EdgeError):\\n    def __init__(self, msg, ex=None):\\n        super(EdgeValueError, self).__init__(msg, ex)\\n\\n\\nclass EdgeFileAccessError(EdgeError):\\n    def __init__(self, msg, file_name, ex=None):\\n        msg += ': {0}'.format(file_name)\\n        super(EdgeFileAccessError, self).__init__(msg, ex)\\n        self.file_name = file_name\\n\\n\\nclass EdgeFileParseError(EdgeError):\\n    def __init__(self, msg, file_name, ex=None):\\n        msg += ': {0}'.format(file_name)\\n        super(EdgeFileParseError, self).__init__(msg, ex)\\n        self.file_name = file_name\\n\\n\\nclass EdgeDeploymentError(EdgeError):\\n    def __init__(self, msg, ex=None):\\n        super(EdgeDeploymentError, self).__init__(msg, ex)\\n\\n\\nclass ResponseError(EdgeError):\\n    def __init__(self, status_code, value):\\n        super(ResponseError, self).__init__('Code:{0}. Detail:{1}'.format(status_code, value))\\n        self.value = value\\n        self.status_code = status_code\\n\\n\\nclass RegistriesLoginError(EdgeError):\\n    def __init__(self, registries, errmsg):\\n        super(RegistriesLoginError, self).__init__(errmsg)\\n        self._registries = registries\\n        self._errmsg = errmsg\\n\\n    def getmsg(self):\\n        return ('Fail to login {0}. Detail: {1}').format(self._registries, self._errmsg)\\n\\n    def registries(self):\\n        return self._registries\\n\\n\\nclass InvalidConfigError(EdgeError):\\n    def __init__(self, msg):\\n        super(InvalidConfigError, self).__init__(msg)\\n\""}, {"func_args": {"source": "\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport os\\nimport platform\\nfrom .errors import EdgeInvalidArgument\\n\\n\\nclass HostPlatform(object):\\n    _edge_dir = 'iotedgehubdev'\\n    _edgehub_config = 'edgehub.json'\\n    _setting_ini = 'setting.ini'\\n    _certs = 'certs'\\n    _data = 'data'\\n    _windows_config_path = os.getenv('PROGRAMDATA', '%%PROGRAMDATA%%')\\n\\n    _platforms = {\\n        'linux': {\\n            'supported_deployments': ['docker'],\\n            'default_deployment': 'docker',\\n            'default_edge_conf_dir': '/etc/' + _edge_dir,\\n            'default_edge_data_dir': '/var/lib/' + _edge_dir,\\n            'default_edge_meta_dir_env': 'HOME',\\n            'deployment': {\\n                'docker': {\\n                    'linux': {\\n                        'default_uri': 'unix:///var/run/docker.sock'\\n                    },\\n                }\\n            }\\n        },\\n        'windows': {\\n            'supported_deployments': ['docker'],\\n            'default_deployment': 'docker',\\n            'default_edge_conf_dir': _windows_config_path + '\\\\\\\\' + _edge_dir + '\\\\\\\\config',\\n            'default_edge_data_dir': _windows_config_path + '\\\\\\\\' + _edge_dir + '\\\\\\\\data',\\n            'default_edge_meta_dir_env': 'USERPROFILE',\\n            'deployment': {\\n                'docker': {\\n                    'linux': {\\n                        'default_uri': 'unix:///var/run/docker.sock'\\n                    },\\n                    'windows': {\\n                        'default_uri': 'npipe://./pipe/docker_engine'\\n                    }\\n                }\\n            }\\n        },\\n        'darwin': {\\n            'supported_deployments': ['docker'],\\n            'default_deployment': 'docker',\\n            'default_edge_conf_dir': '/etc/' + _edge_dir,\\n            'default_edge_data_dir': '/var/lib/' + _edge_dir,\\n            'default_edge_meta_dir_env': 'HOME',\\n            'deployment': {\\n                'docker': {\\n                    'linux': {\\n                        'default_uri': 'unix:///var/run/docker.sock'\\n                    },\\n                }\\n            }\\n        }\\n    }\\n\\n    # @staticmethod\\n    # def is_host_supported(host):\\n    #     if host is None:\\n    #         raise EdgeInvalidArgument('host cannot be None')\\n\\n    #     host = host.lower()\\n    #     if host in _platforms:\\n    #         return True\\n    #     return False\\n\\n    @staticmethod\\n    def get_config_path():\\n        host = platform.system()\\n        if host is None:\\n            raise EdgeInvalidArgument('host cannot be None')\\n        host = host.lower()\\n        if host in HostPlatform._platforms:\\n            return HostPlatform._platforms[host]['default_edge_conf_dir']\\n        return None\\n\\n    @staticmethod\\n    def get_config_file_path():\\n        configPath = HostPlatform.get_config_path()\\n        if configPath is not None:\\n            return os.path.join(configPath, HostPlatform._edgehub_config)\\n        return None\\n\\n    @staticmethod\\n    def get_setting_ini_path():\\n        configPath = HostPlatform.get_config_path()\\n        if configPath is not None:\\n            return os.path.join(configPath, HostPlatform._setting_ini)\\n        return None\\n\\n    @staticmethod\\n    def get_default_cert_path():\\n        host = platform.system()\\n        if host is None:\\n            raise EdgeInvalidArgument('host cannot be None')\\n        host = host.lower()\\n        if host in HostPlatform._platforms:\\n            return os.path.join(HostPlatform._platforms[host]['default_edge_data_dir'], HostPlatform._certs)\\n        return None\\n\\n    @staticmethod\\n    def get_share_data_path():\\n        host = platform.system()\\n        if host is None:\\n            raise EdgeInvalidArgument('host cannot be None')\\n        host = host.lower()\\n        if host in HostPlatform._platforms:\\n            return os.path.join(HostPlatform._platforms[host]['default_edge_data_dir'], HostPlatform._data)\\n        return None\\n\""}, "return_value": "\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport os\\nimport platform\\nfrom .errors import EdgeInvalidArgument\\n\\n\\nclass HostPlatform(object):\\n    _edge_dir = 'iotedgehubdev'\\n    _edgehub_config = 'edgehub.json'\\n    _setting_ini = 'setting.ini'\\n    _certs = 'certs'\\n    _data = 'data'\\n    _windows_config_path = os.getenv('PROGRAMDATA', '%%PROGRAMDATA%%')\\n\\n    _platforms = {\\n        'linux': {\\n            'supported_deployments': ['docker'],\\n            'default_deployment': 'docker',\\n            'default_edge_conf_dir': '/etc/' + _edge_dir,\\n            'default_edge_data_dir': '/var/lib/' + _edge_dir,\\n            'default_edge_meta_dir_env': 'HOME',\\n            'deployment': {\\n                'docker': {\\n                    'linux': {\\n                        'default_uri': 'unix:///var/run/docker.sock'\\n                    },\\n                }\\n            }\\n        },\\n        'windows': {\\n            'supported_deployments': ['docker'],\\n            'default_deployment': 'docker',\\n            'default_edge_conf_dir': _windows_config_path + '\\\\\\\\' + _edge_dir + '\\\\\\\\config',\\n            'default_edge_data_dir': _windows_config_path + '\\\\\\\\' + _edge_dir + '\\\\\\\\data',\\n            'default_edge_meta_dir_env': 'USERPROFILE',\\n            'deployment': {\\n                'docker': {\\n                    'linux': {\\n                        'default_uri': 'unix:///var/run/docker.sock'\\n                    },\\n                    'windows': {\\n                        'default_uri': 'npipe://./pipe/docker_engine'\\n                    }\\n                }\\n            }\\n        },\\n        'darwin': {\\n            'supported_deployments': ['docker'],\\n            'default_deployment': 'docker',\\n            'default_edge_conf_dir': '/etc/' + _edge_dir,\\n            'default_edge_data_dir': '/var/lib/' + _edge_dir,\\n            'default_edge_meta_dir_env': 'HOME',\\n            'deployment': {\\n                'docker': {\\n                    'linux': {\\n                        'default_uri': 'unix:///var/run/docker.sock'\\n                    },\\n                }\\n            }\\n        }\\n    }\\n\\n    # @staticmethod\\n    # def is_host_supported(host):\\n    #     if host is None:\\n    #         raise EdgeInvalidArgument('host cannot be None')\\n\\n    #     host = host.lower()\\n    #     if host in _platforms:\\n    #         return True\\n    #     return False\\n\\n    @staticmethod\\n    def get_config_path():\\n        host = platform.system()\\n        if host is None:\\n            raise EdgeInvalidArgument('host cannot be None')\\n        host = host.lower()\\n        if host in HostPlatform._platforms:\\n            return HostPlatform._platforms[host]['default_edge_conf_dir']\\n        return None\\n\\n    @staticmethod\\n    def get_config_file_path():\\n        configPath = HostPlatform.get_config_path()\\n        if configPath is not None:\\n            return os.path.join(configPath, HostPlatform._edgehub_config)\\n        return None\\n\\n    @staticmethod\\n    def get_setting_ini_path():\\n        configPath = HostPlatform.get_config_path()\\n        if configPath is not None:\\n            return os.path.join(configPath, HostPlatform._setting_ini)\\n        return None\\n\\n    @staticmethod\\n    def get_default_cert_path():\\n        host = platform.system()\\n        if host is None:\\n            raise EdgeInvalidArgument('host cannot be None')\\n        host = host.lower()\\n        if host in HostPlatform._platforms:\\n            return os.path.join(HostPlatform._platforms[host]['default_edge_data_dir'], HostPlatform._certs)\\n        return None\\n\\n    @staticmethod\\n    def get_share_data_path():\\n        host = platform.system()\\n        if host is None:\\n            raise EdgeInvalidArgument('host cannot be None')\\n        host = host.lower()\\n        if host in HostPlatform._platforms:\\n            return os.path.join(HostPlatform._platforms[host]['default_edge_data_dir'], HostPlatform._data)\\n        return None\\n\""}, {"func_args": {"source": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport click\\n\\n\\nclass Output:\\n\\n    def info(self, text, suppress=False):\\n        if not suppress:\\n            self.echo(text, color=\\'yellow\\')\\n\\n    def status(self, text):\\n        self.info(text)\\n        self.line()\\n\\n    def prompt(self, text):\\n        self.echo(text, color=\\'white\\')\\n\\n    def warning(self, text):\\n        self.echo(\"WARNING: \" + text, color=\\'yellow\\')\\n\\n    def error(self, text):\\n        self.echo(\"ERROR: \" + text, color=\\'red\\', err=True)\\n\\n    def header(self, text, suppress=False):\\n\\n        if not suppress:\\n            self.line()\\n            s = \"======== {0} ========\".format(text).upper()\\n            m = \"=\" * len(s)\\n            self.echo(m, color=\\'white\\')\\n            self.echo(s, color=\\'white\\')\\n            self.echo(m, color=\\'white\\')\\n            self.line()\\n\\n    def param(self, text, value, status, suppress):\\n        if value and not suppress:\\n            self.header(\"SETTING \" + text)\\n            self.status(status)\\n\\n    def footer(self, text, suppress=False):\\n        if not suppress:\\n            self.info(text.upper())\\n            self.line()\\n\\n    def procout(self, text):\\n        self.echo(text, dim=True)\\n\\n    def line(self):\\n        self.echo(text=\"\")\\n\\n    def echo(self, text, color=\"\", dim=False, err=False):\\n        try:\\n            click.secho(text, fg=color, dim=dim, err=err)\\n        except Exception:\\n            print(text)\\n'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport click\\n\\n\\nclass Output:\\n\\n    def info(self, text, suppress=False):\\n        if not suppress:\\n            self.echo(text, color=\\'yellow\\')\\n\\n    def status(self, text):\\n        self.info(text)\\n        self.line()\\n\\n    def prompt(self, text):\\n        self.echo(text, color=\\'white\\')\\n\\n    def warning(self, text):\\n        self.echo(\"WARNING: \" + text, color=\\'yellow\\')\\n\\n    def error(self, text):\\n        self.echo(\"ERROR: \" + text, color=\\'red\\', err=True)\\n\\n    def header(self, text, suppress=False):\\n\\n        if not suppress:\\n            self.line()\\n            s = \"======== {0} ========\".format(text).upper()\\n            m = \"=\" * len(s)\\n            self.echo(m, color=\\'white\\')\\n            self.echo(s, color=\\'white\\')\\n            self.echo(m, color=\\'white\\')\\n            self.line()\\n\\n    def param(self, text, value, status, suppress):\\n        if value and not suppress:\\n            self.header(\"SETTING \" + text)\\n            self.status(status)\\n\\n    def footer(self, text, suppress=False):\\n        if not suppress:\\n            self.info(text.upper())\\n            self.line()\\n\\n    def procout(self, text):\\n        self.echo(text, dim=True)\\n\\n    def line(self):\\n        self.echo(text=\"\")\\n\\n    def echo(self, text, color=\"\", dim=False, err=False):\\n        try:\\n            click.secho(text, fg=color, dim=dim, err=err)\\n        except Exception:\\n            print(text)\\n'"}, {"func_args": {"source": "\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport datetime\\nimport json\\nimport platform\\nimport uuid\\nimport multiprocessing\\n\\nfrom collections import defaultdict\\nfrom functools import wraps\\n\\n\\nfrom . import configs, decorators\\nfrom . import telemetry_upload as telemetry_core\\nfrom . import __production__ as production_name\\n\\nPRODUCT_NAME = production_name\\n\\n\\nclass TelemetrySession(object):\\n    def __init__(self, correlation_id=None):\\n        self.start_time = None\\n        self.end_time = None\\n        self.correlation_id = correlation_id or str(uuid.uuid4())\\n        self.command = 'command_name'\\n        self.parameters = []\\n        self.result = 'None'\\n        self.result_summary = None\\n        self.exception = None\\n        self.extra_props = {}\\n        self.machineId = self._get_hash_mac_address()\\n        self.events = defaultdict(list)\\n\\n    def generate_payload(self):\\n        props = {\\n            'EventId': str(uuid.uuid4()),\\n            'CorrelationId': self.correlation_id,\\n            'MachineId': self.machineId,\\n            'ProductName': PRODUCT_NAME,\\n            'ProductVersion': _get_core_version(),\\n            'CommandName': self.command,\\n            'OS.Type': platform.system().lower(),\\n            'OS.Version': platform.version().lower(),\\n            'Result': self.result,\\n            'StartTime': str(self.start_time),\\n            'EndTime': str(self.end_time),\\n            'Parameters': ','.join(self.parameters)\\n        }\\n\\n        if self.result_summary:\\n            props['ResultSummary'] = self.result_summary\\n\\n        if self.exception:\\n            props['Exception'] = self.exception\\n\\n        props.update(self.extra_props)\\n\\n        self.events[_get_AI_key()].append({\\n            'name': '{}/command'.format(PRODUCT_NAME),\\n            'properties': props\\n        })\\n\\n        payload = json.dumps(self.events)\\n        return _remove_symbols(payload)\\n\\n    @decorators.suppress_all_exceptions()\\n    @decorators.hash256_result\\n    def _get_hash_mac_address(self):\\n        s = ''\\n        for index, c in enumerate(hex(uuid.getnode())[2:].upper()):\\n            s += c\\n            if index % 2:\\n                s += '-'\\n\\n        s = s.strip('-')\\n        return s\\n\\n\\n_session = TelemetrySession()\\n\\n\\ndef _user_agrees_to_telemetry(func):\\n    @wraps(func)\\n    def _wrapper(*args, **kwargs):\\n        if not configs.get_ini_config().getboolean('DEFAULT', 'collect_telemetry'):\\n            return None\\n        return func(*args, **kwargs)\\n\\n    return _wrapper\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef start(cmdname, params=[]):\\n    _session.command = cmdname\\n    _session.start_time = datetime.datetime.utcnow()\\n    if params is not None:\\n        _session.parameters.extend(params)\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef success():\\n    _session.result = 'Success'\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef fail(exception, summary):\\n    _session.exception = exception\\n    _session.result = 'Fail'\\n    _session.result_summary = summary\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef add_extra_props(props):\\n    if props is not None:\\n        _session.extra_props.update(props)\\n\\n\\n@_user_agrees_to_telemetry\\n@decorators.suppress_all_exceptions()\\ndef flush():\\n    # flush out current information\\n    _session.end_time = datetime.datetime.utcnow()\\n\\n    payload = _session.generate_payload()\\n    if payload:\\n        _upload_telemetry_with_user_agreement(payload)\\n\\n    # reset session fields, retaining correlation id and application\\n    _session.__init__(correlation_id=_session.correlation_id)\\n\\n\\n@decorators.suppress_all_exceptions(fallback_return=None)\\ndef _get_core_version():\\n    from iotedgehubdev import __version__ as core_version\\n    return core_version\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef _get_AI_key():\\n    from iotedgehubdev import __AIkey__ as key\\n    return key\\n\\n\\n# This includes a final user-agreement-check; ALL methods sending telemetry MUST call this.\\n@_user_agrees_to_telemetry\\n@decorators.suppress_all_exceptions()\\ndef _upload_telemetry_with_user_agreement(payload):\\n    p = multiprocessing.Process(target=telemetry_core.upload, args=(payload,))\\n    p.start()\\n\\n\\ndef _remove_symbols(s):\\n    if isinstance(s, str):\\n        for c in '$%^&|':\\n            s = s.replace(c, '_')\\n    return s\\n\""}, "return_value": "\"# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport datetime\\nimport json\\nimport platform\\nimport uuid\\nimport multiprocessing\\n\\nfrom collections import defaultdict\\nfrom functools import wraps\\n\\n\\nfrom . import configs, decorators\\nfrom . import telemetry_upload as telemetry_core\\nfrom . import __production__ as production_name\\n\\nPRODUCT_NAME = production_name\\n\\n\\nclass TelemetrySession(object):\\n    def __init__(self, correlation_id=None):\\n        self.start_time = None\\n        self.end_time = None\\n        self.correlation_id = correlation_id or str(uuid.uuid4())\\n        self.command = 'command_name'\\n        self.parameters = []\\n        self.result = 'None'\\n        self.result_summary = None\\n        self.exception = None\\n        self.extra_props = {}\\n        self.machineId = self._get_hash_mac_address()\\n        self.events = defaultdict(list)\\n\\n    def generate_payload(self):\\n        props = {\\n            'EventId': str(uuid.uuid4()),\\n            'CorrelationId': self.correlation_id,\\n            'MachineId': self.machineId,\\n            'ProductName': PRODUCT_NAME,\\n            'ProductVersion': _get_core_version(),\\n            'CommandName': self.command,\\n            'OS.Type': platform.system().lower(),\\n            'OS.Version': platform.version().lower(),\\n            'Result': self.result,\\n            'StartTime': str(self.start_time),\\n            'EndTime': str(self.end_time),\\n            'Parameters': ','.join(self.parameters)\\n        }\\n\\n        if self.result_summary:\\n            props['ResultSummary'] = self.result_summary\\n\\n        if self.exception:\\n            props['Exception'] = self.exception\\n\\n        props.update(self.extra_props)\\n\\n        self.events[_get_AI_key()].append({\\n            'name': '{}/command'.format(PRODUCT_NAME),\\n            'properties': props\\n        })\\n\\n        payload = json.dumps(self.events)\\n        return _remove_symbols(payload)\\n\\n    @decorators.suppress_all_exceptions()\\n    @decorators.hash256_result\\n    def _get_hash_mac_address(self):\\n        s = ''\\n        for index, c in enumerate(hex(uuid.getnode())[2:].upper()):\\n            s += c\\n            if index % 2:\\n                s += '-'\\n\\n        s = s.strip('-')\\n        return s\\n\\n\\n_session = TelemetrySession()\\n\\n\\ndef _user_agrees_to_telemetry(func):\\n    @wraps(func)\\n    def _wrapper(*args, **kwargs):\\n        if not configs.get_ini_config().getboolean('DEFAULT', 'collect_telemetry'):\\n            return None\\n        return func(*args, **kwargs)\\n\\n    return _wrapper\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef start(cmdname, params=[]):\\n    _session.command = cmdname\\n    _session.start_time = datetime.datetime.utcnow()\\n    if params is not None:\\n        _session.parameters.extend(params)\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef success():\\n    _session.result = 'Success'\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef fail(exception, summary):\\n    _session.exception = exception\\n    _session.result = 'Fail'\\n    _session.result_summary = summary\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef add_extra_props(props):\\n    if props is not None:\\n        _session.extra_props.update(props)\\n\\n\\n@_user_agrees_to_telemetry\\n@decorators.suppress_all_exceptions()\\ndef flush():\\n    # flush out current information\\n    _session.end_time = datetime.datetime.utcnow()\\n\\n    payload = _session.generate_payload()\\n    if payload:\\n        _upload_telemetry_with_user_agreement(payload)\\n\\n    # reset session fields, retaining correlation id and application\\n    _session.__init__(correlation_id=_session.correlation_id)\\n\\n\\n@decorators.suppress_all_exceptions(fallback_return=None)\\ndef _get_core_version():\\n    from iotedgehubdev import __version__ as core_version\\n    return core_version\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef _get_AI_key():\\n    from iotedgehubdev import __AIkey__ as key\\n    return key\\n\\n\\n# This includes a final user-agreement-check; ALL methods sending telemetry MUST call this.\\n@_user_agrees_to_telemetry\\n@decorators.suppress_all_exceptions()\\ndef _upload_telemetry_with_user_agreement(payload):\\n    p = multiprocessing.Process(target=telemetry_core.upload, args=(payload,))\\n    p.start()\\n\\n\\ndef _remove_symbols(s):\\n    if isinstance(s, str):\\n        for c in '$%^&|':\\n            s = s.replace(c, '_')\\n    return s\\n\""}, {"func_args": {"source": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport urllib.request as HTTPClient\\nimport sys\\nimport json\\n\\nfrom applicationinsights import TelemetryClient\\nfrom applicationinsights.exceptions import enable\\nfrom applicationinsights.channel import SynchronousSender, SynchronousQueue, TelemetryChannel\\nfrom iotedgehubdev import decorators\\n\\n\\nclass LimitedRetrySender(SynchronousSender):\\n    def __init__(self):\\n        super(LimitedRetrySender, self).__init__()\\n\\n    def send(self, data_to_send):\\n        \"\"\" Override the default resend mechanism in SenderBase. Stop resend when it fails.\"\"\"\\n        request_payload = json.dumps([a.write() for a in data_to_send])\\n\\n        request = HTTPClient.Request(self._service_endpoint_uri, bytearray(request_payload, \\'utf-8\\'),\\n                                     {\\'Accept\\': \\'application/json\\', \\'Content-Type\\': \\'application/json; charset=utf-8\\'})\\n        try:\\n            HTTPClient.urlopen(request, timeout=10)\\n        except Exception:  # pylint: disable=broad-except\\n            pass\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef upload(data_to_save):\\n    try:\\n        data_to_save = json.loads(data_to_save)\\n    except Exception:\\n        pass\\n\\n    for instrumentation_key in data_to_save:\\n        client = TelemetryClient(instrumentation_key=instrumentation_key,\\n                                 telemetry_channel=TelemetryChannel(queue=SynchronousQueue(LimitedRetrySender())))\\n        enable(instrumentation_key)\\n        for record in data_to_save[instrumentation_key]:\\n            name = record[\\'name\\']\\n            raw_properties = record[\\'properties\\']\\n            properties = {}\\n            measurements = {}\\n            for k, v in raw_properties.items():\\n                if isinstance(v, str):\\n                    properties[k] = v\\n                else:\\n                    measurements[k] = v\\n            client.track_event(name, properties, measurements)\\n        client.flush()\\n\\n\\nif __name__ == \\'__main__\\':\\n    # If user doesn\\'t agree to upload telemetry, this scripts won\\'t be executed. The caller should control.\\n    upload(sys.argv[1])\\n'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport urllib.request as HTTPClient\\nimport sys\\nimport json\\n\\nfrom applicationinsights import TelemetryClient\\nfrom applicationinsights.exceptions import enable\\nfrom applicationinsights.channel import SynchronousSender, SynchronousQueue, TelemetryChannel\\nfrom iotedgehubdev import decorators\\n\\n\\nclass LimitedRetrySender(SynchronousSender):\\n    def __init__(self):\\n        super(LimitedRetrySender, self).__init__()\\n\\n    def send(self, data_to_send):\\n        \"\"\" Override the default resend mechanism in SenderBase. Stop resend when it fails.\"\"\"\\n        request_payload = json.dumps([a.write() for a in data_to_send])\\n\\n        request = HTTPClient.Request(self._service_endpoint_uri, bytearray(request_payload, \\'utf-8\\'),\\n                                     {\\'Accept\\': \\'application/json\\', \\'Content-Type\\': \\'application/json; charset=utf-8\\'})\\n        try:\\n            HTTPClient.urlopen(request, timeout=10)\\n        except Exception:  # pylint: disable=broad-except\\n            pass\\n\\n\\n@decorators.suppress_all_exceptions()\\ndef upload(data_to_save):\\n    try:\\n        data_to_save = json.loads(data_to_save)\\n    except Exception:\\n        pass\\n\\n    for instrumentation_key in data_to_save:\\n        client = TelemetryClient(instrumentation_key=instrumentation_key,\\n                                 telemetry_channel=TelemetryChannel(queue=SynchronousQueue(LimitedRetrySender())))\\n        enable(instrumentation_key)\\n        for record in data_to_save[instrumentation_key]:\\n            name = record[\\'name\\']\\n            raw_properties = record[\\'properties\\']\\n            properties = {}\\n            measurements = {}\\n            for k, v in raw_properties.items():\\n                if isinstance(v, str):\\n                    properties[k] = v\\n                else:\\n                    measurements[k] = v\\n            client.track_event(name, properties, measurements)\\n        client.flush()\\n\\n\\nif __name__ == \\'__main__\\':\\n    # If user doesn\\'t agree to upload telemetry, this scripts won\\'t be executed. The caller should control.\\n    upload(sys.argv[1])\\n'"}, {"func_args": {"source": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport errno\\nimport os\\nimport shutil\\nimport socket\\nimport stat\\nimport subprocess\\n\\n\\nfrom base64 import b64decode, b64encode\\nfrom hashlib import sha256\\nfrom hmac import HMAC\\nfrom time import time\\nfrom urllib.parse import urlencode, quote_plus\\nfrom .constants import EdgeConstants as EC\\nfrom .decorators import suppress_all_exceptions\\nfrom .errors import EdgeFileAccessError\\n\\n\\nclass Utils(object):\\n    @staticmethod\\n    def parse_connection_strs(device_conn_str, hub_conn_str=None):\\n        data = Utils._parse_device_connection_str(device_conn_str)\\n        data[EC.DEVICE_ACCESS_KEY_KEY] = data.pop(EC.ACCESS_KEY_KEY)\\n        if hub_conn_str is not None:\\n            hub_data = Utils._parse_hub_connection_str(hub_conn_str, data[EC.HOSTNAME_KEY])\\n            data[EC.HUB_ACCESS_KEY_KEY] = hub_data[EC.ACCESS_KEY_KEY]\\n            data[EC.ACCESS_KEY_NAME] = hub_data[EC.ACCESS_KEY_NAME]\\n        return data\\n\\n    @staticmethod\\n    def _parse_device_connection_str(connection_string):\\n        data = Utils._split_connection_string(connection_string)\\n        if len(data) > 0:\\n            if EC.HOSTNAME_KEY not in data or EC.DEVICE_ID_KEY not in data or EC.ACCESS_KEY_KEY not in data:\\n                if EC.ACCESS_KEY_NAME in data:\\n                    raise KeyError(\\'Please make sure you are using a device connection string \\'\\n                                   \\'instead of an IoT Hub connection string\\')\\n                else:\\n                    raise KeyError(\\'Error parsing connection string. \\'\\n                                   \\'Please make sure you wrap the connection string with double quotes when supplying it via CLI\\')\\n            return data\\n        else:\\n            raise KeyError(\\'Error parsing connection string\\')\\n\\n    @staticmethod\\n    def _parse_hub_connection_str(hub_connection_string, host_name):\\n        hub_data = Utils._split_connection_string(hub_connection_string)\\n        if len(hub_data) > 0:\\n            if EC.HOSTNAME_KEY not in hub_data or EC.ACCESS_KEY_NAME not in hub_data or EC.ACCESS_KEY_KEY not in hub_data:\\n                if EC.DEVICE_ID_KEY in hub_data:\\n                    raise KeyError(\\'Please make sure you are using a IoT Hub connection string \\'\\n                                   \\'instead of an device connection string\\')\\n                else:\\n                    raise KeyError(\\'Error parsing connection string. \\'\\n                                   \\'Please make sure you wrap the connection string with double quotes when supplying it via CLI\\')\\n            elif hub_data[EC.HOSTNAME_KEY] != host_name:\\n                raise KeyError(\\'Please make sure the device belongs to the IoT Hub\\')\\n            return hub_data\\n        else:\\n            raise KeyError(\\'Error parsing IoT Hub connection string\\')\\n\\n    @staticmethod\\n    def _split_connection_string(connection_string):\\n        data = dict()\\n        if connection_string is not None:\\n            parts = connection_string.split(\\';\\')\\n            for part in parts:\\n                if \"=\" in part:\\n                    subparts = [s.strip() for s in part.split(\"=\", 1)]\\n                    data[subparts[0]] = subparts[1]\\n        return data\\n\\n    @staticmethod\\n    def get_hostname():\\n        try:\\n            return socket.getfqdn()\\n        except IOError as ex:\\n            raise ex\\n\\n    @staticmethod\\n    def check_if_file_exists(file_path):\\n        if file_path is None \\\\\\n           or os.path.exists(file_path) is False \\\\\\n           or os.path.isfile(file_path) is False:\\n            return False\\n        return True\\n\\n    @staticmethod\\n    def check_if_directory_exists(dir_path):\\n        if dir_path is None \\\\\\n           or os.path.exists(dir_path) is False \\\\\\n           or os.path.isdir(dir_path) is False:\\n            return False\\n        return True\\n\\n    @staticmethod\\n    def delete_dir(dir_path):\\n        try:\\n            if os.path.exists(dir_path):\\n                shutil.rmtree(dir_path, onerror=Utils._remove_readonly_callback)\\n        except OSError as ex:\\n            raise ex\\n\\n    @staticmethod\\n    def mkdir_if_needed(dir_path):\\n        try:\\n            os.makedirs(dir_path)\\n        except OSError as ex:\\n            if ex.errno != errno.EEXIST:\\n                raise ex\\n\\n    @staticmethod\\n    def delete_file(file_path, file_type_diagnostic):\\n        try:\\n            if os.path.exists(file_path):\\n                os.unlink(file_path)\\n        except OSError as ex:\\n            msg = \\'Error deleteing {0}: {1}. \\' \\\\\\n                  \\'Errno: {2}, Error: {3}\\'.format(file_type_diagnostic,\\n                                                  file_path, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, file_path)\\n\\n    @staticmethod\\n    def create_file(file_path, data, file_type_diagnostic, mode=0o644):\\n        try:\\n            fd = os.open(file_path, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, mode)\\n            with os.fdopen(fd, \\'w\\') as output_file:\\n                output_file.write(data)\\n        except OSError as ex:\\n            msg = \\'Error creating {0}: {1}. \\' \\\\\\n                  \\'Errno: {2}, Error: {3}\\'.format(file_type_diagnostic,\\n                                                  file_path, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, file_path)\\n\\n    @staticmethod\\n    def get_iot_hub_sas_token(uri, key, policy_name, expiry=3600):\\n        ttl = time() + expiry\\n        sign_key = \"%s\\\\n%d\" % ((quote_plus(uri)), int(ttl))\\n        signature = b64encode(\\n            HMAC(b64decode(key), sign_key.encode(\"utf-8\"), sha256).digest())\\n\\n        rawtoken = {\\n            \"sr\": uri,\\n            \"sig\": signature,\\n            \"se\": str(int(ttl))\\n        }\\n\\n        if policy_name is not None:\\n            rawtoken[\"skn\"] = policy_name\\n\\n        return \"SharedAccessSignature \" + urlencode(rawtoken)\\n\\n    @staticmethod\\n    def copy_files(src_path, dst_path):\\n        try:\\n            shutil.copy2(src_path, dst_path)\\n        except OSError as ex:\\n            raise ex\\n\\n    @staticmethod\\n    def _remove_readonly_callback(func, path, excinfo):\\n        del func, excinfo\\n        os.chmod(path, stat.S_IWRITE)\\n        os.unlink(path)\\n\\n    @staticmethod\\n    def exe_proc(params, shell=False, cwd=None, suppress_out=False):\\n        try:\\n            subprocess.check_call(params, shell=shell, cwd=cwd)\\n        except KeyboardInterrupt:\\n            raise\\n        except Exception as e:\\n            raise Exception(\"Error while executing command: {0}. {1}\".format(\\' \\'.join(params), str(e)))\\n\\n    @staticmethod\\n    @suppress_all_exceptions()\\n    def hash_connection_str_hostname(hostname):\\n        \"\"\"Hash connection string hostname to count distint IoT Hub number\"\"\"\\n        if not hostname:\\n            return (\"\", \"\")\\n\\n        # get hostname suffix (e.g., azure-devices.net) to distinguish national clouds\\n        if \".\" in hostname:\\n            hostname_suffix = hostname[hostname.index(\".\") + 1:]\\n        else:\\n            hostname_suffix = \"\"\\n\\n        return (Utils.get_sha256_hash(hostname), hostname_suffix)\\n\\n    @staticmethod\\n    def get_sha256_hash(val):\\n        hash_object = sha256(val.encode(\\'utf-8\\'))\\n\\n        return str(hash_object.hexdigest()).lower()\\n\\n    @staticmethod\\n    def get_device_ca_file_paths(root_dir, cert_id):\\n        result = {}\\n        result[EC.CERT_SUFFIX] = os.path.join(root_dir, cert_id + EC.CERT_SUFFIX)\\n        result[EC.KEY_SUFFIX] = os.path.join(root_dir, cert_id + EC.KEY_SUFFIX)\\n        result[EC.CHAIN_CERT_SUFFIX] = os.path.join(root_dir, cert_id + EC.CHAIN_CERT_SUFFIX)\\n        return result\\n'"}, "return_value": "'# Copyright (c) Microsoft Corporation. All rights reserved.\\n# Licensed under the MIT License.\\n\\n\\nimport errno\\nimport os\\nimport shutil\\nimport socket\\nimport stat\\nimport subprocess\\n\\n\\nfrom base64 import b64decode, b64encode\\nfrom hashlib import sha256\\nfrom hmac import HMAC\\nfrom time import time\\nfrom urllib.parse import urlencode, quote_plus\\nfrom .constants import EdgeConstants as EC\\nfrom .decorators import suppress_all_exceptions\\nfrom .errors import EdgeFileAccessError\\n\\n\\nclass Utils(object):\\n    @staticmethod\\n    def parse_connection_strs(device_conn_str, hub_conn_str=None):\\n        data = Utils._parse_device_connection_str(device_conn_str)\\n        data[EC.DEVICE_ACCESS_KEY_KEY] = data.pop(EC.ACCESS_KEY_KEY)\\n        if hub_conn_str is not None:\\n            hub_data = Utils._parse_hub_connection_str(hub_conn_str, data[EC.HOSTNAME_KEY])\\n            data[EC.HUB_ACCESS_KEY_KEY] = hub_data[EC.ACCESS_KEY_KEY]\\n            data[EC.ACCESS_KEY_NAME] = hub_data[EC.ACCESS_KEY_NAME]\\n        return data\\n\\n    @staticmethod\\n    def _parse_device_connection_str(connection_string):\\n        data = Utils._split_connection_string(connection_string)\\n        if len(data) > 0:\\n            if EC.HOSTNAME_KEY not in data or EC.DEVICE_ID_KEY not in data or EC.ACCESS_KEY_KEY not in data:\\n                if EC.ACCESS_KEY_NAME in data:\\n                    raise KeyError(\\'Please make sure you are using a device connection string \\'\\n                                   \\'instead of an IoT Hub connection string\\')\\n                else:\\n                    raise KeyError(\\'Error parsing connection string. \\'\\n                                   \\'Please make sure you wrap the connection string with double quotes when supplying it via CLI\\')\\n            return data\\n        else:\\n            raise KeyError(\\'Error parsing connection string\\')\\n\\n    @staticmethod\\n    def _parse_hub_connection_str(hub_connection_string, host_name):\\n        hub_data = Utils._split_connection_string(hub_connection_string)\\n        if len(hub_data) > 0:\\n            if EC.HOSTNAME_KEY not in hub_data or EC.ACCESS_KEY_NAME not in hub_data or EC.ACCESS_KEY_KEY not in hub_data:\\n                if EC.DEVICE_ID_KEY in hub_data:\\n                    raise KeyError(\\'Please make sure you are using a IoT Hub connection string \\'\\n                                   \\'instead of an device connection string\\')\\n                else:\\n                    raise KeyError(\\'Error parsing connection string. \\'\\n                                   \\'Please make sure you wrap the connection string with double quotes when supplying it via CLI\\')\\n            elif hub_data[EC.HOSTNAME_KEY] != host_name:\\n                raise KeyError(\\'Please make sure the device belongs to the IoT Hub\\')\\n            return hub_data\\n        else:\\n            raise KeyError(\\'Error parsing IoT Hub connection string\\')\\n\\n    @staticmethod\\n    def _split_connection_string(connection_string):\\n        data = dict()\\n        if connection_string is not None:\\n            parts = connection_string.split(\\';\\')\\n            for part in parts:\\n                if \"=\" in part:\\n                    subparts = [s.strip() for s in part.split(\"=\", 1)]\\n                    data[subparts[0]] = subparts[1]\\n        return data\\n\\n    @staticmethod\\n    def get_hostname():\\n        try:\\n            return socket.getfqdn()\\n        except IOError as ex:\\n            raise ex\\n\\n    @staticmethod\\n    def check_if_file_exists(file_path):\\n        if file_path is None \\\\\\n           or os.path.exists(file_path) is False \\\\\\n           or os.path.isfile(file_path) is False:\\n            return False\\n        return True\\n\\n    @staticmethod\\n    def check_if_directory_exists(dir_path):\\n        if dir_path is None \\\\\\n           or os.path.exists(dir_path) is False \\\\\\n           or os.path.isdir(dir_path) is False:\\n            return False\\n        return True\\n\\n    @staticmethod\\n    def delete_dir(dir_path):\\n        try:\\n            if os.path.exists(dir_path):\\n                shutil.rmtree(dir_path, onerror=Utils._remove_readonly_callback)\\n        except OSError as ex:\\n            raise ex\\n\\n    @staticmethod\\n    def mkdir_if_needed(dir_path):\\n        try:\\n            os.makedirs(dir_path)\\n        except OSError as ex:\\n            if ex.errno != errno.EEXIST:\\n                raise ex\\n\\n    @staticmethod\\n    def delete_file(file_path, file_type_diagnostic):\\n        try:\\n            if os.path.exists(file_path):\\n                os.unlink(file_path)\\n        except OSError as ex:\\n            msg = \\'Error deleteing {0}: {1}. \\' \\\\\\n                  \\'Errno: {2}, Error: {3}\\'.format(file_type_diagnostic,\\n                                                  file_path, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, file_path)\\n\\n    @staticmethod\\n    def create_file(file_path, data, file_type_diagnostic, mode=0o644):\\n        try:\\n            fd = os.open(file_path, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, mode)\\n            with os.fdopen(fd, \\'w\\') as output_file:\\n                output_file.write(data)\\n        except OSError as ex:\\n            msg = \\'Error creating {0}: {1}. \\' \\\\\\n                  \\'Errno: {2}, Error: {3}\\'.format(file_type_diagnostic,\\n                                                  file_path, str(ex.errno), ex.strerror)\\n            raise EdgeFileAccessError(msg, file_path)\\n\\n    @staticmethod\\n    def get_iot_hub_sas_token(uri, key, policy_name, expiry=3600):\\n        ttl = time() + expiry\\n        sign_key = \"%s\\\\n%d\" % ((quote_plus(uri)), int(ttl))\\n        signature = b64encode(\\n            HMAC(b64decode(key), sign_key.encode(\"utf-8\"), sha256).digest())\\n\\n        rawtoken = {\\n            \"sr\": uri,\\n            \"sig\": signature,\\n            \"se\": str(int(ttl))\\n        }\\n\\n        if policy_name is not None:\\n            rawtoken[\"skn\"] = policy_name\\n\\n        return \"SharedAccessSignature \" + urlencode(rawtoken)\\n\\n    @staticmethod\\n    def copy_files(src_path, dst_path):\\n        try:\\n            shutil.copy2(src_path, dst_path)\\n        except OSError as ex:\\n            raise ex\\n\\n    @staticmethod\\n    def _remove_readonly_callback(func, path, excinfo):\\n        del func, excinfo\\n        os.chmod(path, stat.S_IWRITE)\\n        os.unlink(path)\\n\\n    @staticmethod\\n    def exe_proc(params, shell=False, cwd=None, suppress_out=False):\\n        try:\\n            subprocess.check_call(params, shell=shell, cwd=cwd)\\n        except KeyboardInterrupt:\\n            raise\\n        except Exception as e:\\n            raise Exception(\"Error while executing command: {0}. {1}\".format(\\' \\'.join(params), str(e)))\\n\\n    @staticmethod\\n    @suppress_all_exceptions()\\n    def hash_connection_str_hostname(hostname):\\n        \"\"\"Hash connection string hostname to count distint IoT Hub number\"\"\"\\n        if not hostname:\\n            return (\"\", \"\")\\n\\n        # get hostname suffix (e.g., azure-devices.net) to distinguish national clouds\\n        if \".\" in hostname:\\n            hostname_suffix = hostname[hostname.index(\".\") + 1:]\\n        else:\\n            hostname_suffix = \"\"\\n\\n        return (Utils.get_sha256_hash(hostname), hostname_suffix)\\n\\n    @staticmethod\\n    def get_sha256_hash(val):\\n        hash_object = sha256(val.encode(\\'utf-8\\'))\\n\\n        return str(hash_object.hexdigest()).lower()\\n\\n    @staticmethod\\n    def get_device_ca_file_paths(root_dir, cert_id):\\n        result = {}\\n        result[EC.CERT_SUFFIX] = os.path.join(root_dir, cert_id + EC.CERT_SUFFIX)\\n        result[EC.KEY_SUFFIX] = os.path.join(root_dir, cert_id + EC.KEY_SUFFIX)\\n        result[EC.CHAIN_CERT_SUFFIX] = os.path.join(root_dir, cert_id + EC.CHAIN_CERT_SUFFIX)\\n        return result\\n'"}]}, "_ellipsize": {"line": 29, "args": [{"func_args": {"s": "'<_pytest.config.Config object at 0xffffaca96310>'", "maxsize": "240"}, "return_value": "'<_pytest.config.Config object at 0xffffaca96310>'"}, {"func_args": {"s": "'<_pytest.config.Config object at 0xffffaca96310>'", "maxsize": "240"}, "return_value": "'<_pytest.config.Config object at 0xffffaca96310>'"}, {"func_args": {"s": "'<function _main at 0xffffacdbc310>'", "maxsize": "240"}, "return_value": "'<function _main at 0xffffacdbc310>'"}, {"func_args": {"s": "'<function _main at 0xffffacdbc310>'", "maxsize": "240"}, "return_value": "'<function _main at 0xffffacdbc310>'"}, {"func_args": {"s": "'<_pytest.config.Config object at 0xffffaca96310>'", "maxsize": "240"}, "return_value": "'<_pytest.config.Config object at 0xffffaca96310>'"}, {"func_args": {"s": "'<_pytest.config.Config object at 0xffffaca96310>'", "maxsize": "240"}, "return_value": "'<_pytest.config.Config object at 0xffffaca96310>'"}, {"func_args": {"s": "'<Session iotedgehubdev exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=165>'", "maxsize": "240"}, "return_value": "'<Session iotedgehubdev exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=165>'"}, {"func_args": {"s": "'<Session iotedgehubdev exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=165>'", "maxsize": "240"}, "return_value": "'<Session iotedgehubdev exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=165>'"}, {"func_args": {"s": "\"<_HookCaller 'pytest_runtestloop'>\"", "maxsize": "240"}, "return_value": "\"<_HookCaller 'pytest_runtestloop'>\""}, {"func_args": {"s": "\"<_HookCaller 'pytest_runtestloop'>\"", "maxsize": "240"}, "return_value": "\"<_HookCaller 'pytest_runtestloop'>\""}, {"func_args": {"s": "'()'", "maxsize": "240"}, "return_value": "'()'"}, {"func_args": {"s": "'<Session iotedgehubdev exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=165>'", "maxsize": "240"}, "return_value": "'<Session iotedgehubdev exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=165>'"}, {"func_args": {"s": "\"{'session': <Session iotedgehubdev exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=165>}\"", "maxsize": "240"}, "return_value": "\"{'session': <Session iotedgehubdev exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=165>}\""}, {"func_args": {"s": "\"'session'\"", "maxsize": "240"}, "return_value": "\"'session'\""}, {"func_args": {"s": "'True'", "maxsize": "240"}, "return_value": "'True'"}, {"func_args": {"s": "'True'", "maxsize": "240"}, "return_value": "'True'"}, {"func_args": {"s": "'<_pytest.config.PytestPluginManager object at 0xffffb25f9d60>'", "maxsize": "240"}, "return_value": "'<_pytest.config.PytestPluginManager object at 0xffffb25f9d60>'"}, {"func_args": {"s": "'<_pytest.config.PytestPluginManager object at 0xffffb25f9d60>'", "maxsize": "240"}, "return_value": "'<_pytest.config.PytestPluginManager object at 0xffffb25f9d60>'"}, {"func_args": {"s": "\"'pytest_runtestloop'\"", "maxsize": "240"}, "return_value": "\"'pytest_runtestloop'\""}, {"func_args": {"s": "\"<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/usr/app/src/test_repos/iotedgehubdev/.tox/py38/lib/python3.8/site-packages/_pytest/main.py'>>\"", "maxsize": "240"}, "return_value": "\"<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/usr/app/src/test_repos/iotedgehubdev/.tox/py38/lib/python3.8/site-packages/_pytest/main.py'>>\""}, {"func_args": {"s": "\"<HookImpl plugin_name='_cov', plugin=<pytest_cov.plugin.CovPlugin object at 0xffffac1dcd60>>\"", "maxsize": "240"}, "return_value": "\"<HookImpl plugin_name='_cov', plugin=<pytest_cov.plugin.CovPlugin object at 0xffffac1dcd60>>\""}, {"func_args": {"s": "\"<HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0xffffaabfe460>>\"", "maxsize": "240"}, "return_value": "\"<HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0xffffaabfe460>>\""}, {"func_args": {"s": "\"[<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/usr/app/src/test_repos/iotedgehubdev/.tox/py38/lib/python3.8/site-packages/_pytest/main.py'>>, <HookImpl plugin_name='_cov', plugin=<pytest_cov.plugin.CovPlugin object at 0xffffac1dcd60>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0xffffaabfe460>>]\"", "maxsize": "240"}, "return_value": "\"[<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/usr/app/src/test_repos/iotedgehubdev/.tox/py38/lib...ffac1dcd60>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0xffffaabfe460>>]\""}, {"func_args": {"s": "'<Session iotedgehubdev exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=165>'", "maxsize": "240"}, "return_value": "'<Session iotedgehubdev exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=165>'"}, {"func_args": {"s": "\"{'session': <Session iotedgehubdev exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=165>}\"", "maxsize": "240"}, "return_value": "\"{'session': <Session iotedgehubdev exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=165>}\""}, {"func_args": {"s": "'True'", "maxsize": "240"}, "return_value": "'True'"}, {"func_args": {"s": "'True'", "maxsize": "240"}, "return_value": "'True'"}, {"func_args": {"s": "'<Session iotedgehubdev exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=165>'", "maxsize": "240"}, "return_value": "'<Session iotedgehubdev exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=165>'"}, {"func_args": {"s": "'<Session iotedgehubdev exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=165>'", "maxsize": "240"}, "return_value": "'<Session iotedgehubdev exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=165>'"}], "text": "def _ellipsize(s: str, maxsize: int) -> str:\n    if len(s) > maxsize:\n        i = max(0, (maxsize - 3) // 2)\n        j = max(0, maxsize - 3 - i)\n        return s[:i] + \"...\" + s[len(s) - j :]\n    return s"}, "wcwidth": {"line": 4, "args": [{"func_args": {"c": "'E'"}, "return_value": "1"}, {"func_args": {"c": "'R'"}, "return_value": "1"}, {"func_args": {"c": "'O'"}, "return_value": "1"}, {"func_args": {"c": "' '"}, "return_value": "1"}, {"func_args": {"c": "'t'"}, "return_value": "1"}, {"func_args": {"c": "'e'"}, "return_value": "1"}, {"func_args": {"c": "'s'"}, "return_value": "1"}, {"func_args": {"c": "'/'"}, "return_value": "1"}, {"func_args": {"c": "'_'"}, "return_value": "1"}, {"func_args": {"c": "'c'"}, "return_value": "1"}, {"func_args": {"c": "'l'"}, "return_value": "1"}, {"func_args": {"c": "'i'"}, "return_value": "1"}, {"func_args": {"c": "'.'"}, "return_value": "1"}, {"func_args": {"c": "'p'"}, "return_value": "1"}, {"func_args": {"c": "'y'"}, "return_value": "1"}, {"func_args": {"c": "'-'"}, "return_value": "1"}, {"func_args": {"c": "'o'"}, "return_value": "1"}, {"func_args": {"c": "'d'"}, "return_value": "1"}, {"func_args": {"c": "'g'"}, "return_value": "1"}, {"func_args": {"c": "'h'"}, "return_value": "1"}, {"func_args": {"c": "'u'"}, "return_value": "1"}, {"func_args": {"c": "'b'"}, "return_value": "1"}, {"func_args": {"c": "'v'"}, "return_value": "1"}, {"func_args": {"c": "'r'"}, "return_value": "1"}, {"func_args": {"c": "'D'"}, "return_value": "1"}, {"func_args": {"c": "'m'"}, "return_value": "1"}, {"func_args": {"c": "'n'"}, "return_value": "1"}, {"func_args": {"c": "':'"}, "return_value": "1"}, {"func_args": {"c": "'C'"}, "return_value": "1"}, {"func_args": {"c": "'k'"}, "return_value": "1"}, {"func_args": {"c": "'a'"}, "return_value": "1"}, {"func_args": {"c": "'P'"}, "return_value": "1"}, {"func_args": {"c": "'w'"}, "return_value": "1"}, {"func_args": {"c": "'f'"}, "return_value": "1"}, {"func_args": {"c": "'A'"}, "return_value": "1"}, {"func_args": {"c": "'I'"}, "return_value": "1"}, {"func_args": {"c": "'('"}, "return_value": "1"}, {"func_args": {"c": "\"'\""}, "return_value": "1"}, {"func_args": {"c": "','"}, "return_value": "1"}, {"func_args": {"c": "'F'"}, "return_value": "1"}, {"func_args": {"c": "'N'"}, "return_value": "1"}, {"func_args": {"c": "'2'"}, "return_value": "1"}, {"func_args": {"c": "')'"}, "return_value": "1"}]}, "wcswidth": {"line": 43, "args": [{"func_args": {"s": "'ERROR tests/test_cli.py'"}, "return_value": "23"}, {"func_args": {"s": "' - '"}, "return_value": "3"}, {"func_args": {"s": "\"iotedgehubdev.errors.EdgeDeploymentError: Could not connect to Docker daemon. Please make sure Docker is running : Error while fetching server API version: ('Connection aborted.', FileNotFoundError(2, 'No such file or directory'))\""}, "return_value": "230"}, {"func_args": {"s": "'iotedgehubdev.errors.EdgeDeploymentError: Could not co'"}, "return_value": "54"}, {"func_args": {"s": "'iotedgehubdev.errors.EdgeDeploymentError: Could not c'"}, "return_value": "53"}, {"func_args": {"s": "'iotedgehubdev.errors.EdgeDeploymentError: Could not '"}, "return_value": "52"}, {"func_args": {"s": "'iotedgehubdev.errors.EdgeDeploymentError: Could not'"}, "return_value": "51"}], "text": "def wcswidth(s: str) -> int:\n    \"\"\"Determine how many columns are needed to display a string in a terminal.\n\n    Returns -1 if the string contains non-printable characters.\n    \"\"\"\n    width = 0\n    for c in unicodedata.normalize(\"NFC\", s):\n        wc = wcwidth(c)\n        if wc < 0:\n            return -1\n        width += wc\n    return width"}}