{"short_stack": {"line": 136, "args": [{"func_args": {"limit": "None", "skip": "0"}, "return_value": "'                      <module> : /usr/app/src/test_repos/django-extra-views/.tox/py38/bin/viztracer:8\\n                          main : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/viztracer/main.py:523\\n                           run : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/viztracer/main.py:332\\n                   run_command : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/viztracer/main.py:438\\n                      run_code : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/viztracer/main.py:355\\n                      <module> : /usr/app/src/test_repos/django-extra-views/.tox/py38/bin/pytest:8\\n                  console_main : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:185\\n                          main : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:143\\n                _prepareconfig : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:318\\n                      __call__ : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/pluggy/_hooks.py:265\\n                     _hookexec : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/pluggy/_manager.py:80\\n                    _multicall : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/pluggy/_callers.py:39\\n          pytest_cmdline_parse : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:1003\\n                         parse : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:1283\\n                     _preparse : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:1191\\n                      __call__ : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/pluggy/_hooks.py:265\\n                     _hookexec : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/pluggy/_manager.py:80\\n                    _multicall : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/pluggy/_callers.py:39\\n pytest_load_initial_conftests : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/pytest_cov/plugin.py:149\\n                      __init__ : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/pytest_cov/plugin.py:200\\n                         start : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/pytest_cov/plugin.py:222\\n         ensure_topdir_wrapper : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/pytest_cov/engine.py:44\\n                         start : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/pytest_cov/engine.py:222\\n                         start : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/coverage/control.py:558\\n               _init_for_start : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/coverage/control.py:473\\n                      __init__ : /usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/coverage/collector.py:114'"}], "text": "def short_stack(limit=None, skip=0):\n    \"\"\"Return a string summarizing the call stack.\n\n    The string is multi-line, with one line per stack frame. Each line shows\n    the function name, the file name, and the line number:\n\n        ...\n        start_import_stop : /Users/ned/coverage/trunk/tests/coveragetest.py @95\n        import_local_file : /Users/ned/coverage/trunk/tests/coveragetest.py @81\n        import_local_file : /Users/ned/coverage/trunk/coverage/backward.py @159\n        ...\n\n    `limit` is the number of frames to include, defaulting to all of them.\n\n    `skip` is the number of frames to skip, so that debugging functions can\n    call this and not be included in the result.\n\n    \"\"\"\n    stack = inspect.stack()[limit:skip:-1]\n    return \"\\n\".join(\"%30s : %s:%d\" % (t[3], t[1], t[2]) for t in stack)"}, "tryint": {"line": 370, "args": [{"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/.tox/py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/.tox/py'"}, {"func_args": {"s": "'38'"}, "return_value": "38"}, {"func_args": {"s": "'/lib/python'"}, "return_value": "'/lib/python'"}, {"func_args": {"s": "'3'"}, "return_value": "3"}, {"func_args": {"s": "'.'"}, "return_value": "'.'"}, {"func_args": {"s": "'8'"}, "return_value": "8"}, {"func_args": {"s": "'/site-packages/coverage'"}, "return_value": "'/site-packages/coverage'"}, {"func_args": {"s": "'/root/.local/lib/python'"}, "return_value": "'/root/.local/lib/python'"}, {"func_args": {"s": "'3'"}, "return_value": "3"}, {"func_args": {"s": "'.'"}, "return_value": "'.'"}, {"func_args": {"s": "'8'"}, "return_value": "8"}, {"func_args": {"s": "'/site-packages'"}, "return_value": "'/site-packages'"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/.tox/py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/.tox/py'"}, {"func_args": {"s": "'38'"}, "return_value": "38"}, {"func_args": {"s": "'/lib/python'"}, "return_value": "'/lib/python'"}, {"func_args": {"s": "'3'"}, "return_value": "3"}, {"func_args": {"s": "'.'"}, "return_value": "'.'"}, {"func_args": {"s": "'8'"}, "return_value": "8"}, {"func_args": {"s": "'/site-packages'"}, "return_value": "'/site-packages'"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/.tox/py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/.tox/py'"}, {"func_args": {"s": "'38'"}, "return_value": "38"}, {"func_args": {"s": "'/bin'"}, "return_value": "'/bin'"}, {"func_args": {"s": "'/root/.local/bin'"}, "return_value": "'/root/.local/bin'"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/.tox/py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/.tox/py'"}, {"func_args": {"s": "'38'"}, "return_value": "38"}, {"func_args": {"s": "'/lib/python'"}, "return_value": "'/lib/python'"}, {"func_args": {"s": "'extra_views/__init__.py               '"}, "return_value": "'extra_views/__init__.py               '"}, {"func_args": {"s": "'6'"}, "return_value": "6"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'6'"}, "return_value": "6"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'extra_views/advanced.py             '"}, "return_value": "'extra_views/advanced.py             '"}, {"func_args": {"s": "'108'"}, "return_value": "108"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'108'"}, "return_value": "108"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'extra_views/contrib/__init__.py       '"}, "return_value": "'extra_views/contrib/__init__.py       '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'extra_views/contrib/mixins.py       '"}, "return_value": "'extra_views/contrib/mixins.py       '"}, {"func_args": {"s": "'123'"}, "return_value": "123"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'123'"}, "return_value": "123"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'extra_views/dates.py                '"}, "return_value": "'extra_views/dates.py                '"}, {"func_args": {"s": "'116'"}, "return_value": "116"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'116'"}, "return_value": "116"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'extra_views/formsets.py             '"}, "return_value": "'extra_views/formsets.py             '"}, {"func_args": {"s": "'120'"}, "return_value": "120"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'120'"}, "return_value": "120"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'extra_views/generic.py               '"}, "return_value": "'extra_views/generic.py               '"}, {"func_args": {"s": "'17'"}, "return_value": "17"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'17'"}, "return_value": "17"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'extra_views/models.py                 '"}, "return_value": "'extra_views/models.py                 '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%'"}, "return_value": "'%'"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"s": "'.'"}, "return_value": "'.'"}, {"func_args": {"s": "'contrib'"}, "return_value": "'contrib'"}, {"func_args": {"s": "'__init__.py'"}, "return_value": "'__init__.py'"}, {"func_args": {"s": "'advanced.py'"}, "return_value": "'advanced.py'"}, {"func_args": {"s": "'dates.py'"}, "return_value": "'dates.py'"}, {"func_args": {"s": "'formsets.py'"}, "return_value": "'formsets.py'"}, {"func_args": {"s": "'generic.py'"}, "return_value": "'generic.py'"}, {"func_args": {"s": "'models.py'"}, "return_value": "'models.py'"}, {"func_args": {"s": "'contrib/__init__.py'"}, "return_value": "'contrib/__init__.py'"}, {"func_args": {"s": "'contrib/mixins.py'"}, "return_value": "'contrib/mixins.py'"}], "text": "def tryint(s):\n        \"\"\"If `s` is a number, return an int, else `s` unchanged.\"\"\"\n        try:\n            return int(s)\n        except ValueError:\n            return s"}, "human_key": {"line": 366, "args": [{"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "['/usr/app/src/test_repos/django-extra-views/extra_views']"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/coverage'"}, "return_value": "['/usr/app/src/test_repos/django-extra-views/.tox/py', 38, '/lib/python', 3, '.', 8, '/site-packages/coverage']"}, {"func_args": {"s": "'/root/.local/lib/python3.8/site-packages'"}, "return_value": "['/root/.local/lib/python', 3, '.', 8, '/site-packages']"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages'"}, "return_value": "['/usr/app/src/test_repos/django-extra-views/.tox/py', 38, '/lib/python', 3, '.', 8, '/site-packages']"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/.tox/py38/bin'"}, "return_value": "['/usr/app/src/test_repos/django-extra-views/.tox/py', 38, '/bin']"}, {"func_args": {"s": "'/root/.local/bin'"}, "return_value": "['/root/.local/bin']"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python'"}, "return_value": "['/usr/app/src/test_repos/django-extra-views/.tox/py', 38, '/lib/python']"}, {"func_args": {"s": "'extra_views/__init__.py               6      6     0%'"}, "return_value": "['extra_views/__init__.py               ', 6, '      ', 6, '     ', 0, '%']"}, {"func_args": {"s": "'extra_views/advanced.py             108    108     0%'"}, "return_value": "['extra_views/advanced.py             ', 108, '    ', 108, '     ', 0, '%']"}, {"func_args": {"s": "'extra_views/contrib/__init__.py       0      0   100%'"}, "return_value": "['extra_views/contrib/__init__.py       ', 0, '      ', 0, '   ', 100, '%']"}, {"func_args": {"s": "'extra_views/contrib/mixins.py       123    123     0%'"}, "return_value": "['extra_views/contrib/mixins.py       ', 123, '    ', 123, '     ', 0, '%']"}, {"func_args": {"s": "'extra_views/dates.py                116    116     0%'"}, "return_value": "['extra_views/dates.py                ', 116, '    ', 116, '     ', 0, '%']"}, {"func_args": {"s": "'extra_views/formsets.py             120    120     0%'"}, "return_value": "['extra_views/formsets.py             ', 120, '    ', 120, '     ', 0, '%']"}, {"func_args": {"s": "'extra_views/generic.py               17     17     0%'"}, "return_value": "['extra_views/generic.py               ', 17, '     ', 17, '     ', 0, '%']"}, {"func_args": {"s": "'extra_views/models.py                 0      0   100%'"}, "return_value": "['extra_views/models.py                 ', 0, '      ', 0, '   ', 100, '%']"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "['/usr/app/src/test_repos/django-extra-views/extra_views']"}, {"func_args": {"s": "'.'"}, "return_value": "['.']"}, {"func_args": {"s": "'contrib'"}, "return_value": "['contrib']"}, {"func_args": {"s": "'__init__.py'"}, "return_value": "['__init__.py']"}, {"func_args": {"s": "'advanced.py'"}, "return_value": "['advanced.py']"}, {"func_args": {"s": "'dates.py'"}, "return_value": "['dates.py']"}, {"func_args": {"s": "'formsets.py'"}, "return_value": "['formsets.py']"}, {"func_args": {"s": "'generic.py'"}, "return_value": "['generic.py']"}, {"func_args": {"s": "'models.py'"}, "return_value": "['models.py']"}, {"func_args": {"s": "'contrib/__init__.py'"}, "return_value": "['contrib/__init__.py']"}, {"func_args": {"s": "'contrib/mixins.py'"}, "return_value": "['contrib/mixins.py']"}], "text": "def human_key(s):\n    \"\"\"Turn a string into a list of string and number chunks.\n        \"z23a\" -> [\"z\", 23, \"a\"]\n    \"\"\"\n    def tryint(s):\n        \"\"\"If `s` is a number, return an int, else `s` unchanged.\"\"\"\n        try:\n            return int(s)\n        except ValueError:\n            return s\n\n    return [tryint(c) for c in re.split(r\"(\\d+)\", s)]"}, "human_sorted": {"line": 379, "args": [{"func_args": {"strings": "['/usr/app/src/test_repos/django-extra-views/extra_views']"}, "return_value": "['/usr/app/src/test_repos/django-extra-views/extra_views']"}, {"func_args": {"strings": "{'/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/coverage'}"}, "return_value": "['/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/coverage']"}, {"func_args": {"strings": "{'/root/.local/lib/python3.8/site-packages', '/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages', '/usr/app/src/test_repos/django-extra-views/.tox/py38/bin', '/root/.local/bin', '/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python'}"}, "return_value": "['/root/.local/bin', '/root/.local/lib/python3.8/site-packages', '/usr/app/src/test_repos/django-extra-views/.tox/py38/bin', '/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python', '/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages']"}, {"func_args": {"strings": "{'/usr/app/src/test_repos/django-extra-views/extra_views'}"}, "return_value": "['/usr/app/src/test_repos/django-extra-views/extra_views']"}], "text": "def human_sorted(strings):\n    \"\"\"Sort the given iterable of strings the way that humans expect.\n\n    Numeric components in the strings are sorted as numbers.\n\n    Returns the sorted list.\n\n    \"\"\"\n    return sorted(strings, key=human_key)"}, "join_regex": {"line": 182, "args": [{"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}], "text": "def join_regex(regexes):\n    \"\"\"Combine a list of regexes into one that matches any of them.\"\"\"\n    return \"|\".join(f\"(?:{r})\" for r in regexes)"}, "filename_suffix": {"line": 1006, "args": [{"func_args": {"suffix": "True"}, "return_value": "'cae2a1e14906.5669.932020'"}, {"func_args": {"suffix": "None"}, "return_value": "None"}, {"func_args": {"suffix": "None"}, "return_value": "None"}], "text": "def filename_suffix(suffix):\n    \"\"\"Compute a filename suffix for a data file.\n\n    If `suffix` is a string or None, simply return it. If `suffix` is True,\n    then build a suffix incorporating the hostname, process id, and a random\n    number.\n\n    Returns a string or None.\n\n    \"\"\"\n    if suffix is True:\n        # If data_suffix was a simple true value, then make a suffix with\n        # plenty of distinguishing information.  We do this here in\n        # `save()` at the last minute so that the pid will be correct even\n        # if the process forks.\n        dice = random.Random(os.urandom(8)).randint(0, 999999)\n        suffix = \"%s.%s.%06d\" % (socket.gethostname(), os.getpid(), dice)\n    return suffix"}, "actual_path": {"line": 139, "args": [{"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/inspect.py'"}, "return_value": "'/usr/local/lib/python3.8/inspect.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/os.py'"}, "return_value": "'/usr/local/lib/python3.8/os.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/platform.py'"}, "return_value": "'/usr/local/lib/python3.8/platform.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/re.py'"}, "return_value": "'/usr/local/lib/python3.8/re.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/sysconfig.py'"}, "return_value": "'/usr/local/lib/python3.8/sysconfig.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/traceback.py'"}, "return_value": "'/usr/local/lib/python3.8/traceback.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}], "text": "def actual_path(path):\n        \"\"\"The actual path for non-Windows platforms.\"\"\"\n        return path"}, "abs_file": {"line": 144, "args": [{"func_args": {"path": "'./extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/inspect.py'"}, "return_value": "'/usr/local/lib/python3.8/inspect.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/os.py'"}, "return_value": "'/usr/local/lib/python3.8/os.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/platform.py'"}, "return_value": "'/usr/local/lib/python3.8/platform.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/re.py'"}, "return_value": "'/usr/local/lib/python3.8/re.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/sysconfig.py'"}, "return_value": "'/usr/local/lib/python3.8/sysconfig.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/traceback.py'"}, "return_value": "'/usr/local/lib/python3.8/traceback.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"path": "'.'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"path": "'./extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}]}, "canonical_filename": {"line": 53, "args": [{"func_args": {"filename": "'extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/inspect.py'"}, "return_value": "'/usr/local/lib/python3.8/inspect.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/os.py'"}, "return_value": "'/usr/local/lib/python3.8/os.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/platform.py'"}, "return_value": "'/usr/local/lib/python3.8/platform.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/re.py'"}, "return_value": "'/usr/local/lib/python3.8/re.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/sysconfig.py'"}, "return_value": "'/usr/local/lib/python3.8/sysconfig.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/traceback.py'"}, "return_value": "'/usr/local/lib/python3.8/traceback.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"filename": "'extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}]}, "prep_patterns": {"line": 173, "args": [{"func_args": {"patterns": "None"}, "return_value": "[]"}, {"func_args": {"patterns": "None"}, "return_value": "[]"}], "text": "def prep_patterns(patterns):\n    \"\"\"Prepare the file patterns for use in a `FnmatchMatcher`.\n\n    If a pattern starts with a wildcard, it is used as a pattern\n    as-is.  If it does not start with a wildcard, then it is made\n    absolute with the current directory.\n\n    If `patterns` is None, an empty list is returned.\n\n    \"\"\"\n    prepped = []\n    for p in patterns or []:\n        if p.startswith((\"*\", \"?\")):\n            prepped.append(p)\n        else:\n            prepped.append(abs_file(p))\n    return prepped"}, "find_python_files": {"line": 403, "args": [{"func_args": {"dirname": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/django-extra-views/extra_views'"}, "return_value": "None"}], "text": "def find_python_files(dirname):\n    \"\"\"Yield all of the importable Python files in `dirname`, recursively.\n\n    To be importable, the files have to be in a directory with a __init__.py,\n    except for `dirname` itself, which isn't required to have one.  The\n    assumption is that `dirname` was specified directly, so the user knows\n    best, but sub-directories are checked for a __init__.py to be sure we only\n    find the importable files.\n\n    \"\"\"\n    for i, (dirpath, dirnames, filenames) in enumerate(os.walk(dirname)):\n        if i > 0 and '__init__.py' not in filenames:\n            # If a directory doesn't have __init__.py, then it isn't\n            # importable and neither are its files\n            del dirnames[:]\n            continue\n        for filename in filenames:\n            # We're only interested in files that look like reasonable Python\n            # files: Must end with .py or .pyw, and must not have certain funny\n            # characters that probably mean they are editor junk.\n            if re.match(r\"^[^.#~!$@%^&*()+=,]+\\.pyw?$\", filename):\n                yield os.path.join(dirpath, filename)"}, "relative_filename": {"line": 39, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'extra_views/formsets.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'extra_views/generic.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'extra_views/contrib/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'extra_views/dates.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'extra_views/models.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'extra_views/contrib/mixins.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'extra_views/advanced.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'extra_views/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'extra_views/formsets.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'extra_views/generic.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'extra_views/contrib/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'extra_views/dates.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'extra_views/models.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'extra_views/contrib/mixins.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'extra_views/advanced.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'extra_views/__init__.py'"}]}, "source_for_file": {"line": 97, "args": [{"func_args": {"filename": "'/usr/local/lib/python3.8/inspect.py'"}, "return_value": "'/usr/local/lib/python3.8/inspect.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/os.py'"}, "return_value": "'/usr/local/lib/python3.8/os.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/platform.py'"}, "return_value": "'/usr/local/lib/python3.8/platform.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/re.py'"}, "return_value": "'/usr/local/lib/python3.8/re.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/sysconfig.py'"}, "return_value": "'/usr/local/lib/python3.8/sysconfig.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/traceback.py'"}, "return_value": "'/usr/local/lib/python3.8/traceback.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}], "text": "def source_for_file(filename):\n    \"\"\"Return the source filename for `filename`.\n\n    Given a file name being traced, return the best guess as to the source\n    file to attribute it to.\n\n    \"\"\"\n    if filename.endswith(\".py\"):\n        # .py files are themselves source files.\n        return filename\n\n    elif filename.endswith((\".pyc\", \".pyo\")):\n        # Bytecode files probably have source files near them.\n        py_filename = filename[:-1]\n        if os.path.exists(py_filename):\n            # Found a .py file, use that.\n            return py_filename\n        if env.WINDOWS:\n            # On Windows, it could be a .pyw file.\n            pyw_filename = py_filename + \"w\"\n            if os.path.exists(pyw_filename):\n                return pyw_filename\n        # Didn't find source, but it's probably the .py file we want.\n        return py_filename\n\n    elif filename.endswith(\"$py.class\"):\n        # Jython is easy to guess.\n        return filename[:-9] + \".py\"\n\n    # No idea, just use the file name as-is.\n    return filename"}, "read_python_source": {"line": 20, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "b'from extra_views.advanced import (\\n    CreateWithInlinesView,\\n    FormSetSuccessMessageMixin,\\n    InlineFormSetFactory,\\n    NamedFormsetsMixin,\\n    SuccessMessageMixin,\\n    UpdateWithInlinesView,\\n)\\nfrom extra_views.contrib.mixins import SearchableListMixin, SortableListMixin\\nfrom extra_views.dates import CalendarMonthView\\nfrom extra_views.formsets import FormSetView, InlineFormSetView, ModelFormSetView\\n\\n__version__ = \"0.14.0\"\\n\\n__all__ = [\\n    \"CreateWithInlinesView\",\\n    \"FormSetSuccessMessageMixin\",\\n    \"InlineFormSetFactory\",\\n    \"NamedFormsetsMixin\",\\n    \"SuccessMessageMixin\",\\n    \"UpdateWithInlinesView\",\\n    \"SearchableListMixin\",\\n    \"SortableListMixin\",\\n    \"CalendarMonthView\",\\n    \"FormSetView\",\\n    \"InlineFormSetView\",\\n    \"ModelFormSetView\",\\n]\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "b'from django.contrib import messages\\nfrom django.forms.formsets import all_valid\\nfrom django.views.generic.base import ContextMixin\\nfrom django.views.generic.detail import SingleObjectTemplateResponseMixin\\nfrom django.views.generic.edit import FormView, ModelFormMixin\\n\\nfrom extra_views.formsets import BaseInlineFormSetFactory\\n\\n\\nclass InlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create an `InlineFormSet` from `inlineformset_factory` as\\n    one of multiple `InlineFormSet`s within a single view.\\n\\n    Subclasses `BaseInlineFormSetFactory` and passes in the necessary view arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Overrides construct_formset to attach the model class as\\n        an attribute of the returned formset instance.\\n        \"\"\"\\n        formset = super().construct_formset()\\n        formset.model = self.inline_model\\n        return formset\\n\\n\\nclass ModelFormWithInlinesMixin(ModelFormMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a modelform and inline\\n    formsets in a request.\\n\\n    The inlines should be subclasses of `InlineFormSetFactory`.\\n    \"\"\"\\n\\n    inlines = []\\n\\n    def get_inlines(self):\\n        \"\"\"\\n        Returns the inline formset classes\\n        \"\"\"\\n        return self.inlines[:]\\n\\n    def forms_valid(self, form, inlines):\\n        \"\"\"\\n        If the form and formsets are valid, save the associated models.\\n        \"\"\"\\n        response = self.form_valid(form)\\n        for formset in inlines:\\n            formset.save()\\n        return response\\n\\n    def forms_invalid(self, form, inlines):\\n        \"\"\"\\n        If the form or formsets are invalid, re-render the context data with the\\n        data-filled form and formsets and errors.\\n        \"\"\"\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines)\\n        )\\n\\n    def construct_inlines(self):\\n        \"\"\"\\n        Returns the inline formset instances\\n        \"\"\"\\n        inline_formsets = []\\n        for inline_class in self.get_inlines():\\n            inline_instance = inline_class(\\n                self.model, self.request, self.object, self.kwargs, self\\n            )\\n            inline_formset = inline_instance.construct_formset()\\n            inline_formsets.append(inline_formset)\\n        return inline_formsets\\n\\n\\nclass ProcessFormWithInlinesView(FormView):\\n    \"\"\"\\n    A mixin that renders a form and inline formsets on GET and processes it on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the form and formsets.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n        inlines = self.construct_inlines()\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines, **kwargs)\\n        )\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a form and formset instances with the\\n        passed POST variables and then checked for validity.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n\\n        initial_object = self.object\\n        if form.is_valid():\\n            self.object = form.save(commit=False)\\n            form_validated = True\\n        else:\\n            form_validated = False\\n\\n        inlines = self.construct_inlines()\\n\\n        if all_valid(inlines) and form_validated:\\n            return self.forms_valid(form, inlines)\\n        self.object = initial_object\\n        return self.forms_invalid(form, inlines)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseCreateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for creating an new object instance with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass CreateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseCreateWithInlinesView\\n):\\n    \"\"\"\\n    View for creating a new object instance with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass BaseUpdateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for updating an existing object with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass UpdateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseUpdateWithInlinesView\\n):\\n    \"\"\"\\n    View for updating an object with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass NamedFormsetsMixin(ContextMixin):\\n    \"\"\"\\n    A mixin for use with `CreateWithInlinesView` or `UpdateWithInlinesView` that lets\\n    you define the context variable for each inline.\\n    \"\"\"\\n\\n    inlines_names = []\\n\\n    def get_inlines_names(self):\\n        \"\"\"\\n        Returns a list of names of context variables for each inline in `inlines`.\\n        \"\"\"\\n        return self.inlines_names[:]\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        If `inlines_names` has been defined, add each formset to the context under\\n        its corresponding entry in `inlines_names`\\n        \"\"\"\\n        context = {}\\n        inlines_names = self.get_inlines_names()\\n\\n        if inlines_names:\\n            # We have formset or inlines in context, but never both\\n            context.update(zip(inlines_names, kwargs.get(\"inlines\", [])))\\n            if \"formset\" in kwargs:\\n                context[inlines_names[0]] = kwargs[\"formset\"]\\n        context.update(kwargs)\\n        return super().get_context_data(**context)\\n\\n\\nclass SuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on views with inlines if django.contrib.messages framework\\n    is used.\\n    In order to use just add mixin in to inheritance before main class, e.g.:\\n    class MyCreateWithInlinesView (SuccessMessageMixin, CreateWithInlinesView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super().forms_valid(form, inlines)\\n        success_message = self.get_success_message(form.cleaned_data, inlines)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data, inlines):\\n        return self.success_message % cleaned_data\\n\\n\\nclass FormSetSuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on FormSet views if django.contrib.messages framework\\n    is used. In order to use just add mixin in to inheritance before main\\n    class, e.g.:\\n    class MyFormSetView (FormSetSuccessMessageMixin, ModelFormSetView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def formset_valid(self, formset):\\n        response = super().formset_valid(formset)\\n        success_message = self.get_success_message(formset)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, formset):\\n        return self.success_message\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "b''"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "b'import datetime\\nimport functools\\nimport operator\\n\\nfrom django.contrib import messages\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.views.generic.base import ContextMixin\\n\\nVALID_STRING_LOOKUPS = (\\n    \"iexact\",\\n    \"contains\",\\n    \"icontains\",\\n    \"startswith\",\\n    \"istartswith\",\\n    \"endswith\",\\n    \"iendswith\",\\n    \"search\",\\n    \"regex\",\\n    \"iregex\",\\n)\\n\\n\\nclass SearchableListMixin(object):\\n    \"\"\"\\n    Filter queryset like a django admin search_fields does, but with little\\n     more intelligence:\\n    if self.search_split is set to True (by default) it will split query\\n     to words (by whitespace)\\n    Also tries to convert each word to date with self.search_date_formats and\\n     then search each word in separate field\\n    e.g. with query \\'foo bar\\' you can find object with\\n     obj.field1__icontains=\\'foo\\' and obj.field2__icontains==\\'bar\\'\\n\\n    To provide custom lookup just set one of the search_fields to tuple,\\n    e.g. search_fields = [(\\'field1\\', \\'iexact\\'), \\'field2\\', (\\'field3\\', \\'startswith\\')]\\n\\n    This class is designed to be used with django.generic.ListView\\n\\n    You could specify query by overriding get_search_query method\\n    by default this method will try to get \\'q\\' key from request.GET\\n    (this can be disabled with search_use_q=False)\\n    \"\"\"\\n\\n    search_fields = [\"id\"]\\n    search_date_fields = None\\n    search_date_formats = [\"%d.%m.%y\", \"%d.%m.%Y\"]\\n    search_split = True\\n    search_use_q = True\\n    check_lookups = True\\n\\n    def get_words(self, query):\\n        if self.search_split:\\n            return query.split()\\n        return [query]\\n\\n    def get_search_fields_with_filters(self):\\n        fields = []\\n        for sf in self.search_fields:\\n            if isinstance(sf, str):\\n                fields.append((sf, \"icontains\"))\\n            else:\\n                if self.check_lookups and sf[1] not in VALID_STRING_LOOKUPS:\\n                    raise ValueError(\"Invalid string lookup - %s\" % sf[1])\\n                fields.append(sf)\\n        return fields\\n\\n    def try_convert_to_date(self, word):\\n        \"\"\"\\n        Tries to convert word to date(datetime) using search_date_formats\\n        Return None if word fits no one format\\n        \"\"\"\\n        for frm in self.search_date_formats:\\n            try:\\n                return datetime.datetime.strptime(word, frm).date()\\n            except ValueError:\\n                pass\\n        return None\\n\\n    def get_search_query(self):\\n        \"\"\"\\n        Get query from request.GET \\'q\\' parameter when search_use_q is set to True\\n        Override this method to provide your own query to search\\n        \"\"\"\\n        return self.search_use_q and self.request.GET.get(\"q\", \"\").strip()\\n\\n    def get_queryset(self):\\n        qs = super(SearchableListMixin, self).get_queryset()\\n        query = self.get_search_query()\\n        if query:\\n            w_qs = []\\n            search_pairs = self.get_search_fields_with_filters()\\n            for word in self.get_words(query):\\n                filters = [\\n                    Q(**{\"%s__%s\" % (pair[0], pair[1]): word}) for pair in search_pairs\\n                ]\\n                if self.search_date_fields:\\n                    dt = self.try_convert_to_date(word)\\n                    if dt:\\n                        filters.extend(\\n                            [\\n                                Q(**{field_name: dt})\\n                                for field_name in self.search_date_fields\\n                            ]\\n                        )\\n                w_qs.append(functools.reduce(operator.or_, filters))\\n            qs = qs.filter(functools.reduce(operator.and_, w_qs))\\n            qs = qs.distinct()\\n        return qs\\n\\n\\nclass SortHelper(object):\\n    def __init__(\\n        self, request, sort_fields_aliases, sort_param_name, sort_type_param_name\\n    ):\\n        # Create a list from sort_fields_aliases, in case it is a generator,\\n        # since we want to iterate through it multiple times.\\n        sort_fields_aliases = list(sort_fields_aliases)\\n\\n        self.initial_params = request.GET.copy()\\n        self.sort_fields = dict(sort_fields_aliases)\\n        self.inv_sort_fields = dict((v, k) for k, v in sort_fields_aliases)\\n        self.initial_sort = self.inv_sort_fields.get(\\n            self.initial_params.get(sort_param_name), None\\n        )\\n        self.initial_sort_type = self.initial_params.get(sort_type_param_name, \"asc\")\\n        self.sort_param_name = sort_param_name\\n        self.sort_type_param_name = sort_type_param_name\\n\\n        for field, alias in self.sort_fields.items():\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s\" % alias,\\n                functools.partial(self.get_params_for_field, field),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_asc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"asc\"),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_desc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"desc\"),\\n            )\\n            setattr(\\n                self,\\n                \"is_sorted_by_%s\" % alias,\\n                functools.partial(self.is_sorted_by, field),\\n            )\\n\\n    def is_sorted_by(self, field_name):\\n        return field_name == self.initial_sort and self.initial_sort_type or False\\n\\n    def get_params_for_field(self, field_name, sort_type=None):\\n        \"\"\"\\n        If sort_type is None - inverse current sort for field, if no sorted - use asc\\n        \"\"\"\\n        if not sort_type:\\n            if self.initial_sort == field_name:\\n                sort_type = \"desc\" if self.initial_sort_type == \"asc\" else \"asc\"\\n            else:\\n                sort_type = \"asc\"\\n        self.initial_params[self.sort_param_name] = self.sort_fields[field_name]\\n        self.initial_params[self.sort_type_param_name] = sort_type\\n        return \"?%s\" % self.initial_params.urlencode()\\n\\n    def get_sort(self):\\n        if not self.initial_sort:\\n            return None\\n        sort = \"%s\" % self.initial_sort\\n        if self.initial_sort_type == \"desc\":\\n            sort = \"-%s\" % sort\\n        return sort\\n\\n\\nclass SortableListMixin(ContextMixin):\\n    \"\"\"\\n    You can provide either sort_fields as a plain list like\\n     [\\'id\\', \\'some\\', \\'foo__bar\\', ...]\\n    or, if you want to hide original field names you can provide list of tuples with\\n    alias that will be used:\\n    [(\\'id\\', \\'by_id\\'), (\\'some\\', \\'show_this\\'), (\\'foo__bar\\', \\'bar\\')]\\n\\n    If sort_param_name exists in query but sort_type_param_name is omitted queryset\\n     will be sorted as \\'asc\\'\\n    \"\"\"\\n\\n    sort_fields = []\\n    sort_fields_aliases = []\\n    sort_param_name = \"o\"\\n    sort_type_param_name = \"ot\"\\n\\n    def get_sort_fields(self):\\n        if self.sort_fields:\\n            return zip(self.sort_fields, self.sort_fields)\\n        return self.sort_fields_aliases\\n\\n    def get_sort_helper(self):\\n        return SortHelper(\\n            self.request,\\n            self.get_sort_fields(),\\n            self.sort_param_name,\\n            self.sort_type_param_name,\\n        )\\n\\n    def _sort_queryset(self, queryset):\\n        self.sort_helper = self.get_sort_helper()\\n        sort = self.sort_helper.get_sort()\\n        if sort:\\n            queryset = queryset.order_by(sort)\\n        return queryset\\n\\n    def get_queryset(self):\\n        qs = super(SortableListMixin, self).get_queryset()\\n        if self.sort_fields and self.sort_fields_aliases:\\n            raise ImproperlyConfigured(\\n                \"You should provide sort_fields or sort_fields_aliaces but not both\"\\n            )\\n        return self._sort_queryset(qs)\\n\\n    def get_context_data(self, **kwargs):\\n        context = {}\\n        if hasattr(self, \"sort_helper\"):\\n            context[\"sort_helper\"] = self.sort_helper\\n        context.update(kwargs)\\n        return super(SortableListMixin, self).get_context_data(**context)\\n\\n\\nclass SuccessMessageWithInlinesMixin(object):\\n    \"\"\"\\n    Adds a success message on successful form submission.\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super(SuccessMessageWithInlinesMixin, self).forms_valid(\\n            form, inlines\\n        )\\n        success_message = self.get_success_message(form.cleaned_data)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data):\\n        return self.success_message % cleaned_data\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "b'import datetime\\nimport math\\nfrom calendar import Calendar\\nfrom collections import defaultdict\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.utils.translation import gettext_lazy as _\\nfrom django.views.generic.dates import (\\n    DateMixin,\\n    MonthMixin,\\n    YearMixin,\\n    _date_from_string,\\n)\\nfrom django.views.generic.list import BaseListView, MultipleObjectTemplateResponseMixin\\n\\nDAYS = (\\n    _(\"Monday\"),\\n    _(\"Tuesday\"),\\n    _(\"Wednesday\"),\\n    _(\"Thursday\"),\\n    _(\"Friday\"),\\n    _(\"Saturday\"),\\n    _(\"Sunday\"),\\n)\\n\\n\\ndef daterange(start_date, end_date):\\n    \"\"\"\\n    Returns an iterator of dates between two provided ones\\n    \"\"\"\\n    for n in range(int((end_date - start_date).days + 1)):\\n        yield start_date + datetime.timedelta(n)\\n\\n\\nclass BaseCalendarMonthView(DateMixin, YearMixin, MonthMixin, BaseListView):\\n    \"\"\"\\n    A base view for displaying a calendar month\\n    \"\"\"\\n\\n    first_of_week = 0  # 0 = Monday, 6 = Sunday\\n    paginate_by = None  # We don\\'t want to use this part of MultipleObjectMixin\\n    date_field = None\\n    end_date_field = None  # For supporting events with duration\\n\\n    def get_paginate_by(self, queryset):\\n        if self.paginate_by is not None:\\n            raise ImproperlyConfigured(\\n                \"\\'%s\\' cannot be paginated, it is a calendar view\"\\n                % self.__class__.__name__\\n            )\\n        return None\\n\\n    def get_allow_future(self):\\n        return True\\n\\n    def get_end_date_field(self):\\n        \"\"\"\\n        Returns the model field to use for end dates\\n        \"\"\"\\n        return self.end_date_field\\n\\n    def get_start_date(self, obj):\\n        \"\"\"\\n        Returns the start date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_end_date(self, obj):\\n        \"\"\"\\n        Returns the end date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_end_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_first_of_week(self):\\n        \"\"\"\\n        Returns an integer representing the first day of the week.\\n\\n        0 represents Monday, 6 represents Sunday.\\n        \"\"\"\\n        if self.first_of_week is None:\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week is required.\" % self.__class__.__name__\\n            )\\n        if self.first_of_week not in range(7):\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week must be an integer between 0 and 6.\"\\n                % self.__class__.__name__\\n            )\\n        return self.first_of_week\\n\\n    def get_queryset(self):\\n        \"\"\"\\n        Returns a queryset of models for the month requested\\n        \"\"\"\\n        qs = super().get_queryset()\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date_field = self.get_date_field()\\n        end_date_field = self.get_end_date_field()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        since = date\\n        until = self.get_next_month(date)\\n\\n        # Adjust our start and end dates to allow for next and previous\\n        # month edges\\n        if since.weekday() != self.get_first_of_week():\\n            diff = math.fabs(since.weekday() - self.get_first_of_week())\\n            since = since - datetime.timedelta(days=diff)\\n\\n        if until.weekday() != ((self.get_first_of_week() + 6) % 7):\\n            diff = math.fabs(((self.get_first_of_week() + 6) % 7) - until.weekday())\\n            until = until + datetime.timedelta(days=diff)\\n\\n        if end_date_field:\\n            # 5 possible conditions for showing an event:\\n\\n            # 1) Single day event, starts after \\'since\\'\\n            # 2) Multi-day event, starts after \\'since\\' and ends before \\'until\\'\\n            # 3) Starts before \\'since\\' and ends after \\'since\\' and before \\'until\\'\\n            # 4) Starts after \\'since\\' but before \\'until\\' and ends after \\'until\\'\\n            # 5) Starts before \\'since\\' and ends after \\'until\\'\\n            predicate1 = Q(**{\"%s__gte\" % date_field: since, end_date_field: None})\\n            predicate2 = Q(\\n                **{\"%s__gte\" % date_field: since, \"%s__lt\" % end_date_field: until}\\n            )\\n            predicate3 = Q(\\n                **{\\n                    \"%s__lt\" % date_field: since,\\n                    \"%s__gte\" % end_date_field: since,\\n                    \"%s__lt\" % end_date_field: until,\\n                }\\n            )\\n            predicate4 = Q(\\n                **{\\n                    \"%s__gte\" % date_field: since,\\n                    \"%s__lt\" % date_field: until,\\n                    \"%s__gte\" % end_date_field: until,\\n                }\\n            )\\n            predicate5 = Q(\\n                **{\"%s__lt\" % date_field: since, \"%s__gte\" % end_date_field: until}\\n            )\\n            return qs.filter(\\n                predicate1 | predicate2 | predicate3 | predicate4 | predicate5\\n            )\\n        return qs.filter(**{\"%s__gte\" % date_field: since})\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        Injects variables necessary for rendering the calendar into the context.\\n\\n        Variables added are: `calendar`, `weekdays`, `month`, `next_month` and\\n        `previous_month`.\\n        \"\"\"\\n        data = super().get_context_data(**kwargs)\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        cal = Calendar(self.get_first_of_week())\\n\\n        month_calendar = []\\n        now = datetime.datetime.utcnow()\\n\\n        date_lists = defaultdict(list)\\n        multidate_objs = []\\n\\n        for obj in data[\"object_list\"]:\\n            obj_date = self.get_start_date(obj)\\n            end_date_field = self.get_end_date_field()\\n\\n            if end_date_field:\\n                end_date = self.get_end_date(obj)\\n                if end_date and end_date != obj_date:\\n                    multidate_objs.append(\\n                        {\\n                            \"obj\": obj,\\n                            \"range\": [x for x in daterange(obj_date, end_date)],\\n                        }\\n                    )\\n                    continue  # We don\\'t put multi-day events in date_lists\\n            date_lists[obj_date].append(obj)\\n\\n        for week in cal.monthdatescalendar(date.year, date.month):\\n            week_range = set(daterange(week[0], week[6]))\\n            week_events = []\\n\\n            for val in multidate_objs:\\n                intersect_length = len(week_range.intersection(val[\"range\"]))\\n\\n                if intersect_length:\\n                    # Event happens during this week\\n                    slot = 1\\n                    width = (\\n                        intersect_length  # How many days is the event during this week?\\n                    )\\n                    nowrap_previous = (\\n                        True  # Does the event continue from the previous week?\\n                    )\\n                    nowrap_next = True  # Does the event continue to the next week?\\n\\n                    if val[\"range\"][0] >= week[0]:\\n                        slot = 1 + (val[\"range\"][0] - week[0]).days\\n                    else:\\n                        nowrap_previous = False\\n                    if val[\"range\"][-1] > week[6]:\\n                        nowrap_next = False\\n\\n                    week_events.append(\\n                        {\\n                            \"event\": val[\"obj\"],\\n                            \"slot\": slot,\\n                            \"width\": width,\\n                            \"nowrap_previous\": nowrap_previous,\\n                            \"nowrap_next\": nowrap_next,\\n                        }\\n                    )\\n\\n            week_calendar = {\"events\": week_events, \"date_list\": []}\\n            for day in week:\\n                week_calendar[\"date_list\"].append(\\n                    {\\n                        \"day\": day,\\n                        \"events\": date_lists[day],\\n                        \"today\": day == now.date(),\\n                        \"is_current_month\": day.month == date.month,\\n                    }\\n                )\\n            month_calendar.append(week_calendar)\\n\\n        data[\"calendar\"] = month_calendar\\n        data[\"weekdays\"] = [DAYS[x] for x in cal.iterweekdays()]\\n        data[\"month\"] = date\\n        data[\"next_month\"] = self.get_next_month(date)\\n        data[\"previous_month\"] = self.get_previous_month(date)\\n\\n        return data\\n\\n\\nclass CalendarMonthView(MultipleObjectTemplateResponseMixin, BaseCalendarMonthView):\\n    \"\"\"\\n    A view for displaying a calendar month, and rendering a template response\\n    \"\"\"\\n\\n    template_name_suffix = \"_calendar_month\"\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "b'from django.forms.formsets import formset_factory\\nfrom django.forms.models import inlineformset_factory, modelformset_factory\\nfrom django.http import HttpResponseRedirect\\nfrom django.views.generic.base import ContextMixin, TemplateResponseMixin, View\\nfrom django.views.generic.detail import (\\n    SingleObjectMixin,\\n    SingleObjectTemplateResponseMixin,\\n)\\nfrom django.views.generic.list import (\\n    MultipleObjectMixin,\\n    MultipleObjectTemplateResponseMixin,\\n)\\n\\n\\nclass BaseFormSetFactory(object):\\n    \"\"\"\\n    Base class for constructing a FormSet from `formset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    initial = []\\n    form_class = None\\n    formset_class = None\\n    prefix = None\\n    formset_kwargs = {}\\n    factory_kwargs = {}\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Returns an instance of the formset\\n        \"\"\"\\n        formset_class = self.get_formset()\\n        return formset_class(**self.get_formset_kwargs())\\n\\n    def get_initial(self):\\n        \"\"\"\\n        Returns a copy of the initial data to use for formsets on this view.\\n        \"\"\"\\n        return self.initial[:]\\n\\n    def get_prefix(self):\\n        \"\"\"\\n        Returns the prefix used for formsets on this view.\\n        \"\"\"\\n        return self.prefix\\n\\n    def get_formset_class(self):\\n        \"\"\"\\n        Returns the formset class to use in the formset factory\\n        \"\"\"\\n        return self.formset_class\\n\\n    def get_form_class(self):\\n        \"\"\"\\n        Returns the form class to use with the formset in this view\\n        \"\"\"\\n        return self.form_class\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the formset factory\\n        \"\"\"\\n        return formset_factory(self.get_form_class(), **self.get_factory_kwargs())\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = self.formset_kwargs.copy()\\n        kwargs.update({\"initial\": self.get_initial(), \"prefix\": self.get_prefix()})\\n\\n        if self.request.method in (\"POST\", \"PUT\"):\\n            kwargs.update(\\n                {\"data\": self.request.POST.copy(), \"files\": self.request.FILES}\\n            )\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = self.factory_kwargs.copy()\\n        if self.get_formset_class():\\n            kwargs[\"formset\"] = self.get_formset_class()\\n        return kwargs\\n\\n\\nclass FormSetMixin(BaseFormSetFactory, ContextMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single formset in a request.\\n    \"\"\"\\n\\n    success_url = None\\n\\n    def get_success_url(self):\\n        \"\"\"\\n        Returns the supplied URL.\\n        \"\"\"\\n        if self.success_url:\\n            url = self.success_url\\n        else:\\n            # Default to returning to the same page\\n            url = self.request.get_full_path()\\n        return url\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid redirect to the supplied URL\\n        \"\"\"\\n        return HttpResponseRedirect(self.get_success_url())\\n\\n    def formset_invalid(self, formset):\\n        \"\"\"\\n        If the formset is invalid, re-render the context data with the\\n        data-filled formset and errors.\\n        \"\"\"\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n\\nclass ModelFormSetMixin(FormSetMixin, MultipleObjectMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single model formset\\n    in a request.\\n\\n    Uses `modelformset_factory`.\\n    \"\"\"\\n\\n    exclude = None\\n    fields = None\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"queryset\"] = self.get_queryset()\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the model formset factory\\n        \"\"\"\\n        return modelformset_factory(self.model, **self.get_factory_kwargs())\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid, save the associated models.\\n        \"\"\"\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass BaseInlineFormSetFactory(BaseFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a FormSet from `inlineformset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    model = None\\n    inline_model = None\\n    exclude = None\\n    fields = None\\n\\n    def get_inline_model(self):\\n        \"\"\"\\n        Returns the inline model to use with the inline formset\\n        \"\"\"\\n        return self.inline_model\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"instance\"] = self.object\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the inline formset factory\\n        \"\"\"\\n        return inlineformset_factory(\\n            self.model, self.get_inline_model(), **self.get_factory_kwargs()\\n        )\\n\\n\\nclass InlineFormSetMixin(BaseInlineFormSetFactory, SingleObjectMixin, FormSetMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single inline formset\\n    in a request.\\n    \"\"\"\\n\\n    def formset_valid(self, formset):\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass ProcessFormSetView(View):\\n    \"\"\"\\n    A mixin that processes a formset on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the formset.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a formset instance with the passed\\n        POST variables and then checked for validity.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        if formset.is_valid():\\n            return self.formset_valid(formset)\\n        else:\\n            return self.formset_invalid(formset)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseFormSetView(FormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a formset\\n    \"\"\"\\n\\n\\nclass FormSetView(TemplateResponseMixin, BaseFormSetView):\\n    \"\"\"\\n    A view for displaying a formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseModelFormSetView(ModelFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a model formset\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass ModelFormSetView(MultipleObjectTemplateResponseMixin, BaseModelFormSetView):\\n    \"\"\"\\n    A view for displaying a model formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseInlineFormSetView(InlineFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying an inline formset for a queryset belonging to\\n    a parent model\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass InlineFormSetView(SingleObjectTemplateResponseMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A view for displaying an inline formset for a queryset belonging to a parent model\\n    \"\"\"\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "b'from django.contrib.contenttypes.forms import generic_inlineformset_factory\\n\\nfrom extra_views.formsets import (\\n    BaseInlineFormSetFactory,\\n    BaseInlineFormSetView,\\n    InlineFormSetMixin,\\n    InlineFormSetView,\\n)\\n\\n\\nclass BaseGenericInlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a GenericInlineFormSet from\\n    `generic_inlineformset_factory` in a view.\\n    \"\"\"\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the final formset class from generic_inlineformset_factory.\\n        \"\"\"\\n        result = generic_inlineformset_factory(\\n            self.inline_model, **self.get_factory_kwargs()\\n        )\\n        return result\\n\\n\\nclass GenericInlineFormSetFactory(BaseGenericInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create a `GenericInlineFormSet` from `generic_inlineformset_factory`\\n    as one of multiple `GenericInlineFormSet`s within a single view.\\n\\n    Subclasses `BaseGenericInlineFormSetFactory` and passes in the necessary view\\n    arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n\\nclass GenericInlineFormSetMixin(BaseGenericInlineFormSetFactory, InlineFormSetMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a generic inline formset in a\\n    request.\\n    \"\"\"\\n\\n\\nclass BaseGenericInlineFormSetView(GenericInlineFormSetMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A base view for displaying a generic inline formset\\n    \"\"\"\\n\\n\\nclass GenericInlineFormSetView(BaseGenericInlineFormSetView, InlineFormSetView):\\n    \"\"\"\\n    A view for displaying a generic inline formset for a queryset belonging to a\\n    parent model\\n    \"\"\"\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "b''"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "b'from extra_views.advanced import (\\n    CreateWithInlinesView,\\n    FormSetSuccessMessageMixin,\\n    InlineFormSetFactory,\\n    NamedFormsetsMixin,\\n    SuccessMessageMixin,\\n    UpdateWithInlinesView,\\n)\\nfrom extra_views.contrib.mixins import SearchableListMixin, SortableListMixin\\nfrom extra_views.dates import CalendarMonthView\\nfrom extra_views.formsets import FormSetView, InlineFormSetView, ModelFormSetView\\n\\n__version__ = \"0.14.0\"\\n\\n__all__ = [\\n    \"CreateWithInlinesView\",\\n    \"FormSetSuccessMessageMixin\",\\n    \"InlineFormSetFactory\",\\n    \"NamedFormsetsMixin\",\\n    \"SuccessMessageMixin\",\\n    \"UpdateWithInlinesView\",\\n    \"SearchableListMixin\",\\n    \"SortableListMixin\",\\n    \"CalendarMonthView\",\\n    \"FormSetView\",\\n    \"InlineFormSetView\",\\n    \"ModelFormSetView\",\\n]\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "b'from django.contrib import messages\\nfrom django.forms.formsets import all_valid\\nfrom django.views.generic.base import ContextMixin\\nfrom django.views.generic.detail import SingleObjectTemplateResponseMixin\\nfrom django.views.generic.edit import FormView, ModelFormMixin\\n\\nfrom extra_views.formsets import BaseInlineFormSetFactory\\n\\n\\nclass InlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create an `InlineFormSet` from `inlineformset_factory` as\\n    one of multiple `InlineFormSet`s within a single view.\\n\\n    Subclasses `BaseInlineFormSetFactory` and passes in the necessary view arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Overrides construct_formset to attach the model class as\\n        an attribute of the returned formset instance.\\n        \"\"\"\\n        formset = super().construct_formset()\\n        formset.model = self.inline_model\\n        return formset\\n\\n\\nclass ModelFormWithInlinesMixin(ModelFormMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a modelform and inline\\n    formsets in a request.\\n\\n    The inlines should be subclasses of `InlineFormSetFactory`.\\n    \"\"\"\\n\\n    inlines = []\\n\\n    def get_inlines(self):\\n        \"\"\"\\n        Returns the inline formset classes\\n        \"\"\"\\n        return self.inlines[:]\\n\\n    def forms_valid(self, form, inlines):\\n        \"\"\"\\n        If the form and formsets are valid, save the associated models.\\n        \"\"\"\\n        response = self.form_valid(form)\\n        for formset in inlines:\\n            formset.save()\\n        return response\\n\\n    def forms_invalid(self, form, inlines):\\n        \"\"\"\\n        If the form or formsets are invalid, re-render the context data with the\\n        data-filled form and formsets and errors.\\n        \"\"\"\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines)\\n        )\\n\\n    def construct_inlines(self):\\n        \"\"\"\\n        Returns the inline formset instances\\n        \"\"\"\\n        inline_formsets = []\\n        for inline_class in self.get_inlines():\\n            inline_instance = inline_class(\\n                self.model, self.request, self.object, self.kwargs, self\\n            )\\n            inline_formset = inline_instance.construct_formset()\\n            inline_formsets.append(inline_formset)\\n        return inline_formsets\\n\\n\\nclass ProcessFormWithInlinesView(FormView):\\n    \"\"\"\\n    A mixin that renders a form and inline formsets on GET and processes it on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the form and formsets.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n        inlines = self.construct_inlines()\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines, **kwargs)\\n        )\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a form and formset instances with the\\n        passed POST variables and then checked for validity.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n\\n        initial_object = self.object\\n        if form.is_valid():\\n            self.object = form.save(commit=False)\\n            form_validated = True\\n        else:\\n            form_validated = False\\n\\n        inlines = self.construct_inlines()\\n\\n        if all_valid(inlines) and form_validated:\\n            return self.forms_valid(form, inlines)\\n        self.object = initial_object\\n        return self.forms_invalid(form, inlines)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseCreateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for creating an new object instance with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass CreateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseCreateWithInlinesView\\n):\\n    \"\"\"\\n    View for creating a new object instance with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass BaseUpdateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for updating an existing object with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass UpdateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseUpdateWithInlinesView\\n):\\n    \"\"\"\\n    View for updating an object with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass NamedFormsetsMixin(ContextMixin):\\n    \"\"\"\\n    A mixin for use with `CreateWithInlinesView` or `UpdateWithInlinesView` that lets\\n    you define the context variable for each inline.\\n    \"\"\"\\n\\n    inlines_names = []\\n\\n    def get_inlines_names(self):\\n        \"\"\"\\n        Returns a list of names of context variables for each inline in `inlines`.\\n        \"\"\"\\n        return self.inlines_names[:]\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        If `inlines_names` has been defined, add each formset to the context under\\n        its corresponding entry in `inlines_names`\\n        \"\"\"\\n        context = {}\\n        inlines_names = self.get_inlines_names()\\n\\n        if inlines_names:\\n            # We have formset or inlines in context, but never both\\n            context.update(zip(inlines_names, kwargs.get(\"inlines\", [])))\\n            if \"formset\" in kwargs:\\n                context[inlines_names[0]] = kwargs[\"formset\"]\\n        context.update(kwargs)\\n        return super().get_context_data(**context)\\n\\n\\nclass SuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on views with inlines if django.contrib.messages framework\\n    is used.\\n    In order to use just add mixin in to inheritance before main class, e.g.:\\n    class MyCreateWithInlinesView (SuccessMessageMixin, CreateWithInlinesView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super().forms_valid(form, inlines)\\n        success_message = self.get_success_message(form.cleaned_data, inlines)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data, inlines):\\n        return self.success_message % cleaned_data\\n\\n\\nclass FormSetSuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on FormSet views if django.contrib.messages framework\\n    is used. In order to use just add mixin in to inheritance before main\\n    class, e.g.:\\n    class MyFormSetView (FormSetSuccessMessageMixin, ModelFormSetView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def formset_valid(self, formset):\\n        response = super().formset_valid(formset)\\n        success_message = self.get_success_message(formset)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, formset):\\n        return self.success_message\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "b''"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "b'import datetime\\nimport functools\\nimport operator\\n\\nfrom django.contrib import messages\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.views.generic.base import ContextMixin\\n\\nVALID_STRING_LOOKUPS = (\\n    \"iexact\",\\n    \"contains\",\\n    \"icontains\",\\n    \"startswith\",\\n    \"istartswith\",\\n    \"endswith\",\\n    \"iendswith\",\\n    \"search\",\\n    \"regex\",\\n    \"iregex\",\\n)\\n\\n\\nclass SearchableListMixin(object):\\n    \"\"\"\\n    Filter queryset like a django admin search_fields does, but with little\\n     more intelligence:\\n    if self.search_split is set to True (by default) it will split query\\n     to words (by whitespace)\\n    Also tries to convert each word to date with self.search_date_formats and\\n     then search each word in separate field\\n    e.g. with query \\'foo bar\\' you can find object with\\n     obj.field1__icontains=\\'foo\\' and obj.field2__icontains==\\'bar\\'\\n\\n    To provide custom lookup just set one of the search_fields to tuple,\\n    e.g. search_fields = [(\\'field1\\', \\'iexact\\'), \\'field2\\', (\\'field3\\', \\'startswith\\')]\\n\\n    This class is designed to be used with django.generic.ListView\\n\\n    You could specify query by overriding get_search_query method\\n    by default this method will try to get \\'q\\' key from request.GET\\n    (this can be disabled with search_use_q=False)\\n    \"\"\"\\n\\n    search_fields = [\"id\"]\\n    search_date_fields = None\\n    search_date_formats = [\"%d.%m.%y\", \"%d.%m.%Y\"]\\n    search_split = True\\n    search_use_q = True\\n    check_lookups = True\\n\\n    def get_words(self, query):\\n        if self.search_split:\\n            return query.split()\\n        return [query]\\n\\n    def get_search_fields_with_filters(self):\\n        fields = []\\n        for sf in self.search_fields:\\n            if isinstance(sf, str):\\n                fields.append((sf, \"icontains\"))\\n            else:\\n                if self.check_lookups and sf[1] not in VALID_STRING_LOOKUPS:\\n                    raise ValueError(\"Invalid string lookup - %s\" % sf[1])\\n                fields.append(sf)\\n        return fields\\n\\n    def try_convert_to_date(self, word):\\n        \"\"\"\\n        Tries to convert word to date(datetime) using search_date_formats\\n        Return None if word fits no one format\\n        \"\"\"\\n        for frm in self.search_date_formats:\\n            try:\\n                return datetime.datetime.strptime(word, frm).date()\\n            except ValueError:\\n                pass\\n        return None\\n\\n    def get_search_query(self):\\n        \"\"\"\\n        Get query from request.GET \\'q\\' parameter when search_use_q is set to True\\n        Override this method to provide your own query to search\\n        \"\"\"\\n        return self.search_use_q and self.request.GET.get(\"q\", \"\").strip()\\n\\n    def get_queryset(self):\\n        qs = super(SearchableListMixin, self).get_queryset()\\n        query = self.get_search_query()\\n        if query:\\n            w_qs = []\\n            search_pairs = self.get_search_fields_with_filters()\\n            for word in self.get_words(query):\\n                filters = [\\n                    Q(**{\"%s__%s\" % (pair[0], pair[1]): word}) for pair in search_pairs\\n                ]\\n                if self.search_date_fields:\\n                    dt = self.try_convert_to_date(word)\\n                    if dt:\\n                        filters.extend(\\n                            [\\n                                Q(**{field_name: dt})\\n                                for field_name in self.search_date_fields\\n                            ]\\n                        )\\n                w_qs.append(functools.reduce(operator.or_, filters))\\n            qs = qs.filter(functools.reduce(operator.and_, w_qs))\\n            qs = qs.distinct()\\n        return qs\\n\\n\\nclass SortHelper(object):\\n    def __init__(\\n        self, request, sort_fields_aliases, sort_param_name, sort_type_param_name\\n    ):\\n        # Create a list from sort_fields_aliases, in case it is a generator,\\n        # since we want to iterate through it multiple times.\\n        sort_fields_aliases = list(sort_fields_aliases)\\n\\n        self.initial_params = request.GET.copy()\\n        self.sort_fields = dict(sort_fields_aliases)\\n        self.inv_sort_fields = dict((v, k) for k, v in sort_fields_aliases)\\n        self.initial_sort = self.inv_sort_fields.get(\\n            self.initial_params.get(sort_param_name), None\\n        )\\n        self.initial_sort_type = self.initial_params.get(sort_type_param_name, \"asc\")\\n        self.sort_param_name = sort_param_name\\n        self.sort_type_param_name = sort_type_param_name\\n\\n        for field, alias in self.sort_fields.items():\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s\" % alias,\\n                functools.partial(self.get_params_for_field, field),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_asc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"asc\"),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_desc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"desc\"),\\n            )\\n            setattr(\\n                self,\\n                \"is_sorted_by_%s\" % alias,\\n                functools.partial(self.is_sorted_by, field),\\n            )\\n\\n    def is_sorted_by(self, field_name):\\n        return field_name == self.initial_sort and self.initial_sort_type or False\\n\\n    def get_params_for_field(self, field_name, sort_type=None):\\n        \"\"\"\\n        If sort_type is None - inverse current sort for field, if no sorted - use asc\\n        \"\"\"\\n        if not sort_type:\\n            if self.initial_sort == field_name:\\n                sort_type = \"desc\" if self.initial_sort_type == \"asc\" else \"asc\"\\n            else:\\n                sort_type = \"asc\"\\n        self.initial_params[self.sort_param_name] = self.sort_fields[field_name]\\n        self.initial_params[self.sort_type_param_name] = sort_type\\n        return \"?%s\" % self.initial_params.urlencode()\\n\\n    def get_sort(self):\\n        if not self.initial_sort:\\n            return None\\n        sort = \"%s\" % self.initial_sort\\n        if self.initial_sort_type == \"desc\":\\n            sort = \"-%s\" % sort\\n        return sort\\n\\n\\nclass SortableListMixin(ContextMixin):\\n    \"\"\"\\n    You can provide either sort_fields as a plain list like\\n     [\\'id\\', \\'some\\', \\'foo__bar\\', ...]\\n    or, if you want to hide original field names you can provide list of tuples with\\n    alias that will be used:\\n    [(\\'id\\', \\'by_id\\'), (\\'some\\', \\'show_this\\'), (\\'foo__bar\\', \\'bar\\')]\\n\\n    If sort_param_name exists in query but sort_type_param_name is omitted queryset\\n     will be sorted as \\'asc\\'\\n    \"\"\"\\n\\n    sort_fields = []\\n    sort_fields_aliases = []\\n    sort_param_name = \"o\"\\n    sort_type_param_name = \"ot\"\\n\\n    def get_sort_fields(self):\\n        if self.sort_fields:\\n            return zip(self.sort_fields, self.sort_fields)\\n        return self.sort_fields_aliases\\n\\n    def get_sort_helper(self):\\n        return SortHelper(\\n            self.request,\\n            self.get_sort_fields(),\\n            self.sort_param_name,\\n            self.sort_type_param_name,\\n        )\\n\\n    def _sort_queryset(self, queryset):\\n        self.sort_helper = self.get_sort_helper()\\n        sort = self.sort_helper.get_sort()\\n        if sort:\\n            queryset = queryset.order_by(sort)\\n        return queryset\\n\\n    def get_queryset(self):\\n        qs = super(SortableListMixin, self).get_queryset()\\n        if self.sort_fields and self.sort_fields_aliases:\\n            raise ImproperlyConfigured(\\n                \"You should provide sort_fields or sort_fields_aliaces but not both\"\\n            )\\n        return self._sort_queryset(qs)\\n\\n    def get_context_data(self, **kwargs):\\n        context = {}\\n        if hasattr(self, \"sort_helper\"):\\n            context[\"sort_helper\"] = self.sort_helper\\n        context.update(kwargs)\\n        return super(SortableListMixin, self).get_context_data(**context)\\n\\n\\nclass SuccessMessageWithInlinesMixin(object):\\n    \"\"\"\\n    Adds a success message on successful form submission.\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super(SuccessMessageWithInlinesMixin, self).forms_valid(\\n            form, inlines\\n        )\\n        success_message = self.get_success_message(form.cleaned_data)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data):\\n        return self.success_message % cleaned_data\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "b'import datetime\\nimport math\\nfrom calendar import Calendar\\nfrom collections import defaultdict\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.utils.translation import gettext_lazy as _\\nfrom django.views.generic.dates import (\\n    DateMixin,\\n    MonthMixin,\\n    YearMixin,\\n    _date_from_string,\\n)\\nfrom django.views.generic.list import BaseListView, MultipleObjectTemplateResponseMixin\\n\\nDAYS = (\\n    _(\"Monday\"),\\n    _(\"Tuesday\"),\\n    _(\"Wednesday\"),\\n    _(\"Thursday\"),\\n    _(\"Friday\"),\\n    _(\"Saturday\"),\\n    _(\"Sunday\"),\\n)\\n\\n\\ndef daterange(start_date, end_date):\\n    \"\"\"\\n    Returns an iterator of dates between two provided ones\\n    \"\"\"\\n    for n in range(int((end_date - start_date).days + 1)):\\n        yield start_date + datetime.timedelta(n)\\n\\n\\nclass BaseCalendarMonthView(DateMixin, YearMixin, MonthMixin, BaseListView):\\n    \"\"\"\\n    A base view for displaying a calendar month\\n    \"\"\"\\n\\n    first_of_week = 0  # 0 = Monday, 6 = Sunday\\n    paginate_by = None  # We don\\'t want to use this part of MultipleObjectMixin\\n    date_field = None\\n    end_date_field = None  # For supporting events with duration\\n\\n    def get_paginate_by(self, queryset):\\n        if self.paginate_by is not None:\\n            raise ImproperlyConfigured(\\n                \"\\'%s\\' cannot be paginated, it is a calendar view\"\\n                % self.__class__.__name__\\n            )\\n        return None\\n\\n    def get_allow_future(self):\\n        return True\\n\\n    def get_end_date_field(self):\\n        \"\"\"\\n        Returns the model field to use for end dates\\n        \"\"\"\\n        return self.end_date_field\\n\\n    def get_start_date(self, obj):\\n        \"\"\"\\n        Returns the start date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_end_date(self, obj):\\n        \"\"\"\\n        Returns the end date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_end_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_first_of_week(self):\\n        \"\"\"\\n        Returns an integer representing the first day of the week.\\n\\n        0 represents Monday, 6 represents Sunday.\\n        \"\"\"\\n        if self.first_of_week is None:\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week is required.\" % self.__class__.__name__\\n            )\\n        if self.first_of_week not in range(7):\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week must be an integer between 0 and 6.\"\\n                % self.__class__.__name__\\n            )\\n        return self.first_of_week\\n\\n    def get_queryset(self):\\n        \"\"\"\\n        Returns a queryset of models for the month requested\\n        \"\"\"\\n        qs = super().get_queryset()\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date_field = self.get_date_field()\\n        end_date_field = self.get_end_date_field()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        since = date\\n        until = self.get_next_month(date)\\n\\n        # Adjust our start and end dates to allow for next and previous\\n        # month edges\\n        if since.weekday() != self.get_first_of_week():\\n            diff = math.fabs(since.weekday() - self.get_first_of_week())\\n            since = since - datetime.timedelta(days=diff)\\n\\n        if until.weekday() != ((self.get_first_of_week() + 6) % 7):\\n            diff = math.fabs(((self.get_first_of_week() + 6) % 7) - until.weekday())\\n            until = until + datetime.timedelta(days=diff)\\n\\n        if end_date_field:\\n            # 5 possible conditions for showing an event:\\n\\n            # 1) Single day event, starts after \\'since\\'\\n            # 2) Multi-day event, starts after \\'since\\' and ends before \\'until\\'\\n            # 3) Starts before \\'since\\' and ends after \\'since\\' and before \\'until\\'\\n            # 4) Starts after \\'since\\' but before \\'until\\' and ends after \\'until\\'\\n            # 5) Starts before \\'since\\' and ends after \\'until\\'\\n            predicate1 = Q(**{\"%s__gte\" % date_field: since, end_date_field: None})\\n            predicate2 = Q(\\n                **{\"%s__gte\" % date_field: since, \"%s__lt\" % end_date_field: until}\\n            )\\n            predicate3 = Q(\\n                **{\\n                    \"%s__lt\" % date_field: since,\\n                    \"%s__gte\" % end_date_field: since,\\n                    \"%s__lt\" % end_date_field: until,\\n                }\\n            )\\n            predicate4 = Q(\\n                **{\\n                    \"%s__gte\" % date_field: since,\\n                    \"%s__lt\" % date_field: until,\\n                    \"%s__gte\" % end_date_field: until,\\n                }\\n            )\\n            predicate5 = Q(\\n                **{\"%s__lt\" % date_field: since, \"%s__gte\" % end_date_field: until}\\n            )\\n            return qs.filter(\\n                predicate1 | predicate2 | predicate3 | predicate4 | predicate5\\n            )\\n        return qs.filter(**{\"%s__gte\" % date_field: since})\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        Injects variables necessary for rendering the calendar into the context.\\n\\n        Variables added are: `calendar`, `weekdays`, `month`, `next_month` and\\n        `previous_month`.\\n        \"\"\"\\n        data = super().get_context_data(**kwargs)\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        cal = Calendar(self.get_first_of_week())\\n\\n        month_calendar = []\\n        now = datetime.datetime.utcnow()\\n\\n        date_lists = defaultdict(list)\\n        multidate_objs = []\\n\\n        for obj in data[\"object_list\"]:\\n            obj_date = self.get_start_date(obj)\\n            end_date_field = self.get_end_date_field()\\n\\n            if end_date_field:\\n                end_date = self.get_end_date(obj)\\n                if end_date and end_date != obj_date:\\n                    multidate_objs.append(\\n                        {\\n                            \"obj\": obj,\\n                            \"range\": [x for x in daterange(obj_date, end_date)],\\n                        }\\n                    )\\n                    continue  # We don\\'t put multi-day events in date_lists\\n            date_lists[obj_date].append(obj)\\n\\n        for week in cal.monthdatescalendar(date.year, date.month):\\n            week_range = set(daterange(week[0], week[6]))\\n            week_events = []\\n\\n            for val in multidate_objs:\\n                intersect_length = len(week_range.intersection(val[\"range\"]))\\n\\n                if intersect_length:\\n                    # Event happens during this week\\n                    slot = 1\\n                    width = (\\n                        intersect_length  # How many days is the event during this week?\\n                    )\\n                    nowrap_previous = (\\n                        True  # Does the event continue from the previous week?\\n                    )\\n                    nowrap_next = True  # Does the event continue to the next week?\\n\\n                    if val[\"range\"][0] >= week[0]:\\n                        slot = 1 + (val[\"range\"][0] - week[0]).days\\n                    else:\\n                        nowrap_previous = False\\n                    if val[\"range\"][-1] > week[6]:\\n                        nowrap_next = False\\n\\n                    week_events.append(\\n                        {\\n                            \"event\": val[\"obj\"],\\n                            \"slot\": slot,\\n                            \"width\": width,\\n                            \"nowrap_previous\": nowrap_previous,\\n                            \"nowrap_next\": nowrap_next,\\n                        }\\n                    )\\n\\n            week_calendar = {\"events\": week_events, \"date_list\": []}\\n            for day in week:\\n                week_calendar[\"date_list\"].append(\\n                    {\\n                        \"day\": day,\\n                        \"events\": date_lists[day],\\n                        \"today\": day == now.date(),\\n                        \"is_current_month\": day.month == date.month,\\n                    }\\n                )\\n            month_calendar.append(week_calendar)\\n\\n        data[\"calendar\"] = month_calendar\\n        data[\"weekdays\"] = [DAYS[x] for x in cal.iterweekdays()]\\n        data[\"month\"] = date\\n        data[\"next_month\"] = self.get_next_month(date)\\n        data[\"previous_month\"] = self.get_previous_month(date)\\n\\n        return data\\n\\n\\nclass CalendarMonthView(MultipleObjectTemplateResponseMixin, BaseCalendarMonthView):\\n    \"\"\"\\n    A view for displaying a calendar month, and rendering a template response\\n    \"\"\"\\n\\n    template_name_suffix = \"_calendar_month\"\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "b'from django.forms.formsets import formset_factory\\nfrom django.forms.models import inlineformset_factory, modelformset_factory\\nfrom django.http import HttpResponseRedirect\\nfrom django.views.generic.base import ContextMixin, TemplateResponseMixin, View\\nfrom django.views.generic.detail import (\\n    SingleObjectMixin,\\n    SingleObjectTemplateResponseMixin,\\n)\\nfrom django.views.generic.list import (\\n    MultipleObjectMixin,\\n    MultipleObjectTemplateResponseMixin,\\n)\\n\\n\\nclass BaseFormSetFactory(object):\\n    \"\"\"\\n    Base class for constructing a FormSet from `formset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    initial = []\\n    form_class = None\\n    formset_class = None\\n    prefix = None\\n    formset_kwargs = {}\\n    factory_kwargs = {}\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Returns an instance of the formset\\n        \"\"\"\\n        formset_class = self.get_formset()\\n        return formset_class(**self.get_formset_kwargs())\\n\\n    def get_initial(self):\\n        \"\"\"\\n        Returns a copy of the initial data to use for formsets on this view.\\n        \"\"\"\\n        return self.initial[:]\\n\\n    def get_prefix(self):\\n        \"\"\"\\n        Returns the prefix used for formsets on this view.\\n        \"\"\"\\n        return self.prefix\\n\\n    def get_formset_class(self):\\n        \"\"\"\\n        Returns the formset class to use in the formset factory\\n        \"\"\"\\n        return self.formset_class\\n\\n    def get_form_class(self):\\n        \"\"\"\\n        Returns the form class to use with the formset in this view\\n        \"\"\"\\n        return self.form_class\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the formset factory\\n        \"\"\"\\n        return formset_factory(self.get_form_class(), **self.get_factory_kwargs())\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = self.formset_kwargs.copy()\\n        kwargs.update({\"initial\": self.get_initial(), \"prefix\": self.get_prefix()})\\n\\n        if self.request.method in (\"POST\", \"PUT\"):\\n            kwargs.update(\\n                {\"data\": self.request.POST.copy(), \"files\": self.request.FILES}\\n            )\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = self.factory_kwargs.copy()\\n        if self.get_formset_class():\\n            kwargs[\"formset\"] = self.get_formset_class()\\n        return kwargs\\n\\n\\nclass FormSetMixin(BaseFormSetFactory, ContextMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single formset in a request.\\n    \"\"\"\\n\\n    success_url = None\\n\\n    def get_success_url(self):\\n        \"\"\"\\n        Returns the supplied URL.\\n        \"\"\"\\n        if self.success_url:\\n            url = self.success_url\\n        else:\\n            # Default to returning to the same page\\n            url = self.request.get_full_path()\\n        return url\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid redirect to the supplied URL\\n        \"\"\"\\n        return HttpResponseRedirect(self.get_success_url())\\n\\n    def formset_invalid(self, formset):\\n        \"\"\"\\n        If the formset is invalid, re-render the context data with the\\n        data-filled formset and errors.\\n        \"\"\"\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n\\nclass ModelFormSetMixin(FormSetMixin, MultipleObjectMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single model formset\\n    in a request.\\n\\n    Uses `modelformset_factory`.\\n    \"\"\"\\n\\n    exclude = None\\n    fields = None\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"queryset\"] = self.get_queryset()\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the model formset factory\\n        \"\"\"\\n        return modelformset_factory(self.model, **self.get_factory_kwargs())\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid, save the associated models.\\n        \"\"\"\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass BaseInlineFormSetFactory(BaseFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a FormSet from `inlineformset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    model = None\\n    inline_model = None\\n    exclude = None\\n    fields = None\\n\\n    def get_inline_model(self):\\n        \"\"\"\\n        Returns the inline model to use with the inline formset\\n        \"\"\"\\n        return self.inline_model\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"instance\"] = self.object\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the inline formset factory\\n        \"\"\"\\n        return inlineformset_factory(\\n            self.model, self.get_inline_model(), **self.get_factory_kwargs()\\n        )\\n\\n\\nclass InlineFormSetMixin(BaseInlineFormSetFactory, SingleObjectMixin, FormSetMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single inline formset\\n    in a request.\\n    \"\"\"\\n\\n    def formset_valid(self, formset):\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass ProcessFormSetView(View):\\n    \"\"\"\\n    A mixin that processes a formset on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the formset.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a formset instance with the passed\\n        POST variables and then checked for validity.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        if formset.is_valid():\\n            return self.formset_valid(formset)\\n        else:\\n            return self.formset_invalid(formset)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseFormSetView(FormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a formset\\n    \"\"\"\\n\\n\\nclass FormSetView(TemplateResponseMixin, BaseFormSetView):\\n    \"\"\"\\n    A view for displaying a formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseModelFormSetView(ModelFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a model formset\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass ModelFormSetView(MultipleObjectTemplateResponseMixin, BaseModelFormSetView):\\n    \"\"\"\\n    A view for displaying a model formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseInlineFormSetView(InlineFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying an inline formset for a queryset belonging to\\n    a parent model\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass InlineFormSetView(SingleObjectTemplateResponseMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A view for displaying an inline formset for a queryset belonging to a parent model\\n    \"\"\"\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "b'from django.contrib.contenttypes.forms import generic_inlineformset_factory\\n\\nfrom extra_views.formsets import (\\n    BaseInlineFormSetFactory,\\n    BaseInlineFormSetView,\\n    InlineFormSetMixin,\\n    InlineFormSetView,\\n)\\n\\n\\nclass BaseGenericInlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a GenericInlineFormSet from\\n    `generic_inlineformset_factory` in a view.\\n    \"\"\"\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the final formset class from generic_inlineformset_factory.\\n        \"\"\"\\n        result = generic_inlineformset_factory(\\n            self.inline_model, **self.get_factory_kwargs()\\n        )\\n        return result\\n\\n\\nclass GenericInlineFormSetFactory(BaseGenericInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create a `GenericInlineFormSet` from `generic_inlineformset_factory`\\n    as one of multiple `GenericInlineFormSet`s within a single view.\\n\\n    Subclasses `BaseGenericInlineFormSetFactory` and passes in the necessary view\\n    arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n\\nclass GenericInlineFormSetMixin(BaseGenericInlineFormSetFactory, InlineFormSetMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a generic inline formset in a\\n    request.\\n    \"\"\"\\n\\n\\nclass BaseGenericInlineFormSetView(GenericInlineFormSetMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A base view for displaying a generic inline formset\\n    \"\"\"\\n\\n\\nclass GenericInlineFormSetView(BaseGenericInlineFormSetView, InlineFormSetView):\\n    \"\"\"\\n    A view for displaying a generic inline formset for a queryset belonging to a\\n    parent model\\n    \"\"\"\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "b''"}]}, "get_python_source": {"line": 37, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'from extra_views.advanced import (\\n    CreateWithInlinesView,\\n    FormSetSuccessMessageMixin,\\n    InlineFormSetFactory,\\n    NamedFormsetsMixin,\\n    SuccessMessageMixin,\\n    UpdateWithInlinesView,\\n)\\nfrom extra_views.contrib.mixins import SearchableListMixin, SortableListMixin\\nfrom extra_views.dates import CalendarMonthView\\nfrom extra_views.formsets import FormSetView, InlineFormSetView, ModelFormSetView\\n\\n__version__ = \"0.14.0\"\\n\\n__all__ = [\\n    \"CreateWithInlinesView\",\\n    \"FormSetSuccessMessageMixin\",\\n    \"InlineFormSetFactory\",\\n    \"NamedFormsetsMixin\",\\n    \"SuccessMessageMixin\",\\n    \"UpdateWithInlinesView\",\\n    \"SearchableListMixin\",\\n    \"SortableListMixin\",\\n    \"CalendarMonthView\",\\n    \"FormSetView\",\\n    \"InlineFormSetView\",\\n    \"ModelFormSetView\",\\n]\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'from django.contrib import messages\\nfrom django.forms.formsets import all_valid\\nfrom django.views.generic.base import ContextMixin\\nfrom django.views.generic.detail import SingleObjectTemplateResponseMixin\\nfrom django.views.generic.edit import FormView, ModelFormMixin\\n\\nfrom extra_views.formsets import BaseInlineFormSetFactory\\n\\n\\nclass InlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create an `InlineFormSet` from `inlineformset_factory` as\\n    one of multiple `InlineFormSet`s within a single view.\\n\\n    Subclasses `BaseInlineFormSetFactory` and passes in the necessary view arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Overrides construct_formset to attach the model class as\\n        an attribute of the returned formset instance.\\n        \"\"\"\\n        formset = super().construct_formset()\\n        formset.model = self.inline_model\\n        return formset\\n\\n\\nclass ModelFormWithInlinesMixin(ModelFormMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a modelform and inline\\n    formsets in a request.\\n\\n    The inlines should be subclasses of `InlineFormSetFactory`.\\n    \"\"\"\\n\\n    inlines = []\\n\\n    def get_inlines(self):\\n        \"\"\"\\n        Returns the inline formset classes\\n        \"\"\"\\n        return self.inlines[:]\\n\\n    def forms_valid(self, form, inlines):\\n        \"\"\"\\n        If the form and formsets are valid, save the associated models.\\n        \"\"\"\\n        response = self.form_valid(form)\\n        for formset in inlines:\\n            formset.save()\\n        return response\\n\\n    def forms_invalid(self, form, inlines):\\n        \"\"\"\\n        If the form or formsets are invalid, re-render the context data with the\\n        data-filled form and formsets and errors.\\n        \"\"\"\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines)\\n        )\\n\\n    def construct_inlines(self):\\n        \"\"\"\\n        Returns the inline formset instances\\n        \"\"\"\\n        inline_formsets = []\\n        for inline_class in self.get_inlines():\\n            inline_instance = inline_class(\\n                self.model, self.request, self.object, self.kwargs, self\\n            )\\n            inline_formset = inline_instance.construct_formset()\\n            inline_formsets.append(inline_formset)\\n        return inline_formsets\\n\\n\\nclass ProcessFormWithInlinesView(FormView):\\n    \"\"\"\\n    A mixin that renders a form and inline formsets on GET and processes it on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the form and formsets.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n        inlines = self.construct_inlines()\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines, **kwargs)\\n        )\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a form and formset instances with the\\n        passed POST variables and then checked for validity.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n\\n        initial_object = self.object\\n        if form.is_valid():\\n            self.object = form.save(commit=False)\\n            form_validated = True\\n        else:\\n            form_validated = False\\n\\n        inlines = self.construct_inlines()\\n\\n        if all_valid(inlines) and form_validated:\\n            return self.forms_valid(form, inlines)\\n        self.object = initial_object\\n        return self.forms_invalid(form, inlines)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseCreateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for creating an new object instance with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass CreateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseCreateWithInlinesView\\n):\\n    \"\"\"\\n    View for creating a new object instance with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass BaseUpdateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for updating an existing object with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass UpdateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseUpdateWithInlinesView\\n):\\n    \"\"\"\\n    View for updating an object with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass NamedFormsetsMixin(ContextMixin):\\n    \"\"\"\\n    A mixin for use with `CreateWithInlinesView` or `UpdateWithInlinesView` that lets\\n    you define the context variable for each inline.\\n    \"\"\"\\n\\n    inlines_names = []\\n\\n    def get_inlines_names(self):\\n        \"\"\"\\n        Returns a list of names of context variables for each inline in `inlines`.\\n        \"\"\"\\n        return self.inlines_names[:]\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        If `inlines_names` has been defined, add each formset to the context under\\n        its corresponding entry in `inlines_names`\\n        \"\"\"\\n        context = {}\\n        inlines_names = self.get_inlines_names()\\n\\n        if inlines_names:\\n            # We have formset or inlines in context, but never both\\n            context.update(zip(inlines_names, kwargs.get(\"inlines\", [])))\\n            if \"formset\" in kwargs:\\n                context[inlines_names[0]] = kwargs[\"formset\"]\\n        context.update(kwargs)\\n        return super().get_context_data(**context)\\n\\n\\nclass SuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on views with inlines if django.contrib.messages framework\\n    is used.\\n    In order to use just add mixin in to inheritance before main class, e.g.:\\n    class MyCreateWithInlinesView (SuccessMessageMixin, CreateWithInlinesView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super().forms_valid(form, inlines)\\n        success_message = self.get_success_message(form.cleaned_data, inlines)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data, inlines):\\n        return self.success_message % cleaned_data\\n\\n\\nclass FormSetSuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on FormSet views if django.contrib.messages framework\\n    is used. In order to use just add mixin in to inheritance before main\\n    class, e.g.:\\n    class MyFormSetView (FormSetSuccessMessageMixin, ModelFormSetView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def formset_valid(self, formset):\\n        response = super().formset_valid(formset)\\n        success_message = self.get_success_message(formset)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, formset):\\n        return self.success_message\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "''"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'import datetime\\nimport functools\\nimport operator\\n\\nfrom django.contrib import messages\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.views.generic.base import ContextMixin\\n\\nVALID_STRING_LOOKUPS = (\\n    \"iexact\",\\n    \"contains\",\\n    \"icontains\",\\n    \"startswith\",\\n    \"istartswith\",\\n    \"endswith\",\\n    \"iendswith\",\\n    \"search\",\\n    \"regex\",\\n    \"iregex\",\\n)\\n\\n\\nclass SearchableListMixin(object):\\n    \"\"\"\\n    Filter queryset like a django admin search_fields does, but with little\\n     more intelligence:\\n    if self.search_split is set to True (by default) it will split query\\n     to words (by whitespace)\\n    Also tries to convert each word to date with self.search_date_formats and\\n     then search each word in separate field\\n    e.g. with query \\'foo bar\\' you can find object with\\n     obj.field1__icontains=\\'foo\\' and obj.field2__icontains==\\'bar\\'\\n\\n    To provide custom lookup just set one of the search_fields to tuple,\\n    e.g. search_fields = [(\\'field1\\', \\'iexact\\'), \\'field2\\', (\\'field3\\', \\'startswith\\')]\\n\\n    This class is designed to be used with django.generic.ListView\\n\\n    You could specify query by overriding get_search_query method\\n    by default this method will try to get \\'q\\' key from request.GET\\n    (this can be disabled with search_use_q=False)\\n    \"\"\"\\n\\n    search_fields = [\"id\"]\\n    search_date_fields = None\\n    search_date_formats = [\"%d.%m.%y\", \"%d.%m.%Y\"]\\n    search_split = True\\n    search_use_q = True\\n    check_lookups = True\\n\\n    def get_words(self, query):\\n        if self.search_split:\\n            return query.split()\\n        return [query]\\n\\n    def get_search_fields_with_filters(self):\\n        fields = []\\n        for sf in self.search_fields:\\n            if isinstance(sf, str):\\n                fields.append((sf, \"icontains\"))\\n            else:\\n                if self.check_lookups and sf[1] not in VALID_STRING_LOOKUPS:\\n                    raise ValueError(\"Invalid string lookup - %s\" % sf[1])\\n                fields.append(sf)\\n        return fields\\n\\n    def try_convert_to_date(self, word):\\n        \"\"\"\\n        Tries to convert word to date(datetime) using search_date_formats\\n        Return None if word fits no one format\\n        \"\"\"\\n        for frm in self.search_date_formats:\\n            try:\\n                return datetime.datetime.strptime(word, frm).date()\\n            except ValueError:\\n                pass\\n        return None\\n\\n    def get_search_query(self):\\n        \"\"\"\\n        Get query from request.GET \\'q\\' parameter when search_use_q is set to True\\n        Override this method to provide your own query to search\\n        \"\"\"\\n        return self.search_use_q and self.request.GET.get(\"q\", \"\").strip()\\n\\n    def get_queryset(self):\\n        qs = super(SearchableListMixin, self).get_queryset()\\n        query = self.get_search_query()\\n        if query:\\n            w_qs = []\\n            search_pairs = self.get_search_fields_with_filters()\\n            for word in self.get_words(query):\\n                filters = [\\n                    Q(**{\"%s__%s\" % (pair[0], pair[1]): word}) for pair in search_pairs\\n                ]\\n                if self.search_date_fields:\\n                    dt = self.try_convert_to_date(word)\\n                    if dt:\\n                        filters.extend(\\n                            [\\n                                Q(**{field_name: dt})\\n                                for field_name in self.search_date_fields\\n                            ]\\n                        )\\n                w_qs.append(functools.reduce(operator.or_, filters))\\n            qs = qs.filter(functools.reduce(operator.and_, w_qs))\\n            qs = qs.distinct()\\n        return qs\\n\\n\\nclass SortHelper(object):\\n    def __init__(\\n        self, request, sort_fields_aliases, sort_param_name, sort_type_param_name\\n    ):\\n        # Create a list from sort_fields_aliases, in case it is a generator,\\n        # since we want to iterate through it multiple times.\\n        sort_fields_aliases = list(sort_fields_aliases)\\n\\n        self.initial_params = request.GET.copy()\\n        self.sort_fields = dict(sort_fields_aliases)\\n        self.inv_sort_fields = dict((v, k) for k, v in sort_fields_aliases)\\n        self.initial_sort = self.inv_sort_fields.get(\\n            self.initial_params.get(sort_param_name), None\\n        )\\n        self.initial_sort_type = self.initial_params.get(sort_type_param_name, \"asc\")\\n        self.sort_param_name = sort_param_name\\n        self.sort_type_param_name = sort_type_param_name\\n\\n        for field, alias in self.sort_fields.items():\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s\" % alias,\\n                functools.partial(self.get_params_for_field, field),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_asc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"asc\"),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_desc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"desc\"),\\n            )\\n            setattr(\\n                self,\\n                \"is_sorted_by_%s\" % alias,\\n                functools.partial(self.is_sorted_by, field),\\n            )\\n\\n    def is_sorted_by(self, field_name):\\n        return field_name == self.initial_sort and self.initial_sort_type or False\\n\\n    def get_params_for_field(self, field_name, sort_type=None):\\n        \"\"\"\\n        If sort_type is None - inverse current sort for field, if no sorted - use asc\\n        \"\"\"\\n        if not sort_type:\\n            if self.initial_sort == field_name:\\n                sort_type = \"desc\" if self.initial_sort_type == \"asc\" else \"asc\"\\n            else:\\n                sort_type = \"asc\"\\n        self.initial_params[self.sort_param_name] = self.sort_fields[field_name]\\n        self.initial_params[self.sort_type_param_name] = sort_type\\n        return \"?%s\" % self.initial_params.urlencode()\\n\\n    def get_sort(self):\\n        if not self.initial_sort:\\n            return None\\n        sort = \"%s\" % self.initial_sort\\n        if self.initial_sort_type == \"desc\":\\n            sort = \"-%s\" % sort\\n        return sort\\n\\n\\nclass SortableListMixin(ContextMixin):\\n    \"\"\"\\n    You can provide either sort_fields as a plain list like\\n     [\\'id\\', \\'some\\', \\'foo__bar\\', ...]\\n    or, if you want to hide original field names you can provide list of tuples with\\n    alias that will be used:\\n    [(\\'id\\', \\'by_id\\'), (\\'some\\', \\'show_this\\'), (\\'foo__bar\\', \\'bar\\')]\\n\\n    If sort_param_name exists in query but sort_type_param_name is omitted queryset\\n     will be sorted as \\'asc\\'\\n    \"\"\"\\n\\n    sort_fields = []\\n    sort_fields_aliases = []\\n    sort_param_name = \"o\"\\n    sort_type_param_name = \"ot\"\\n\\n    def get_sort_fields(self):\\n        if self.sort_fields:\\n            return zip(self.sort_fields, self.sort_fields)\\n        return self.sort_fields_aliases\\n\\n    def get_sort_helper(self):\\n        return SortHelper(\\n            self.request,\\n            self.get_sort_fields(),\\n            self.sort_param_name,\\n            self.sort_type_param_name,\\n        )\\n\\n    def _sort_queryset(self, queryset):\\n        self.sort_helper = self.get_sort_helper()\\n        sort = self.sort_helper.get_sort()\\n        if sort:\\n            queryset = queryset.order_by(sort)\\n        return queryset\\n\\n    def get_queryset(self):\\n        qs = super(SortableListMixin, self).get_queryset()\\n        if self.sort_fields and self.sort_fields_aliases:\\n            raise ImproperlyConfigured(\\n                \"You should provide sort_fields or sort_fields_aliaces but not both\"\\n            )\\n        return self._sort_queryset(qs)\\n\\n    def get_context_data(self, **kwargs):\\n        context = {}\\n        if hasattr(self, \"sort_helper\"):\\n            context[\"sort_helper\"] = self.sort_helper\\n        context.update(kwargs)\\n        return super(SortableListMixin, self).get_context_data(**context)\\n\\n\\nclass SuccessMessageWithInlinesMixin(object):\\n    \"\"\"\\n    Adds a success message on successful form submission.\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super(SuccessMessageWithInlinesMixin, self).forms_valid(\\n            form, inlines\\n        )\\n        success_message = self.get_success_message(form.cleaned_data)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data):\\n        return self.success_message % cleaned_data\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'import datetime\\nimport math\\nfrom calendar import Calendar\\nfrom collections import defaultdict\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.utils.translation import gettext_lazy as _\\nfrom django.views.generic.dates import (\\n    DateMixin,\\n    MonthMixin,\\n    YearMixin,\\n    _date_from_string,\\n)\\nfrom django.views.generic.list import BaseListView, MultipleObjectTemplateResponseMixin\\n\\nDAYS = (\\n    _(\"Monday\"),\\n    _(\"Tuesday\"),\\n    _(\"Wednesday\"),\\n    _(\"Thursday\"),\\n    _(\"Friday\"),\\n    _(\"Saturday\"),\\n    _(\"Sunday\"),\\n)\\n\\n\\ndef daterange(start_date, end_date):\\n    \"\"\"\\n    Returns an iterator of dates between two provided ones\\n    \"\"\"\\n    for n in range(int((end_date - start_date).days + 1)):\\n        yield start_date + datetime.timedelta(n)\\n\\n\\nclass BaseCalendarMonthView(DateMixin, YearMixin, MonthMixin, BaseListView):\\n    \"\"\"\\n    A base view for displaying a calendar month\\n    \"\"\"\\n\\n    first_of_week = 0  # 0 = Monday, 6 = Sunday\\n    paginate_by = None  # We don\\'t want to use this part of MultipleObjectMixin\\n    date_field = None\\n    end_date_field = None  # For supporting events with duration\\n\\n    def get_paginate_by(self, queryset):\\n        if self.paginate_by is not None:\\n            raise ImproperlyConfigured(\\n                \"\\'%s\\' cannot be paginated, it is a calendar view\"\\n                % self.__class__.__name__\\n            )\\n        return None\\n\\n    def get_allow_future(self):\\n        return True\\n\\n    def get_end_date_field(self):\\n        \"\"\"\\n        Returns the model field to use for end dates\\n        \"\"\"\\n        return self.end_date_field\\n\\n    def get_start_date(self, obj):\\n        \"\"\"\\n        Returns the start date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_end_date(self, obj):\\n        \"\"\"\\n        Returns the end date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_end_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_first_of_week(self):\\n        \"\"\"\\n        Returns an integer representing the first day of the week.\\n\\n        0 represents Monday, 6 represents Sunday.\\n        \"\"\"\\n        if self.first_of_week is None:\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week is required.\" % self.__class__.__name__\\n            )\\n        if self.first_of_week not in range(7):\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week must be an integer between 0 and 6.\"\\n                % self.__class__.__name__\\n            )\\n        return self.first_of_week\\n\\n    def get_queryset(self):\\n        \"\"\"\\n        Returns a queryset of models for the month requested\\n        \"\"\"\\n        qs = super().get_queryset()\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date_field = self.get_date_field()\\n        end_date_field = self.get_end_date_field()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        since = date\\n        until = self.get_next_month(date)\\n\\n        # Adjust our start and end dates to allow for next and previous\\n        # month edges\\n        if since.weekday() != self.get_first_of_week():\\n            diff = math.fabs(since.weekday() - self.get_first_of_week())\\n            since = since - datetime.timedelta(days=diff)\\n\\n        if until.weekday() != ((self.get_first_of_week() + 6) % 7):\\n            diff = math.fabs(((self.get_first_of_week() + 6) % 7) - until.weekday())\\n            until = until + datetime.timedelta(days=diff)\\n\\n        if end_date_field:\\n            # 5 possible conditions for showing an event:\\n\\n            # 1) Single day event, starts after \\'since\\'\\n            # 2) Multi-day event, starts after \\'since\\' and ends before \\'until\\'\\n            # 3) Starts before \\'since\\' and ends after \\'since\\' and before \\'until\\'\\n            # 4) Starts after \\'since\\' but before \\'until\\' and ends after \\'until\\'\\n            # 5) Starts before \\'since\\' and ends after \\'until\\'\\n            predicate1 = Q(**{\"%s__gte\" % date_field: since, end_date_field: None})\\n            predicate2 = Q(\\n                **{\"%s__gte\" % date_field: since, \"%s__lt\" % end_date_field: until}\\n            )\\n            predicate3 = Q(\\n                **{\\n                    \"%s__lt\" % date_field: since,\\n                    \"%s__gte\" % end_date_field: since,\\n                    \"%s__lt\" % end_date_field: until,\\n                }\\n            )\\n            predicate4 = Q(\\n                **{\\n                    \"%s__gte\" % date_field: since,\\n                    \"%s__lt\" % date_field: until,\\n                    \"%s__gte\" % end_date_field: until,\\n                }\\n            )\\n            predicate5 = Q(\\n                **{\"%s__lt\" % date_field: since, \"%s__gte\" % end_date_field: until}\\n            )\\n            return qs.filter(\\n                predicate1 | predicate2 | predicate3 | predicate4 | predicate5\\n            )\\n        return qs.filter(**{\"%s__gte\" % date_field: since})\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        Injects variables necessary for rendering the calendar into the context.\\n\\n        Variables added are: `calendar`, `weekdays`, `month`, `next_month` and\\n        `previous_month`.\\n        \"\"\"\\n        data = super().get_context_data(**kwargs)\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        cal = Calendar(self.get_first_of_week())\\n\\n        month_calendar = []\\n        now = datetime.datetime.utcnow()\\n\\n        date_lists = defaultdict(list)\\n        multidate_objs = []\\n\\n        for obj in data[\"object_list\"]:\\n            obj_date = self.get_start_date(obj)\\n            end_date_field = self.get_end_date_field()\\n\\n            if end_date_field:\\n                end_date = self.get_end_date(obj)\\n                if end_date and end_date != obj_date:\\n                    multidate_objs.append(\\n                        {\\n                            \"obj\": obj,\\n                            \"range\": [x for x in daterange(obj_date, end_date)],\\n                        }\\n                    )\\n                    continue  # We don\\'t put multi-day events in date_lists\\n            date_lists[obj_date].append(obj)\\n\\n        for week in cal.monthdatescalendar(date.year, date.month):\\n            week_range = set(daterange(week[0], week[6]))\\n            week_events = []\\n\\n            for val in multidate_objs:\\n                intersect_length = len(week_range.intersection(val[\"range\"]))\\n\\n                if intersect_length:\\n                    # Event happens during this week\\n                    slot = 1\\n                    width = (\\n                        intersect_length  # How many days is the event during this week?\\n                    )\\n                    nowrap_previous = (\\n                        True  # Does the event continue from the previous week?\\n                    )\\n                    nowrap_next = True  # Does the event continue to the next week?\\n\\n                    if val[\"range\"][0] >= week[0]:\\n                        slot = 1 + (val[\"range\"][0] - week[0]).days\\n                    else:\\n                        nowrap_previous = False\\n                    if val[\"range\"][-1] > week[6]:\\n                        nowrap_next = False\\n\\n                    week_events.append(\\n                        {\\n                            \"event\": val[\"obj\"],\\n                            \"slot\": slot,\\n                            \"width\": width,\\n                            \"nowrap_previous\": nowrap_previous,\\n                            \"nowrap_next\": nowrap_next,\\n                        }\\n                    )\\n\\n            week_calendar = {\"events\": week_events, \"date_list\": []}\\n            for day in week:\\n                week_calendar[\"date_list\"].append(\\n                    {\\n                        \"day\": day,\\n                        \"events\": date_lists[day],\\n                        \"today\": day == now.date(),\\n                        \"is_current_month\": day.month == date.month,\\n                    }\\n                )\\n            month_calendar.append(week_calendar)\\n\\n        data[\"calendar\"] = month_calendar\\n        data[\"weekdays\"] = [DAYS[x] for x in cal.iterweekdays()]\\n        data[\"month\"] = date\\n        data[\"next_month\"] = self.get_next_month(date)\\n        data[\"previous_month\"] = self.get_previous_month(date)\\n\\n        return data\\n\\n\\nclass CalendarMonthView(MultipleObjectTemplateResponseMixin, BaseCalendarMonthView):\\n    \"\"\"\\n    A view for displaying a calendar month, and rendering a template response\\n    \"\"\"\\n\\n    template_name_suffix = \"_calendar_month\"\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'from django.forms.formsets import formset_factory\\nfrom django.forms.models import inlineformset_factory, modelformset_factory\\nfrom django.http import HttpResponseRedirect\\nfrom django.views.generic.base import ContextMixin, TemplateResponseMixin, View\\nfrom django.views.generic.detail import (\\n    SingleObjectMixin,\\n    SingleObjectTemplateResponseMixin,\\n)\\nfrom django.views.generic.list import (\\n    MultipleObjectMixin,\\n    MultipleObjectTemplateResponseMixin,\\n)\\n\\n\\nclass BaseFormSetFactory(object):\\n    \"\"\"\\n    Base class for constructing a FormSet from `formset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    initial = []\\n    form_class = None\\n    formset_class = None\\n    prefix = None\\n    formset_kwargs = {}\\n    factory_kwargs = {}\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Returns an instance of the formset\\n        \"\"\"\\n        formset_class = self.get_formset()\\n        return formset_class(**self.get_formset_kwargs())\\n\\n    def get_initial(self):\\n        \"\"\"\\n        Returns a copy of the initial data to use for formsets on this view.\\n        \"\"\"\\n        return self.initial[:]\\n\\n    def get_prefix(self):\\n        \"\"\"\\n        Returns the prefix used for formsets on this view.\\n        \"\"\"\\n        return self.prefix\\n\\n    def get_formset_class(self):\\n        \"\"\"\\n        Returns the formset class to use in the formset factory\\n        \"\"\"\\n        return self.formset_class\\n\\n    def get_form_class(self):\\n        \"\"\"\\n        Returns the form class to use with the formset in this view\\n        \"\"\"\\n        return self.form_class\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the formset factory\\n        \"\"\"\\n        return formset_factory(self.get_form_class(), **self.get_factory_kwargs())\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = self.formset_kwargs.copy()\\n        kwargs.update({\"initial\": self.get_initial(), \"prefix\": self.get_prefix()})\\n\\n        if self.request.method in (\"POST\", \"PUT\"):\\n            kwargs.update(\\n                {\"data\": self.request.POST.copy(), \"files\": self.request.FILES}\\n            )\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = self.factory_kwargs.copy()\\n        if self.get_formset_class():\\n            kwargs[\"formset\"] = self.get_formset_class()\\n        return kwargs\\n\\n\\nclass FormSetMixin(BaseFormSetFactory, ContextMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single formset in a request.\\n    \"\"\"\\n\\n    success_url = None\\n\\n    def get_success_url(self):\\n        \"\"\"\\n        Returns the supplied URL.\\n        \"\"\"\\n        if self.success_url:\\n            url = self.success_url\\n        else:\\n            # Default to returning to the same page\\n            url = self.request.get_full_path()\\n        return url\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid redirect to the supplied URL\\n        \"\"\"\\n        return HttpResponseRedirect(self.get_success_url())\\n\\n    def formset_invalid(self, formset):\\n        \"\"\"\\n        If the formset is invalid, re-render the context data with the\\n        data-filled formset and errors.\\n        \"\"\"\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n\\nclass ModelFormSetMixin(FormSetMixin, MultipleObjectMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single model formset\\n    in a request.\\n\\n    Uses `modelformset_factory`.\\n    \"\"\"\\n\\n    exclude = None\\n    fields = None\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"queryset\"] = self.get_queryset()\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the model formset factory\\n        \"\"\"\\n        return modelformset_factory(self.model, **self.get_factory_kwargs())\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid, save the associated models.\\n        \"\"\"\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass BaseInlineFormSetFactory(BaseFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a FormSet from `inlineformset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    model = None\\n    inline_model = None\\n    exclude = None\\n    fields = None\\n\\n    def get_inline_model(self):\\n        \"\"\"\\n        Returns the inline model to use with the inline formset\\n        \"\"\"\\n        return self.inline_model\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"instance\"] = self.object\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the inline formset factory\\n        \"\"\"\\n        return inlineformset_factory(\\n            self.model, self.get_inline_model(), **self.get_factory_kwargs()\\n        )\\n\\n\\nclass InlineFormSetMixin(BaseInlineFormSetFactory, SingleObjectMixin, FormSetMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single inline formset\\n    in a request.\\n    \"\"\"\\n\\n    def formset_valid(self, formset):\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass ProcessFormSetView(View):\\n    \"\"\"\\n    A mixin that processes a formset on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the formset.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a formset instance with the passed\\n        POST variables and then checked for validity.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        if formset.is_valid():\\n            return self.formset_valid(formset)\\n        else:\\n            return self.formset_invalid(formset)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseFormSetView(FormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a formset\\n    \"\"\"\\n\\n\\nclass FormSetView(TemplateResponseMixin, BaseFormSetView):\\n    \"\"\"\\n    A view for displaying a formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseModelFormSetView(ModelFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a model formset\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass ModelFormSetView(MultipleObjectTemplateResponseMixin, BaseModelFormSetView):\\n    \"\"\"\\n    A view for displaying a model formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseInlineFormSetView(InlineFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying an inline formset for a queryset belonging to\\n    a parent model\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass InlineFormSetView(SingleObjectTemplateResponseMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A view for displaying an inline formset for a queryset belonging to a parent model\\n    \"\"\"\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'from django.contrib.contenttypes.forms import generic_inlineformset_factory\\n\\nfrom extra_views.formsets import (\\n    BaseInlineFormSetFactory,\\n    BaseInlineFormSetView,\\n    InlineFormSetMixin,\\n    InlineFormSetView,\\n)\\n\\n\\nclass BaseGenericInlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a GenericInlineFormSet from\\n    `generic_inlineformset_factory` in a view.\\n    \"\"\"\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the final formset class from generic_inlineformset_factory.\\n        \"\"\"\\n        result = generic_inlineformset_factory(\\n            self.inline_model, **self.get_factory_kwargs()\\n        )\\n        return result\\n\\n\\nclass GenericInlineFormSetFactory(BaseGenericInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create a `GenericInlineFormSet` from `generic_inlineformset_factory`\\n    as one of multiple `GenericInlineFormSet`s within a single view.\\n\\n    Subclasses `BaseGenericInlineFormSetFactory` and passes in the necessary view\\n    arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n\\nclass GenericInlineFormSetMixin(BaseGenericInlineFormSetFactory, InlineFormSetMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a generic inline formset in a\\n    request.\\n    \"\"\"\\n\\n\\nclass BaseGenericInlineFormSetView(GenericInlineFormSetMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A base view for displaying a generic inline formset\\n    \"\"\"\\n\\n\\nclass GenericInlineFormSetView(BaseGenericInlineFormSetView, InlineFormSetView):\\n    \"\"\"\\n    A view for displaying a generic inline formset for a queryset belonging to a\\n    parent model\\n    \"\"\"\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "''"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/__init__.py'"}, "return_value": "'from extra_views.advanced import (\\n    CreateWithInlinesView,\\n    FormSetSuccessMessageMixin,\\n    InlineFormSetFactory,\\n    NamedFormsetsMixin,\\n    SuccessMessageMixin,\\n    UpdateWithInlinesView,\\n)\\nfrom extra_views.contrib.mixins import SearchableListMixin, SortableListMixin\\nfrom extra_views.dates import CalendarMonthView\\nfrom extra_views.formsets import FormSetView, InlineFormSetView, ModelFormSetView\\n\\n__version__ = \"0.14.0\"\\n\\n__all__ = [\\n    \"CreateWithInlinesView\",\\n    \"FormSetSuccessMessageMixin\",\\n    \"InlineFormSetFactory\",\\n    \"NamedFormsetsMixin\",\\n    \"SuccessMessageMixin\",\\n    \"UpdateWithInlinesView\",\\n    \"SearchableListMixin\",\\n    \"SortableListMixin\",\\n    \"CalendarMonthView\",\\n    \"FormSetView\",\\n    \"InlineFormSetView\",\\n    \"ModelFormSetView\",\\n]\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "'from django.contrib import messages\\nfrom django.forms.formsets import all_valid\\nfrom django.views.generic.base import ContextMixin\\nfrom django.views.generic.detail import SingleObjectTemplateResponseMixin\\nfrom django.views.generic.edit import FormView, ModelFormMixin\\n\\nfrom extra_views.formsets import BaseInlineFormSetFactory\\n\\n\\nclass InlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create an `InlineFormSet` from `inlineformset_factory` as\\n    one of multiple `InlineFormSet`s within a single view.\\n\\n    Subclasses `BaseInlineFormSetFactory` and passes in the necessary view arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Overrides construct_formset to attach the model class as\\n        an attribute of the returned formset instance.\\n        \"\"\"\\n        formset = super().construct_formset()\\n        formset.model = self.inline_model\\n        return formset\\n\\n\\nclass ModelFormWithInlinesMixin(ModelFormMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a modelform and inline\\n    formsets in a request.\\n\\n    The inlines should be subclasses of `InlineFormSetFactory`.\\n    \"\"\"\\n\\n    inlines = []\\n\\n    def get_inlines(self):\\n        \"\"\"\\n        Returns the inline formset classes\\n        \"\"\"\\n        return self.inlines[:]\\n\\n    def forms_valid(self, form, inlines):\\n        \"\"\"\\n        If the form and formsets are valid, save the associated models.\\n        \"\"\"\\n        response = self.form_valid(form)\\n        for formset in inlines:\\n            formset.save()\\n        return response\\n\\n    def forms_invalid(self, form, inlines):\\n        \"\"\"\\n        If the form or formsets are invalid, re-render the context data with the\\n        data-filled form and formsets and errors.\\n        \"\"\"\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines)\\n        )\\n\\n    def construct_inlines(self):\\n        \"\"\"\\n        Returns the inline formset instances\\n        \"\"\"\\n        inline_formsets = []\\n        for inline_class in self.get_inlines():\\n            inline_instance = inline_class(\\n                self.model, self.request, self.object, self.kwargs, self\\n            )\\n            inline_formset = inline_instance.construct_formset()\\n            inline_formsets.append(inline_formset)\\n        return inline_formsets\\n\\n\\nclass ProcessFormWithInlinesView(FormView):\\n    \"\"\"\\n    A mixin that renders a form and inline formsets on GET and processes it on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the form and formsets.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n        inlines = self.construct_inlines()\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines, **kwargs)\\n        )\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a form and formset instances with the\\n        passed POST variables and then checked for validity.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n\\n        initial_object = self.object\\n        if form.is_valid():\\n            self.object = form.save(commit=False)\\n            form_validated = True\\n        else:\\n            form_validated = False\\n\\n        inlines = self.construct_inlines()\\n\\n        if all_valid(inlines) and form_validated:\\n            return self.forms_valid(form, inlines)\\n        self.object = initial_object\\n        return self.forms_invalid(form, inlines)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseCreateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for creating an new object instance with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass CreateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseCreateWithInlinesView\\n):\\n    \"\"\"\\n    View for creating a new object instance with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass BaseUpdateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for updating an existing object with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass UpdateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseUpdateWithInlinesView\\n):\\n    \"\"\"\\n    View for updating an object with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass NamedFormsetsMixin(ContextMixin):\\n    \"\"\"\\n    A mixin for use with `CreateWithInlinesView` or `UpdateWithInlinesView` that lets\\n    you define the context variable for each inline.\\n    \"\"\"\\n\\n    inlines_names = []\\n\\n    def get_inlines_names(self):\\n        \"\"\"\\n        Returns a list of names of context variables for each inline in `inlines`.\\n        \"\"\"\\n        return self.inlines_names[:]\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        If `inlines_names` has been defined, add each formset to the context under\\n        its corresponding entry in `inlines_names`\\n        \"\"\"\\n        context = {}\\n        inlines_names = self.get_inlines_names()\\n\\n        if inlines_names:\\n            # We have formset or inlines in context, but never both\\n            context.update(zip(inlines_names, kwargs.get(\"inlines\", [])))\\n            if \"formset\" in kwargs:\\n                context[inlines_names[0]] = kwargs[\"formset\"]\\n        context.update(kwargs)\\n        return super().get_context_data(**context)\\n\\n\\nclass SuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on views with inlines if django.contrib.messages framework\\n    is used.\\n    In order to use just add mixin in to inheritance before main class, e.g.:\\n    class MyCreateWithInlinesView (SuccessMessageMixin, CreateWithInlinesView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super().forms_valid(form, inlines)\\n        success_message = self.get_success_message(form.cleaned_data, inlines)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data, inlines):\\n        return self.success_message % cleaned_data\\n\\n\\nclass FormSetSuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on FormSet views if django.contrib.messages framework\\n    is used. In order to use just add mixin in to inheritance before main\\n    class, e.g.:\\n    class MyFormSetView (FormSetSuccessMessageMixin, ModelFormSetView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def formset_valid(self, formset):\\n        response = super().formset_valid(formset)\\n        success_message = self.get_success_message(formset)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, formset):\\n        return self.success_message\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "''"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "'import datetime\\nimport functools\\nimport operator\\n\\nfrom django.contrib import messages\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.views.generic.base import ContextMixin\\n\\nVALID_STRING_LOOKUPS = (\\n    \"iexact\",\\n    \"contains\",\\n    \"icontains\",\\n    \"startswith\",\\n    \"istartswith\",\\n    \"endswith\",\\n    \"iendswith\",\\n    \"search\",\\n    \"regex\",\\n    \"iregex\",\\n)\\n\\n\\nclass SearchableListMixin(object):\\n    \"\"\"\\n    Filter queryset like a django admin search_fields does, but with little\\n     more intelligence:\\n    if self.search_split is set to True (by default) it will split query\\n     to words (by whitespace)\\n    Also tries to convert each word to date with self.search_date_formats and\\n     then search each word in separate field\\n    e.g. with query \\'foo bar\\' you can find object with\\n     obj.field1__icontains=\\'foo\\' and obj.field2__icontains==\\'bar\\'\\n\\n    To provide custom lookup just set one of the search_fields to tuple,\\n    e.g. search_fields = [(\\'field1\\', \\'iexact\\'), \\'field2\\', (\\'field3\\', \\'startswith\\')]\\n\\n    This class is designed to be used with django.generic.ListView\\n\\n    You could specify query by overriding get_search_query method\\n    by default this method will try to get \\'q\\' key from request.GET\\n    (this can be disabled with search_use_q=False)\\n    \"\"\"\\n\\n    search_fields = [\"id\"]\\n    search_date_fields = None\\n    search_date_formats = [\"%d.%m.%y\", \"%d.%m.%Y\"]\\n    search_split = True\\n    search_use_q = True\\n    check_lookups = True\\n\\n    def get_words(self, query):\\n        if self.search_split:\\n            return query.split()\\n        return [query]\\n\\n    def get_search_fields_with_filters(self):\\n        fields = []\\n        for sf in self.search_fields:\\n            if isinstance(sf, str):\\n                fields.append((sf, \"icontains\"))\\n            else:\\n                if self.check_lookups and sf[1] not in VALID_STRING_LOOKUPS:\\n                    raise ValueError(\"Invalid string lookup - %s\" % sf[1])\\n                fields.append(sf)\\n        return fields\\n\\n    def try_convert_to_date(self, word):\\n        \"\"\"\\n        Tries to convert word to date(datetime) using search_date_formats\\n        Return None if word fits no one format\\n        \"\"\"\\n        for frm in self.search_date_formats:\\n            try:\\n                return datetime.datetime.strptime(word, frm).date()\\n            except ValueError:\\n                pass\\n        return None\\n\\n    def get_search_query(self):\\n        \"\"\"\\n        Get query from request.GET \\'q\\' parameter when search_use_q is set to True\\n        Override this method to provide your own query to search\\n        \"\"\"\\n        return self.search_use_q and self.request.GET.get(\"q\", \"\").strip()\\n\\n    def get_queryset(self):\\n        qs = super(SearchableListMixin, self).get_queryset()\\n        query = self.get_search_query()\\n        if query:\\n            w_qs = []\\n            search_pairs = self.get_search_fields_with_filters()\\n            for word in self.get_words(query):\\n                filters = [\\n                    Q(**{\"%s__%s\" % (pair[0], pair[1]): word}) for pair in search_pairs\\n                ]\\n                if self.search_date_fields:\\n                    dt = self.try_convert_to_date(word)\\n                    if dt:\\n                        filters.extend(\\n                            [\\n                                Q(**{field_name: dt})\\n                                for field_name in self.search_date_fields\\n                            ]\\n                        )\\n                w_qs.append(functools.reduce(operator.or_, filters))\\n            qs = qs.filter(functools.reduce(operator.and_, w_qs))\\n            qs = qs.distinct()\\n        return qs\\n\\n\\nclass SortHelper(object):\\n    def __init__(\\n        self, request, sort_fields_aliases, sort_param_name, sort_type_param_name\\n    ):\\n        # Create a list from sort_fields_aliases, in case it is a generator,\\n        # since we want to iterate through it multiple times.\\n        sort_fields_aliases = list(sort_fields_aliases)\\n\\n        self.initial_params = request.GET.copy()\\n        self.sort_fields = dict(sort_fields_aliases)\\n        self.inv_sort_fields = dict((v, k) for k, v in sort_fields_aliases)\\n        self.initial_sort = self.inv_sort_fields.get(\\n            self.initial_params.get(sort_param_name), None\\n        )\\n        self.initial_sort_type = self.initial_params.get(sort_type_param_name, \"asc\")\\n        self.sort_param_name = sort_param_name\\n        self.sort_type_param_name = sort_type_param_name\\n\\n        for field, alias in self.sort_fields.items():\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s\" % alias,\\n                functools.partial(self.get_params_for_field, field),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_asc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"asc\"),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_desc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"desc\"),\\n            )\\n            setattr(\\n                self,\\n                \"is_sorted_by_%s\" % alias,\\n                functools.partial(self.is_sorted_by, field),\\n            )\\n\\n    def is_sorted_by(self, field_name):\\n        return field_name == self.initial_sort and self.initial_sort_type or False\\n\\n    def get_params_for_field(self, field_name, sort_type=None):\\n        \"\"\"\\n        If sort_type is None - inverse current sort for field, if no sorted - use asc\\n        \"\"\"\\n        if not sort_type:\\n            if self.initial_sort == field_name:\\n                sort_type = \"desc\" if self.initial_sort_type == \"asc\" else \"asc\"\\n            else:\\n                sort_type = \"asc\"\\n        self.initial_params[self.sort_param_name] = self.sort_fields[field_name]\\n        self.initial_params[self.sort_type_param_name] = sort_type\\n        return \"?%s\" % self.initial_params.urlencode()\\n\\n    def get_sort(self):\\n        if not self.initial_sort:\\n            return None\\n        sort = \"%s\" % self.initial_sort\\n        if self.initial_sort_type == \"desc\":\\n            sort = \"-%s\" % sort\\n        return sort\\n\\n\\nclass SortableListMixin(ContextMixin):\\n    \"\"\"\\n    You can provide either sort_fields as a plain list like\\n     [\\'id\\', \\'some\\', \\'foo__bar\\', ...]\\n    or, if you want to hide original field names you can provide list of tuples with\\n    alias that will be used:\\n    [(\\'id\\', \\'by_id\\'), (\\'some\\', \\'show_this\\'), (\\'foo__bar\\', \\'bar\\')]\\n\\n    If sort_param_name exists in query but sort_type_param_name is omitted queryset\\n     will be sorted as \\'asc\\'\\n    \"\"\"\\n\\n    sort_fields = []\\n    sort_fields_aliases = []\\n    sort_param_name = \"o\"\\n    sort_type_param_name = \"ot\"\\n\\n    def get_sort_fields(self):\\n        if self.sort_fields:\\n            return zip(self.sort_fields, self.sort_fields)\\n        return self.sort_fields_aliases\\n\\n    def get_sort_helper(self):\\n        return SortHelper(\\n            self.request,\\n            self.get_sort_fields(),\\n            self.sort_param_name,\\n            self.sort_type_param_name,\\n        )\\n\\n    def _sort_queryset(self, queryset):\\n        self.sort_helper = self.get_sort_helper()\\n        sort = self.sort_helper.get_sort()\\n        if sort:\\n            queryset = queryset.order_by(sort)\\n        return queryset\\n\\n    def get_queryset(self):\\n        qs = super(SortableListMixin, self).get_queryset()\\n        if self.sort_fields and self.sort_fields_aliases:\\n            raise ImproperlyConfigured(\\n                \"You should provide sort_fields or sort_fields_aliaces but not both\"\\n            )\\n        return self._sort_queryset(qs)\\n\\n    def get_context_data(self, **kwargs):\\n        context = {}\\n        if hasattr(self, \"sort_helper\"):\\n            context[\"sort_helper\"] = self.sort_helper\\n        context.update(kwargs)\\n        return super(SortableListMixin, self).get_context_data(**context)\\n\\n\\nclass SuccessMessageWithInlinesMixin(object):\\n    \"\"\"\\n    Adds a success message on successful form submission.\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super(SuccessMessageWithInlinesMixin, self).forms_valid(\\n            form, inlines\\n        )\\n        success_message = self.get_success_message(form.cleaned_data)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data):\\n        return self.success_message % cleaned_data\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "'import datetime\\nimport math\\nfrom calendar import Calendar\\nfrom collections import defaultdict\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.utils.translation import gettext_lazy as _\\nfrom django.views.generic.dates import (\\n    DateMixin,\\n    MonthMixin,\\n    YearMixin,\\n    _date_from_string,\\n)\\nfrom django.views.generic.list import BaseListView, MultipleObjectTemplateResponseMixin\\n\\nDAYS = (\\n    _(\"Monday\"),\\n    _(\"Tuesday\"),\\n    _(\"Wednesday\"),\\n    _(\"Thursday\"),\\n    _(\"Friday\"),\\n    _(\"Saturday\"),\\n    _(\"Sunday\"),\\n)\\n\\n\\ndef daterange(start_date, end_date):\\n    \"\"\"\\n    Returns an iterator of dates between two provided ones\\n    \"\"\"\\n    for n in range(int((end_date - start_date).days + 1)):\\n        yield start_date + datetime.timedelta(n)\\n\\n\\nclass BaseCalendarMonthView(DateMixin, YearMixin, MonthMixin, BaseListView):\\n    \"\"\"\\n    A base view for displaying a calendar month\\n    \"\"\"\\n\\n    first_of_week = 0  # 0 = Monday, 6 = Sunday\\n    paginate_by = None  # We don\\'t want to use this part of MultipleObjectMixin\\n    date_field = None\\n    end_date_field = None  # For supporting events with duration\\n\\n    def get_paginate_by(self, queryset):\\n        if self.paginate_by is not None:\\n            raise ImproperlyConfigured(\\n                \"\\'%s\\' cannot be paginated, it is a calendar view\"\\n                % self.__class__.__name__\\n            )\\n        return None\\n\\n    def get_allow_future(self):\\n        return True\\n\\n    def get_end_date_field(self):\\n        \"\"\"\\n        Returns the model field to use for end dates\\n        \"\"\"\\n        return self.end_date_field\\n\\n    def get_start_date(self, obj):\\n        \"\"\"\\n        Returns the start date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_end_date(self, obj):\\n        \"\"\"\\n        Returns the end date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_end_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_first_of_week(self):\\n        \"\"\"\\n        Returns an integer representing the first day of the week.\\n\\n        0 represents Monday, 6 represents Sunday.\\n        \"\"\"\\n        if self.first_of_week is None:\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week is required.\" % self.__class__.__name__\\n            )\\n        if self.first_of_week not in range(7):\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week must be an integer between 0 and 6.\"\\n                % self.__class__.__name__\\n            )\\n        return self.first_of_week\\n\\n    def get_queryset(self):\\n        \"\"\"\\n        Returns a queryset of models for the month requested\\n        \"\"\"\\n        qs = super().get_queryset()\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date_field = self.get_date_field()\\n        end_date_field = self.get_end_date_field()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        since = date\\n        until = self.get_next_month(date)\\n\\n        # Adjust our start and end dates to allow for next and previous\\n        # month edges\\n        if since.weekday() != self.get_first_of_week():\\n            diff = math.fabs(since.weekday() - self.get_first_of_week())\\n            since = since - datetime.timedelta(days=diff)\\n\\n        if until.weekday() != ((self.get_first_of_week() + 6) % 7):\\n            diff = math.fabs(((self.get_first_of_week() + 6) % 7) - until.weekday())\\n            until = until + datetime.timedelta(days=diff)\\n\\n        if end_date_field:\\n            # 5 possible conditions for showing an event:\\n\\n            # 1) Single day event, starts after \\'since\\'\\n            # 2) Multi-day event, starts after \\'since\\' and ends before \\'until\\'\\n            # 3) Starts before \\'since\\' and ends after \\'since\\' and before \\'until\\'\\n            # 4) Starts after \\'since\\' but before \\'until\\' and ends after \\'until\\'\\n            # 5) Starts before \\'since\\' and ends after \\'until\\'\\n            predicate1 = Q(**{\"%s__gte\" % date_field: since, end_date_field: None})\\n            predicate2 = Q(\\n                **{\"%s__gte\" % date_field: since, \"%s__lt\" % end_date_field: until}\\n            )\\n            predicate3 = Q(\\n                **{\\n                    \"%s__lt\" % date_field: since,\\n                    \"%s__gte\" % end_date_field: since,\\n                    \"%s__lt\" % end_date_field: until,\\n                }\\n            )\\n            predicate4 = Q(\\n                **{\\n                    \"%s__gte\" % date_field: since,\\n                    \"%s__lt\" % date_field: until,\\n                    \"%s__gte\" % end_date_field: until,\\n                }\\n            )\\n            predicate5 = Q(\\n                **{\"%s__lt\" % date_field: since, \"%s__gte\" % end_date_field: until}\\n            )\\n            return qs.filter(\\n                predicate1 | predicate2 | predicate3 | predicate4 | predicate5\\n            )\\n        return qs.filter(**{\"%s__gte\" % date_field: since})\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        Injects variables necessary for rendering the calendar into the context.\\n\\n        Variables added are: `calendar`, `weekdays`, `month`, `next_month` and\\n        `previous_month`.\\n        \"\"\"\\n        data = super().get_context_data(**kwargs)\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        cal = Calendar(self.get_first_of_week())\\n\\n        month_calendar = []\\n        now = datetime.datetime.utcnow()\\n\\n        date_lists = defaultdict(list)\\n        multidate_objs = []\\n\\n        for obj in data[\"object_list\"]:\\n            obj_date = self.get_start_date(obj)\\n            end_date_field = self.get_end_date_field()\\n\\n            if end_date_field:\\n                end_date = self.get_end_date(obj)\\n                if end_date and end_date != obj_date:\\n                    multidate_objs.append(\\n                        {\\n                            \"obj\": obj,\\n                            \"range\": [x for x in daterange(obj_date, end_date)],\\n                        }\\n                    )\\n                    continue  # We don\\'t put multi-day events in date_lists\\n            date_lists[obj_date].append(obj)\\n\\n        for week in cal.monthdatescalendar(date.year, date.month):\\n            week_range = set(daterange(week[0], week[6]))\\n            week_events = []\\n\\n            for val in multidate_objs:\\n                intersect_length = len(week_range.intersection(val[\"range\"]))\\n\\n                if intersect_length:\\n                    # Event happens during this week\\n                    slot = 1\\n                    width = (\\n                        intersect_length  # How many days is the event during this week?\\n                    )\\n                    nowrap_previous = (\\n                        True  # Does the event continue from the previous week?\\n                    )\\n                    nowrap_next = True  # Does the event continue to the next week?\\n\\n                    if val[\"range\"][0] >= week[0]:\\n                        slot = 1 + (val[\"range\"][0] - week[0]).days\\n                    else:\\n                        nowrap_previous = False\\n                    if val[\"range\"][-1] > week[6]:\\n                        nowrap_next = False\\n\\n                    week_events.append(\\n                        {\\n                            \"event\": val[\"obj\"],\\n                            \"slot\": slot,\\n                            \"width\": width,\\n                            \"nowrap_previous\": nowrap_previous,\\n                            \"nowrap_next\": nowrap_next,\\n                        }\\n                    )\\n\\n            week_calendar = {\"events\": week_events, \"date_list\": []}\\n            for day in week:\\n                week_calendar[\"date_list\"].append(\\n                    {\\n                        \"day\": day,\\n                        \"events\": date_lists[day],\\n                        \"today\": day == now.date(),\\n                        \"is_current_month\": day.month == date.month,\\n                    }\\n                )\\n            month_calendar.append(week_calendar)\\n\\n        data[\"calendar\"] = month_calendar\\n        data[\"weekdays\"] = [DAYS[x] for x in cal.iterweekdays()]\\n        data[\"month\"] = date\\n        data[\"next_month\"] = self.get_next_month(date)\\n        data[\"previous_month\"] = self.get_previous_month(date)\\n\\n        return data\\n\\n\\nclass CalendarMonthView(MultipleObjectTemplateResponseMixin, BaseCalendarMonthView):\\n    \"\"\"\\n    A view for displaying a calendar month, and rendering a template response\\n    \"\"\"\\n\\n    template_name_suffix = \"_calendar_month\"\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "'from django.forms.formsets import formset_factory\\nfrom django.forms.models import inlineformset_factory, modelformset_factory\\nfrom django.http import HttpResponseRedirect\\nfrom django.views.generic.base import ContextMixin, TemplateResponseMixin, View\\nfrom django.views.generic.detail import (\\n    SingleObjectMixin,\\n    SingleObjectTemplateResponseMixin,\\n)\\nfrom django.views.generic.list import (\\n    MultipleObjectMixin,\\n    MultipleObjectTemplateResponseMixin,\\n)\\n\\n\\nclass BaseFormSetFactory(object):\\n    \"\"\"\\n    Base class for constructing a FormSet from `formset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    initial = []\\n    form_class = None\\n    formset_class = None\\n    prefix = None\\n    formset_kwargs = {}\\n    factory_kwargs = {}\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Returns an instance of the formset\\n        \"\"\"\\n        formset_class = self.get_formset()\\n        return formset_class(**self.get_formset_kwargs())\\n\\n    def get_initial(self):\\n        \"\"\"\\n        Returns a copy of the initial data to use for formsets on this view.\\n        \"\"\"\\n        return self.initial[:]\\n\\n    def get_prefix(self):\\n        \"\"\"\\n        Returns the prefix used for formsets on this view.\\n        \"\"\"\\n        return self.prefix\\n\\n    def get_formset_class(self):\\n        \"\"\"\\n        Returns the formset class to use in the formset factory\\n        \"\"\"\\n        return self.formset_class\\n\\n    def get_form_class(self):\\n        \"\"\"\\n        Returns the form class to use with the formset in this view\\n        \"\"\"\\n        return self.form_class\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the formset factory\\n        \"\"\"\\n        return formset_factory(self.get_form_class(), **self.get_factory_kwargs())\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = self.formset_kwargs.copy()\\n        kwargs.update({\"initial\": self.get_initial(), \"prefix\": self.get_prefix()})\\n\\n        if self.request.method in (\"POST\", \"PUT\"):\\n            kwargs.update(\\n                {\"data\": self.request.POST.copy(), \"files\": self.request.FILES}\\n            )\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = self.factory_kwargs.copy()\\n        if self.get_formset_class():\\n            kwargs[\"formset\"] = self.get_formset_class()\\n        return kwargs\\n\\n\\nclass FormSetMixin(BaseFormSetFactory, ContextMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single formset in a request.\\n    \"\"\"\\n\\n    success_url = None\\n\\n    def get_success_url(self):\\n        \"\"\"\\n        Returns the supplied URL.\\n        \"\"\"\\n        if self.success_url:\\n            url = self.success_url\\n        else:\\n            # Default to returning to the same page\\n            url = self.request.get_full_path()\\n        return url\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid redirect to the supplied URL\\n        \"\"\"\\n        return HttpResponseRedirect(self.get_success_url())\\n\\n    def formset_invalid(self, formset):\\n        \"\"\"\\n        If the formset is invalid, re-render the context data with the\\n        data-filled formset and errors.\\n        \"\"\"\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n\\nclass ModelFormSetMixin(FormSetMixin, MultipleObjectMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single model formset\\n    in a request.\\n\\n    Uses `modelformset_factory`.\\n    \"\"\"\\n\\n    exclude = None\\n    fields = None\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"queryset\"] = self.get_queryset()\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the model formset factory\\n        \"\"\"\\n        return modelformset_factory(self.model, **self.get_factory_kwargs())\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid, save the associated models.\\n        \"\"\"\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass BaseInlineFormSetFactory(BaseFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a FormSet from `inlineformset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    model = None\\n    inline_model = None\\n    exclude = None\\n    fields = None\\n\\n    def get_inline_model(self):\\n        \"\"\"\\n        Returns the inline model to use with the inline formset\\n        \"\"\"\\n        return self.inline_model\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"instance\"] = self.object\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the inline formset factory\\n        \"\"\"\\n        return inlineformset_factory(\\n            self.model, self.get_inline_model(), **self.get_factory_kwargs()\\n        )\\n\\n\\nclass InlineFormSetMixin(BaseInlineFormSetFactory, SingleObjectMixin, FormSetMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single inline formset\\n    in a request.\\n    \"\"\"\\n\\n    def formset_valid(self, formset):\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass ProcessFormSetView(View):\\n    \"\"\"\\n    A mixin that processes a formset on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the formset.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a formset instance with the passed\\n        POST variables and then checked for validity.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        if formset.is_valid():\\n            return self.formset_valid(formset)\\n        else:\\n            return self.formset_invalid(formset)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseFormSetView(FormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a formset\\n    \"\"\"\\n\\n\\nclass FormSetView(TemplateResponseMixin, BaseFormSetView):\\n    \"\"\"\\n    A view for displaying a formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseModelFormSetView(ModelFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a model formset\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass ModelFormSetView(MultipleObjectTemplateResponseMixin, BaseModelFormSetView):\\n    \"\"\"\\n    A view for displaying a model formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseInlineFormSetView(InlineFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying an inline formset for a queryset belonging to\\n    a parent model\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass InlineFormSetView(SingleObjectTemplateResponseMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A view for displaying an inline formset for a queryset belonging to a parent model\\n    \"\"\"\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "'from django.contrib.contenttypes.forms import generic_inlineformset_factory\\n\\nfrom extra_views.formsets import (\\n    BaseInlineFormSetFactory,\\n    BaseInlineFormSetView,\\n    InlineFormSetMixin,\\n    InlineFormSetView,\\n)\\n\\n\\nclass BaseGenericInlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a GenericInlineFormSet from\\n    `generic_inlineformset_factory` in a view.\\n    \"\"\"\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the final formset class from generic_inlineformset_factory.\\n        \"\"\"\\n        result = generic_inlineformset_factory(\\n            self.inline_model, **self.get_factory_kwargs()\\n        )\\n        return result\\n\\n\\nclass GenericInlineFormSetFactory(BaseGenericInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create a `GenericInlineFormSet` from `generic_inlineformset_factory`\\n    as one of multiple `GenericInlineFormSet`s within a single view.\\n\\n    Subclasses `BaseGenericInlineFormSetFactory` and passes in the necessary view\\n    arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n\\nclass GenericInlineFormSetMixin(BaseGenericInlineFormSetFactory, InlineFormSetMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a generic inline formset in a\\n    request.\\n    \"\"\"\\n\\n\\nclass BaseGenericInlineFormSetView(GenericInlineFormSetMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A base view for displaying a generic inline formset\\n    \"\"\"\\n\\n\\nclass GenericInlineFormSetView(BaseGenericInlineFormSetView, InlineFormSetView):\\n    \"\"\"\\n    A view for displaying a generic inline formset for a queryset belonging to a\\n    parent model\\n    \"\"\"\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "''"}]}, "validate_fail_under": {"line": 56, "args": [{"func_args": {"num_str": "'85'"}, "return_value": "85"}, {"func_args": {"num_str": "'85'"}, "return_value": "85"}], "text": "def validate_fail_under(num_str):\n    try:\n        value = int(num_str)\n    except ValueError:\n        try:\n            value = float(num_str)\n        except ValueError:\n            raise argparse.ArgumentTypeError('An integer or float value is required.')\n    if value > 100:\n        raise argparse.ArgumentTypeError('Your desire for over-achievement is admirable but misplaced. '\n                                         'The maximum value is 100. Perhaps write more integration tests?')\n    return value"}, "validate_report": {"line": 30, "args": [{"func_args": {"arg": "'xml'"}, "return_value": "('xml', None)"}, {"func_args": {"arg": "'term'"}, "return_value": "('term', None)"}, {"func_args": {"arg": "'xml'"}, "return_value": "('xml', None)"}, {"func_args": {"arg": "'term'"}, "return_value": "('term', None)"}], "text": "def validate_report(arg):\n    file_choices = ['annotate', 'html', 'xml']\n    term_choices = ['term', 'term-missing']\n    term_modifier_choices = ['skip-covered']\n    all_choices = term_choices + file_choices\n    values = arg.split(\":\", 1)\n    report_type = values[0]\n    if report_type not in all_choices + ['']:\n        msg = f'invalid choice: \"{arg}\" (choose from \"{all_choices}\")'\n        raise argparse.ArgumentTypeError(msg)\n\n    if len(values) == 1:\n        return report_type, None\n\n    report_modifier = values[1]\n    if report_type in term_choices and report_modifier in term_modifier_choices:\n        return report_type, report_modifier\n\n    if report_type not in file_choices:\n        msg = 'output specifier not supported for: \"{}\" (choose from \"{}\")'.format(arg,\n                                                                                   file_choices)\n        raise argparse.ArgumentTypeError(msg)\n\n    return values"}, "_format_trimmed": {"line": 1262, "args": [{"func_args": {"format": "' - {}'", "msg": "'django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.'", "available_width": "48"}, "return_value": "' - django.core.exceptions.ImproperlyConfigure...'"}], "text": "def _format_trimmed(format: str, msg: str, available_width: int) -> Optional[str]:\n    \"\"\"Format msg into format, ellipsizing it if doesn't fit in available_width.\n\n    Returns None if even the ellipsis can't fit.\n    \"\"\"\n    # Only use the first line.\n    i = msg.find(\"\\n\")\n    if i != -1:\n        msg = msg[:i]\n\n    ellipsis = \"...\"\n    format_width = wcswidth(format.format(\"\"))\n    if format_width + len(ellipsis) > available_width:\n        return None\n\n    if format_width + wcswidth(msg) > available_width:\n        available_width -= len(ellipsis)\n        msg = msg[:available_width]\n        while format_width + wcswidth(msg) > available_width:\n            msg = msg[:-1]\n        msg += ellipsis\n\n    return format.format(msg)"}, "pluralize": {"line": 1350, "args": [{"func_args": {"count": "1", "noun": "'warnings'"}, "return_value": "(1, 'warning')"}, {"func_args": {"count": "1", "noun": "'error'"}, "return_value": "(1, 'error')"}], "text": "def pluralize(count: int, noun: str) -> Tuple[int, str]:\n    # No need to pluralize words such as `failed` or `passed`.\n    if noun not in [\"error\", \"warnings\", \"test\"]:\n        return count, noun\n\n    # The `warnings` key is plural. To avoid API breakage, we keep it that way but\n    # set it to singular here so we can determine plurality in the same way as we do\n    # for `error`.\n    noun = noun.replace(\"warnings\", \"warning\")\n\n    return count, noun + \"s\" if count != 1 else noun"}, "format_session_duration": {"line": 1377, "args": [{"func_args": {"seconds": "1.8930442333221436"}, "return_value": "'1.89s'"}], "text": "def format_session_duration(seconds: float) -> str:\n    \"\"\"Format the given seconds in a human readable manner to show in the final summary.\"\"\"\n    if seconds < 60:\n        return f\"{seconds:.2f}s\"\n    else:\n        dt = datetime.timedelta(seconds=int(seconds))\n        return f\"{seconds:.2f}s ({dt})\""}, "get_terminal_width": {"line": 15, "args": [{"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}], "text": "def get_terminal_width() -> int:\n    width, _ = shutil.get_terminal_size(fallback=(80, 24))\n\n    # The Windows get_terminal_size may be bogus, let's sanify a bit.\n    if width < 40:\n        width = 80\n\n    return width"}, "_get_boolean_value": {"line": 240, "args": [{"func_args": {"x": "True", "name": "'django_find_project'", "default": "None"}, "return_value": "True"}, {"func_args": {"x": "None", "name": "'FAIL_INVALID_TEMPLATE_VARS'", "default": "None"}, "return_value": "False"}], "text": "def _get_boolean_value(\n    x: Union[None, bool, str],\n    name: str,\n    default: Optional[bool] = None,\n) -> bool:\n    if x is None:\n        return bool(default)\n    if isinstance(x, bool):\n        return x\n    possible_values = {\"true\": True, \"false\": False, \"1\": True, \"0\": False}\n    try:\n        return possible_values[x.lower()]\n    except KeyError:\n        raise ValueError(\n            \"{} is not a valid value for {}. \"\n            \"It must be one of {}.\".format(x, name, \", \".join(possible_values.keys()))\n        )"}, "_add_django_project_to_path": {"line": 185, "args": [{"func_args": {"args": "['--cov', '--cov-fail-under=85', '--cov-report=xml', '--cov-report=term']"}, "return_value": "'pytest-django found a Django project in /usr/app/src/test_repos/django-extra-views (it contains manage.py) and added it to the Python path.\\nIf this is wrong, add \"django_find_project = false\" to pytest.ini and explicitly manage your Python path.'"}], "text": "def _add_django_project_to_path(args) -> str:\n    def is_django_project(path: pathlib.Path) -> bool:\n        try:\n            return path.is_dir() and (path / \"manage.py\").exists()\n        except OSError:\n            return False\n\n    def arg_to_path(arg: str) -> pathlib.Path:\n        # Test classes or functions can be appended to paths separated by ::\n        arg = arg.split(\"::\", 1)[0]\n        return pathlib.Path(arg)\n\n    def find_django_path(args) -> Optional[pathlib.Path]:\n        str_args = (str(arg) for arg in args)\n        path_args = [arg_to_path(x) for x in str_args if not x.startswith(\"-\")]\n\n        cwd = pathlib.Path.cwd()\n        if not path_args:\n            path_args.append(cwd)\n        elif cwd not in path_args:\n            path_args.append(cwd)\n\n        for arg in path_args:\n            if is_django_project(arg):\n                return arg\n            for parent in arg.parents:\n                if is_django_project(parent):\n                    return parent\n        return None\n\n    project_dir = find_django_path(args)\n    if project_dir:\n        sys.path.insert(0, str(project_dir.absolute()))\n        return PROJECT_FOUND % project_dir\n    return PROJECT_NOT_FOUND"}, "_get_option_with_source": {"line": 316, "args": [{"func_args": {"option": "None", "envname": "'DJANGO_SETTINGS_MODULE'"}, "return_value": "(None, None)"}, {"func_args": {"option": "None", "envname": "'DJANGO_CONFIGURATION'"}, "return_value": "(None, None)"}], "text": "def _get_option_with_source(\n        option: Optional[str],\n        envname: str,\n    ) -> Union[Tuple[str, str], Tuple[None, None]]:\n        if option:\n            return option, \"option\"\n        if envname in os.environ:\n            return os.environ[envname], \"env\"\n        cfgval = early_config.getini(envname)\n        if cfgval:\n            return cfgval, \"ini\"\n        return None, None"}, "parts": {"line": 420, "args": [{"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views', '/usr', '/usr/app/src', '/', '/usr/app', '/usr/app/src/test_repos/django-extra-views/extra_views/advanced.py', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views/contrib', '/', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views/dates.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views/dates.py', '/', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views/extra_views/formsets.py', '/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views', '/usr', '/usr/app/src', '/', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views/generic.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views', '/usr/app/src/test_repos/django-extra-views/extra_views/generic.py', '/usr', '/usr/app/src', '/', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views/models.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views/models.py', '/', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views', '/usr', '/usr/app/src/test_repos/django-extra-views/extra_views/contrib/__init__.py', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views/contrib', '/', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views/contrib', '/', '/usr/app', '/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views/contrib', '/', '/usr/app', '/usr/app/src/test_repos/django-extra-views/extra_views/contrib/mixins.py', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/forms.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views/extra_views_tests/forms.py', '/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/formsets.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/', '/usr/app', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/formsets.py', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/migrations'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/migrations', '/usr/app/src', '/', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/models.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/models.py', '/', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/settings.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/settings.py', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/', '/usr/app', '/usr/app/src/test_repos', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/tests.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/tests.py', '/', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/urls.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/urls.py', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/views.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/views.py', '/usr/app/src', '/', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/migrations/0001_initial.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/migrations/0001_initial.py', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/migrations', '/usr/app/src', '/', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/migrations/__init__.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/migrations', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/migrations/__init__.py', '/', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/404.html'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/', '/usr/app', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/404.html', '/usr/app/src/test_repos', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views', '/', '/usr/app', '/usr/app/src/test_repos', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/address_formset.html'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/address_formset.html', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views', '/', '/usr/app', '/usr/app/src/test_repos', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/event_calendar_month.html'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/event_calendar_month.html', '/', '/usr/app', '/usr/app/src/test_repos', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/formsets_multiview.html'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views', '/', '/usr/app', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/formsets_multiview.html', '/usr/app/src/test_repos', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/inline_formset.html'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/inline_formset.html', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views', '/', '/usr/app', '/usr/app/src/test_repos', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/item_formset.html'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/item_formset.html', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views', '/', '/usr/app', '/usr/app/src/test_repos', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/item_list.html'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/item_list.html', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views', '/', '/usr/app', '/usr/app/src/test_repos', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/order_and_items.html'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/order_and_items.html', '/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views', '/', '/usr/app', '/usr/app/src/test_repos', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/orderaddress_multiview.html'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/orderaddress_multiview.html', '/', '/usr/app', '/usr/app/src/test_repos', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/orderitems_multiview.html'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/orderitems_multiview.html', '/', '/usr/app', '/usr/app/src/test_repos', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/paged_formset.html'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/paged_formset.html', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views', '/', '/usr/app', '/usr/app/src/test_repos', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/sortable_item_list.html'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/sortable_item_list.html', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views', '/', '/usr/app', '/usr/app/src/test_repos', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/success.html'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views/success.html', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates/extra_views', '/', '/usr/app', '/usr/app/src/test_repos', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/templates'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/django-extra-views/extra_views_tests/migrations/0001_initial.py'"}, "return_value": "{'/usr/app/src/test_repos/django-extra-views', '/usr/app/src/test_repos/django-extra-views/extra_views_tests', '/usr', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/migrations/0001_initial.py', '/usr/app/src/test_repos/django-extra-views/extra_views_tests/migrations', '/usr/app/src', '/', '/usr/app', '/usr/app/src/test_repos'}"}], "text": "def parts(s: str) -> Set[str]:\n    parts = s.split(sep)\n    return {sep.join(parts[: i + 1]) or sep for i in range(len(parts))}"}, "_get_stderr_fileno": {"line": 68, "args": [{"func_args": {}, "return_value": "2"}, {"func_args": {}, "return_value": "2"}]}, "_get_auto_indent": {"line": 113, "args": [{"func_args": {"auto_indent_option": "None"}, "return_value": "0"}, {"func_args": {"auto_indent_option": "None"}, "return_value": "0"}]}, "scope2index": {"line": 803, "args": [{"func_args": {"scope": "'session'", "descr": "\"Fixture 'pytestconfig'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'capfd'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'capfdbinary'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'capsys'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'capsysbinary'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'tmp_path'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'tmp_path_factory'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'tmpdir'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'tmpdir_factory'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'monkeypatch'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'recwarn'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'record_property'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'record_testsuite_property'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'record_xml_attribute'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'doctest_namespace'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'cache'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'caplog'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture '_dj_autoclear_mailbox'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture '_django_clear_site_cache'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture '_django_db_helper'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture '_django_db_marker'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture '_django_set_urlconf'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'class'", "descr": "\"Fixture '_django_setup_unittest'\"", "where": "None"}, "return_value": "3"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture '_fail_for_invalid_template_variable'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture '_live_server_helper'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture '_template_string_if_invalid_marker'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'admin_client'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'admin_user'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'async_client'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'async_rf'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'client'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'db'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'django_assert_max_num_queries'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'django_assert_num_queries'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'django_capture_on_commit_callbacks'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'django_db_blocker'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'django_db_createdb'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'django_db_keepdb'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'django_db_modify_db_settings'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'django_db_modify_db_settings_parallel_suffix'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'django_db_modify_db_settings_tox_suffix'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'django_db_modify_db_settings_xdist_suffix'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'django_db_reset_sequences'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'django_db_serialized_rollback'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'django_db_setup'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'django_db_use_migrations'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'django_mail_dnsname'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'django_mail_patch_dns'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'django_test_environment'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'django_user_model'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'django_username_field'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'live_server'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'mailoutbox'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'rf'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'settings'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'transactional_db'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'cov'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'no_cover'\"", "where": "None"}, "return_value": "4"}], "text": "def scope2index(scope: str, descr: str, where: Optional[str] = None) -> int:\n    \"\"\"Look up the index of ``scope`` and raise a descriptive value error\n    if not defined.\"\"\"\n    strscopes: Sequence[str] = scopes\n    try:\n        return strscopes.index(scope)\n    except ValueError:\n        fail(\n            \"{} {}got an unexpected scope value '{}'\".format(\n                descr, f\"from {where} \" if where else \"\", scope\n            ),\n            pytrace=False,\n        )"}, "reorder_items": {"line": 270, "args": [{"func_args": {"items": "[]"}, "return_value": "[]"}], "text": "def reorder_items(items: Sequence[nodes.Item]) -> List[nodes.Item]:\n    argkeys_cache: Dict[int, Dict[nodes.Item, Dict[_Key, None]]] = {}\n    items_by_argkey: Dict[int, Dict[_Key, Deque[nodes.Item]]] = {}\n    for scopenum in range(0, scopenum_function):\n        d: Dict[nodes.Item, Dict[_Key, None]] = {}\n        argkeys_cache[scopenum] = d\n        item_d: Dict[_Key, Deque[nodes.Item]] = defaultdict(deque)\n        items_by_argkey[scopenum] = item_d\n        for item in items:\n            keys = dict.fromkeys(get_parametrized_fixture_keys(item, scopenum), None)\n            if keys:\n                d[item] = keys\n                for key in keys:\n                    item_d[key].append(item)\n    items_dict = dict.fromkeys(items, None)\n    return list(reorder_items_atscope(items_dict, argkeys_cache, items_by_argkey, 0))"}, "wcswidth": {"line": 43, "args": [{"func_args": {"s": "''"}, "return_value": "0"}, {"func_args": {"s": "'ERROR extra_views_tests/tests.py'"}, "return_value": "32"}, {"func_args": {"s": "' - '"}, "return_value": "3"}, {"func_args": {"s": "'django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.'"}, "return_value": "238"}, {"func_args": {"s": "'django.core.exceptions.ImproperlyConfigured: '"}, "return_value": "45"}, {"func_args": {"s": "'django.core.exceptions.ImproperlyConfigured:'"}, "return_value": "44"}, {"func_args": {"s": "'django.core.exceptions.ImproperlyConfigured'"}, "return_value": "43"}, {"func_args": {"s": "'django.core.exceptions.ImproperlyConfigure'"}, "return_value": "42"}], "text": "def wcswidth(s: str) -> int:\n    \"\"\"Determine how many columns are needed to display a string in a terminal.\n\n    Returns -1 if the string contains non-printable characters.\n    \"\"\"\n    width = 0\n    for c in unicodedata.normalize(\"NFC\", s):\n        wc = wcwidth(c)\n        if wc < 0:\n            return -1\n        width += wc\n    return width"}, "wcwidth": {"line": 4, "args": [{"func_args": {"c": "'E'"}, "return_value": "1"}, {"func_args": {"c": "'R'"}, "return_value": "1"}, {"func_args": {"c": "'O'"}, "return_value": "1"}, {"func_args": {"c": "' '"}, "return_value": "1"}, {"func_args": {"c": "'e'"}, "return_value": "1"}, {"func_args": {"c": "'x'"}, "return_value": "1"}, {"func_args": {"c": "'t'"}, "return_value": "1"}, {"func_args": {"c": "'r'"}, "return_value": "1"}, {"func_args": {"c": "'a'"}, "return_value": "1"}, {"func_args": {"c": "'_'"}, "return_value": "1"}, {"func_args": {"c": "'v'"}, "return_value": "1"}, {"func_args": {"c": "'i'"}, "return_value": "1"}, {"func_args": {"c": "'w'"}, "return_value": "1"}, {"func_args": {"c": "'s'"}, "return_value": "1"}, {"func_args": {"c": "'/'"}, "return_value": "1"}, {"func_args": {"c": "'.'"}, "return_value": "1"}, {"func_args": {"c": "'p'"}, "return_value": "1"}, {"func_args": {"c": "'y'"}, "return_value": "1"}, {"func_args": {"c": "'-'"}, "return_value": "1"}, {"func_args": {"c": "'d'"}, "return_value": "1"}, {"func_args": {"c": "'j'"}, "return_value": "1"}, {"func_args": {"c": "'n'"}, "return_value": "1"}, {"func_args": {"c": "'g'"}, "return_value": "1"}, {"func_args": {"c": "'o'"}, "return_value": "1"}, {"func_args": {"c": "'c'"}, "return_value": "1"}, {"func_args": {"c": "'I'"}, "return_value": "1"}, {"func_args": {"c": "'m'"}, "return_value": "1"}, {"func_args": {"c": "'l'"}, "return_value": "1"}, {"func_args": {"c": "'C'"}, "return_value": "1"}, {"func_args": {"c": "'f'"}, "return_value": "1"}, {"func_args": {"c": "'u'"}, "return_value": "1"}, {"func_args": {"c": "':'"}, "return_value": "1"}, {"func_args": {"c": "'q'"}, "return_value": "1"}, {"func_args": {"c": "'N'"}, "return_value": "1"}, {"func_args": {"c": "'S'"}, "return_value": "1"}, {"func_args": {"c": "'T'"}, "return_value": "1"}, {"func_args": {"c": "'A'"}, "return_value": "1"}, {"func_args": {"c": "'L'"}, "return_value": "1"}, {"func_args": {"c": "'D'"}, "return_value": "1"}, {"func_args": {"c": "'P'"}, "return_value": "1"}, {"func_args": {"c": "','"}, "return_value": "1"}, {"func_args": {"c": "'b'"}, "return_value": "1"}, {"func_args": {"c": "'Y'"}, "return_value": "1"}, {"func_args": {"c": "'h'"}, "return_value": "1"}, {"func_args": {"c": "'J'"}, "return_value": "1"}, {"func_args": {"c": "'G'"}, "return_value": "1"}, {"func_args": {"c": "'M'"}, "return_value": "1"}, {"func_args": {"c": "'U'"}, "return_value": "1"}, {"func_args": {"c": "'('"}, "return_value": "1"}, {"func_args": {"c": "')'"}, "return_value": "1"}]}, "django_settings_is_configured": {"line": 16, "args": [{"func_args": {}, "return_value": "False"}], "text": "def django_settings_is_configured() -> bool:\n    \"\"\"Return whether the Django settings module has been configured.\n\n    This uses either the DJANGO_SETTINGS_MODULE environment variable, or the\n    configured flag in the Django settings object if django.conf has already\n    been imported.\n    \"\"\"\n    ret = bool(os.environ.get(\"DJANGO_SETTINGS_MODULE\"))\n\n    if not ret and \"django.conf\" in sys.modules:\n        django_conf = sys.modules[\"django.conf\"]  # type: Any\n        return django_conf.settings.configured\n\n    return ret"}, "combinable_files": {"line": 55, "args": [{"func_args": {"data_file": "'/usr/app/src/test_repos/django-extra-views/.coverage'", "data_paths": "None"}, "return_value": "['/usr/app/src/test_repos/django-extra-views/.coverage.cae2a1e14906.5669.932020']"}], "text": "def combinable_files(data_file, data_paths=None):\n    \"\"\"Make a list of data files to be combined.\n\n    `data_file` is a path to a data file.  `data_paths` is a list of files or\n    directories of files.\n\n    Returns a list of absolute file paths.\n    \"\"\"\n    data_dir, local = os.path.split(os.path.abspath(data_file))\n\n    data_paths = data_paths or [data_dir]\n    files_to_combine = []\n    for p in data_paths:\n        if os.path.isfile(p):\n            files_to_combine.append(os.path.abspath(p))\n        elif os.path.isdir(p):\n            pattern = os.path.join(os.path.abspath(p), f\"{local}.*\")\n            files_to_combine.extend(glob.glob(pattern))\n        else:\n            raise NoDataError(f\"Couldn't combine from non-existent path '{p}'\")\n    return files_to_combine"}, "source_encoding": {"line": 184, "args": [{"func_args": {"source": "b'from extra_views.advanced import (\\n    CreateWithInlinesView,\\n    FormSetSuccessMessageMixin,\\n    InlineFormSetFactory,\\n    NamedFormsetsMixin,\\n    SuccessMessageMixin,\\n    UpdateWithInlinesView,\\n)\\nfrom extra_views.contrib.mixins import SearchableListMixin, SortableListMixin\\nfrom extra_views.dates import CalendarMonthView\\nfrom extra_views.formsets import FormSetView, InlineFormSetView, ModelFormSetView\\n\\n__version__ = \"0.14.0\"\\n\\n__all__ = [\\n    \"CreateWithInlinesView\",\\n    \"FormSetSuccessMessageMixin\",\\n    \"InlineFormSetFactory\",\\n    \"NamedFormsetsMixin\",\\n    \"SuccessMessageMixin\",\\n    \"UpdateWithInlinesView\",\\n    \"SearchableListMixin\",\\n    \"SortableListMixin\",\\n    \"CalendarMonthView\",\\n    \"FormSetView\",\\n    \"InlineFormSetView\",\\n    \"ModelFormSetView\",\\n]\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.contrib import messages\\nfrom django.forms.formsets import all_valid\\nfrom django.views.generic.base import ContextMixin\\nfrom django.views.generic.detail import SingleObjectTemplateResponseMixin\\nfrom django.views.generic.edit import FormView, ModelFormMixin\\n\\nfrom extra_views.formsets import BaseInlineFormSetFactory\\n\\n\\nclass InlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create an `InlineFormSet` from `inlineformset_factory` as\\n    one of multiple `InlineFormSet`s within a single view.\\n\\n    Subclasses `BaseInlineFormSetFactory` and passes in the necessary view arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Overrides construct_formset to attach the model class as\\n        an attribute of the returned formset instance.\\n        \"\"\"\\n        formset = super().construct_formset()\\n        formset.model = self.inline_model\\n        return formset\\n\\n\\nclass ModelFormWithInlinesMixin(ModelFormMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a modelform and inline\\n    formsets in a request.\\n\\n    The inlines should be subclasses of `InlineFormSetFactory`.\\n    \"\"\"\\n\\n    inlines = []\\n\\n    def get_inlines(self):\\n        \"\"\"\\n        Returns the inline formset classes\\n        \"\"\"\\n        return self.inlines[:]\\n\\n    def forms_valid(self, form, inlines):\\n        \"\"\"\\n        If the form and formsets are valid, save the associated models.\\n        \"\"\"\\n        response = self.form_valid(form)\\n        for formset in inlines:\\n            formset.save()\\n        return response\\n\\n    def forms_invalid(self, form, inlines):\\n        \"\"\"\\n        If the form or formsets are invalid, re-render the context data with the\\n        data-filled form and formsets and errors.\\n        \"\"\"\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines)\\n        )\\n\\n    def construct_inlines(self):\\n        \"\"\"\\n        Returns the inline formset instances\\n        \"\"\"\\n        inline_formsets = []\\n        for inline_class in self.get_inlines():\\n            inline_instance = inline_class(\\n                self.model, self.request, self.object, self.kwargs, self\\n            )\\n            inline_formset = inline_instance.construct_formset()\\n            inline_formsets.append(inline_formset)\\n        return inline_formsets\\n\\n\\nclass ProcessFormWithInlinesView(FormView):\\n    \"\"\"\\n    A mixin that renders a form and inline formsets on GET and processes it on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the form and formsets.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n        inlines = self.construct_inlines()\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines, **kwargs)\\n        )\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a form and formset instances with the\\n        passed POST variables and then checked for validity.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n\\n        initial_object = self.object\\n        if form.is_valid():\\n            self.object = form.save(commit=False)\\n            form_validated = True\\n        else:\\n            form_validated = False\\n\\n        inlines = self.construct_inlines()\\n\\n        if all_valid(inlines) and form_validated:\\n            return self.forms_valid(form, inlines)\\n        self.object = initial_object\\n        return self.forms_invalid(form, inlines)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseCreateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for creating an new object instance with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass CreateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseCreateWithInlinesView\\n):\\n    \"\"\"\\n    View for creating a new object instance with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass BaseUpdateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for updating an existing object with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass UpdateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseUpdateWithInlinesView\\n):\\n    \"\"\"\\n    View for updating an object with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass NamedFormsetsMixin(ContextMixin):\\n    \"\"\"\\n    A mixin for use with `CreateWithInlinesView` or `UpdateWithInlinesView` that lets\\n    you define the context variable for each inline.\\n    \"\"\"\\n\\n    inlines_names = []\\n\\n    def get_inlines_names(self):\\n        \"\"\"\\n        Returns a list of names of context variables for each inline in `inlines`.\\n        \"\"\"\\n        return self.inlines_names[:]\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        If `inlines_names` has been defined, add each formset to the context under\\n        its corresponding entry in `inlines_names`\\n        \"\"\"\\n        context = {}\\n        inlines_names = self.get_inlines_names()\\n\\n        if inlines_names:\\n            # We have formset or inlines in context, but never both\\n            context.update(zip(inlines_names, kwargs.get(\"inlines\", [])))\\n            if \"formset\" in kwargs:\\n                context[inlines_names[0]] = kwargs[\"formset\"]\\n        context.update(kwargs)\\n        return super().get_context_data(**context)\\n\\n\\nclass SuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on views with inlines if django.contrib.messages framework\\n    is used.\\n    In order to use just add mixin in to inheritance before main class, e.g.:\\n    class MyCreateWithInlinesView (SuccessMessageMixin, CreateWithInlinesView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super().forms_valid(form, inlines)\\n        success_message = self.get_success_message(form.cleaned_data, inlines)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data, inlines):\\n        return self.success_message % cleaned_data\\n\\n\\nclass FormSetSuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on FormSet views if django.contrib.messages framework\\n    is used. In order to use just add mixin in to inheritance before main\\n    class, e.g.:\\n    class MyFormSetView (FormSetSuccessMessageMixin, ModelFormSetView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def formset_valid(self, formset):\\n        response = super().formset_valid(formset)\\n        success_message = self.get_success_message(formset)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, formset):\\n        return self.success_message\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b''"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'import datetime\\nimport functools\\nimport operator\\n\\nfrom django.contrib import messages\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.views.generic.base import ContextMixin\\n\\nVALID_STRING_LOOKUPS = (\\n    \"iexact\",\\n    \"contains\",\\n    \"icontains\",\\n    \"startswith\",\\n    \"istartswith\",\\n    \"endswith\",\\n    \"iendswith\",\\n    \"search\",\\n    \"regex\",\\n    \"iregex\",\\n)\\n\\n\\nclass SearchableListMixin(object):\\n    \"\"\"\\n    Filter queryset like a django admin search_fields does, but with little\\n     more intelligence:\\n    if self.search_split is set to True (by default) it will split query\\n     to words (by whitespace)\\n    Also tries to convert each word to date with self.search_date_formats and\\n     then search each word in separate field\\n    e.g. with query \\'foo bar\\' you can find object with\\n     obj.field1__icontains=\\'foo\\' and obj.field2__icontains==\\'bar\\'\\n\\n    To provide custom lookup just set one of the search_fields to tuple,\\n    e.g. search_fields = [(\\'field1\\', \\'iexact\\'), \\'field2\\', (\\'field3\\', \\'startswith\\')]\\n\\n    This class is designed to be used with django.generic.ListView\\n\\n    You could specify query by overriding get_search_query method\\n    by default this method will try to get \\'q\\' key from request.GET\\n    (this can be disabled with search_use_q=False)\\n    \"\"\"\\n\\n    search_fields = [\"id\"]\\n    search_date_fields = None\\n    search_date_formats = [\"%d.%m.%y\", \"%d.%m.%Y\"]\\n    search_split = True\\n    search_use_q = True\\n    check_lookups = True\\n\\n    def get_words(self, query):\\n        if self.search_split:\\n            return query.split()\\n        return [query]\\n\\n    def get_search_fields_with_filters(self):\\n        fields = []\\n        for sf in self.search_fields:\\n            if isinstance(sf, str):\\n                fields.append((sf, \"icontains\"))\\n            else:\\n                if self.check_lookups and sf[1] not in VALID_STRING_LOOKUPS:\\n                    raise ValueError(\"Invalid string lookup - %s\" % sf[1])\\n                fields.append(sf)\\n        return fields\\n\\n    def try_convert_to_date(self, word):\\n        \"\"\"\\n        Tries to convert word to date(datetime) using search_date_formats\\n        Return None if word fits no one format\\n        \"\"\"\\n        for frm in self.search_date_formats:\\n            try:\\n                return datetime.datetime.strptime(word, frm).date()\\n            except ValueError:\\n                pass\\n        return None\\n\\n    def get_search_query(self):\\n        \"\"\"\\n        Get query from request.GET \\'q\\' parameter when search_use_q is set to True\\n        Override this method to provide your own query to search\\n        \"\"\"\\n        return self.search_use_q and self.request.GET.get(\"q\", \"\").strip()\\n\\n    def get_queryset(self):\\n        qs = super(SearchableListMixin, self).get_queryset()\\n        query = self.get_search_query()\\n        if query:\\n            w_qs = []\\n            search_pairs = self.get_search_fields_with_filters()\\n            for word in self.get_words(query):\\n                filters = [\\n                    Q(**{\"%s__%s\" % (pair[0], pair[1]): word}) for pair in search_pairs\\n                ]\\n                if self.search_date_fields:\\n                    dt = self.try_convert_to_date(word)\\n                    if dt:\\n                        filters.extend(\\n                            [\\n                                Q(**{field_name: dt})\\n                                for field_name in self.search_date_fields\\n                            ]\\n                        )\\n                w_qs.append(functools.reduce(operator.or_, filters))\\n            qs = qs.filter(functools.reduce(operator.and_, w_qs))\\n            qs = qs.distinct()\\n        return qs\\n\\n\\nclass SortHelper(object):\\n    def __init__(\\n        self, request, sort_fields_aliases, sort_param_name, sort_type_param_name\\n    ):\\n        # Create a list from sort_fields_aliases, in case it is a generator,\\n        # since we want to iterate through it multiple times.\\n        sort_fields_aliases = list(sort_fields_aliases)\\n\\n        self.initial_params = request.GET.copy()\\n        self.sort_fields = dict(sort_fields_aliases)\\n        self.inv_sort_fields = dict((v, k) for k, v in sort_fields_aliases)\\n        self.initial_sort = self.inv_sort_fields.get(\\n            self.initial_params.get(sort_param_name), None\\n        )\\n        self.initial_sort_type = self.initial_params.get(sort_type_param_name, \"asc\")\\n        self.sort_param_name = sort_param_name\\n        self.sort_type_param_name = sort_type_param_name\\n\\n        for field, alias in self.sort_fields.items():\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s\" % alias,\\n                functools.partial(self.get_params_for_field, field),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_asc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"asc\"),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_desc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"desc\"),\\n            )\\n            setattr(\\n                self,\\n                \"is_sorted_by_%s\" % alias,\\n                functools.partial(self.is_sorted_by, field),\\n            )\\n\\n    def is_sorted_by(self, field_name):\\n        return field_name == self.initial_sort and self.initial_sort_type or False\\n\\n    def get_params_for_field(self, field_name, sort_type=None):\\n        \"\"\"\\n        If sort_type is None - inverse current sort for field, if no sorted - use asc\\n        \"\"\"\\n        if not sort_type:\\n            if self.initial_sort == field_name:\\n                sort_type = \"desc\" if self.initial_sort_type == \"asc\" else \"asc\"\\n            else:\\n                sort_type = \"asc\"\\n        self.initial_params[self.sort_param_name] = self.sort_fields[field_name]\\n        self.initial_params[self.sort_type_param_name] = sort_type\\n        return \"?%s\" % self.initial_params.urlencode()\\n\\n    def get_sort(self):\\n        if not self.initial_sort:\\n            return None\\n        sort = \"%s\" % self.initial_sort\\n        if self.initial_sort_type == \"desc\":\\n            sort = \"-%s\" % sort\\n        return sort\\n\\n\\nclass SortableListMixin(ContextMixin):\\n    \"\"\"\\n    You can provide either sort_fields as a plain list like\\n     [\\'id\\', \\'some\\', \\'foo__bar\\', ...]\\n    or, if you want to hide original field names you can provide list of tuples with\\n    alias that will be used:\\n    [(\\'id\\', \\'by_id\\'), (\\'some\\', \\'show_this\\'), (\\'foo__bar\\', \\'bar\\')]\\n\\n    If sort_param_name exists in query but sort_type_param_name is omitted queryset\\n     will be sorted as \\'asc\\'\\n    \"\"\"\\n\\n    sort_fields = []\\n    sort_fields_aliases = []\\n    sort_param_name = \"o\"\\n    sort_type_param_name = \"ot\"\\n\\n    def get_sort_fields(self):\\n        if self.sort_fields:\\n            return zip(self.sort_fields, self.sort_fields)\\n        return self.sort_fields_aliases\\n\\n    def get_sort_helper(self):\\n        return SortHelper(\\n            self.request,\\n            self.get_sort_fields(),\\n            self.sort_param_name,\\n            self.sort_type_param_name,\\n        )\\n\\n    def _sort_queryset(self, queryset):\\n        self.sort_helper = self.get_sort_helper()\\n        sort = self.sort_helper.get_sort()\\n        if sort:\\n            queryset = queryset.order_by(sort)\\n        return queryset\\n\\n    def get_queryset(self):\\n        qs = super(SortableListMixin, self).get_queryset()\\n        if self.sort_fields and self.sort_fields_aliases:\\n            raise ImproperlyConfigured(\\n                \"You should provide sort_fields or sort_fields_aliaces but not both\"\\n            )\\n        return self._sort_queryset(qs)\\n\\n    def get_context_data(self, **kwargs):\\n        context = {}\\n        if hasattr(self, \"sort_helper\"):\\n            context[\"sort_helper\"] = self.sort_helper\\n        context.update(kwargs)\\n        return super(SortableListMixin, self).get_context_data(**context)\\n\\n\\nclass SuccessMessageWithInlinesMixin(object):\\n    \"\"\"\\n    Adds a success message on successful form submission.\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super(SuccessMessageWithInlinesMixin, self).forms_valid(\\n            form, inlines\\n        )\\n        success_message = self.get_success_message(form.cleaned_data)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data):\\n        return self.success_message % cleaned_data\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'import datetime\\nimport math\\nfrom calendar import Calendar\\nfrom collections import defaultdict\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.utils.translation import gettext_lazy as _\\nfrom django.views.generic.dates import (\\n    DateMixin,\\n    MonthMixin,\\n    YearMixin,\\n    _date_from_string,\\n)\\nfrom django.views.generic.list import BaseListView, MultipleObjectTemplateResponseMixin\\n\\nDAYS = (\\n    _(\"Monday\"),\\n    _(\"Tuesday\"),\\n    _(\"Wednesday\"),\\n    _(\"Thursday\"),\\n    _(\"Friday\"),\\n    _(\"Saturday\"),\\n    _(\"Sunday\"),\\n)\\n\\n\\ndef daterange(start_date, end_date):\\n    \"\"\"\\n    Returns an iterator of dates between two provided ones\\n    \"\"\"\\n    for n in range(int((end_date - start_date).days + 1)):\\n        yield start_date + datetime.timedelta(n)\\n\\n\\nclass BaseCalendarMonthView(DateMixin, YearMixin, MonthMixin, BaseListView):\\n    \"\"\"\\n    A base view for displaying a calendar month\\n    \"\"\"\\n\\n    first_of_week = 0  # 0 = Monday, 6 = Sunday\\n    paginate_by = None  # We don\\'t want to use this part of MultipleObjectMixin\\n    date_field = None\\n    end_date_field = None  # For supporting events with duration\\n\\n    def get_paginate_by(self, queryset):\\n        if self.paginate_by is not None:\\n            raise ImproperlyConfigured(\\n                \"\\'%s\\' cannot be paginated, it is a calendar view\"\\n                % self.__class__.__name__\\n            )\\n        return None\\n\\n    def get_allow_future(self):\\n        return True\\n\\n    def get_end_date_field(self):\\n        \"\"\"\\n        Returns the model field to use for end dates\\n        \"\"\"\\n        return self.end_date_field\\n\\n    def get_start_date(self, obj):\\n        \"\"\"\\n        Returns the start date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_end_date(self, obj):\\n        \"\"\"\\n        Returns the end date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_end_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_first_of_week(self):\\n        \"\"\"\\n        Returns an integer representing the first day of the week.\\n\\n        0 represents Monday, 6 represents Sunday.\\n        \"\"\"\\n        if self.first_of_week is None:\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week is required.\" % self.__class__.__name__\\n            )\\n        if self.first_of_week not in range(7):\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week must be an integer between 0 and 6.\"\\n                % self.__class__.__name__\\n            )\\n        return self.first_of_week\\n\\n    def get_queryset(self):\\n        \"\"\"\\n        Returns a queryset of models for the month requested\\n        \"\"\"\\n        qs = super().get_queryset()\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date_field = self.get_date_field()\\n        end_date_field = self.get_end_date_field()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        since = date\\n        until = self.get_next_month(date)\\n\\n        # Adjust our start and end dates to allow for next and previous\\n        # month edges\\n        if since.weekday() != self.get_first_of_week():\\n            diff = math.fabs(since.weekday() - self.get_first_of_week())\\n            since = since - datetime.timedelta(days=diff)\\n\\n        if until.weekday() != ((self.get_first_of_week() + 6) % 7):\\n            diff = math.fabs(((self.get_first_of_week() + 6) % 7) - until.weekday())\\n            until = until + datetime.timedelta(days=diff)\\n\\n        if end_date_field:\\n            # 5 possible conditions for showing an event:\\n\\n            # 1) Single day event, starts after \\'since\\'\\n            # 2) Multi-day event, starts after \\'since\\' and ends before \\'until\\'\\n            # 3) Starts before \\'since\\' and ends after \\'since\\' and before \\'until\\'\\n            # 4) Starts after \\'since\\' but before \\'until\\' and ends after \\'until\\'\\n            # 5) Starts before \\'since\\' and ends after \\'until\\'\\n            predicate1 = Q(**{\"%s__gte\" % date_field: since, end_date_field: None})\\n            predicate2 = Q(\\n                **{\"%s__gte\" % date_field: since, \"%s__lt\" % end_date_field: until}\\n            )\\n            predicate3 = Q(\\n                **{\\n                    \"%s__lt\" % date_field: since,\\n                    \"%s__gte\" % end_date_field: since,\\n                    \"%s__lt\" % end_date_field: until,\\n                }\\n            )\\n            predicate4 = Q(\\n                **{\\n                    \"%s__gte\" % date_field: since,\\n                    \"%s__lt\" % date_field: until,\\n                    \"%s__gte\" % end_date_field: until,\\n                }\\n            )\\n            predicate5 = Q(\\n                **{\"%s__lt\" % date_field: since, \"%s__gte\" % end_date_field: until}\\n            )\\n            return qs.filter(\\n                predicate1 | predicate2 | predicate3 | predicate4 | predicate5\\n            )\\n        return qs.filter(**{\"%s__gte\" % date_field: since})\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        Injects variables necessary for rendering the calendar into the context.\\n\\n        Variables added are: `calendar`, `weekdays`, `month`, `next_month` and\\n        `previous_month`.\\n        \"\"\"\\n        data = super().get_context_data(**kwargs)\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        cal = Calendar(self.get_first_of_week())\\n\\n        month_calendar = []\\n        now = datetime.datetime.utcnow()\\n\\n        date_lists = defaultdict(list)\\n        multidate_objs = []\\n\\n        for obj in data[\"object_list\"]:\\n            obj_date = self.get_start_date(obj)\\n            end_date_field = self.get_end_date_field()\\n\\n            if end_date_field:\\n                end_date = self.get_end_date(obj)\\n                if end_date and end_date != obj_date:\\n                    multidate_objs.append(\\n                        {\\n                            \"obj\": obj,\\n                            \"range\": [x for x in daterange(obj_date, end_date)],\\n                        }\\n                    )\\n                    continue  # We don\\'t put multi-day events in date_lists\\n            date_lists[obj_date].append(obj)\\n\\n        for week in cal.monthdatescalendar(date.year, date.month):\\n            week_range = set(daterange(week[0], week[6]))\\n            week_events = []\\n\\n            for val in multidate_objs:\\n                intersect_length = len(week_range.intersection(val[\"range\"]))\\n\\n                if intersect_length:\\n                    # Event happens during this week\\n                    slot = 1\\n                    width = (\\n                        intersect_length  # How many days is the event during this week?\\n                    )\\n                    nowrap_previous = (\\n                        True  # Does the event continue from the previous week?\\n                    )\\n                    nowrap_next = True  # Does the event continue to the next week?\\n\\n                    if val[\"range\"][0] >= week[0]:\\n                        slot = 1 + (val[\"range\"][0] - week[0]).days\\n                    else:\\n                        nowrap_previous = False\\n                    if val[\"range\"][-1] > week[6]:\\n                        nowrap_next = False\\n\\n                    week_events.append(\\n                        {\\n                            \"event\": val[\"obj\"],\\n                            \"slot\": slot,\\n                            \"width\": width,\\n                            \"nowrap_previous\": nowrap_previous,\\n                            \"nowrap_next\": nowrap_next,\\n                        }\\n                    )\\n\\n            week_calendar = {\"events\": week_events, \"date_list\": []}\\n            for day in week:\\n                week_calendar[\"date_list\"].append(\\n                    {\\n                        \"day\": day,\\n                        \"events\": date_lists[day],\\n                        \"today\": day == now.date(),\\n                        \"is_current_month\": day.month == date.month,\\n                    }\\n                )\\n            month_calendar.append(week_calendar)\\n\\n        data[\"calendar\"] = month_calendar\\n        data[\"weekdays\"] = [DAYS[x] for x in cal.iterweekdays()]\\n        data[\"month\"] = date\\n        data[\"next_month\"] = self.get_next_month(date)\\n        data[\"previous_month\"] = self.get_previous_month(date)\\n\\n        return data\\n\\n\\nclass CalendarMonthView(MultipleObjectTemplateResponseMixin, BaseCalendarMonthView):\\n    \"\"\"\\n    A view for displaying a calendar month, and rendering a template response\\n    \"\"\"\\n\\n    template_name_suffix = \"_calendar_month\"\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.forms.formsets import formset_factory\\nfrom django.forms.models import inlineformset_factory, modelformset_factory\\nfrom django.http import HttpResponseRedirect\\nfrom django.views.generic.base import ContextMixin, TemplateResponseMixin, View\\nfrom django.views.generic.detail import (\\n    SingleObjectMixin,\\n    SingleObjectTemplateResponseMixin,\\n)\\nfrom django.views.generic.list import (\\n    MultipleObjectMixin,\\n    MultipleObjectTemplateResponseMixin,\\n)\\n\\n\\nclass BaseFormSetFactory(object):\\n    \"\"\"\\n    Base class for constructing a FormSet from `formset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    initial = []\\n    form_class = None\\n    formset_class = None\\n    prefix = None\\n    formset_kwargs = {}\\n    factory_kwargs = {}\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Returns an instance of the formset\\n        \"\"\"\\n        formset_class = self.get_formset()\\n        return formset_class(**self.get_formset_kwargs())\\n\\n    def get_initial(self):\\n        \"\"\"\\n        Returns a copy of the initial data to use for formsets on this view.\\n        \"\"\"\\n        return self.initial[:]\\n\\n    def get_prefix(self):\\n        \"\"\"\\n        Returns the prefix used for formsets on this view.\\n        \"\"\"\\n        return self.prefix\\n\\n    def get_formset_class(self):\\n        \"\"\"\\n        Returns the formset class to use in the formset factory\\n        \"\"\"\\n        return self.formset_class\\n\\n    def get_form_class(self):\\n        \"\"\"\\n        Returns the form class to use with the formset in this view\\n        \"\"\"\\n        return self.form_class\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the formset factory\\n        \"\"\"\\n        return formset_factory(self.get_form_class(), **self.get_factory_kwargs())\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = self.formset_kwargs.copy()\\n        kwargs.update({\"initial\": self.get_initial(), \"prefix\": self.get_prefix()})\\n\\n        if self.request.method in (\"POST\", \"PUT\"):\\n            kwargs.update(\\n                {\"data\": self.request.POST.copy(), \"files\": self.request.FILES}\\n            )\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = self.factory_kwargs.copy()\\n        if self.get_formset_class():\\n            kwargs[\"formset\"] = self.get_formset_class()\\n        return kwargs\\n\\n\\nclass FormSetMixin(BaseFormSetFactory, ContextMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single formset in a request.\\n    \"\"\"\\n\\n    success_url = None\\n\\n    def get_success_url(self):\\n        \"\"\"\\n        Returns the supplied URL.\\n        \"\"\"\\n        if self.success_url:\\n            url = self.success_url\\n        else:\\n            # Default to returning to the same page\\n            url = self.request.get_full_path()\\n        return url\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid redirect to the supplied URL\\n        \"\"\"\\n        return HttpResponseRedirect(self.get_success_url())\\n\\n    def formset_invalid(self, formset):\\n        \"\"\"\\n        If the formset is invalid, re-render the context data with the\\n        data-filled formset and errors.\\n        \"\"\"\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n\\nclass ModelFormSetMixin(FormSetMixin, MultipleObjectMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single model formset\\n    in a request.\\n\\n    Uses `modelformset_factory`.\\n    \"\"\"\\n\\n    exclude = None\\n    fields = None\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"queryset\"] = self.get_queryset()\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the model formset factory\\n        \"\"\"\\n        return modelformset_factory(self.model, **self.get_factory_kwargs())\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid, save the associated models.\\n        \"\"\"\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass BaseInlineFormSetFactory(BaseFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a FormSet from `inlineformset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    model = None\\n    inline_model = None\\n    exclude = None\\n    fields = None\\n\\n    def get_inline_model(self):\\n        \"\"\"\\n        Returns the inline model to use with the inline formset\\n        \"\"\"\\n        return self.inline_model\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"instance\"] = self.object\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the inline formset factory\\n        \"\"\"\\n        return inlineformset_factory(\\n            self.model, self.get_inline_model(), **self.get_factory_kwargs()\\n        )\\n\\n\\nclass InlineFormSetMixin(BaseInlineFormSetFactory, SingleObjectMixin, FormSetMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single inline formset\\n    in a request.\\n    \"\"\"\\n\\n    def formset_valid(self, formset):\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass ProcessFormSetView(View):\\n    \"\"\"\\n    A mixin that processes a formset on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the formset.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a formset instance with the passed\\n        POST variables and then checked for validity.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        if formset.is_valid():\\n            return self.formset_valid(formset)\\n        else:\\n            return self.formset_invalid(formset)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseFormSetView(FormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a formset\\n    \"\"\"\\n\\n\\nclass FormSetView(TemplateResponseMixin, BaseFormSetView):\\n    \"\"\"\\n    A view for displaying a formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseModelFormSetView(ModelFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a model formset\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass ModelFormSetView(MultipleObjectTemplateResponseMixin, BaseModelFormSetView):\\n    \"\"\"\\n    A view for displaying a model formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseInlineFormSetView(InlineFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying an inline formset for a queryset belonging to\\n    a parent model\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass InlineFormSetView(SingleObjectTemplateResponseMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A view for displaying an inline formset for a queryset belonging to a parent model\\n    \"\"\"\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.contrib.contenttypes.forms import generic_inlineformset_factory\\n\\nfrom extra_views.formsets import (\\n    BaseInlineFormSetFactory,\\n    BaseInlineFormSetView,\\n    InlineFormSetMixin,\\n    InlineFormSetView,\\n)\\n\\n\\nclass BaseGenericInlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a GenericInlineFormSet from\\n    `generic_inlineformset_factory` in a view.\\n    \"\"\"\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the final formset class from generic_inlineformset_factory.\\n        \"\"\"\\n        result = generic_inlineformset_factory(\\n            self.inline_model, **self.get_factory_kwargs()\\n        )\\n        return result\\n\\n\\nclass GenericInlineFormSetFactory(BaseGenericInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create a `GenericInlineFormSet` from `generic_inlineformset_factory`\\n    as one of multiple `GenericInlineFormSet`s within a single view.\\n\\n    Subclasses `BaseGenericInlineFormSetFactory` and passes in the necessary view\\n    arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n\\nclass GenericInlineFormSetMixin(BaseGenericInlineFormSetFactory, InlineFormSetMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a generic inline formset in a\\n    request.\\n    \"\"\"\\n\\n\\nclass BaseGenericInlineFormSetView(GenericInlineFormSetMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A base view for displaying a generic inline formset\\n    \"\"\"\\n\\n\\nclass GenericInlineFormSetView(BaseGenericInlineFormSetView, InlineFormSetView):\\n    \"\"\"\\n    A view for displaying a generic inline formset for a queryset belonging to a\\n    parent model\\n    \"\"\"\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b''"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from extra_views.advanced import (\\n    CreateWithInlinesView,\\n    FormSetSuccessMessageMixin,\\n    InlineFormSetFactory,\\n    NamedFormsetsMixin,\\n    SuccessMessageMixin,\\n    UpdateWithInlinesView,\\n)\\nfrom extra_views.contrib.mixins import SearchableListMixin, SortableListMixin\\nfrom extra_views.dates import CalendarMonthView\\nfrom extra_views.formsets import FormSetView, InlineFormSetView, ModelFormSetView\\n\\n__version__ = \"0.14.0\"\\n\\n__all__ = [\\n    \"CreateWithInlinesView\",\\n    \"FormSetSuccessMessageMixin\",\\n    \"InlineFormSetFactory\",\\n    \"NamedFormsetsMixin\",\\n    \"SuccessMessageMixin\",\\n    \"UpdateWithInlinesView\",\\n    \"SearchableListMixin\",\\n    \"SortableListMixin\",\\n    \"CalendarMonthView\",\\n    \"FormSetView\",\\n    \"InlineFormSetView\",\\n    \"ModelFormSetView\",\\n]\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.contrib import messages\\nfrom django.forms.formsets import all_valid\\nfrom django.views.generic.base import ContextMixin\\nfrom django.views.generic.detail import SingleObjectTemplateResponseMixin\\nfrom django.views.generic.edit import FormView, ModelFormMixin\\n\\nfrom extra_views.formsets import BaseInlineFormSetFactory\\n\\n\\nclass InlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create an `InlineFormSet` from `inlineformset_factory` as\\n    one of multiple `InlineFormSet`s within a single view.\\n\\n    Subclasses `BaseInlineFormSetFactory` and passes in the necessary view arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Overrides construct_formset to attach the model class as\\n        an attribute of the returned formset instance.\\n        \"\"\"\\n        formset = super().construct_formset()\\n        formset.model = self.inline_model\\n        return formset\\n\\n\\nclass ModelFormWithInlinesMixin(ModelFormMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a modelform and inline\\n    formsets in a request.\\n\\n    The inlines should be subclasses of `InlineFormSetFactory`.\\n    \"\"\"\\n\\n    inlines = []\\n\\n    def get_inlines(self):\\n        \"\"\"\\n        Returns the inline formset classes\\n        \"\"\"\\n        return self.inlines[:]\\n\\n    def forms_valid(self, form, inlines):\\n        \"\"\"\\n        If the form and formsets are valid, save the associated models.\\n        \"\"\"\\n        response = self.form_valid(form)\\n        for formset in inlines:\\n            formset.save()\\n        return response\\n\\n    def forms_invalid(self, form, inlines):\\n        \"\"\"\\n        If the form or formsets are invalid, re-render the context data with the\\n        data-filled form and formsets and errors.\\n        \"\"\"\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines)\\n        )\\n\\n    def construct_inlines(self):\\n        \"\"\"\\n        Returns the inline formset instances\\n        \"\"\"\\n        inline_formsets = []\\n        for inline_class in self.get_inlines():\\n            inline_instance = inline_class(\\n                self.model, self.request, self.object, self.kwargs, self\\n            )\\n            inline_formset = inline_instance.construct_formset()\\n            inline_formsets.append(inline_formset)\\n        return inline_formsets\\n\\n\\nclass ProcessFormWithInlinesView(FormView):\\n    \"\"\"\\n    A mixin that renders a form and inline formsets on GET and processes it on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the form and formsets.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n        inlines = self.construct_inlines()\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines, **kwargs)\\n        )\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a form and formset instances with the\\n        passed POST variables and then checked for validity.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n\\n        initial_object = self.object\\n        if form.is_valid():\\n            self.object = form.save(commit=False)\\n            form_validated = True\\n        else:\\n            form_validated = False\\n\\n        inlines = self.construct_inlines()\\n\\n        if all_valid(inlines) and form_validated:\\n            return self.forms_valid(form, inlines)\\n        self.object = initial_object\\n        return self.forms_invalid(form, inlines)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseCreateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for creating an new object instance with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass CreateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseCreateWithInlinesView\\n):\\n    \"\"\"\\n    View for creating a new object instance with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass BaseUpdateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for updating an existing object with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass UpdateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseUpdateWithInlinesView\\n):\\n    \"\"\"\\n    View for updating an object with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass NamedFormsetsMixin(ContextMixin):\\n    \"\"\"\\n    A mixin for use with `CreateWithInlinesView` or `UpdateWithInlinesView` that lets\\n    you define the context variable for each inline.\\n    \"\"\"\\n\\n    inlines_names = []\\n\\n    def get_inlines_names(self):\\n        \"\"\"\\n        Returns a list of names of context variables for each inline in `inlines`.\\n        \"\"\"\\n        return self.inlines_names[:]\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        If `inlines_names` has been defined, add each formset to the context under\\n        its corresponding entry in `inlines_names`\\n        \"\"\"\\n        context = {}\\n        inlines_names = self.get_inlines_names()\\n\\n        if inlines_names:\\n            # We have formset or inlines in context, but never both\\n            context.update(zip(inlines_names, kwargs.get(\"inlines\", [])))\\n            if \"formset\" in kwargs:\\n                context[inlines_names[0]] = kwargs[\"formset\"]\\n        context.update(kwargs)\\n        return super().get_context_data(**context)\\n\\n\\nclass SuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on views with inlines if django.contrib.messages framework\\n    is used.\\n    In order to use just add mixin in to inheritance before main class, e.g.:\\n    class MyCreateWithInlinesView (SuccessMessageMixin, CreateWithInlinesView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super().forms_valid(form, inlines)\\n        success_message = self.get_success_message(form.cleaned_data, inlines)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data, inlines):\\n        return self.success_message % cleaned_data\\n\\n\\nclass FormSetSuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on FormSet views if django.contrib.messages framework\\n    is used. In order to use just add mixin in to inheritance before main\\n    class, e.g.:\\n    class MyFormSetView (FormSetSuccessMessageMixin, ModelFormSetView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def formset_valid(self, formset):\\n        response = super().formset_valid(formset)\\n        success_message = self.get_success_message(formset)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, formset):\\n        return self.success_message\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b''"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'import datetime\\nimport functools\\nimport operator\\n\\nfrom django.contrib import messages\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.views.generic.base import ContextMixin\\n\\nVALID_STRING_LOOKUPS = (\\n    \"iexact\",\\n    \"contains\",\\n    \"icontains\",\\n    \"startswith\",\\n    \"istartswith\",\\n    \"endswith\",\\n    \"iendswith\",\\n    \"search\",\\n    \"regex\",\\n    \"iregex\",\\n)\\n\\n\\nclass SearchableListMixin(object):\\n    \"\"\"\\n    Filter queryset like a django admin search_fields does, but with little\\n     more intelligence:\\n    if self.search_split is set to True (by default) it will split query\\n     to words (by whitespace)\\n    Also tries to convert each word to date with self.search_date_formats and\\n     then search each word in separate field\\n    e.g. with query \\'foo bar\\' you can find object with\\n     obj.field1__icontains=\\'foo\\' and obj.field2__icontains==\\'bar\\'\\n\\n    To provide custom lookup just set one of the search_fields to tuple,\\n    e.g. search_fields = [(\\'field1\\', \\'iexact\\'), \\'field2\\', (\\'field3\\', \\'startswith\\')]\\n\\n    This class is designed to be used with django.generic.ListView\\n\\n    You could specify query by overriding get_search_query method\\n    by default this method will try to get \\'q\\' key from request.GET\\n    (this can be disabled with search_use_q=False)\\n    \"\"\"\\n\\n    search_fields = [\"id\"]\\n    search_date_fields = None\\n    search_date_formats = [\"%d.%m.%y\", \"%d.%m.%Y\"]\\n    search_split = True\\n    search_use_q = True\\n    check_lookups = True\\n\\n    def get_words(self, query):\\n        if self.search_split:\\n            return query.split()\\n        return [query]\\n\\n    def get_search_fields_with_filters(self):\\n        fields = []\\n        for sf in self.search_fields:\\n            if isinstance(sf, str):\\n                fields.append((sf, \"icontains\"))\\n            else:\\n                if self.check_lookups and sf[1] not in VALID_STRING_LOOKUPS:\\n                    raise ValueError(\"Invalid string lookup - %s\" % sf[1])\\n                fields.append(sf)\\n        return fields\\n\\n    def try_convert_to_date(self, word):\\n        \"\"\"\\n        Tries to convert word to date(datetime) using search_date_formats\\n        Return None if word fits no one format\\n        \"\"\"\\n        for frm in self.search_date_formats:\\n            try:\\n                return datetime.datetime.strptime(word, frm).date()\\n            except ValueError:\\n                pass\\n        return None\\n\\n    def get_search_query(self):\\n        \"\"\"\\n        Get query from request.GET \\'q\\' parameter when search_use_q is set to True\\n        Override this method to provide your own query to search\\n        \"\"\"\\n        return self.search_use_q and self.request.GET.get(\"q\", \"\").strip()\\n\\n    def get_queryset(self):\\n        qs = super(SearchableListMixin, self).get_queryset()\\n        query = self.get_search_query()\\n        if query:\\n            w_qs = []\\n            search_pairs = self.get_search_fields_with_filters()\\n            for word in self.get_words(query):\\n                filters = [\\n                    Q(**{\"%s__%s\" % (pair[0], pair[1]): word}) for pair in search_pairs\\n                ]\\n                if self.search_date_fields:\\n                    dt = self.try_convert_to_date(word)\\n                    if dt:\\n                        filters.extend(\\n                            [\\n                                Q(**{field_name: dt})\\n                                for field_name in self.search_date_fields\\n                            ]\\n                        )\\n                w_qs.append(functools.reduce(operator.or_, filters))\\n            qs = qs.filter(functools.reduce(operator.and_, w_qs))\\n            qs = qs.distinct()\\n        return qs\\n\\n\\nclass SortHelper(object):\\n    def __init__(\\n        self, request, sort_fields_aliases, sort_param_name, sort_type_param_name\\n    ):\\n        # Create a list from sort_fields_aliases, in case it is a generator,\\n        # since we want to iterate through it multiple times.\\n        sort_fields_aliases = list(sort_fields_aliases)\\n\\n        self.initial_params = request.GET.copy()\\n        self.sort_fields = dict(sort_fields_aliases)\\n        self.inv_sort_fields = dict((v, k) for k, v in sort_fields_aliases)\\n        self.initial_sort = self.inv_sort_fields.get(\\n            self.initial_params.get(sort_param_name), None\\n        )\\n        self.initial_sort_type = self.initial_params.get(sort_type_param_name, \"asc\")\\n        self.sort_param_name = sort_param_name\\n        self.sort_type_param_name = sort_type_param_name\\n\\n        for field, alias in self.sort_fields.items():\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s\" % alias,\\n                functools.partial(self.get_params_for_field, field),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_asc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"asc\"),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_desc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"desc\"),\\n            )\\n            setattr(\\n                self,\\n                \"is_sorted_by_%s\" % alias,\\n                functools.partial(self.is_sorted_by, field),\\n            )\\n\\n    def is_sorted_by(self, field_name):\\n        return field_name == self.initial_sort and self.initial_sort_type or False\\n\\n    def get_params_for_field(self, field_name, sort_type=None):\\n        \"\"\"\\n        If sort_type is None - inverse current sort for field, if no sorted - use asc\\n        \"\"\"\\n        if not sort_type:\\n            if self.initial_sort == field_name:\\n                sort_type = \"desc\" if self.initial_sort_type == \"asc\" else \"asc\"\\n            else:\\n                sort_type = \"asc\"\\n        self.initial_params[self.sort_param_name] = self.sort_fields[field_name]\\n        self.initial_params[self.sort_type_param_name] = sort_type\\n        return \"?%s\" % self.initial_params.urlencode()\\n\\n    def get_sort(self):\\n        if not self.initial_sort:\\n            return None\\n        sort = \"%s\" % self.initial_sort\\n        if self.initial_sort_type == \"desc\":\\n            sort = \"-%s\" % sort\\n        return sort\\n\\n\\nclass SortableListMixin(ContextMixin):\\n    \"\"\"\\n    You can provide either sort_fields as a plain list like\\n     [\\'id\\', \\'some\\', \\'foo__bar\\', ...]\\n    or, if you want to hide original field names you can provide list of tuples with\\n    alias that will be used:\\n    [(\\'id\\', \\'by_id\\'), (\\'some\\', \\'show_this\\'), (\\'foo__bar\\', \\'bar\\')]\\n\\n    If sort_param_name exists in query but sort_type_param_name is omitted queryset\\n     will be sorted as \\'asc\\'\\n    \"\"\"\\n\\n    sort_fields = []\\n    sort_fields_aliases = []\\n    sort_param_name = \"o\"\\n    sort_type_param_name = \"ot\"\\n\\n    def get_sort_fields(self):\\n        if self.sort_fields:\\n            return zip(self.sort_fields, self.sort_fields)\\n        return self.sort_fields_aliases\\n\\n    def get_sort_helper(self):\\n        return SortHelper(\\n            self.request,\\n            self.get_sort_fields(),\\n            self.sort_param_name,\\n            self.sort_type_param_name,\\n        )\\n\\n    def _sort_queryset(self, queryset):\\n        self.sort_helper = self.get_sort_helper()\\n        sort = self.sort_helper.get_sort()\\n        if sort:\\n            queryset = queryset.order_by(sort)\\n        return queryset\\n\\n    def get_queryset(self):\\n        qs = super(SortableListMixin, self).get_queryset()\\n        if self.sort_fields and self.sort_fields_aliases:\\n            raise ImproperlyConfigured(\\n                \"You should provide sort_fields or sort_fields_aliaces but not both\"\\n            )\\n        return self._sort_queryset(qs)\\n\\n    def get_context_data(self, **kwargs):\\n        context = {}\\n        if hasattr(self, \"sort_helper\"):\\n            context[\"sort_helper\"] = self.sort_helper\\n        context.update(kwargs)\\n        return super(SortableListMixin, self).get_context_data(**context)\\n\\n\\nclass SuccessMessageWithInlinesMixin(object):\\n    \"\"\"\\n    Adds a success message on successful form submission.\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super(SuccessMessageWithInlinesMixin, self).forms_valid(\\n            form, inlines\\n        )\\n        success_message = self.get_success_message(form.cleaned_data)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data):\\n        return self.success_message % cleaned_data\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'import datetime\\nimport math\\nfrom calendar import Calendar\\nfrom collections import defaultdict\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.utils.translation import gettext_lazy as _\\nfrom django.views.generic.dates import (\\n    DateMixin,\\n    MonthMixin,\\n    YearMixin,\\n    _date_from_string,\\n)\\nfrom django.views.generic.list import BaseListView, MultipleObjectTemplateResponseMixin\\n\\nDAYS = (\\n    _(\"Monday\"),\\n    _(\"Tuesday\"),\\n    _(\"Wednesday\"),\\n    _(\"Thursday\"),\\n    _(\"Friday\"),\\n    _(\"Saturday\"),\\n    _(\"Sunday\"),\\n)\\n\\n\\ndef daterange(start_date, end_date):\\n    \"\"\"\\n    Returns an iterator of dates between two provided ones\\n    \"\"\"\\n    for n in range(int((end_date - start_date).days + 1)):\\n        yield start_date + datetime.timedelta(n)\\n\\n\\nclass BaseCalendarMonthView(DateMixin, YearMixin, MonthMixin, BaseListView):\\n    \"\"\"\\n    A base view for displaying a calendar month\\n    \"\"\"\\n\\n    first_of_week = 0  # 0 = Monday, 6 = Sunday\\n    paginate_by = None  # We don\\'t want to use this part of MultipleObjectMixin\\n    date_field = None\\n    end_date_field = None  # For supporting events with duration\\n\\n    def get_paginate_by(self, queryset):\\n        if self.paginate_by is not None:\\n            raise ImproperlyConfigured(\\n                \"\\'%s\\' cannot be paginated, it is a calendar view\"\\n                % self.__class__.__name__\\n            )\\n        return None\\n\\n    def get_allow_future(self):\\n        return True\\n\\n    def get_end_date_field(self):\\n        \"\"\"\\n        Returns the model field to use for end dates\\n        \"\"\"\\n        return self.end_date_field\\n\\n    def get_start_date(self, obj):\\n        \"\"\"\\n        Returns the start date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_end_date(self, obj):\\n        \"\"\"\\n        Returns the end date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_end_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_first_of_week(self):\\n        \"\"\"\\n        Returns an integer representing the first day of the week.\\n\\n        0 represents Monday, 6 represents Sunday.\\n        \"\"\"\\n        if self.first_of_week is None:\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week is required.\" % self.__class__.__name__\\n            )\\n        if self.first_of_week not in range(7):\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week must be an integer between 0 and 6.\"\\n                % self.__class__.__name__\\n            )\\n        return self.first_of_week\\n\\n    def get_queryset(self):\\n        \"\"\"\\n        Returns a queryset of models for the month requested\\n        \"\"\"\\n        qs = super().get_queryset()\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date_field = self.get_date_field()\\n        end_date_field = self.get_end_date_field()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        since = date\\n        until = self.get_next_month(date)\\n\\n        # Adjust our start and end dates to allow for next and previous\\n        # month edges\\n        if since.weekday() != self.get_first_of_week():\\n            diff = math.fabs(since.weekday() - self.get_first_of_week())\\n            since = since - datetime.timedelta(days=diff)\\n\\n        if until.weekday() != ((self.get_first_of_week() + 6) % 7):\\n            diff = math.fabs(((self.get_first_of_week() + 6) % 7) - until.weekday())\\n            until = until + datetime.timedelta(days=diff)\\n\\n        if end_date_field:\\n            # 5 possible conditions for showing an event:\\n\\n            # 1) Single day event, starts after \\'since\\'\\n            # 2) Multi-day event, starts after \\'since\\' and ends before \\'until\\'\\n            # 3) Starts before \\'since\\' and ends after \\'since\\' and before \\'until\\'\\n            # 4) Starts after \\'since\\' but before \\'until\\' and ends after \\'until\\'\\n            # 5) Starts before \\'since\\' and ends after \\'until\\'\\n            predicate1 = Q(**{\"%s__gte\" % date_field: since, end_date_field: None})\\n            predicate2 = Q(\\n                **{\"%s__gte\" % date_field: since, \"%s__lt\" % end_date_field: until}\\n            )\\n            predicate3 = Q(\\n                **{\\n                    \"%s__lt\" % date_field: since,\\n                    \"%s__gte\" % end_date_field: since,\\n                    \"%s__lt\" % end_date_field: until,\\n                }\\n            )\\n            predicate4 = Q(\\n                **{\\n                    \"%s__gte\" % date_field: since,\\n                    \"%s__lt\" % date_field: until,\\n                    \"%s__gte\" % end_date_field: until,\\n                }\\n            )\\n            predicate5 = Q(\\n                **{\"%s__lt\" % date_field: since, \"%s__gte\" % end_date_field: until}\\n            )\\n            return qs.filter(\\n                predicate1 | predicate2 | predicate3 | predicate4 | predicate5\\n            )\\n        return qs.filter(**{\"%s__gte\" % date_field: since})\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        Injects variables necessary for rendering the calendar into the context.\\n\\n        Variables added are: `calendar`, `weekdays`, `month`, `next_month` and\\n        `previous_month`.\\n        \"\"\"\\n        data = super().get_context_data(**kwargs)\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        cal = Calendar(self.get_first_of_week())\\n\\n        month_calendar = []\\n        now = datetime.datetime.utcnow()\\n\\n        date_lists = defaultdict(list)\\n        multidate_objs = []\\n\\n        for obj in data[\"object_list\"]:\\n            obj_date = self.get_start_date(obj)\\n            end_date_field = self.get_end_date_field()\\n\\n            if end_date_field:\\n                end_date = self.get_end_date(obj)\\n                if end_date and end_date != obj_date:\\n                    multidate_objs.append(\\n                        {\\n                            \"obj\": obj,\\n                            \"range\": [x for x in daterange(obj_date, end_date)],\\n                        }\\n                    )\\n                    continue  # We don\\'t put multi-day events in date_lists\\n            date_lists[obj_date].append(obj)\\n\\n        for week in cal.monthdatescalendar(date.year, date.month):\\n            week_range = set(daterange(week[0], week[6]))\\n            week_events = []\\n\\n            for val in multidate_objs:\\n                intersect_length = len(week_range.intersection(val[\"range\"]))\\n\\n                if intersect_length:\\n                    # Event happens during this week\\n                    slot = 1\\n                    width = (\\n                        intersect_length  # How many days is the event during this week?\\n                    )\\n                    nowrap_previous = (\\n                        True  # Does the event continue from the previous week?\\n                    )\\n                    nowrap_next = True  # Does the event continue to the next week?\\n\\n                    if val[\"range\"][0] >= week[0]:\\n                        slot = 1 + (val[\"range\"][0] - week[0]).days\\n                    else:\\n                        nowrap_previous = False\\n                    if val[\"range\"][-1] > week[6]:\\n                        nowrap_next = False\\n\\n                    week_events.append(\\n                        {\\n                            \"event\": val[\"obj\"],\\n                            \"slot\": slot,\\n                            \"width\": width,\\n                            \"nowrap_previous\": nowrap_previous,\\n                            \"nowrap_next\": nowrap_next,\\n                        }\\n                    )\\n\\n            week_calendar = {\"events\": week_events, \"date_list\": []}\\n            for day in week:\\n                week_calendar[\"date_list\"].append(\\n                    {\\n                        \"day\": day,\\n                        \"events\": date_lists[day],\\n                        \"today\": day == now.date(),\\n                        \"is_current_month\": day.month == date.month,\\n                    }\\n                )\\n            month_calendar.append(week_calendar)\\n\\n        data[\"calendar\"] = month_calendar\\n        data[\"weekdays\"] = [DAYS[x] for x in cal.iterweekdays()]\\n        data[\"month\"] = date\\n        data[\"next_month\"] = self.get_next_month(date)\\n        data[\"previous_month\"] = self.get_previous_month(date)\\n\\n        return data\\n\\n\\nclass CalendarMonthView(MultipleObjectTemplateResponseMixin, BaseCalendarMonthView):\\n    \"\"\"\\n    A view for displaying a calendar month, and rendering a template response\\n    \"\"\"\\n\\n    template_name_suffix = \"_calendar_month\"\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.forms.formsets import formset_factory\\nfrom django.forms.models import inlineformset_factory, modelformset_factory\\nfrom django.http import HttpResponseRedirect\\nfrom django.views.generic.base import ContextMixin, TemplateResponseMixin, View\\nfrom django.views.generic.detail import (\\n    SingleObjectMixin,\\n    SingleObjectTemplateResponseMixin,\\n)\\nfrom django.views.generic.list import (\\n    MultipleObjectMixin,\\n    MultipleObjectTemplateResponseMixin,\\n)\\n\\n\\nclass BaseFormSetFactory(object):\\n    \"\"\"\\n    Base class for constructing a FormSet from `formset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    initial = []\\n    form_class = None\\n    formset_class = None\\n    prefix = None\\n    formset_kwargs = {}\\n    factory_kwargs = {}\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Returns an instance of the formset\\n        \"\"\"\\n        formset_class = self.get_formset()\\n        return formset_class(**self.get_formset_kwargs())\\n\\n    def get_initial(self):\\n        \"\"\"\\n        Returns a copy of the initial data to use for formsets on this view.\\n        \"\"\"\\n        return self.initial[:]\\n\\n    def get_prefix(self):\\n        \"\"\"\\n        Returns the prefix used for formsets on this view.\\n        \"\"\"\\n        return self.prefix\\n\\n    def get_formset_class(self):\\n        \"\"\"\\n        Returns the formset class to use in the formset factory\\n        \"\"\"\\n        return self.formset_class\\n\\n    def get_form_class(self):\\n        \"\"\"\\n        Returns the form class to use with the formset in this view\\n        \"\"\"\\n        return self.form_class\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the formset factory\\n        \"\"\"\\n        return formset_factory(self.get_form_class(), **self.get_factory_kwargs())\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = self.formset_kwargs.copy()\\n        kwargs.update({\"initial\": self.get_initial(), \"prefix\": self.get_prefix()})\\n\\n        if self.request.method in (\"POST\", \"PUT\"):\\n            kwargs.update(\\n                {\"data\": self.request.POST.copy(), \"files\": self.request.FILES}\\n            )\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = self.factory_kwargs.copy()\\n        if self.get_formset_class():\\n            kwargs[\"formset\"] = self.get_formset_class()\\n        return kwargs\\n\\n\\nclass FormSetMixin(BaseFormSetFactory, ContextMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single formset in a request.\\n    \"\"\"\\n\\n    success_url = None\\n\\n    def get_success_url(self):\\n        \"\"\"\\n        Returns the supplied URL.\\n        \"\"\"\\n        if self.success_url:\\n            url = self.success_url\\n        else:\\n            # Default to returning to the same page\\n            url = self.request.get_full_path()\\n        return url\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid redirect to the supplied URL\\n        \"\"\"\\n        return HttpResponseRedirect(self.get_success_url())\\n\\n    def formset_invalid(self, formset):\\n        \"\"\"\\n        If the formset is invalid, re-render the context data with the\\n        data-filled formset and errors.\\n        \"\"\"\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n\\nclass ModelFormSetMixin(FormSetMixin, MultipleObjectMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single model formset\\n    in a request.\\n\\n    Uses `modelformset_factory`.\\n    \"\"\"\\n\\n    exclude = None\\n    fields = None\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"queryset\"] = self.get_queryset()\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the model formset factory\\n        \"\"\"\\n        return modelformset_factory(self.model, **self.get_factory_kwargs())\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid, save the associated models.\\n        \"\"\"\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass BaseInlineFormSetFactory(BaseFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a FormSet from `inlineformset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    model = None\\n    inline_model = None\\n    exclude = None\\n    fields = None\\n\\n    def get_inline_model(self):\\n        \"\"\"\\n        Returns the inline model to use with the inline formset\\n        \"\"\"\\n        return self.inline_model\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"instance\"] = self.object\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the inline formset factory\\n        \"\"\"\\n        return inlineformset_factory(\\n            self.model, self.get_inline_model(), **self.get_factory_kwargs()\\n        )\\n\\n\\nclass InlineFormSetMixin(BaseInlineFormSetFactory, SingleObjectMixin, FormSetMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single inline formset\\n    in a request.\\n    \"\"\"\\n\\n    def formset_valid(self, formset):\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass ProcessFormSetView(View):\\n    \"\"\"\\n    A mixin that processes a formset on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the formset.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a formset instance with the passed\\n        POST variables and then checked for validity.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        if formset.is_valid():\\n            return self.formset_valid(formset)\\n        else:\\n            return self.formset_invalid(formset)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseFormSetView(FormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a formset\\n    \"\"\"\\n\\n\\nclass FormSetView(TemplateResponseMixin, BaseFormSetView):\\n    \"\"\"\\n    A view for displaying a formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseModelFormSetView(ModelFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a model formset\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass ModelFormSetView(MultipleObjectTemplateResponseMixin, BaseModelFormSetView):\\n    \"\"\"\\n    A view for displaying a model formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseInlineFormSetView(InlineFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying an inline formset for a queryset belonging to\\n    a parent model\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass InlineFormSetView(SingleObjectTemplateResponseMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A view for displaying an inline formset for a queryset belonging to a parent model\\n    \"\"\"\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from django.contrib.contenttypes.forms import generic_inlineformset_factory\\n\\nfrom extra_views.formsets import (\\n    BaseInlineFormSetFactory,\\n    BaseInlineFormSetView,\\n    InlineFormSetMixin,\\n    InlineFormSetView,\\n)\\n\\n\\nclass BaseGenericInlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a GenericInlineFormSet from\\n    `generic_inlineformset_factory` in a view.\\n    \"\"\"\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the final formset class from generic_inlineformset_factory.\\n        \"\"\"\\n        result = generic_inlineformset_factory(\\n            self.inline_model, **self.get_factory_kwargs()\\n        )\\n        return result\\n\\n\\nclass GenericInlineFormSetFactory(BaseGenericInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create a `GenericInlineFormSet` from `generic_inlineformset_factory`\\n    as one of multiple `GenericInlineFormSet`s within a single view.\\n\\n    Subclasses `BaseGenericInlineFormSetFactory` and passes in the necessary view\\n    arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n\\nclass GenericInlineFormSetMixin(BaseGenericInlineFormSetFactory, InlineFormSetMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a generic inline formset in a\\n    request.\\n    \"\"\"\\n\\n\\nclass BaseGenericInlineFormSetView(GenericInlineFormSetMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A base view for displaying a generic inline formset\\n    \"\"\"\\n\\n\\nclass GenericInlineFormSetView(BaseGenericInlineFormSetView, InlineFormSetView):\\n    \"\"\"\\n    A view for displaying a generic inline formset for a queryset belonging to a\\n    parent model\\n    \"\"\"\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b''"}, "return_value": "'utf-8'"}]}, "neuter_encoding_declaration": {"line": 214, "args": [{"func_args": {"source": "'from extra_views.advanced import (\\n    CreateWithInlinesView,\\n    FormSetSuccessMessageMixin,\\n    InlineFormSetFactory,\\n    NamedFormsetsMixin,\\n    SuccessMessageMixin,\\n    UpdateWithInlinesView,\\n)\\nfrom extra_views.contrib.mixins import SearchableListMixin, SortableListMixin\\nfrom extra_views.dates import CalendarMonthView\\nfrom extra_views.formsets import FormSetView, InlineFormSetView, ModelFormSetView\\n\\n__version__ = \"0.14.0\"\\n\\n__all__ = [\\n    \"CreateWithInlinesView\",\\n    \"FormSetSuccessMessageMixin\",\\n    \"InlineFormSetFactory\",\\n    \"NamedFormsetsMixin\",\\n    \"SuccessMessageMixin\",\\n    \"UpdateWithInlinesView\",\\n    \"SearchableListMixin\",\\n    \"SortableListMixin\",\\n    \"CalendarMonthView\",\\n    \"FormSetView\",\\n    \"InlineFormSetView\",\\n    \"ModelFormSetView\",\\n]\\n'"}, "return_value": "'from extra_views.advanced import (\\n    CreateWithInlinesView,\\n    FormSetSuccessMessageMixin,\\n    InlineFormSetFactory,\\n    NamedFormsetsMixin,\\n    SuccessMessageMixin,\\n    UpdateWithInlinesView,\\n)\\nfrom extra_views.contrib.mixins import SearchableListMixin, SortableListMixin\\nfrom extra_views.dates import CalendarMonthView\\nfrom extra_views.formsets import FormSetView, InlineFormSetView, ModelFormSetView\\n\\n__version__ = \"0.14.0\"\\n\\n__all__ = [\\n    \"CreateWithInlinesView\",\\n    \"FormSetSuccessMessageMixin\",\\n    \"InlineFormSetFactory\",\\n    \"NamedFormsetsMixin\",\\n    \"SuccessMessageMixin\",\\n    \"UpdateWithInlinesView\",\\n    \"SearchableListMixin\",\\n    \"SortableListMixin\",\\n    \"CalendarMonthView\",\\n    \"FormSetView\",\\n    \"InlineFormSetView\",\\n    \"ModelFormSetView\",\\n]\\n'"}, {"func_args": {"source": "'from django.contrib import messages\\nfrom django.forms.formsets import all_valid\\nfrom django.views.generic.base import ContextMixin\\nfrom django.views.generic.detail import SingleObjectTemplateResponseMixin\\nfrom django.views.generic.edit import FormView, ModelFormMixin\\n\\nfrom extra_views.formsets import BaseInlineFormSetFactory\\n\\n\\nclass InlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create an `InlineFormSet` from `inlineformset_factory` as\\n    one of multiple `InlineFormSet`s within a single view.\\n\\n    Subclasses `BaseInlineFormSetFactory` and passes in the necessary view arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Overrides construct_formset to attach the model class as\\n        an attribute of the returned formset instance.\\n        \"\"\"\\n        formset = super().construct_formset()\\n        formset.model = self.inline_model\\n        return formset\\n\\n\\nclass ModelFormWithInlinesMixin(ModelFormMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a modelform and inline\\n    formsets in a request.\\n\\n    The inlines should be subclasses of `InlineFormSetFactory`.\\n    \"\"\"\\n\\n    inlines = []\\n\\n    def get_inlines(self):\\n        \"\"\"\\n        Returns the inline formset classes\\n        \"\"\"\\n        return self.inlines[:]\\n\\n    def forms_valid(self, form, inlines):\\n        \"\"\"\\n        If the form and formsets are valid, save the associated models.\\n        \"\"\"\\n        response = self.form_valid(form)\\n        for formset in inlines:\\n            formset.save()\\n        return response\\n\\n    def forms_invalid(self, form, inlines):\\n        \"\"\"\\n        If the form or formsets are invalid, re-render the context data with the\\n        data-filled form and formsets and errors.\\n        \"\"\"\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines)\\n        )\\n\\n    def construct_inlines(self):\\n        \"\"\"\\n        Returns the inline formset instances\\n        \"\"\"\\n        inline_formsets = []\\n        for inline_class in self.get_inlines():\\n            inline_instance = inline_class(\\n                self.model, self.request, self.object, self.kwargs, self\\n            )\\n            inline_formset = inline_instance.construct_formset()\\n            inline_formsets.append(inline_formset)\\n        return inline_formsets\\n\\n\\nclass ProcessFormWithInlinesView(FormView):\\n    \"\"\"\\n    A mixin that renders a form and inline formsets on GET and processes it on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the form and formsets.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n        inlines = self.construct_inlines()\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines, **kwargs)\\n        )\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a form and formset instances with the\\n        passed POST variables and then checked for validity.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n\\n        initial_object = self.object\\n        if form.is_valid():\\n            self.object = form.save(commit=False)\\n            form_validated = True\\n        else:\\n            form_validated = False\\n\\n        inlines = self.construct_inlines()\\n\\n        if all_valid(inlines) and form_validated:\\n            return self.forms_valid(form, inlines)\\n        self.object = initial_object\\n        return self.forms_invalid(form, inlines)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseCreateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for creating an new object instance with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass CreateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseCreateWithInlinesView\\n):\\n    \"\"\"\\n    View for creating a new object instance with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass BaseUpdateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for updating an existing object with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass UpdateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseUpdateWithInlinesView\\n):\\n    \"\"\"\\n    View for updating an object with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass NamedFormsetsMixin(ContextMixin):\\n    \"\"\"\\n    A mixin for use with `CreateWithInlinesView` or `UpdateWithInlinesView` that lets\\n    you define the context variable for each inline.\\n    \"\"\"\\n\\n    inlines_names = []\\n\\n    def get_inlines_names(self):\\n        \"\"\"\\n        Returns a list of names of context variables for each inline in `inlines`.\\n        \"\"\"\\n        return self.inlines_names[:]\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        If `inlines_names` has been defined, add each formset to the context under\\n        its corresponding entry in `inlines_names`\\n        \"\"\"\\n        context = {}\\n        inlines_names = self.get_inlines_names()\\n\\n        if inlines_names:\\n            # We have formset or inlines in context, but never both\\n            context.update(zip(inlines_names, kwargs.get(\"inlines\", [])))\\n            if \"formset\" in kwargs:\\n                context[inlines_names[0]] = kwargs[\"formset\"]\\n        context.update(kwargs)\\n        return super().get_context_data(**context)\\n\\n\\nclass SuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on views with inlines if django.contrib.messages framework\\n    is used.\\n    In order to use just add mixin in to inheritance before main class, e.g.:\\n    class MyCreateWithInlinesView (SuccessMessageMixin, CreateWithInlinesView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super().forms_valid(form, inlines)\\n        success_message = self.get_success_message(form.cleaned_data, inlines)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data, inlines):\\n        return self.success_message % cleaned_data\\n\\n\\nclass FormSetSuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on FormSet views if django.contrib.messages framework\\n    is used. In order to use just add mixin in to inheritance before main\\n    class, e.g.:\\n    class MyFormSetView (FormSetSuccessMessageMixin, ModelFormSetView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def formset_valid(self, formset):\\n        response = super().formset_valid(formset)\\n        success_message = self.get_success_message(formset)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, formset):\\n        return self.success_message\\n'"}, "return_value": "'from django.contrib import messages\\nfrom django.forms.formsets import all_valid\\nfrom django.views.generic.base import ContextMixin\\nfrom django.views.generic.detail import SingleObjectTemplateResponseMixin\\nfrom django.views.generic.edit import FormView, ModelFormMixin\\n\\nfrom extra_views.formsets import BaseInlineFormSetFactory\\n\\n\\nclass InlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create an `InlineFormSet` from `inlineformset_factory` as\\n    one of multiple `InlineFormSet`s within a single view.\\n\\n    Subclasses `BaseInlineFormSetFactory` and passes in the necessary view arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Overrides construct_formset to attach the model class as\\n        an attribute of the returned formset instance.\\n        \"\"\"\\n        formset = super().construct_formset()\\n        formset.model = self.inline_model\\n        return formset\\n\\n\\nclass ModelFormWithInlinesMixin(ModelFormMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a modelform and inline\\n    formsets in a request.\\n\\n    The inlines should be subclasses of `InlineFormSetFactory`.\\n    \"\"\"\\n\\n    inlines = []\\n\\n    def get_inlines(self):\\n        \"\"\"\\n        Returns the inline formset classes\\n        \"\"\"\\n        return self.inlines[:]\\n\\n    def forms_valid(self, form, inlines):\\n        \"\"\"\\n        If the form and formsets are valid, save the associated models.\\n        \"\"\"\\n        response = self.form_valid(form)\\n        for formset in inlines:\\n            formset.save()\\n        return response\\n\\n    def forms_invalid(self, form, inlines):\\n        \"\"\"\\n        If the form or formsets are invalid, re-render the context data with the\\n        data-filled form and formsets and errors.\\n        \"\"\"\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines)\\n        )\\n\\n    def construct_inlines(self):\\n        \"\"\"\\n        Returns the inline formset instances\\n        \"\"\"\\n        inline_formsets = []\\n        for inline_class in self.get_inlines():\\n            inline_instance = inline_class(\\n                self.model, self.request, self.object, self.kwargs, self\\n            )\\n            inline_formset = inline_instance.construct_formset()\\n            inline_formsets.append(inline_formset)\\n        return inline_formsets\\n\\n\\nclass ProcessFormWithInlinesView(FormView):\\n    \"\"\"\\n    A mixin that renders a form and inline formsets on GET and processes it on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the form and formsets.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n        inlines = self.construct_inlines()\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines, **kwargs)\\n        )\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a form and formset instances with the\\n        passed POST variables and then checked for validity.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n\\n        initial_object = self.object\\n        if form.is_valid():\\n            self.object = form.save(commit=False)\\n            form_validated = True\\n        else:\\n            form_validated = False\\n\\n        inlines = self.construct_inlines()\\n\\n        if all_valid(inlines) and form_validated:\\n            return self.forms_valid(form, inlines)\\n        self.object = initial_object\\n        return self.forms_invalid(form, inlines)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseCreateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for creating an new object instance with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass CreateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseCreateWithInlinesView\\n):\\n    \"\"\"\\n    View for creating a new object instance with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass BaseUpdateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for updating an existing object with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass UpdateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseUpdateWithInlinesView\\n):\\n    \"\"\"\\n    View for updating an object with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass NamedFormsetsMixin(ContextMixin):\\n    \"\"\"\\n    A mixin for use with `CreateWithInlinesView` or `UpdateWithInlinesView` that lets\\n    you define the context variable for each inline.\\n    \"\"\"\\n\\n    inlines_names = []\\n\\n    def get_inlines_names(self):\\n        \"\"\"\\n        Returns a list of names of context variables for each inline in `inlines`.\\n        \"\"\"\\n        return self.inlines_names[:]\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        If `inlines_names` has been defined, add each formset to the context under\\n        its corresponding entry in `inlines_names`\\n        \"\"\"\\n        context = {}\\n        inlines_names = self.get_inlines_names()\\n\\n        if inlines_names:\\n            # We have formset or inlines in context, but never both\\n            context.update(zip(inlines_names, kwargs.get(\"inlines\", [])))\\n            if \"formset\" in kwargs:\\n                context[inlines_names[0]] = kwargs[\"formset\"]\\n        context.update(kwargs)\\n        return super().get_context_data(**context)\\n\\n\\nclass SuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on views with inlines if django.contrib.messages framework\\n    is used.\\n    In order to use just add mixin in to inheritance before main class, e.g.:\\n    class MyCreateWithInlinesView (SuccessMessageMixin, CreateWithInlinesView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super().forms_valid(form, inlines)\\n        success_message = self.get_success_message(form.cleaned_data, inlines)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data, inlines):\\n        return self.success_message % cleaned_data\\n\\n\\nclass FormSetSuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on FormSet views if django.contrib.messages framework\\n    is used. In order to use just add mixin in to inheritance before main\\n    class, e.g.:\\n    class MyFormSetView (FormSetSuccessMessageMixin, ModelFormSetView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def formset_valid(self, formset):\\n        response = super().formset_valid(formset)\\n        success_message = self.get_success_message(formset)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, formset):\\n        return self.success_message\\n'"}, {"func_args": {"source": "'import datetime\\nimport functools\\nimport operator\\n\\nfrom django.contrib import messages\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.views.generic.base import ContextMixin\\n\\nVALID_STRING_LOOKUPS = (\\n    \"iexact\",\\n    \"contains\",\\n    \"icontains\",\\n    \"startswith\",\\n    \"istartswith\",\\n    \"endswith\",\\n    \"iendswith\",\\n    \"search\",\\n    \"regex\",\\n    \"iregex\",\\n)\\n\\n\\nclass SearchableListMixin(object):\\n    \"\"\"\\n    Filter queryset like a django admin search_fields does, but with little\\n     more intelligence:\\n    if self.search_split is set to True (by default) it will split query\\n     to words (by whitespace)\\n    Also tries to convert each word to date with self.search_date_formats and\\n     then search each word in separate field\\n    e.g. with query \\'foo bar\\' you can find object with\\n     obj.field1__icontains=\\'foo\\' and obj.field2__icontains==\\'bar\\'\\n\\n    To provide custom lookup just set one of the search_fields to tuple,\\n    e.g. search_fields = [(\\'field1\\', \\'iexact\\'), \\'field2\\', (\\'field3\\', \\'startswith\\')]\\n\\n    This class is designed to be used with django.generic.ListView\\n\\n    You could specify query by overriding get_search_query method\\n    by default this method will try to get \\'q\\' key from request.GET\\n    (this can be disabled with search_use_q=False)\\n    \"\"\"\\n\\n    search_fields = [\"id\"]\\n    search_date_fields = None\\n    search_date_formats = [\"%d.%m.%y\", \"%d.%m.%Y\"]\\n    search_split = True\\n    search_use_q = True\\n    check_lookups = True\\n\\n    def get_words(self, query):\\n        if self.search_split:\\n            return query.split()\\n        return [query]\\n\\n    def get_search_fields_with_filters(self):\\n        fields = []\\n        for sf in self.search_fields:\\n            if isinstance(sf, str):\\n                fields.append((sf, \"icontains\"))\\n            else:\\n                if self.check_lookups and sf[1] not in VALID_STRING_LOOKUPS:\\n                    raise ValueError(\"Invalid string lookup - %s\" % sf[1])\\n                fields.append(sf)\\n        return fields\\n\\n    def try_convert_to_date(self, word):\\n        \"\"\"\\n        Tries to convert word to date(datetime) using search_date_formats\\n        Return None if word fits no one format\\n        \"\"\"\\n        for frm in self.search_date_formats:\\n            try:\\n                return datetime.datetime.strptime(word, frm).date()\\n            except ValueError:\\n                pass\\n        return None\\n\\n    def get_search_query(self):\\n        \"\"\"\\n        Get query from request.GET \\'q\\' parameter when search_use_q is set to True\\n        Override this method to provide your own query to search\\n        \"\"\"\\n        return self.search_use_q and self.request.GET.get(\"q\", \"\").strip()\\n\\n    def get_queryset(self):\\n        qs = super(SearchableListMixin, self).get_queryset()\\n        query = self.get_search_query()\\n        if query:\\n            w_qs = []\\n            search_pairs = self.get_search_fields_with_filters()\\n            for word in self.get_words(query):\\n                filters = [\\n                    Q(**{\"%s__%s\" % (pair[0], pair[1]): word}) for pair in search_pairs\\n                ]\\n                if self.search_date_fields:\\n                    dt = self.try_convert_to_date(word)\\n                    if dt:\\n                        filters.extend(\\n                            [\\n                                Q(**{field_name: dt})\\n                                for field_name in self.search_date_fields\\n                            ]\\n                        )\\n                w_qs.append(functools.reduce(operator.or_, filters))\\n            qs = qs.filter(functools.reduce(operator.and_, w_qs))\\n            qs = qs.distinct()\\n        return qs\\n\\n\\nclass SortHelper(object):\\n    def __init__(\\n        self, request, sort_fields_aliases, sort_param_name, sort_type_param_name\\n    ):\\n        # Create a list from sort_fields_aliases, in case it is a generator,\\n        # since we want to iterate through it multiple times.\\n        sort_fields_aliases = list(sort_fields_aliases)\\n\\n        self.initial_params = request.GET.copy()\\n        self.sort_fields = dict(sort_fields_aliases)\\n        self.inv_sort_fields = dict((v, k) for k, v in sort_fields_aliases)\\n        self.initial_sort = self.inv_sort_fields.get(\\n            self.initial_params.get(sort_param_name), None\\n        )\\n        self.initial_sort_type = self.initial_params.get(sort_type_param_name, \"asc\")\\n        self.sort_param_name = sort_param_name\\n        self.sort_type_param_name = sort_type_param_name\\n\\n        for field, alias in self.sort_fields.items():\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s\" % alias,\\n                functools.partial(self.get_params_for_field, field),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_asc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"asc\"),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_desc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"desc\"),\\n            )\\n            setattr(\\n                self,\\n                \"is_sorted_by_%s\" % alias,\\n                functools.partial(self.is_sorted_by, field),\\n            )\\n\\n    def is_sorted_by(self, field_name):\\n        return field_name == self.initial_sort and self.initial_sort_type or False\\n\\n    def get_params_for_field(self, field_name, sort_type=None):\\n        \"\"\"\\n        If sort_type is None - inverse current sort for field, if no sorted - use asc\\n        \"\"\"\\n        if not sort_type:\\n            if self.initial_sort == field_name:\\n                sort_type = \"desc\" if self.initial_sort_type == \"asc\" else \"asc\"\\n            else:\\n                sort_type = \"asc\"\\n        self.initial_params[self.sort_param_name] = self.sort_fields[field_name]\\n        self.initial_params[self.sort_type_param_name] = sort_type\\n        return \"?%s\" % self.initial_params.urlencode()\\n\\n    def get_sort(self):\\n        if not self.initial_sort:\\n            return None\\n        sort = \"%s\" % self.initial_sort\\n        if self.initial_sort_type == \"desc\":\\n            sort = \"-%s\" % sort\\n        return sort\\n\\n\\nclass SortableListMixin(ContextMixin):\\n    \"\"\"\\n    You can provide either sort_fields as a plain list like\\n     [\\'id\\', \\'some\\', \\'foo__bar\\', ...]\\n    or, if you want to hide original field names you can provide list of tuples with\\n    alias that will be used:\\n    [(\\'id\\', \\'by_id\\'), (\\'some\\', \\'show_this\\'), (\\'foo__bar\\', \\'bar\\')]\\n\\n    If sort_param_name exists in query but sort_type_param_name is omitted queryset\\n     will be sorted as \\'asc\\'\\n    \"\"\"\\n\\n    sort_fields = []\\n    sort_fields_aliases = []\\n    sort_param_name = \"o\"\\n    sort_type_param_name = \"ot\"\\n\\n    def get_sort_fields(self):\\n        if self.sort_fields:\\n            return zip(self.sort_fields, self.sort_fields)\\n        return self.sort_fields_aliases\\n\\n    def get_sort_helper(self):\\n        return SortHelper(\\n            self.request,\\n            self.get_sort_fields(),\\n            self.sort_param_name,\\n            self.sort_type_param_name,\\n        )\\n\\n    def _sort_queryset(self, queryset):\\n        self.sort_helper = self.get_sort_helper()\\n        sort = self.sort_helper.get_sort()\\n        if sort:\\n            queryset = queryset.order_by(sort)\\n        return queryset\\n\\n    def get_queryset(self):\\n        qs = super(SortableListMixin, self).get_queryset()\\n        if self.sort_fields and self.sort_fields_aliases:\\n            raise ImproperlyConfigured(\\n                \"You should provide sort_fields or sort_fields_aliaces but not both\"\\n            )\\n        return self._sort_queryset(qs)\\n\\n    def get_context_data(self, **kwargs):\\n        context = {}\\n        if hasattr(self, \"sort_helper\"):\\n            context[\"sort_helper\"] = self.sort_helper\\n        context.update(kwargs)\\n        return super(SortableListMixin, self).get_context_data(**context)\\n\\n\\nclass SuccessMessageWithInlinesMixin(object):\\n    \"\"\"\\n    Adds a success message on successful form submission.\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super(SuccessMessageWithInlinesMixin, self).forms_valid(\\n            form, inlines\\n        )\\n        success_message = self.get_success_message(form.cleaned_data)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data):\\n        return self.success_message % cleaned_data\\n'"}, "return_value": "'import datetime\\nimport functools\\nimport operator\\n\\nfrom django.contrib import messages\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.views.generic.base import ContextMixin\\n\\nVALID_STRING_LOOKUPS = (\\n    \"iexact\",\\n    \"contains\",\\n    \"icontains\",\\n    \"startswith\",\\n    \"istartswith\",\\n    \"endswith\",\\n    \"iendswith\",\\n    \"search\",\\n    \"regex\",\\n    \"iregex\",\\n)\\n\\n\\nclass SearchableListMixin(object):\\n    \"\"\"\\n    Filter queryset like a django admin search_fields does, but with little\\n     more intelligence:\\n    if self.search_split is set to True (by default) it will split query\\n     to words (by whitespace)\\n    Also tries to convert each word to date with self.search_date_formats and\\n     then search each word in separate field\\n    e.g. with query \\'foo bar\\' you can find object with\\n     obj.field1__icontains=\\'foo\\' and obj.field2__icontains==\\'bar\\'\\n\\n    To provide custom lookup just set one of the search_fields to tuple,\\n    e.g. search_fields = [(\\'field1\\', \\'iexact\\'), \\'field2\\', (\\'field3\\', \\'startswith\\')]\\n\\n    This class is designed to be used with django.generic.ListView\\n\\n    You could specify query by overriding get_search_query method\\n    by default this method will try to get \\'q\\' key from request.GET\\n    (this can be disabled with search_use_q=False)\\n    \"\"\"\\n\\n    search_fields = [\"id\"]\\n    search_date_fields = None\\n    search_date_formats = [\"%d.%m.%y\", \"%d.%m.%Y\"]\\n    search_split = True\\n    search_use_q = True\\n    check_lookups = True\\n\\n    def get_words(self, query):\\n        if self.search_split:\\n            return query.split()\\n        return [query]\\n\\n    def get_search_fields_with_filters(self):\\n        fields = []\\n        for sf in self.search_fields:\\n            if isinstance(sf, str):\\n                fields.append((sf, \"icontains\"))\\n            else:\\n                if self.check_lookups and sf[1] not in VALID_STRING_LOOKUPS:\\n                    raise ValueError(\"Invalid string lookup - %s\" % sf[1])\\n                fields.append(sf)\\n        return fields\\n\\n    def try_convert_to_date(self, word):\\n        \"\"\"\\n        Tries to convert word to date(datetime) using search_date_formats\\n        Return None if word fits no one format\\n        \"\"\"\\n        for frm in self.search_date_formats:\\n            try:\\n                return datetime.datetime.strptime(word, frm).date()\\n            except ValueError:\\n                pass\\n        return None\\n\\n    def get_search_query(self):\\n        \"\"\"\\n        Get query from request.GET \\'q\\' parameter when search_use_q is set to True\\n        Override this method to provide your own query to search\\n        \"\"\"\\n        return self.search_use_q and self.request.GET.get(\"q\", \"\").strip()\\n\\n    def get_queryset(self):\\n        qs = super(SearchableListMixin, self).get_queryset()\\n        query = self.get_search_query()\\n        if query:\\n            w_qs = []\\n            search_pairs = self.get_search_fields_with_filters()\\n            for word in self.get_words(query):\\n                filters = [\\n                    Q(**{\"%s__%s\" % (pair[0], pair[1]): word}) for pair in search_pairs\\n                ]\\n                if self.search_date_fields:\\n                    dt = self.try_convert_to_date(word)\\n                    if dt:\\n                        filters.extend(\\n                            [\\n                                Q(**{field_name: dt})\\n                                for field_name in self.search_date_fields\\n                            ]\\n                        )\\n                w_qs.append(functools.reduce(operator.or_, filters))\\n            qs = qs.filter(functools.reduce(operator.and_, w_qs))\\n            qs = qs.distinct()\\n        return qs\\n\\n\\nclass SortHelper(object):\\n    def __init__(\\n        self, request, sort_fields_aliases, sort_param_name, sort_type_param_name\\n    ):\\n        # Create a list from sort_fields_aliases, in case it is a generator,\\n        # since we want to iterate through it multiple times.\\n        sort_fields_aliases = list(sort_fields_aliases)\\n\\n        self.initial_params = request.GET.copy()\\n        self.sort_fields = dict(sort_fields_aliases)\\n        self.inv_sort_fields = dict((v, k) for k, v in sort_fields_aliases)\\n        self.initial_sort = self.inv_sort_fields.get(\\n            self.initial_params.get(sort_param_name), None\\n        )\\n        self.initial_sort_type = self.initial_params.get(sort_type_param_name, \"asc\")\\n        self.sort_param_name = sort_param_name\\n        self.sort_type_param_name = sort_type_param_name\\n\\n        for field, alias in self.sort_fields.items():\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s\" % alias,\\n                functools.partial(self.get_params_for_field, field),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_asc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"asc\"),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_desc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"desc\"),\\n            )\\n            setattr(\\n                self,\\n                \"is_sorted_by_%s\" % alias,\\n                functools.partial(self.is_sorted_by, field),\\n            )\\n\\n    def is_sorted_by(self, field_name):\\n        return field_name == self.initial_sort and self.initial_sort_type or False\\n\\n    def get_params_for_field(self, field_name, sort_type=None):\\n        \"\"\"\\n        If sort_type is None - inverse current sort for field, if no sorted - use asc\\n        \"\"\"\\n        if not sort_type:\\n            if self.initial_sort == field_name:\\n                sort_type = \"desc\" if self.initial_sort_type == \"asc\" else \"asc\"\\n            else:\\n                sort_type = \"asc\"\\n        self.initial_params[self.sort_param_name] = self.sort_fields[field_name]\\n        self.initial_params[self.sort_type_param_name] = sort_type\\n        return \"?%s\" % self.initial_params.urlencode()\\n\\n    def get_sort(self):\\n        if not self.initial_sort:\\n            return None\\n        sort = \"%s\" % self.initial_sort\\n        if self.initial_sort_type == \"desc\":\\n            sort = \"-%s\" % sort\\n        return sort\\n\\n\\nclass SortableListMixin(ContextMixin):\\n    \"\"\"\\n    You can provide either sort_fields as a plain list like\\n     [\\'id\\', \\'some\\', \\'foo__bar\\', ...]\\n    or, if you want to hide original field names you can provide list of tuples with\\n    alias that will be used:\\n    [(\\'id\\', \\'by_id\\'), (\\'some\\', \\'show_this\\'), (\\'foo__bar\\', \\'bar\\')]\\n\\n    If sort_param_name exists in query but sort_type_param_name is omitted queryset\\n     will be sorted as \\'asc\\'\\n    \"\"\"\\n\\n    sort_fields = []\\n    sort_fields_aliases = []\\n    sort_param_name = \"o\"\\n    sort_type_param_name = \"ot\"\\n\\n    def get_sort_fields(self):\\n        if self.sort_fields:\\n            return zip(self.sort_fields, self.sort_fields)\\n        return self.sort_fields_aliases\\n\\n    def get_sort_helper(self):\\n        return SortHelper(\\n            self.request,\\n            self.get_sort_fields(),\\n            self.sort_param_name,\\n            self.sort_type_param_name,\\n        )\\n\\n    def _sort_queryset(self, queryset):\\n        self.sort_helper = self.get_sort_helper()\\n        sort = self.sort_helper.get_sort()\\n        if sort:\\n            queryset = queryset.order_by(sort)\\n        return queryset\\n\\n    def get_queryset(self):\\n        qs = super(SortableListMixin, self).get_queryset()\\n        if self.sort_fields and self.sort_fields_aliases:\\n            raise ImproperlyConfigured(\\n                \"You should provide sort_fields or sort_fields_aliaces but not both\"\\n            )\\n        return self._sort_queryset(qs)\\n\\n    def get_context_data(self, **kwargs):\\n        context = {}\\n        if hasattr(self, \"sort_helper\"):\\n            context[\"sort_helper\"] = self.sort_helper\\n        context.update(kwargs)\\n        return super(SortableListMixin, self).get_context_data(**context)\\n\\n\\nclass SuccessMessageWithInlinesMixin(object):\\n    \"\"\"\\n    Adds a success message on successful form submission.\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super(SuccessMessageWithInlinesMixin, self).forms_valid(\\n            form, inlines\\n        )\\n        success_message = self.get_success_message(form.cleaned_data)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data):\\n        return self.success_message % cleaned_data\\n'"}, {"func_args": {"source": "'import datetime\\nimport math\\nfrom calendar import Calendar\\nfrom collections import defaultdict\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.utils.translation import gettext_lazy as _\\nfrom django.views.generic.dates import (\\n    DateMixin,\\n    MonthMixin,\\n    YearMixin,\\n    _date_from_string,\\n)\\nfrom django.views.generic.list import BaseListView, MultipleObjectTemplateResponseMixin\\n\\nDAYS = (\\n    _(\"Monday\"),\\n    _(\"Tuesday\"),\\n    _(\"Wednesday\"),\\n    _(\"Thursday\"),\\n    _(\"Friday\"),\\n    _(\"Saturday\"),\\n    _(\"Sunday\"),\\n)\\n\\n\\ndef daterange(start_date, end_date):\\n    \"\"\"\\n    Returns an iterator of dates between two provided ones\\n    \"\"\"\\n    for n in range(int((end_date - start_date).days + 1)):\\n        yield start_date + datetime.timedelta(n)\\n\\n\\nclass BaseCalendarMonthView(DateMixin, YearMixin, MonthMixin, BaseListView):\\n    \"\"\"\\n    A base view for displaying a calendar month\\n    \"\"\"\\n\\n    first_of_week = 0  # 0 = Monday, 6 = Sunday\\n    paginate_by = None  # We don\\'t want to use this part of MultipleObjectMixin\\n    date_field = None\\n    end_date_field = None  # For supporting events with duration\\n\\n    def get_paginate_by(self, queryset):\\n        if self.paginate_by is not None:\\n            raise ImproperlyConfigured(\\n                \"\\'%s\\' cannot be paginated, it is a calendar view\"\\n                % self.__class__.__name__\\n            )\\n        return None\\n\\n    def get_allow_future(self):\\n        return True\\n\\n    def get_end_date_field(self):\\n        \"\"\"\\n        Returns the model field to use for end dates\\n        \"\"\"\\n        return self.end_date_field\\n\\n    def get_start_date(self, obj):\\n        \"\"\"\\n        Returns the start date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_end_date(self, obj):\\n        \"\"\"\\n        Returns the end date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_end_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_first_of_week(self):\\n        \"\"\"\\n        Returns an integer representing the first day of the week.\\n\\n        0 represents Monday, 6 represents Sunday.\\n        \"\"\"\\n        if self.first_of_week is None:\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week is required.\" % self.__class__.__name__\\n            )\\n        if self.first_of_week not in range(7):\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week must be an integer between 0 and 6.\"\\n                % self.__class__.__name__\\n            )\\n        return self.first_of_week\\n\\n    def get_queryset(self):\\n        \"\"\"\\n        Returns a queryset of models for the month requested\\n        \"\"\"\\n        qs = super().get_queryset()\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date_field = self.get_date_field()\\n        end_date_field = self.get_end_date_field()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        since = date\\n        until = self.get_next_month(date)\\n\\n        # Adjust our start and end dates to allow for next and previous\\n        # month edges\\n        if since.weekday() != self.get_first_of_week():\\n            diff = math.fabs(since.weekday() - self.get_first_of_week())\\n            since = since - datetime.timedelta(days=diff)\\n\\n        if until.weekday() != ((self.get_first_of_week() + 6) % 7):\\n            diff = math.fabs(((self.get_first_of_week() + 6) % 7) - until.weekday())\\n            until = until + datetime.timedelta(days=diff)\\n\\n        if end_date_field:\\n            # 5 possible conditions for showing an event:\\n\\n            # 1) Single day event, starts after \\'since\\'\\n            # 2) Multi-day event, starts after \\'since\\' and ends before \\'until\\'\\n            # 3) Starts before \\'since\\' and ends after \\'since\\' and before \\'until\\'\\n            # 4) Starts after \\'since\\' but before \\'until\\' and ends after \\'until\\'\\n            # 5) Starts before \\'since\\' and ends after \\'until\\'\\n            predicate1 = Q(**{\"%s__gte\" % date_field: since, end_date_field: None})\\n            predicate2 = Q(\\n                **{\"%s__gte\" % date_field: since, \"%s__lt\" % end_date_field: until}\\n            )\\n            predicate3 = Q(\\n                **{\\n                    \"%s__lt\" % date_field: since,\\n                    \"%s__gte\" % end_date_field: since,\\n                    \"%s__lt\" % end_date_field: until,\\n                }\\n            )\\n            predicate4 = Q(\\n                **{\\n                    \"%s__gte\" % date_field: since,\\n                    \"%s__lt\" % date_field: until,\\n                    \"%s__gte\" % end_date_field: until,\\n                }\\n            )\\n            predicate5 = Q(\\n                **{\"%s__lt\" % date_field: since, \"%s__gte\" % end_date_field: until}\\n            )\\n            return qs.filter(\\n                predicate1 | predicate2 | predicate3 | predicate4 | predicate5\\n            )\\n        return qs.filter(**{\"%s__gte\" % date_field: since})\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        Injects variables necessary for rendering the calendar into the context.\\n\\n        Variables added are: `calendar`, `weekdays`, `month`, `next_month` and\\n        `previous_month`.\\n        \"\"\"\\n        data = super().get_context_data(**kwargs)\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        cal = Calendar(self.get_first_of_week())\\n\\n        month_calendar = []\\n        now = datetime.datetime.utcnow()\\n\\n        date_lists = defaultdict(list)\\n        multidate_objs = []\\n\\n        for obj in data[\"object_list\"]:\\n            obj_date = self.get_start_date(obj)\\n            end_date_field = self.get_end_date_field()\\n\\n            if end_date_field:\\n                end_date = self.get_end_date(obj)\\n                if end_date and end_date != obj_date:\\n                    multidate_objs.append(\\n                        {\\n                            \"obj\": obj,\\n                            \"range\": [x for x in daterange(obj_date, end_date)],\\n                        }\\n                    )\\n                    continue  # We don\\'t put multi-day events in date_lists\\n            date_lists[obj_date].append(obj)\\n\\n        for week in cal.monthdatescalendar(date.year, date.month):\\n            week_range = set(daterange(week[0], week[6]))\\n            week_events = []\\n\\n            for val in multidate_objs:\\n                intersect_length = len(week_range.intersection(val[\"range\"]))\\n\\n                if intersect_length:\\n                    # Event happens during this week\\n                    slot = 1\\n                    width = (\\n                        intersect_length  # How many days is the event during this week?\\n                    )\\n                    nowrap_previous = (\\n                        True  # Does the event continue from the previous week?\\n                    )\\n                    nowrap_next = True  # Does the event continue to the next week?\\n\\n                    if val[\"range\"][0] >= week[0]:\\n                        slot = 1 + (val[\"range\"][0] - week[0]).days\\n                    else:\\n                        nowrap_previous = False\\n                    if val[\"range\"][-1] > week[6]:\\n                        nowrap_next = False\\n\\n                    week_events.append(\\n                        {\\n                            \"event\": val[\"obj\"],\\n                            \"slot\": slot,\\n                            \"width\": width,\\n                            \"nowrap_previous\": nowrap_previous,\\n                            \"nowrap_next\": nowrap_next,\\n                        }\\n                    )\\n\\n            week_calendar = {\"events\": week_events, \"date_list\": []}\\n            for day in week:\\n                week_calendar[\"date_list\"].append(\\n                    {\\n                        \"day\": day,\\n                        \"events\": date_lists[day],\\n                        \"today\": day == now.date(),\\n                        \"is_current_month\": day.month == date.month,\\n                    }\\n                )\\n            month_calendar.append(week_calendar)\\n\\n        data[\"calendar\"] = month_calendar\\n        data[\"weekdays\"] = [DAYS[x] for x in cal.iterweekdays()]\\n        data[\"month\"] = date\\n        data[\"next_month\"] = self.get_next_month(date)\\n        data[\"previous_month\"] = self.get_previous_month(date)\\n\\n        return data\\n\\n\\nclass CalendarMonthView(MultipleObjectTemplateResponseMixin, BaseCalendarMonthView):\\n    \"\"\"\\n    A view for displaying a calendar month, and rendering a template response\\n    \"\"\"\\n\\n    template_name_suffix = \"_calendar_month\"\\n'"}, "return_value": "'import datetime\\nimport math\\nfrom calendar import Calendar\\nfrom collections import defaultdict\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.utils.translation import gettext_lazy as _\\nfrom django.views.generic.dates import (\\n    DateMixin,\\n    MonthMixin,\\n    YearMixin,\\n    _date_from_string,\\n)\\nfrom django.views.generic.list import BaseListView, MultipleObjectTemplateResponseMixin\\n\\nDAYS = (\\n    _(\"Monday\"),\\n    _(\"Tuesday\"),\\n    _(\"Wednesday\"),\\n    _(\"Thursday\"),\\n    _(\"Friday\"),\\n    _(\"Saturday\"),\\n    _(\"Sunday\"),\\n)\\n\\n\\ndef daterange(start_date, end_date):\\n    \"\"\"\\n    Returns an iterator of dates between two provided ones\\n    \"\"\"\\n    for n in range(int((end_date - start_date).days + 1)):\\n        yield start_date + datetime.timedelta(n)\\n\\n\\nclass BaseCalendarMonthView(DateMixin, YearMixin, MonthMixin, BaseListView):\\n    \"\"\"\\n    A base view for displaying a calendar month\\n    \"\"\"\\n\\n    first_of_week = 0  # 0 = Monday, 6 = Sunday\\n    paginate_by = None  # We don\\'t want to use this part of MultipleObjectMixin\\n    date_field = None\\n    end_date_field = None  # For supporting events with duration\\n\\n    def get_paginate_by(self, queryset):\\n        if self.paginate_by is not None:\\n            raise ImproperlyConfigured(\\n                \"\\'%s\\' cannot be paginated, it is a calendar view\"\\n                % self.__class__.__name__\\n            )\\n        return None\\n\\n    def get_allow_future(self):\\n        return True\\n\\n    def get_end_date_field(self):\\n        \"\"\"\\n        Returns the model field to use for end dates\\n        \"\"\"\\n        return self.end_date_field\\n\\n    def get_start_date(self, obj):\\n        \"\"\"\\n        Returns the start date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_end_date(self, obj):\\n        \"\"\"\\n        Returns the end date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_end_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_first_of_week(self):\\n        \"\"\"\\n        Returns an integer representing the first day of the week.\\n\\n        0 represents Monday, 6 represents Sunday.\\n        \"\"\"\\n        if self.first_of_week is None:\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week is required.\" % self.__class__.__name__\\n            )\\n        if self.first_of_week not in range(7):\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week must be an integer between 0 and 6.\"\\n                % self.__class__.__name__\\n            )\\n        return self.first_of_week\\n\\n    def get_queryset(self):\\n        \"\"\"\\n        Returns a queryset of models for the month requested\\n        \"\"\"\\n        qs = super().get_queryset()\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date_field = self.get_date_field()\\n        end_date_field = self.get_end_date_field()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        since = date\\n        until = self.get_next_month(date)\\n\\n        # Adjust our start and end dates to allow for next and previous\\n        # month edges\\n        if since.weekday() != self.get_first_of_week():\\n            diff = math.fabs(since.weekday() - self.get_first_of_week())\\n            since = since - datetime.timedelta(days=diff)\\n\\n        if until.weekday() != ((self.get_first_of_week() + 6) % 7):\\n            diff = math.fabs(((self.get_first_of_week() + 6) % 7) - until.weekday())\\n            until = until + datetime.timedelta(days=diff)\\n\\n        if end_date_field:\\n            # 5 possible conditions for showing an event:\\n\\n            # 1) Single day event, starts after \\'since\\'\\n            # 2) Multi-day event, starts after \\'since\\' and ends before \\'until\\'\\n            # 3) Starts before \\'since\\' and ends after \\'since\\' and before \\'until\\'\\n            # 4) Starts after \\'since\\' but before \\'until\\' and ends after \\'until\\'\\n            # 5) Starts before \\'since\\' and ends after \\'until\\'\\n            predicate1 = Q(**{\"%s__gte\" % date_field: since, end_date_field: None})\\n            predicate2 = Q(\\n                **{\"%s__gte\" % date_field: since, \"%s__lt\" % end_date_field: until}\\n            )\\n            predicate3 = Q(\\n                **{\\n                    \"%s__lt\" % date_field: since,\\n                    \"%s__gte\" % end_date_field: since,\\n                    \"%s__lt\" % end_date_field: until,\\n                }\\n            )\\n            predicate4 = Q(\\n                **{\\n                    \"%s__gte\" % date_field: since,\\n                    \"%s__lt\" % date_field: until,\\n                    \"%s__gte\" % end_date_field: until,\\n                }\\n            )\\n            predicate5 = Q(\\n                **{\"%s__lt\" % date_field: since, \"%s__gte\" % end_date_field: until}\\n            )\\n            return qs.filter(\\n                predicate1 | predicate2 | predicate3 | predicate4 | predicate5\\n            )\\n        return qs.filter(**{\"%s__gte\" % date_field: since})\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        Injects variables necessary for rendering the calendar into the context.\\n\\n        Variables added are: `calendar`, `weekdays`, `month`, `next_month` and\\n        `previous_month`.\\n        \"\"\"\\n        data = super().get_context_data(**kwargs)\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        cal = Calendar(self.get_first_of_week())\\n\\n        month_calendar = []\\n        now = datetime.datetime.utcnow()\\n\\n        date_lists = defaultdict(list)\\n        multidate_objs = []\\n\\n        for obj in data[\"object_list\"]:\\n            obj_date = self.get_start_date(obj)\\n            end_date_field = self.get_end_date_field()\\n\\n            if end_date_field:\\n                end_date = self.get_end_date(obj)\\n                if end_date and end_date != obj_date:\\n                    multidate_objs.append(\\n                        {\\n                            \"obj\": obj,\\n                            \"range\": [x for x in daterange(obj_date, end_date)],\\n                        }\\n                    )\\n                    continue  # We don\\'t put multi-day events in date_lists\\n            date_lists[obj_date].append(obj)\\n\\n        for week in cal.monthdatescalendar(date.year, date.month):\\n            week_range = set(daterange(week[0], week[6]))\\n            week_events = []\\n\\n            for val in multidate_objs:\\n                intersect_length = len(week_range.intersection(val[\"range\"]))\\n\\n                if intersect_length:\\n                    # Event happens during this week\\n                    slot = 1\\n                    width = (\\n                        intersect_length  # How many days is the event during this week?\\n                    )\\n                    nowrap_previous = (\\n                        True  # Does the event continue from the previous week?\\n                    )\\n                    nowrap_next = True  # Does the event continue to the next week?\\n\\n                    if val[\"range\"][0] >= week[0]:\\n                        slot = 1 + (val[\"range\"][0] - week[0]).days\\n                    else:\\n                        nowrap_previous = False\\n                    if val[\"range\"][-1] > week[6]:\\n                        nowrap_next = False\\n\\n                    week_events.append(\\n                        {\\n                            \"event\": val[\"obj\"],\\n                            \"slot\": slot,\\n                            \"width\": width,\\n                            \"nowrap_previous\": nowrap_previous,\\n                            \"nowrap_next\": nowrap_next,\\n                        }\\n                    )\\n\\n            week_calendar = {\"events\": week_events, \"date_list\": []}\\n            for day in week:\\n                week_calendar[\"date_list\"].append(\\n                    {\\n                        \"day\": day,\\n                        \"events\": date_lists[day],\\n                        \"today\": day == now.date(),\\n                        \"is_current_month\": day.month == date.month,\\n                    }\\n                )\\n            month_calendar.append(week_calendar)\\n\\n        data[\"calendar\"] = month_calendar\\n        data[\"weekdays\"] = [DAYS[x] for x in cal.iterweekdays()]\\n        data[\"month\"] = date\\n        data[\"next_month\"] = self.get_next_month(date)\\n        data[\"previous_month\"] = self.get_previous_month(date)\\n\\n        return data\\n\\n\\nclass CalendarMonthView(MultipleObjectTemplateResponseMixin, BaseCalendarMonthView):\\n    \"\"\"\\n    A view for displaying a calendar month, and rendering a template response\\n    \"\"\"\\n\\n    template_name_suffix = \"_calendar_month\"\\n'"}, {"func_args": {"source": "'from django.forms.formsets import formset_factory\\nfrom django.forms.models import inlineformset_factory, modelformset_factory\\nfrom django.http import HttpResponseRedirect\\nfrom django.views.generic.base import ContextMixin, TemplateResponseMixin, View\\nfrom django.views.generic.detail import (\\n    SingleObjectMixin,\\n    SingleObjectTemplateResponseMixin,\\n)\\nfrom django.views.generic.list import (\\n    MultipleObjectMixin,\\n    MultipleObjectTemplateResponseMixin,\\n)\\n\\n\\nclass BaseFormSetFactory(object):\\n    \"\"\"\\n    Base class for constructing a FormSet from `formset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    initial = []\\n    form_class = None\\n    formset_class = None\\n    prefix = None\\n    formset_kwargs = {}\\n    factory_kwargs = {}\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Returns an instance of the formset\\n        \"\"\"\\n        formset_class = self.get_formset()\\n        return formset_class(**self.get_formset_kwargs())\\n\\n    def get_initial(self):\\n        \"\"\"\\n        Returns a copy of the initial data to use for formsets on this view.\\n        \"\"\"\\n        return self.initial[:]\\n\\n    def get_prefix(self):\\n        \"\"\"\\n        Returns the prefix used for formsets on this view.\\n        \"\"\"\\n        return self.prefix\\n\\n    def get_formset_class(self):\\n        \"\"\"\\n        Returns the formset class to use in the formset factory\\n        \"\"\"\\n        return self.formset_class\\n\\n    def get_form_class(self):\\n        \"\"\"\\n        Returns the form class to use with the formset in this view\\n        \"\"\"\\n        return self.form_class\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the formset factory\\n        \"\"\"\\n        return formset_factory(self.get_form_class(), **self.get_factory_kwargs())\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = self.formset_kwargs.copy()\\n        kwargs.update({\"initial\": self.get_initial(), \"prefix\": self.get_prefix()})\\n\\n        if self.request.method in (\"POST\", \"PUT\"):\\n            kwargs.update(\\n                {\"data\": self.request.POST.copy(), \"files\": self.request.FILES}\\n            )\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = self.factory_kwargs.copy()\\n        if self.get_formset_class():\\n            kwargs[\"formset\"] = self.get_formset_class()\\n        return kwargs\\n\\n\\nclass FormSetMixin(BaseFormSetFactory, ContextMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single formset in a request.\\n    \"\"\"\\n\\n    success_url = None\\n\\n    def get_success_url(self):\\n        \"\"\"\\n        Returns the supplied URL.\\n        \"\"\"\\n        if self.success_url:\\n            url = self.success_url\\n        else:\\n            # Default to returning to the same page\\n            url = self.request.get_full_path()\\n        return url\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid redirect to the supplied URL\\n        \"\"\"\\n        return HttpResponseRedirect(self.get_success_url())\\n\\n    def formset_invalid(self, formset):\\n        \"\"\"\\n        If the formset is invalid, re-render the context data with the\\n        data-filled formset and errors.\\n        \"\"\"\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n\\nclass ModelFormSetMixin(FormSetMixin, MultipleObjectMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single model formset\\n    in a request.\\n\\n    Uses `modelformset_factory`.\\n    \"\"\"\\n\\n    exclude = None\\n    fields = None\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"queryset\"] = self.get_queryset()\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the model formset factory\\n        \"\"\"\\n        return modelformset_factory(self.model, **self.get_factory_kwargs())\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid, save the associated models.\\n        \"\"\"\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass BaseInlineFormSetFactory(BaseFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a FormSet from `inlineformset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    model = None\\n    inline_model = None\\n    exclude = None\\n    fields = None\\n\\n    def get_inline_model(self):\\n        \"\"\"\\n        Returns the inline model to use with the inline formset\\n        \"\"\"\\n        return self.inline_model\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"instance\"] = self.object\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the inline formset factory\\n        \"\"\"\\n        return inlineformset_factory(\\n            self.model, self.get_inline_model(), **self.get_factory_kwargs()\\n        )\\n\\n\\nclass InlineFormSetMixin(BaseInlineFormSetFactory, SingleObjectMixin, FormSetMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single inline formset\\n    in a request.\\n    \"\"\"\\n\\n    def formset_valid(self, formset):\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass ProcessFormSetView(View):\\n    \"\"\"\\n    A mixin that processes a formset on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the formset.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a formset instance with the passed\\n        POST variables and then checked for validity.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        if formset.is_valid():\\n            return self.formset_valid(formset)\\n        else:\\n            return self.formset_invalid(formset)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseFormSetView(FormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a formset\\n    \"\"\"\\n\\n\\nclass FormSetView(TemplateResponseMixin, BaseFormSetView):\\n    \"\"\"\\n    A view for displaying a formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseModelFormSetView(ModelFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a model formset\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass ModelFormSetView(MultipleObjectTemplateResponseMixin, BaseModelFormSetView):\\n    \"\"\"\\n    A view for displaying a model formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseInlineFormSetView(InlineFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying an inline formset for a queryset belonging to\\n    a parent model\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass InlineFormSetView(SingleObjectTemplateResponseMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A view for displaying an inline formset for a queryset belonging to a parent model\\n    \"\"\"\\n'"}, "return_value": "'from django.forms.formsets import formset_factory\\nfrom django.forms.models import inlineformset_factory, modelformset_factory\\nfrom django.http import HttpResponseRedirect\\nfrom django.views.generic.base import ContextMixin, TemplateResponseMixin, View\\nfrom django.views.generic.detail import (\\n    SingleObjectMixin,\\n    SingleObjectTemplateResponseMixin,\\n)\\nfrom django.views.generic.list import (\\n    MultipleObjectMixin,\\n    MultipleObjectTemplateResponseMixin,\\n)\\n\\n\\nclass BaseFormSetFactory(object):\\n    \"\"\"\\n    Base class for constructing a FormSet from `formset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    initial = []\\n    form_class = None\\n    formset_class = None\\n    prefix = None\\n    formset_kwargs = {}\\n    factory_kwargs = {}\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Returns an instance of the formset\\n        \"\"\"\\n        formset_class = self.get_formset()\\n        return formset_class(**self.get_formset_kwargs())\\n\\n    def get_initial(self):\\n        \"\"\"\\n        Returns a copy of the initial data to use for formsets on this view.\\n        \"\"\"\\n        return self.initial[:]\\n\\n    def get_prefix(self):\\n        \"\"\"\\n        Returns the prefix used for formsets on this view.\\n        \"\"\"\\n        return self.prefix\\n\\n    def get_formset_class(self):\\n        \"\"\"\\n        Returns the formset class to use in the formset factory\\n        \"\"\"\\n        return self.formset_class\\n\\n    def get_form_class(self):\\n        \"\"\"\\n        Returns the form class to use with the formset in this view\\n        \"\"\"\\n        return self.form_class\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the formset factory\\n        \"\"\"\\n        return formset_factory(self.get_form_class(), **self.get_factory_kwargs())\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = self.formset_kwargs.copy()\\n        kwargs.update({\"initial\": self.get_initial(), \"prefix\": self.get_prefix()})\\n\\n        if self.request.method in (\"POST\", \"PUT\"):\\n            kwargs.update(\\n                {\"data\": self.request.POST.copy(), \"files\": self.request.FILES}\\n            )\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = self.factory_kwargs.copy()\\n        if self.get_formset_class():\\n            kwargs[\"formset\"] = self.get_formset_class()\\n        return kwargs\\n\\n\\nclass FormSetMixin(BaseFormSetFactory, ContextMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single formset in a request.\\n    \"\"\"\\n\\n    success_url = None\\n\\n    def get_success_url(self):\\n        \"\"\"\\n        Returns the supplied URL.\\n        \"\"\"\\n        if self.success_url:\\n            url = self.success_url\\n        else:\\n            # Default to returning to the same page\\n            url = self.request.get_full_path()\\n        return url\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid redirect to the supplied URL\\n        \"\"\"\\n        return HttpResponseRedirect(self.get_success_url())\\n\\n    def formset_invalid(self, formset):\\n        \"\"\"\\n        If the formset is invalid, re-render the context data with the\\n        data-filled formset and errors.\\n        \"\"\"\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n\\nclass ModelFormSetMixin(FormSetMixin, MultipleObjectMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single model formset\\n    in a request.\\n\\n    Uses `modelformset_factory`.\\n    \"\"\"\\n\\n    exclude = None\\n    fields = None\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"queryset\"] = self.get_queryset()\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the model formset factory\\n        \"\"\"\\n        return modelformset_factory(self.model, **self.get_factory_kwargs())\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid, save the associated models.\\n        \"\"\"\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass BaseInlineFormSetFactory(BaseFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a FormSet from `inlineformset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    model = None\\n    inline_model = None\\n    exclude = None\\n    fields = None\\n\\n    def get_inline_model(self):\\n        \"\"\"\\n        Returns the inline model to use with the inline formset\\n        \"\"\"\\n        return self.inline_model\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"instance\"] = self.object\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the inline formset factory\\n        \"\"\"\\n        return inlineformset_factory(\\n            self.model, self.get_inline_model(), **self.get_factory_kwargs()\\n        )\\n\\n\\nclass InlineFormSetMixin(BaseInlineFormSetFactory, SingleObjectMixin, FormSetMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single inline formset\\n    in a request.\\n    \"\"\"\\n\\n    def formset_valid(self, formset):\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass ProcessFormSetView(View):\\n    \"\"\"\\n    A mixin that processes a formset on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the formset.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a formset instance with the passed\\n        POST variables and then checked for validity.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        if formset.is_valid():\\n            return self.formset_valid(formset)\\n        else:\\n            return self.formset_invalid(formset)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseFormSetView(FormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a formset\\n    \"\"\"\\n\\n\\nclass FormSetView(TemplateResponseMixin, BaseFormSetView):\\n    \"\"\"\\n    A view for displaying a formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseModelFormSetView(ModelFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a model formset\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass ModelFormSetView(MultipleObjectTemplateResponseMixin, BaseModelFormSetView):\\n    \"\"\"\\n    A view for displaying a model formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseInlineFormSetView(InlineFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying an inline formset for a queryset belonging to\\n    a parent model\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass InlineFormSetView(SingleObjectTemplateResponseMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A view for displaying an inline formset for a queryset belonging to a parent model\\n    \"\"\"\\n'"}, {"func_args": {"source": "'from django.contrib.contenttypes.forms import generic_inlineformset_factory\\n\\nfrom extra_views.formsets import (\\n    BaseInlineFormSetFactory,\\n    BaseInlineFormSetView,\\n    InlineFormSetMixin,\\n    InlineFormSetView,\\n)\\n\\n\\nclass BaseGenericInlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a GenericInlineFormSet from\\n    `generic_inlineformset_factory` in a view.\\n    \"\"\"\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the final formset class from generic_inlineformset_factory.\\n        \"\"\"\\n        result = generic_inlineformset_factory(\\n            self.inline_model, **self.get_factory_kwargs()\\n        )\\n        return result\\n\\n\\nclass GenericInlineFormSetFactory(BaseGenericInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create a `GenericInlineFormSet` from `generic_inlineformset_factory`\\n    as one of multiple `GenericInlineFormSet`s within a single view.\\n\\n    Subclasses `BaseGenericInlineFormSetFactory` and passes in the necessary view\\n    arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n\\nclass GenericInlineFormSetMixin(BaseGenericInlineFormSetFactory, InlineFormSetMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a generic inline formset in a\\n    request.\\n    \"\"\"\\n\\n\\nclass BaseGenericInlineFormSetView(GenericInlineFormSetMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A base view for displaying a generic inline formset\\n    \"\"\"\\n\\n\\nclass GenericInlineFormSetView(BaseGenericInlineFormSetView, InlineFormSetView):\\n    \"\"\"\\n    A view for displaying a generic inline formset for a queryset belonging to a\\n    parent model\\n    \"\"\"\\n'"}, "return_value": "'from django.contrib.contenttypes.forms import generic_inlineformset_factory\\n\\nfrom extra_views.formsets import (\\n    BaseInlineFormSetFactory,\\n    BaseInlineFormSetView,\\n    InlineFormSetMixin,\\n    InlineFormSetView,\\n)\\n\\n\\nclass BaseGenericInlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a GenericInlineFormSet from\\n    `generic_inlineformset_factory` in a view.\\n    \"\"\"\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the final formset class from generic_inlineformset_factory.\\n        \"\"\"\\n        result = generic_inlineformset_factory(\\n            self.inline_model, **self.get_factory_kwargs()\\n        )\\n        return result\\n\\n\\nclass GenericInlineFormSetFactory(BaseGenericInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create a `GenericInlineFormSet` from `generic_inlineformset_factory`\\n    as one of multiple `GenericInlineFormSet`s within a single view.\\n\\n    Subclasses `BaseGenericInlineFormSetFactory` and passes in the necessary view\\n    arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n\\nclass GenericInlineFormSetMixin(BaseGenericInlineFormSetFactory, InlineFormSetMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a generic inline formset in a\\n    request.\\n    \"\"\"\\n\\n\\nclass BaseGenericInlineFormSetView(GenericInlineFormSetMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A base view for displaying a generic inline formset\\n    \"\"\"\\n\\n\\nclass GenericInlineFormSetView(BaseGenericInlineFormSetView, InlineFormSetView):\\n    \"\"\"\\n    A view for displaying a generic inline formset for a queryset belonging to a\\n    parent model\\n    \"\"\"\\n'"}, {"func_args": {"source": "'from extra_views.advanced import (\\n    CreateWithInlinesView,\\n    FormSetSuccessMessageMixin,\\n    InlineFormSetFactory,\\n    NamedFormsetsMixin,\\n    SuccessMessageMixin,\\n    UpdateWithInlinesView,\\n)\\nfrom extra_views.contrib.mixins import SearchableListMixin, SortableListMixin\\nfrom extra_views.dates import CalendarMonthView\\nfrom extra_views.formsets import FormSetView, InlineFormSetView, ModelFormSetView\\n\\n__version__ = \"0.14.0\"\\n\\n__all__ = [\\n    \"CreateWithInlinesView\",\\n    \"FormSetSuccessMessageMixin\",\\n    \"InlineFormSetFactory\",\\n    \"NamedFormsetsMixin\",\\n    \"SuccessMessageMixin\",\\n    \"UpdateWithInlinesView\",\\n    \"SearchableListMixin\",\\n    \"SortableListMixin\",\\n    \"CalendarMonthView\",\\n    \"FormSetView\",\\n    \"InlineFormSetView\",\\n    \"ModelFormSetView\",\\n]\\n'"}, "return_value": "'from extra_views.advanced import (\\n    CreateWithInlinesView,\\n    FormSetSuccessMessageMixin,\\n    InlineFormSetFactory,\\n    NamedFormsetsMixin,\\n    SuccessMessageMixin,\\n    UpdateWithInlinesView,\\n)\\nfrom extra_views.contrib.mixins import SearchableListMixin, SortableListMixin\\nfrom extra_views.dates import CalendarMonthView\\nfrom extra_views.formsets import FormSetView, InlineFormSetView, ModelFormSetView\\n\\n__version__ = \"0.14.0\"\\n\\n__all__ = [\\n    \"CreateWithInlinesView\",\\n    \"FormSetSuccessMessageMixin\",\\n    \"InlineFormSetFactory\",\\n    \"NamedFormsetsMixin\",\\n    \"SuccessMessageMixin\",\\n    \"UpdateWithInlinesView\",\\n    \"SearchableListMixin\",\\n    \"SortableListMixin\",\\n    \"CalendarMonthView\",\\n    \"FormSetView\",\\n    \"InlineFormSetView\",\\n    \"ModelFormSetView\",\\n]\\n'"}, {"func_args": {"source": "'from django.contrib import messages\\nfrom django.forms.formsets import all_valid\\nfrom django.views.generic.base import ContextMixin\\nfrom django.views.generic.detail import SingleObjectTemplateResponseMixin\\nfrom django.views.generic.edit import FormView, ModelFormMixin\\n\\nfrom extra_views.formsets import BaseInlineFormSetFactory\\n\\n\\nclass InlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create an `InlineFormSet` from `inlineformset_factory` as\\n    one of multiple `InlineFormSet`s within a single view.\\n\\n    Subclasses `BaseInlineFormSetFactory` and passes in the necessary view arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Overrides construct_formset to attach the model class as\\n        an attribute of the returned formset instance.\\n        \"\"\"\\n        formset = super().construct_formset()\\n        formset.model = self.inline_model\\n        return formset\\n\\n\\nclass ModelFormWithInlinesMixin(ModelFormMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a modelform and inline\\n    formsets in a request.\\n\\n    The inlines should be subclasses of `InlineFormSetFactory`.\\n    \"\"\"\\n\\n    inlines = []\\n\\n    def get_inlines(self):\\n        \"\"\"\\n        Returns the inline formset classes\\n        \"\"\"\\n        return self.inlines[:]\\n\\n    def forms_valid(self, form, inlines):\\n        \"\"\"\\n        If the form and formsets are valid, save the associated models.\\n        \"\"\"\\n        response = self.form_valid(form)\\n        for formset in inlines:\\n            formset.save()\\n        return response\\n\\n    def forms_invalid(self, form, inlines):\\n        \"\"\"\\n        If the form or formsets are invalid, re-render the context data with the\\n        data-filled form and formsets and errors.\\n        \"\"\"\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines)\\n        )\\n\\n    def construct_inlines(self):\\n        \"\"\"\\n        Returns the inline formset instances\\n        \"\"\"\\n        inline_formsets = []\\n        for inline_class in self.get_inlines():\\n            inline_instance = inline_class(\\n                self.model, self.request, self.object, self.kwargs, self\\n            )\\n            inline_formset = inline_instance.construct_formset()\\n            inline_formsets.append(inline_formset)\\n        return inline_formsets\\n\\n\\nclass ProcessFormWithInlinesView(FormView):\\n    \"\"\"\\n    A mixin that renders a form and inline formsets on GET and processes it on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the form and formsets.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n        inlines = self.construct_inlines()\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines, **kwargs)\\n        )\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a form and formset instances with the\\n        passed POST variables and then checked for validity.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n\\n        initial_object = self.object\\n        if form.is_valid():\\n            self.object = form.save(commit=False)\\n            form_validated = True\\n        else:\\n            form_validated = False\\n\\n        inlines = self.construct_inlines()\\n\\n        if all_valid(inlines) and form_validated:\\n            return self.forms_valid(form, inlines)\\n        self.object = initial_object\\n        return self.forms_invalid(form, inlines)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseCreateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for creating an new object instance with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass CreateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseCreateWithInlinesView\\n):\\n    \"\"\"\\n    View for creating a new object instance with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass BaseUpdateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for updating an existing object with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass UpdateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseUpdateWithInlinesView\\n):\\n    \"\"\"\\n    View for updating an object with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass NamedFormsetsMixin(ContextMixin):\\n    \"\"\"\\n    A mixin for use with `CreateWithInlinesView` or `UpdateWithInlinesView` that lets\\n    you define the context variable for each inline.\\n    \"\"\"\\n\\n    inlines_names = []\\n\\n    def get_inlines_names(self):\\n        \"\"\"\\n        Returns a list of names of context variables for each inline in `inlines`.\\n        \"\"\"\\n        return self.inlines_names[:]\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        If `inlines_names` has been defined, add each formset to the context under\\n        its corresponding entry in `inlines_names`\\n        \"\"\"\\n        context = {}\\n        inlines_names = self.get_inlines_names()\\n\\n        if inlines_names:\\n            # We have formset or inlines in context, but never both\\n            context.update(zip(inlines_names, kwargs.get(\"inlines\", [])))\\n            if \"formset\" in kwargs:\\n                context[inlines_names[0]] = kwargs[\"formset\"]\\n        context.update(kwargs)\\n        return super().get_context_data(**context)\\n\\n\\nclass SuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on views with inlines if django.contrib.messages framework\\n    is used.\\n    In order to use just add mixin in to inheritance before main class, e.g.:\\n    class MyCreateWithInlinesView (SuccessMessageMixin, CreateWithInlinesView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super().forms_valid(form, inlines)\\n        success_message = self.get_success_message(form.cleaned_data, inlines)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data, inlines):\\n        return self.success_message % cleaned_data\\n\\n\\nclass FormSetSuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on FormSet views if django.contrib.messages framework\\n    is used. In order to use just add mixin in to inheritance before main\\n    class, e.g.:\\n    class MyFormSetView (FormSetSuccessMessageMixin, ModelFormSetView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def formset_valid(self, formset):\\n        response = super().formset_valid(formset)\\n        success_message = self.get_success_message(formset)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, formset):\\n        return self.success_message\\n'"}, "return_value": "'from django.contrib import messages\\nfrom django.forms.formsets import all_valid\\nfrom django.views.generic.base import ContextMixin\\nfrom django.views.generic.detail import SingleObjectTemplateResponseMixin\\nfrom django.views.generic.edit import FormView, ModelFormMixin\\n\\nfrom extra_views.formsets import BaseInlineFormSetFactory\\n\\n\\nclass InlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create an `InlineFormSet` from `inlineformset_factory` as\\n    one of multiple `InlineFormSet`s within a single view.\\n\\n    Subclasses `BaseInlineFormSetFactory` and passes in the necessary view arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Overrides construct_formset to attach the model class as\\n        an attribute of the returned formset instance.\\n        \"\"\"\\n        formset = super().construct_formset()\\n        formset.model = self.inline_model\\n        return formset\\n\\n\\nclass ModelFormWithInlinesMixin(ModelFormMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a modelform and inline\\n    formsets in a request.\\n\\n    The inlines should be subclasses of `InlineFormSetFactory`.\\n    \"\"\"\\n\\n    inlines = []\\n\\n    def get_inlines(self):\\n        \"\"\"\\n        Returns the inline formset classes\\n        \"\"\"\\n        return self.inlines[:]\\n\\n    def forms_valid(self, form, inlines):\\n        \"\"\"\\n        If the form and formsets are valid, save the associated models.\\n        \"\"\"\\n        response = self.form_valid(form)\\n        for formset in inlines:\\n            formset.save()\\n        return response\\n\\n    def forms_invalid(self, form, inlines):\\n        \"\"\"\\n        If the form or formsets are invalid, re-render the context data with the\\n        data-filled form and formsets and errors.\\n        \"\"\"\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines)\\n        )\\n\\n    def construct_inlines(self):\\n        \"\"\"\\n        Returns the inline formset instances\\n        \"\"\"\\n        inline_formsets = []\\n        for inline_class in self.get_inlines():\\n            inline_instance = inline_class(\\n                self.model, self.request, self.object, self.kwargs, self\\n            )\\n            inline_formset = inline_instance.construct_formset()\\n            inline_formsets.append(inline_formset)\\n        return inline_formsets\\n\\n\\nclass ProcessFormWithInlinesView(FormView):\\n    \"\"\"\\n    A mixin that renders a form and inline formsets on GET and processes it on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the form and formsets.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n        inlines = self.construct_inlines()\\n        return self.render_to_response(\\n            self.get_context_data(form=form, inlines=inlines, **kwargs)\\n        )\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a form and formset instances with the\\n        passed POST variables and then checked for validity.\\n        \"\"\"\\n        form_class = self.get_form_class()\\n        form = self.get_form(form_class)\\n\\n        initial_object = self.object\\n        if form.is_valid():\\n            self.object = form.save(commit=False)\\n            form_validated = True\\n        else:\\n            form_validated = False\\n\\n        inlines = self.construct_inlines()\\n\\n        if all_valid(inlines) and form_validated:\\n            return self.forms_valid(form, inlines)\\n        self.object = initial_object\\n        return self.forms_invalid(form, inlines)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseCreateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for creating an new object instance with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = None\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass CreateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseCreateWithInlinesView\\n):\\n    \"\"\"\\n    View for creating a new object instance with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass BaseUpdateWithInlinesView(ModelFormWithInlinesMixin, ProcessFormWithInlinesView):\\n    \"\"\"\\n    Base view for updating an existing object with related model instances.\\n\\n    Using this base class requires subclassing to provide a response mixin.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass UpdateWithInlinesView(\\n    SingleObjectTemplateResponseMixin, BaseUpdateWithInlinesView\\n):\\n    \"\"\"\\n    View for updating an object with related model instances,\\n    with a response rendered by template.\\n    \"\"\"\\n\\n    template_name_suffix = \"_form\"\\n\\n\\nclass NamedFormsetsMixin(ContextMixin):\\n    \"\"\"\\n    A mixin for use with `CreateWithInlinesView` or `UpdateWithInlinesView` that lets\\n    you define the context variable for each inline.\\n    \"\"\"\\n\\n    inlines_names = []\\n\\n    def get_inlines_names(self):\\n        \"\"\"\\n        Returns a list of names of context variables for each inline in `inlines`.\\n        \"\"\"\\n        return self.inlines_names[:]\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        If `inlines_names` has been defined, add each formset to the context under\\n        its corresponding entry in `inlines_names`\\n        \"\"\"\\n        context = {}\\n        inlines_names = self.get_inlines_names()\\n\\n        if inlines_names:\\n            # We have formset or inlines in context, but never both\\n            context.update(zip(inlines_names, kwargs.get(\"inlines\", [])))\\n            if \"formset\" in kwargs:\\n                context[inlines_names[0]] = kwargs[\"formset\"]\\n        context.update(kwargs)\\n        return super().get_context_data(**context)\\n\\n\\nclass SuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on views with inlines if django.contrib.messages framework\\n    is used.\\n    In order to use just add mixin in to inheritance before main class, e.g.:\\n    class MyCreateWithInlinesView (SuccessMessageMixin, CreateWithInlinesView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super().forms_valid(form, inlines)\\n        success_message = self.get_success_message(form.cleaned_data, inlines)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data, inlines):\\n        return self.success_message % cleaned_data\\n\\n\\nclass FormSetSuccessMessageMixin(object):\\n    \"\"\"\\n    Adds success message on FormSet views if django.contrib.messages framework\\n    is used. In order to use just add mixin in to inheritance before main\\n    class, e.g.:\\n    class MyFormSetView (FormSetSuccessMessageMixin, ModelFormSetView):\\n        success_message=\\'Something was created!\\'\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def formset_valid(self, formset):\\n        response = super().formset_valid(formset)\\n        success_message = self.get_success_message(formset)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, formset):\\n        return self.success_message\\n'"}, {"func_args": {"source": "'import datetime\\nimport functools\\nimport operator\\n\\nfrom django.contrib import messages\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.views.generic.base import ContextMixin\\n\\nVALID_STRING_LOOKUPS = (\\n    \"iexact\",\\n    \"contains\",\\n    \"icontains\",\\n    \"startswith\",\\n    \"istartswith\",\\n    \"endswith\",\\n    \"iendswith\",\\n    \"search\",\\n    \"regex\",\\n    \"iregex\",\\n)\\n\\n\\nclass SearchableListMixin(object):\\n    \"\"\"\\n    Filter queryset like a django admin search_fields does, but with little\\n     more intelligence:\\n    if self.search_split is set to True (by default) it will split query\\n     to words (by whitespace)\\n    Also tries to convert each word to date with self.search_date_formats and\\n     then search each word in separate field\\n    e.g. with query \\'foo bar\\' you can find object with\\n     obj.field1__icontains=\\'foo\\' and obj.field2__icontains==\\'bar\\'\\n\\n    To provide custom lookup just set one of the search_fields to tuple,\\n    e.g. search_fields = [(\\'field1\\', \\'iexact\\'), \\'field2\\', (\\'field3\\', \\'startswith\\')]\\n\\n    This class is designed to be used with django.generic.ListView\\n\\n    You could specify query by overriding get_search_query method\\n    by default this method will try to get \\'q\\' key from request.GET\\n    (this can be disabled with search_use_q=False)\\n    \"\"\"\\n\\n    search_fields = [\"id\"]\\n    search_date_fields = None\\n    search_date_formats = [\"%d.%m.%y\", \"%d.%m.%Y\"]\\n    search_split = True\\n    search_use_q = True\\n    check_lookups = True\\n\\n    def get_words(self, query):\\n        if self.search_split:\\n            return query.split()\\n        return [query]\\n\\n    def get_search_fields_with_filters(self):\\n        fields = []\\n        for sf in self.search_fields:\\n            if isinstance(sf, str):\\n                fields.append((sf, \"icontains\"))\\n            else:\\n                if self.check_lookups and sf[1] not in VALID_STRING_LOOKUPS:\\n                    raise ValueError(\"Invalid string lookup - %s\" % sf[1])\\n                fields.append(sf)\\n        return fields\\n\\n    def try_convert_to_date(self, word):\\n        \"\"\"\\n        Tries to convert word to date(datetime) using search_date_formats\\n        Return None if word fits no one format\\n        \"\"\"\\n        for frm in self.search_date_formats:\\n            try:\\n                return datetime.datetime.strptime(word, frm).date()\\n            except ValueError:\\n                pass\\n        return None\\n\\n    def get_search_query(self):\\n        \"\"\"\\n        Get query from request.GET \\'q\\' parameter when search_use_q is set to True\\n        Override this method to provide your own query to search\\n        \"\"\"\\n        return self.search_use_q and self.request.GET.get(\"q\", \"\").strip()\\n\\n    def get_queryset(self):\\n        qs = super(SearchableListMixin, self).get_queryset()\\n        query = self.get_search_query()\\n        if query:\\n            w_qs = []\\n            search_pairs = self.get_search_fields_with_filters()\\n            for word in self.get_words(query):\\n                filters = [\\n                    Q(**{\"%s__%s\" % (pair[0], pair[1]): word}) for pair in search_pairs\\n                ]\\n                if self.search_date_fields:\\n                    dt = self.try_convert_to_date(word)\\n                    if dt:\\n                        filters.extend(\\n                            [\\n                                Q(**{field_name: dt})\\n                                for field_name in self.search_date_fields\\n                            ]\\n                        )\\n                w_qs.append(functools.reduce(operator.or_, filters))\\n            qs = qs.filter(functools.reduce(operator.and_, w_qs))\\n            qs = qs.distinct()\\n        return qs\\n\\n\\nclass SortHelper(object):\\n    def __init__(\\n        self, request, sort_fields_aliases, sort_param_name, sort_type_param_name\\n    ):\\n        # Create a list from sort_fields_aliases, in case it is a generator,\\n        # since we want to iterate through it multiple times.\\n        sort_fields_aliases = list(sort_fields_aliases)\\n\\n        self.initial_params = request.GET.copy()\\n        self.sort_fields = dict(sort_fields_aliases)\\n        self.inv_sort_fields = dict((v, k) for k, v in sort_fields_aliases)\\n        self.initial_sort = self.inv_sort_fields.get(\\n            self.initial_params.get(sort_param_name), None\\n        )\\n        self.initial_sort_type = self.initial_params.get(sort_type_param_name, \"asc\")\\n        self.sort_param_name = sort_param_name\\n        self.sort_type_param_name = sort_type_param_name\\n\\n        for field, alias in self.sort_fields.items():\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s\" % alias,\\n                functools.partial(self.get_params_for_field, field),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_asc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"asc\"),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_desc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"desc\"),\\n            )\\n            setattr(\\n                self,\\n                \"is_sorted_by_%s\" % alias,\\n                functools.partial(self.is_sorted_by, field),\\n            )\\n\\n    def is_sorted_by(self, field_name):\\n        return field_name == self.initial_sort and self.initial_sort_type or False\\n\\n    def get_params_for_field(self, field_name, sort_type=None):\\n        \"\"\"\\n        If sort_type is None - inverse current sort for field, if no sorted - use asc\\n        \"\"\"\\n        if not sort_type:\\n            if self.initial_sort == field_name:\\n                sort_type = \"desc\" if self.initial_sort_type == \"asc\" else \"asc\"\\n            else:\\n                sort_type = \"asc\"\\n        self.initial_params[self.sort_param_name] = self.sort_fields[field_name]\\n        self.initial_params[self.sort_type_param_name] = sort_type\\n        return \"?%s\" % self.initial_params.urlencode()\\n\\n    def get_sort(self):\\n        if not self.initial_sort:\\n            return None\\n        sort = \"%s\" % self.initial_sort\\n        if self.initial_sort_type == \"desc\":\\n            sort = \"-%s\" % sort\\n        return sort\\n\\n\\nclass SortableListMixin(ContextMixin):\\n    \"\"\"\\n    You can provide either sort_fields as a plain list like\\n     [\\'id\\', \\'some\\', \\'foo__bar\\', ...]\\n    or, if you want to hide original field names you can provide list of tuples with\\n    alias that will be used:\\n    [(\\'id\\', \\'by_id\\'), (\\'some\\', \\'show_this\\'), (\\'foo__bar\\', \\'bar\\')]\\n\\n    If sort_param_name exists in query but sort_type_param_name is omitted queryset\\n     will be sorted as \\'asc\\'\\n    \"\"\"\\n\\n    sort_fields = []\\n    sort_fields_aliases = []\\n    sort_param_name = \"o\"\\n    sort_type_param_name = \"ot\"\\n\\n    def get_sort_fields(self):\\n        if self.sort_fields:\\n            return zip(self.sort_fields, self.sort_fields)\\n        return self.sort_fields_aliases\\n\\n    def get_sort_helper(self):\\n        return SortHelper(\\n            self.request,\\n            self.get_sort_fields(),\\n            self.sort_param_name,\\n            self.sort_type_param_name,\\n        )\\n\\n    def _sort_queryset(self, queryset):\\n        self.sort_helper = self.get_sort_helper()\\n        sort = self.sort_helper.get_sort()\\n        if sort:\\n            queryset = queryset.order_by(sort)\\n        return queryset\\n\\n    def get_queryset(self):\\n        qs = super(SortableListMixin, self).get_queryset()\\n        if self.sort_fields and self.sort_fields_aliases:\\n            raise ImproperlyConfigured(\\n                \"You should provide sort_fields or sort_fields_aliaces but not both\"\\n            )\\n        return self._sort_queryset(qs)\\n\\n    def get_context_data(self, **kwargs):\\n        context = {}\\n        if hasattr(self, \"sort_helper\"):\\n            context[\"sort_helper\"] = self.sort_helper\\n        context.update(kwargs)\\n        return super(SortableListMixin, self).get_context_data(**context)\\n\\n\\nclass SuccessMessageWithInlinesMixin(object):\\n    \"\"\"\\n    Adds a success message on successful form submission.\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super(SuccessMessageWithInlinesMixin, self).forms_valid(\\n            form, inlines\\n        )\\n        success_message = self.get_success_message(form.cleaned_data)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data):\\n        return self.success_message % cleaned_data\\n'"}, "return_value": "'import datetime\\nimport functools\\nimport operator\\n\\nfrom django.contrib import messages\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.views.generic.base import ContextMixin\\n\\nVALID_STRING_LOOKUPS = (\\n    \"iexact\",\\n    \"contains\",\\n    \"icontains\",\\n    \"startswith\",\\n    \"istartswith\",\\n    \"endswith\",\\n    \"iendswith\",\\n    \"search\",\\n    \"regex\",\\n    \"iregex\",\\n)\\n\\n\\nclass SearchableListMixin(object):\\n    \"\"\"\\n    Filter queryset like a django admin search_fields does, but with little\\n     more intelligence:\\n    if self.search_split is set to True (by default) it will split query\\n     to words (by whitespace)\\n    Also tries to convert each word to date with self.search_date_formats and\\n     then search each word in separate field\\n    e.g. with query \\'foo bar\\' you can find object with\\n     obj.field1__icontains=\\'foo\\' and obj.field2__icontains==\\'bar\\'\\n\\n    To provide custom lookup just set one of the search_fields to tuple,\\n    e.g. search_fields = [(\\'field1\\', \\'iexact\\'), \\'field2\\', (\\'field3\\', \\'startswith\\')]\\n\\n    This class is designed to be used with django.generic.ListView\\n\\n    You could specify query by overriding get_search_query method\\n    by default this method will try to get \\'q\\' key from request.GET\\n    (this can be disabled with search_use_q=False)\\n    \"\"\"\\n\\n    search_fields = [\"id\"]\\n    search_date_fields = None\\n    search_date_formats = [\"%d.%m.%y\", \"%d.%m.%Y\"]\\n    search_split = True\\n    search_use_q = True\\n    check_lookups = True\\n\\n    def get_words(self, query):\\n        if self.search_split:\\n            return query.split()\\n        return [query]\\n\\n    def get_search_fields_with_filters(self):\\n        fields = []\\n        for sf in self.search_fields:\\n            if isinstance(sf, str):\\n                fields.append((sf, \"icontains\"))\\n            else:\\n                if self.check_lookups and sf[1] not in VALID_STRING_LOOKUPS:\\n                    raise ValueError(\"Invalid string lookup - %s\" % sf[1])\\n                fields.append(sf)\\n        return fields\\n\\n    def try_convert_to_date(self, word):\\n        \"\"\"\\n        Tries to convert word to date(datetime) using search_date_formats\\n        Return None if word fits no one format\\n        \"\"\"\\n        for frm in self.search_date_formats:\\n            try:\\n                return datetime.datetime.strptime(word, frm).date()\\n            except ValueError:\\n                pass\\n        return None\\n\\n    def get_search_query(self):\\n        \"\"\"\\n        Get query from request.GET \\'q\\' parameter when search_use_q is set to True\\n        Override this method to provide your own query to search\\n        \"\"\"\\n        return self.search_use_q and self.request.GET.get(\"q\", \"\").strip()\\n\\n    def get_queryset(self):\\n        qs = super(SearchableListMixin, self).get_queryset()\\n        query = self.get_search_query()\\n        if query:\\n            w_qs = []\\n            search_pairs = self.get_search_fields_with_filters()\\n            for word in self.get_words(query):\\n                filters = [\\n                    Q(**{\"%s__%s\" % (pair[0], pair[1]): word}) for pair in search_pairs\\n                ]\\n                if self.search_date_fields:\\n                    dt = self.try_convert_to_date(word)\\n                    if dt:\\n                        filters.extend(\\n                            [\\n                                Q(**{field_name: dt})\\n                                for field_name in self.search_date_fields\\n                            ]\\n                        )\\n                w_qs.append(functools.reduce(operator.or_, filters))\\n            qs = qs.filter(functools.reduce(operator.and_, w_qs))\\n            qs = qs.distinct()\\n        return qs\\n\\n\\nclass SortHelper(object):\\n    def __init__(\\n        self, request, sort_fields_aliases, sort_param_name, sort_type_param_name\\n    ):\\n        # Create a list from sort_fields_aliases, in case it is a generator,\\n        # since we want to iterate through it multiple times.\\n        sort_fields_aliases = list(sort_fields_aliases)\\n\\n        self.initial_params = request.GET.copy()\\n        self.sort_fields = dict(sort_fields_aliases)\\n        self.inv_sort_fields = dict((v, k) for k, v in sort_fields_aliases)\\n        self.initial_sort = self.inv_sort_fields.get(\\n            self.initial_params.get(sort_param_name), None\\n        )\\n        self.initial_sort_type = self.initial_params.get(sort_type_param_name, \"asc\")\\n        self.sort_param_name = sort_param_name\\n        self.sort_type_param_name = sort_type_param_name\\n\\n        for field, alias in self.sort_fields.items():\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s\" % alias,\\n                functools.partial(self.get_params_for_field, field),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_asc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"asc\"),\\n            )\\n            setattr(\\n                self,\\n                \"get_sort_query_by_%s_desc\" % alias,\\n                functools.partial(self.get_params_for_field, field, \"desc\"),\\n            )\\n            setattr(\\n                self,\\n                \"is_sorted_by_%s\" % alias,\\n                functools.partial(self.is_sorted_by, field),\\n            )\\n\\n    def is_sorted_by(self, field_name):\\n        return field_name == self.initial_sort and self.initial_sort_type or False\\n\\n    def get_params_for_field(self, field_name, sort_type=None):\\n        \"\"\"\\n        If sort_type is None - inverse current sort for field, if no sorted - use asc\\n        \"\"\"\\n        if not sort_type:\\n            if self.initial_sort == field_name:\\n                sort_type = \"desc\" if self.initial_sort_type == \"asc\" else \"asc\"\\n            else:\\n                sort_type = \"asc\"\\n        self.initial_params[self.sort_param_name] = self.sort_fields[field_name]\\n        self.initial_params[self.sort_type_param_name] = sort_type\\n        return \"?%s\" % self.initial_params.urlencode()\\n\\n    def get_sort(self):\\n        if not self.initial_sort:\\n            return None\\n        sort = \"%s\" % self.initial_sort\\n        if self.initial_sort_type == \"desc\":\\n            sort = \"-%s\" % sort\\n        return sort\\n\\n\\nclass SortableListMixin(ContextMixin):\\n    \"\"\"\\n    You can provide either sort_fields as a plain list like\\n     [\\'id\\', \\'some\\', \\'foo__bar\\', ...]\\n    or, if you want to hide original field names you can provide list of tuples with\\n    alias that will be used:\\n    [(\\'id\\', \\'by_id\\'), (\\'some\\', \\'show_this\\'), (\\'foo__bar\\', \\'bar\\')]\\n\\n    If sort_param_name exists in query but sort_type_param_name is omitted queryset\\n     will be sorted as \\'asc\\'\\n    \"\"\"\\n\\n    sort_fields = []\\n    sort_fields_aliases = []\\n    sort_param_name = \"o\"\\n    sort_type_param_name = \"ot\"\\n\\n    def get_sort_fields(self):\\n        if self.sort_fields:\\n            return zip(self.sort_fields, self.sort_fields)\\n        return self.sort_fields_aliases\\n\\n    def get_sort_helper(self):\\n        return SortHelper(\\n            self.request,\\n            self.get_sort_fields(),\\n            self.sort_param_name,\\n            self.sort_type_param_name,\\n        )\\n\\n    def _sort_queryset(self, queryset):\\n        self.sort_helper = self.get_sort_helper()\\n        sort = self.sort_helper.get_sort()\\n        if sort:\\n            queryset = queryset.order_by(sort)\\n        return queryset\\n\\n    def get_queryset(self):\\n        qs = super(SortableListMixin, self).get_queryset()\\n        if self.sort_fields and self.sort_fields_aliases:\\n            raise ImproperlyConfigured(\\n                \"You should provide sort_fields or sort_fields_aliaces but not both\"\\n            )\\n        return self._sort_queryset(qs)\\n\\n    def get_context_data(self, **kwargs):\\n        context = {}\\n        if hasattr(self, \"sort_helper\"):\\n            context[\"sort_helper\"] = self.sort_helper\\n        context.update(kwargs)\\n        return super(SortableListMixin, self).get_context_data(**context)\\n\\n\\nclass SuccessMessageWithInlinesMixin(object):\\n    \"\"\"\\n    Adds a success message on successful form submission.\\n    \"\"\"\\n\\n    success_message = \"\"\\n\\n    def forms_valid(self, form, inlines):\\n        response = super(SuccessMessageWithInlinesMixin, self).forms_valid(\\n            form, inlines\\n        )\\n        success_message = self.get_success_message(form.cleaned_data)\\n        if success_message:\\n            messages.success(self.request, success_message)\\n        return response\\n\\n    def get_success_message(self, cleaned_data):\\n        return self.success_message % cleaned_data\\n'"}, {"func_args": {"source": "'import datetime\\nimport math\\nfrom calendar import Calendar\\nfrom collections import defaultdict\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.utils.translation import gettext_lazy as _\\nfrom django.views.generic.dates import (\\n    DateMixin,\\n    MonthMixin,\\n    YearMixin,\\n    _date_from_string,\\n)\\nfrom django.views.generic.list import BaseListView, MultipleObjectTemplateResponseMixin\\n\\nDAYS = (\\n    _(\"Monday\"),\\n    _(\"Tuesday\"),\\n    _(\"Wednesday\"),\\n    _(\"Thursday\"),\\n    _(\"Friday\"),\\n    _(\"Saturday\"),\\n    _(\"Sunday\"),\\n)\\n\\n\\ndef daterange(start_date, end_date):\\n    \"\"\"\\n    Returns an iterator of dates between two provided ones\\n    \"\"\"\\n    for n in range(int((end_date - start_date).days + 1)):\\n        yield start_date + datetime.timedelta(n)\\n\\n\\nclass BaseCalendarMonthView(DateMixin, YearMixin, MonthMixin, BaseListView):\\n    \"\"\"\\n    A base view for displaying a calendar month\\n    \"\"\"\\n\\n    first_of_week = 0  # 0 = Monday, 6 = Sunday\\n    paginate_by = None  # We don\\'t want to use this part of MultipleObjectMixin\\n    date_field = None\\n    end_date_field = None  # For supporting events with duration\\n\\n    def get_paginate_by(self, queryset):\\n        if self.paginate_by is not None:\\n            raise ImproperlyConfigured(\\n                \"\\'%s\\' cannot be paginated, it is a calendar view\"\\n                % self.__class__.__name__\\n            )\\n        return None\\n\\n    def get_allow_future(self):\\n        return True\\n\\n    def get_end_date_field(self):\\n        \"\"\"\\n        Returns the model field to use for end dates\\n        \"\"\"\\n        return self.end_date_field\\n\\n    def get_start_date(self, obj):\\n        \"\"\"\\n        Returns the start date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_end_date(self, obj):\\n        \"\"\"\\n        Returns the end date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_end_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_first_of_week(self):\\n        \"\"\"\\n        Returns an integer representing the first day of the week.\\n\\n        0 represents Monday, 6 represents Sunday.\\n        \"\"\"\\n        if self.first_of_week is None:\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week is required.\" % self.__class__.__name__\\n            )\\n        if self.first_of_week not in range(7):\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week must be an integer between 0 and 6.\"\\n                % self.__class__.__name__\\n            )\\n        return self.first_of_week\\n\\n    def get_queryset(self):\\n        \"\"\"\\n        Returns a queryset of models for the month requested\\n        \"\"\"\\n        qs = super().get_queryset()\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date_field = self.get_date_field()\\n        end_date_field = self.get_end_date_field()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        since = date\\n        until = self.get_next_month(date)\\n\\n        # Adjust our start and end dates to allow for next and previous\\n        # month edges\\n        if since.weekday() != self.get_first_of_week():\\n            diff = math.fabs(since.weekday() - self.get_first_of_week())\\n            since = since - datetime.timedelta(days=diff)\\n\\n        if until.weekday() != ((self.get_first_of_week() + 6) % 7):\\n            diff = math.fabs(((self.get_first_of_week() + 6) % 7) - until.weekday())\\n            until = until + datetime.timedelta(days=diff)\\n\\n        if end_date_field:\\n            # 5 possible conditions for showing an event:\\n\\n            # 1) Single day event, starts after \\'since\\'\\n            # 2) Multi-day event, starts after \\'since\\' and ends before \\'until\\'\\n            # 3) Starts before \\'since\\' and ends after \\'since\\' and before \\'until\\'\\n            # 4) Starts after \\'since\\' but before \\'until\\' and ends after \\'until\\'\\n            # 5) Starts before \\'since\\' and ends after \\'until\\'\\n            predicate1 = Q(**{\"%s__gte\" % date_field: since, end_date_field: None})\\n            predicate2 = Q(\\n                **{\"%s__gte\" % date_field: since, \"%s__lt\" % end_date_field: until}\\n            )\\n            predicate3 = Q(\\n                **{\\n                    \"%s__lt\" % date_field: since,\\n                    \"%s__gte\" % end_date_field: since,\\n                    \"%s__lt\" % end_date_field: until,\\n                }\\n            )\\n            predicate4 = Q(\\n                **{\\n                    \"%s__gte\" % date_field: since,\\n                    \"%s__lt\" % date_field: until,\\n                    \"%s__gte\" % end_date_field: until,\\n                }\\n            )\\n            predicate5 = Q(\\n                **{\"%s__lt\" % date_field: since, \"%s__gte\" % end_date_field: until}\\n            )\\n            return qs.filter(\\n                predicate1 | predicate2 | predicate3 | predicate4 | predicate5\\n            )\\n        return qs.filter(**{\"%s__gte\" % date_field: since})\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        Injects variables necessary for rendering the calendar into the context.\\n\\n        Variables added are: `calendar`, `weekdays`, `month`, `next_month` and\\n        `previous_month`.\\n        \"\"\"\\n        data = super().get_context_data(**kwargs)\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        cal = Calendar(self.get_first_of_week())\\n\\n        month_calendar = []\\n        now = datetime.datetime.utcnow()\\n\\n        date_lists = defaultdict(list)\\n        multidate_objs = []\\n\\n        for obj in data[\"object_list\"]:\\n            obj_date = self.get_start_date(obj)\\n            end_date_field = self.get_end_date_field()\\n\\n            if end_date_field:\\n                end_date = self.get_end_date(obj)\\n                if end_date and end_date != obj_date:\\n                    multidate_objs.append(\\n                        {\\n                            \"obj\": obj,\\n                            \"range\": [x for x in daterange(obj_date, end_date)],\\n                        }\\n                    )\\n                    continue  # We don\\'t put multi-day events in date_lists\\n            date_lists[obj_date].append(obj)\\n\\n        for week in cal.monthdatescalendar(date.year, date.month):\\n            week_range = set(daterange(week[0], week[6]))\\n            week_events = []\\n\\n            for val in multidate_objs:\\n                intersect_length = len(week_range.intersection(val[\"range\"]))\\n\\n                if intersect_length:\\n                    # Event happens during this week\\n                    slot = 1\\n                    width = (\\n                        intersect_length  # How many days is the event during this week?\\n                    )\\n                    nowrap_previous = (\\n                        True  # Does the event continue from the previous week?\\n                    )\\n                    nowrap_next = True  # Does the event continue to the next week?\\n\\n                    if val[\"range\"][0] >= week[0]:\\n                        slot = 1 + (val[\"range\"][0] - week[0]).days\\n                    else:\\n                        nowrap_previous = False\\n                    if val[\"range\"][-1] > week[6]:\\n                        nowrap_next = False\\n\\n                    week_events.append(\\n                        {\\n                            \"event\": val[\"obj\"],\\n                            \"slot\": slot,\\n                            \"width\": width,\\n                            \"nowrap_previous\": nowrap_previous,\\n                            \"nowrap_next\": nowrap_next,\\n                        }\\n                    )\\n\\n            week_calendar = {\"events\": week_events, \"date_list\": []}\\n            for day in week:\\n                week_calendar[\"date_list\"].append(\\n                    {\\n                        \"day\": day,\\n                        \"events\": date_lists[day],\\n                        \"today\": day == now.date(),\\n                        \"is_current_month\": day.month == date.month,\\n                    }\\n                )\\n            month_calendar.append(week_calendar)\\n\\n        data[\"calendar\"] = month_calendar\\n        data[\"weekdays\"] = [DAYS[x] for x in cal.iterweekdays()]\\n        data[\"month\"] = date\\n        data[\"next_month\"] = self.get_next_month(date)\\n        data[\"previous_month\"] = self.get_previous_month(date)\\n\\n        return data\\n\\n\\nclass CalendarMonthView(MultipleObjectTemplateResponseMixin, BaseCalendarMonthView):\\n    \"\"\"\\n    A view for displaying a calendar month, and rendering a template response\\n    \"\"\"\\n\\n    template_name_suffix = \"_calendar_month\"\\n'"}, "return_value": "'import datetime\\nimport math\\nfrom calendar import Calendar\\nfrom collections import defaultdict\\n\\nfrom django.core.exceptions import ImproperlyConfigured\\nfrom django.db.models import Q\\nfrom django.utils.translation import gettext_lazy as _\\nfrom django.views.generic.dates import (\\n    DateMixin,\\n    MonthMixin,\\n    YearMixin,\\n    _date_from_string,\\n)\\nfrom django.views.generic.list import BaseListView, MultipleObjectTemplateResponseMixin\\n\\nDAYS = (\\n    _(\"Monday\"),\\n    _(\"Tuesday\"),\\n    _(\"Wednesday\"),\\n    _(\"Thursday\"),\\n    _(\"Friday\"),\\n    _(\"Saturday\"),\\n    _(\"Sunday\"),\\n)\\n\\n\\ndef daterange(start_date, end_date):\\n    \"\"\"\\n    Returns an iterator of dates between two provided ones\\n    \"\"\"\\n    for n in range(int((end_date - start_date).days + 1)):\\n        yield start_date + datetime.timedelta(n)\\n\\n\\nclass BaseCalendarMonthView(DateMixin, YearMixin, MonthMixin, BaseListView):\\n    \"\"\"\\n    A base view for displaying a calendar month\\n    \"\"\"\\n\\n    first_of_week = 0  # 0 = Monday, 6 = Sunday\\n    paginate_by = None  # We don\\'t want to use this part of MultipleObjectMixin\\n    date_field = None\\n    end_date_field = None  # For supporting events with duration\\n\\n    def get_paginate_by(self, queryset):\\n        if self.paginate_by is not None:\\n            raise ImproperlyConfigured(\\n                \"\\'%s\\' cannot be paginated, it is a calendar view\"\\n                % self.__class__.__name__\\n            )\\n        return None\\n\\n    def get_allow_future(self):\\n        return True\\n\\n    def get_end_date_field(self):\\n        \"\"\"\\n        Returns the model field to use for end dates\\n        \"\"\"\\n        return self.end_date_field\\n\\n    def get_start_date(self, obj):\\n        \"\"\"\\n        Returns the start date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_end_date(self, obj):\\n        \"\"\"\\n        Returns the end date for a model instance\\n        \"\"\"\\n        obj_date = getattr(obj, self.get_end_date_field())\\n        try:\\n            obj_date = obj_date.date()\\n        except AttributeError:\\n            # It\\'s a date rather than datetime, so we use it as is\\n            pass\\n        return obj_date\\n\\n    def get_first_of_week(self):\\n        \"\"\"\\n        Returns an integer representing the first day of the week.\\n\\n        0 represents Monday, 6 represents Sunday.\\n        \"\"\"\\n        if self.first_of_week is None:\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week is required.\" % self.__class__.__name__\\n            )\\n        if self.first_of_week not in range(7):\\n            raise ImproperlyConfigured(\\n                \"%s.first_of_week must be an integer between 0 and 6.\"\\n                % self.__class__.__name__\\n            )\\n        return self.first_of_week\\n\\n    def get_queryset(self):\\n        \"\"\"\\n        Returns a queryset of models for the month requested\\n        \"\"\"\\n        qs = super().get_queryset()\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date_field = self.get_date_field()\\n        end_date_field = self.get_end_date_field()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        since = date\\n        until = self.get_next_month(date)\\n\\n        # Adjust our start and end dates to allow for next and previous\\n        # month edges\\n        if since.weekday() != self.get_first_of_week():\\n            diff = math.fabs(since.weekday() - self.get_first_of_week())\\n            since = since - datetime.timedelta(days=diff)\\n\\n        if until.weekday() != ((self.get_first_of_week() + 6) % 7):\\n            diff = math.fabs(((self.get_first_of_week() + 6) % 7) - until.weekday())\\n            until = until + datetime.timedelta(days=diff)\\n\\n        if end_date_field:\\n            # 5 possible conditions for showing an event:\\n\\n            # 1) Single day event, starts after \\'since\\'\\n            # 2) Multi-day event, starts after \\'since\\' and ends before \\'until\\'\\n            # 3) Starts before \\'since\\' and ends after \\'since\\' and before \\'until\\'\\n            # 4) Starts after \\'since\\' but before \\'until\\' and ends after \\'until\\'\\n            # 5) Starts before \\'since\\' and ends after \\'until\\'\\n            predicate1 = Q(**{\"%s__gte\" % date_field: since, end_date_field: None})\\n            predicate2 = Q(\\n                **{\"%s__gte\" % date_field: since, \"%s__lt\" % end_date_field: until}\\n            )\\n            predicate3 = Q(\\n                **{\\n                    \"%s__lt\" % date_field: since,\\n                    \"%s__gte\" % end_date_field: since,\\n                    \"%s__lt\" % end_date_field: until,\\n                }\\n            )\\n            predicate4 = Q(\\n                **{\\n                    \"%s__gte\" % date_field: since,\\n                    \"%s__lt\" % date_field: until,\\n                    \"%s__gte\" % end_date_field: until,\\n                }\\n            )\\n            predicate5 = Q(\\n                **{\"%s__lt\" % date_field: since, \"%s__gte\" % end_date_field: until}\\n            )\\n            return qs.filter(\\n                predicate1 | predicate2 | predicate3 | predicate4 | predicate5\\n            )\\n        return qs.filter(**{\"%s__gte\" % date_field: since})\\n\\n    def get_context_data(self, **kwargs):\\n        \"\"\"\\n        Injects variables necessary for rendering the calendar into the context.\\n\\n        Variables added are: `calendar`, `weekdays`, `month`, `next_month` and\\n        `previous_month`.\\n        \"\"\"\\n        data = super().get_context_data(**kwargs)\\n\\n        year = self.get_year()\\n        month = self.get_month()\\n\\n        date = _date_from_string(\\n            year, self.get_year_format(), month, self.get_month_format()\\n        )\\n\\n        cal = Calendar(self.get_first_of_week())\\n\\n        month_calendar = []\\n        now = datetime.datetime.utcnow()\\n\\n        date_lists = defaultdict(list)\\n        multidate_objs = []\\n\\n        for obj in data[\"object_list\"]:\\n            obj_date = self.get_start_date(obj)\\n            end_date_field = self.get_end_date_field()\\n\\n            if end_date_field:\\n                end_date = self.get_end_date(obj)\\n                if end_date and end_date != obj_date:\\n                    multidate_objs.append(\\n                        {\\n                            \"obj\": obj,\\n                            \"range\": [x for x in daterange(obj_date, end_date)],\\n                        }\\n                    )\\n                    continue  # We don\\'t put multi-day events in date_lists\\n            date_lists[obj_date].append(obj)\\n\\n        for week in cal.monthdatescalendar(date.year, date.month):\\n            week_range = set(daterange(week[0], week[6]))\\n            week_events = []\\n\\n            for val in multidate_objs:\\n                intersect_length = len(week_range.intersection(val[\"range\"]))\\n\\n                if intersect_length:\\n                    # Event happens during this week\\n                    slot = 1\\n                    width = (\\n                        intersect_length  # How many days is the event during this week?\\n                    )\\n                    nowrap_previous = (\\n                        True  # Does the event continue from the previous week?\\n                    )\\n                    nowrap_next = True  # Does the event continue to the next week?\\n\\n                    if val[\"range\"][0] >= week[0]:\\n                        slot = 1 + (val[\"range\"][0] - week[0]).days\\n                    else:\\n                        nowrap_previous = False\\n                    if val[\"range\"][-1] > week[6]:\\n                        nowrap_next = False\\n\\n                    week_events.append(\\n                        {\\n                            \"event\": val[\"obj\"],\\n                            \"slot\": slot,\\n                            \"width\": width,\\n                            \"nowrap_previous\": nowrap_previous,\\n                            \"nowrap_next\": nowrap_next,\\n                        }\\n                    )\\n\\n            week_calendar = {\"events\": week_events, \"date_list\": []}\\n            for day in week:\\n                week_calendar[\"date_list\"].append(\\n                    {\\n                        \"day\": day,\\n                        \"events\": date_lists[day],\\n                        \"today\": day == now.date(),\\n                        \"is_current_month\": day.month == date.month,\\n                    }\\n                )\\n            month_calendar.append(week_calendar)\\n\\n        data[\"calendar\"] = month_calendar\\n        data[\"weekdays\"] = [DAYS[x] for x in cal.iterweekdays()]\\n        data[\"month\"] = date\\n        data[\"next_month\"] = self.get_next_month(date)\\n        data[\"previous_month\"] = self.get_previous_month(date)\\n\\n        return data\\n\\n\\nclass CalendarMonthView(MultipleObjectTemplateResponseMixin, BaseCalendarMonthView):\\n    \"\"\"\\n    A view for displaying a calendar month, and rendering a template response\\n    \"\"\"\\n\\n    template_name_suffix = \"_calendar_month\"\\n'"}, {"func_args": {"source": "'from django.forms.formsets import formset_factory\\nfrom django.forms.models import inlineformset_factory, modelformset_factory\\nfrom django.http import HttpResponseRedirect\\nfrom django.views.generic.base import ContextMixin, TemplateResponseMixin, View\\nfrom django.views.generic.detail import (\\n    SingleObjectMixin,\\n    SingleObjectTemplateResponseMixin,\\n)\\nfrom django.views.generic.list import (\\n    MultipleObjectMixin,\\n    MultipleObjectTemplateResponseMixin,\\n)\\n\\n\\nclass BaseFormSetFactory(object):\\n    \"\"\"\\n    Base class for constructing a FormSet from `formset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    initial = []\\n    form_class = None\\n    formset_class = None\\n    prefix = None\\n    formset_kwargs = {}\\n    factory_kwargs = {}\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Returns an instance of the formset\\n        \"\"\"\\n        formset_class = self.get_formset()\\n        return formset_class(**self.get_formset_kwargs())\\n\\n    def get_initial(self):\\n        \"\"\"\\n        Returns a copy of the initial data to use for formsets on this view.\\n        \"\"\"\\n        return self.initial[:]\\n\\n    def get_prefix(self):\\n        \"\"\"\\n        Returns the prefix used for formsets on this view.\\n        \"\"\"\\n        return self.prefix\\n\\n    def get_formset_class(self):\\n        \"\"\"\\n        Returns the formset class to use in the formset factory\\n        \"\"\"\\n        return self.formset_class\\n\\n    def get_form_class(self):\\n        \"\"\"\\n        Returns the form class to use with the formset in this view\\n        \"\"\"\\n        return self.form_class\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the formset factory\\n        \"\"\"\\n        return formset_factory(self.get_form_class(), **self.get_factory_kwargs())\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = self.formset_kwargs.copy()\\n        kwargs.update({\"initial\": self.get_initial(), \"prefix\": self.get_prefix()})\\n\\n        if self.request.method in (\"POST\", \"PUT\"):\\n            kwargs.update(\\n                {\"data\": self.request.POST.copy(), \"files\": self.request.FILES}\\n            )\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = self.factory_kwargs.copy()\\n        if self.get_formset_class():\\n            kwargs[\"formset\"] = self.get_formset_class()\\n        return kwargs\\n\\n\\nclass FormSetMixin(BaseFormSetFactory, ContextMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single formset in a request.\\n    \"\"\"\\n\\n    success_url = None\\n\\n    def get_success_url(self):\\n        \"\"\"\\n        Returns the supplied URL.\\n        \"\"\"\\n        if self.success_url:\\n            url = self.success_url\\n        else:\\n            # Default to returning to the same page\\n            url = self.request.get_full_path()\\n        return url\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid redirect to the supplied URL\\n        \"\"\"\\n        return HttpResponseRedirect(self.get_success_url())\\n\\n    def formset_invalid(self, formset):\\n        \"\"\"\\n        If the formset is invalid, re-render the context data with the\\n        data-filled formset and errors.\\n        \"\"\"\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n\\nclass ModelFormSetMixin(FormSetMixin, MultipleObjectMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single model formset\\n    in a request.\\n\\n    Uses `modelformset_factory`.\\n    \"\"\"\\n\\n    exclude = None\\n    fields = None\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"queryset\"] = self.get_queryset()\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the model formset factory\\n        \"\"\"\\n        return modelformset_factory(self.model, **self.get_factory_kwargs())\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid, save the associated models.\\n        \"\"\"\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass BaseInlineFormSetFactory(BaseFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a FormSet from `inlineformset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    model = None\\n    inline_model = None\\n    exclude = None\\n    fields = None\\n\\n    def get_inline_model(self):\\n        \"\"\"\\n        Returns the inline model to use with the inline formset\\n        \"\"\"\\n        return self.inline_model\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"instance\"] = self.object\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the inline formset factory\\n        \"\"\"\\n        return inlineformset_factory(\\n            self.model, self.get_inline_model(), **self.get_factory_kwargs()\\n        )\\n\\n\\nclass InlineFormSetMixin(BaseInlineFormSetFactory, SingleObjectMixin, FormSetMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single inline formset\\n    in a request.\\n    \"\"\"\\n\\n    def formset_valid(self, formset):\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass ProcessFormSetView(View):\\n    \"\"\"\\n    A mixin that processes a formset on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the formset.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a formset instance with the passed\\n        POST variables and then checked for validity.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        if formset.is_valid():\\n            return self.formset_valid(formset)\\n        else:\\n            return self.formset_invalid(formset)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseFormSetView(FormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a formset\\n    \"\"\"\\n\\n\\nclass FormSetView(TemplateResponseMixin, BaseFormSetView):\\n    \"\"\"\\n    A view for displaying a formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseModelFormSetView(ModelFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a model formset\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass ModelFormSetView(MultipleObjectTemplateResponseMixin, BaseModelFormSetView):\\n    \"\"\"\\n    A view for displaying a model formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseInlineFormSetView(InlineFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying an inline formset for a queryset belonging to\\n    a parent model\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass InlineFormSetView(SingleObjectTemplateResponseMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A view for displaying an inline formset for a queryset belonging to a parent model\\n    \"\"\"\\n'"}, "return_value": "'from django.forms.formsets import formset_factory\\nfrom django.forms.models import inlineformset_factory, modelformset_factory\\nfrom django.http import HttpResponseRedirect\\nfrom django.views.generic.base import ContextMixin, TemplateResponseMixin, View\\nfrom django.views.generic.detail import (\\n    SingleObjectMixin,\\n    SingleObjectTemplateResponseMixin,\\n)\\nfrom django.views.generic.list import (\\n    MultipleObjectMixin,\\n    MultipleObjectTemplateResponseMixin,\\n)\\n\\n\\nclass BaseFormSetFactory(object):\\n    \"\"\"\\n    Base class for constructing a FormSet from `formset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    initial = []\\n    form_class = None\\n    formset_class = None\\n    prefix = None\\n    formset_kwargs = {}\\n    factory_kwargs = {}\\n\\n    def construct_formset(self):\\n        \"\"\"\\n        Returns an instance of the formset\\n        \"\"\"\\n        formset_class = self.get_formset()\\n        return formset_class(**self.get_formset_kwargs())\\n\\n    def get_initial(self):\\n        \"\"\"\\n        Returns a copy of the initial data to use for formsets on this view.\\n        \"\"\"\\n        return self.initial[:]\\n\\n    def get_prefix(self):\\n        \"\"\"\\n        Returns the prefix used for formsets on this view.\\n        \"\"\"\\n        return self.prefix\\n\\n    def get_formset_class(self):\\n        \"\"\"\\n        Returns the formset class to use in the formset factory\\n        \"\"\"\\n        return self.formset_class\\n\\n    def get_form_class(self):\\n        \"\"\"\\n        Returns the form class to use with the formset in this view\\n        \"\"\"\\n        return self.form_class\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the formset factory\\n        \"\"\"\\n        return formset_factory(self.get_form_class(), **self.get_factory_kwargs())\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = self.formset_kwargs.copy()\\n        kwargs.update({\"initial\": self.get_initial(), \"prefix\": self.get_prefix()})\\n\\n        if self.request.method in (\"POST\", \"PUT\"):\\n            kwargs.update(\\n                {\"data\": self.request.POST.copy(), \"files\": self.request.FILES}\\n            )\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = self.factory_kwargs.copy()\\n        if self.get_formset_class():\\n            kwargs[\"formset\"] = self.get_formset_class()\\n        return kwargs\\n\\n\\nclass FormSetMixin(BaseFormSetFactory, ContextMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single formset in a request.\\n    \"\"\"\\n\\n    success_url = None\\n\\n    def get_success_url(self):\\n        \"\"\"\\n        Returns the supplied URL.\\n        \"\"\"\\n        if self.success_url:\\n            url = self.success_url\\n        else:\\n            # Default to returning to the same page\\n            url = self.request.get_full_path()\\n        return url\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid redirect to the supplied URL\\n        \"\"\"\\n        return HttpResponseRedirect(self.get_success_url())\\n\\n    def formset_invalid(self, formset):\\n        \"\"\"\\n        If the formset is invalid, re-render the context data with the\\n        data-filled formset and errors.\\n        \"\"\"\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n\\nclass ModelFormSetMixin(FormSetMixin, MultipleObjectMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single model formset\\n    in a request.\\n\\n    Uses `modelformset_factory`.\\n    \"\"\"\\n\\n    exclude = None\\n    fields = None\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"queryset\"] = self.get_queryset()\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the model formset factory\\n        \"\"\"\\n        return modelformset_factory(self.model, **self.get_factory_kwargs())\\n\\n    def formset_valid(self, formset):\\n        \"\"\"\\n        If the formset is valid, save the associated models.\\n        \"\"\"\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass BaseInlineFormSetFactory(BaseFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a FormSet from `inlineformset_factory` in a view.\\n\\n    Calling `construct_formset` calls all other methods.\\n    \"\"\"\\n\\n    model = None\\n    inline_model = None\\n    exclude = None\\n    fields = None\\n\\n    def get_inline_model(self):\\n        \"\"\"\\n        Returns the inline model to use with the inline formset\\n        \"\"\"\\n        return self.inline_model\\n\\n    def get_formset_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for instantiating the formset.\\n        \"\"\"\\n        kwargs = super().get_formset_kwargs()\\n        kwargs[\"instance\"] = self.object\\n        return kwargs\\n\\n    def get_factory_kwargs(self):\\n        \"\"\"\\n        Returns the keyword arguments for calling the formset factory\\n        \"\"\"\\n        kwargs = super().get_factory_kwargs()\\n        kwargs.setdefault(\"fields\", self.fields)\\n        kwargs.setdefault(\"exclude\", self.exclude)\\n\\n        if self.get_form_class():\\n            kwargs[\"form\"] = self.get_form_class()\\n        return kwargs\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the formset class from the inline formset factory\\n        \"\"\"\\n        return inlineformset_factory(\\n            self.model, self.get_inline_model(), **self.get_factory_kwargs()\\n        )\\n\\n\\nclass InlineFormSetMixin(BaseInlineFormSetFactory, SingleObjectMixin, FormSetMixin):\\n    \"\"\"\\n    A view mixin that provides a way to show and handle a single inline formset\\n    in a request.\\n    \"\"\"\\n\\n    def formset_valid(self, formset):\\n        self.object_list = formset.save()\\n        return super().formset_valid(formset)\\n\\n\\nclass ProcessFormSetView(View):\\n    \"\"\"\\n    A mixin that processes a formset on POST.\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles GET requests and instantiates a blank version of the formset.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        return self.render_to_response(self.get_context_data(formset=formset))\\n\\n    def post(self, request, *args, **kwargs):\\n        \"\"\"\\n        Handles POST requests, instantiating a formset instance with the passed\\n        POST variables and then checked for validity.\\n        \"\"\"\\n        formset = self.construct_formset()\\n        if formset.is_valid():\\n            return self.formset_valid(formset)\\n        else:\\n            return self.formset_invalid(formset)\\n\\n    # PUT is a valid HTTP verb for creating (with a known URL) or editing an\\n    # object, note that browsers only support POST for now.\\n    def put(self, *args, **kwargs):\\n        return self.post(*args, **kwargs)\\n\\n\\nclass BaseFormSetView(FormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a formset\\n    \"\"\"\\n\\n\\nclass FormSetView(TemplateResponseMixin, BaseFormSetView):\\n    \"\"\"\\n    A view for displaying a formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseModelFormSetView(ModelFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying a model formset\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object_list = self.get_queryset()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass ModelFormSetView(MultipleObjectTemplateResponseMixin, BaseModelFormSetView):\\n    \"\"\"\\n    A view for displaying a model formset, and rendering a template response\\n    \"\"\"\\n\\n\\nclass BaseInlineFormSetView(InlineFormSetMixin, ProcessFormSetView):\\n    \"\"\"\\n    A base view for displaying an inline formset for a queryset belonging to\\n    a parent model\\n    \"\"\"\\n\\n    def get(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().get(request, *args, **kwargs)\\n\\n    def post(self, request, *args, **kwargs):\\n        self.object = self.get_object()\\n        return super().post(request, *args, **kwargs)\\n\\n\\nclass InlineFormSetView(SingleObjectTemplateResponseMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A view for displaying an inline formset for a queryset belonging to a parent model\\n    \"\"\"\\n'"}, {"func_args": {"source": "'from django.contrib.contenttypes.forms import generic_inlineformset_factory\\n\\nfrom extra_views.formsets import (\\n    BaseInlineFormSetFactory,\\n    BaseInlineFormSetView,\\n    InlineFormSetMixin,\\n    InlineFormSetView,\\n)\\n\\n\\nclass BaseGenericInlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a GenericInlineFormSet from\\n    `generic_inlineformset_factory` in a view.\\n    \"\"\"\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the final formset class from generic_inlineformset_factory.\\n        \"\"\"\\n        result = generic_inlineformset_factory(\\n            self.inline_model, **self.get_factory_kwargs()\\n        )\\n        return result\\n\\n\\nclass GenericInlineFormSetFactory(BaseGenericInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create a `GenericInlineFormSet` from `generic_inlineformset_factory`\\n    as one of multiple `GenericInlineFormSet`s within a single view.\\n\\n    Subclasses `BaseGenericInlineFormSetFactory` and passes in the necessary view\\n    arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n\\nclass GenericInlineFormSetMixin(BaseGenericInlineFormSetFactory, InlineFormSetMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a generic inline formset in a\\n    request.\\n    \"\"\"\\n\\n\\nclass BaseGenericInlineFormSetView(GenericInlineFormSetMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A base view for displaying a generic inline formset\\n    \"\"\"\\n\\n\\nclass GenericInlineFormSetView(BaseGenericInlineFormSetView, InlineFormSetView):\\n    \"\"\"\\n    A view for displaying a generic inline formset for a queryset belonging to a\\n    parent model\\n    \"\"\"\\n'"}, "return_value": "'from django.contrib.contenttypes.forms import generic_inlineformset_factory\\n\\nfrom extra_views.formsets import (\\n    BaseInlineFormSetFactory,\\n    BaseInlineFormSetView,\\n    InlineFormSetMixin,\\n    InlineFormSetView,\\n)\\n\\n\\nclass BaseGenericInlineFormSetFactory(BaseInlineFormSetFactory):\\n    \"\"\"\\n    Base class for constructing a GenericInlineFormSet from\\n    `generic_inlineformset_factory` in a view.\\n    \"\"\"\\n\\n    def get_formset(self):\\n        \"\"\"\\n        Returns the final formset class from generic_inlineformset_factory.\\n        \"\"\"\\n        result = generic_inlineformset_factory(\\n            self.inline_model, **self.get_factory_kwargs()\\n        )\\n        return result\\n\\n\\nclass GenericInlineFormSetFactory(BaseGenericInlineFormSetFactory):\\n    \"\"\"\\n    Class used to create a `GenericInlineFormSet` from `generic_inlineformset_factory`\\n    as one of multiple `GenericInlineFormSet`s within a single view.\\n\\n    Subclasses `BaseGenericInlineFormSetFactory` and passes in the necessary view\\n    arguments.\\n    \"\"\"\\n\\n    def __init__(self, parent_model, request, instance, view_kwargs=None, view=None):\\n        self.inline_model = self.model\\n        self.model = parent_model\\n        self.request = request\\n        self.object = instance\\n        self.kwargs = view_kwargs\\n        self.view = view\\n\\n\\nclass GenericInlineFormSetMixin(BaseGenericInlineFormSetFactory, InlineFormSetMixin):\\n    \"\"\"\\n    A mixin that provides a way to show and handle a generic inline formset in a\\n    request.\\n    \"\"\"\\n\\n\\nclass BaseGenericInlineFormSetView(GenericInlineFormSetMixin, BaseInlineFormSetView):\\n    \"\"\"\\n    A base view for displaying a generic inline formset\\n    \"\"\"\\n\\n\\nclass GenericInlineFormSetView(BaseGenericInlineFormSetView, InlineFormSetView):\\n    \"\"\"\\n    A view for displaying a generic inline formset for a queryset belonging to a\\n    parent model\\n    \"\"\"\\n'"}]}, "rate": {"line": 21, "args": [{"func_args": {"hit": "0", "num": "6"}, "return_value": "'0'"}, {"func_args": {"hit": "0", "num": "108"}, "return_value": "'0'"}, {"func_args": {"hit": "0", "num": "0"}, "return_value": "'1'"}, {"func_args": {"hit": "0", "num": "123"}, "return_value": "'0'"}, {"func_args": {"hit": "0", "num": "116"}, "return_value": "'0'"}, {"func_args": {"hit": "0", "num": "120"}, "return_value": "'0'"}, {"func_args": {"hit": "0", "num": "17"}, "return_value": "'0'"}, {"func_args": {"hit": "0", "num": "0"}, "return_value": "'1'"}, {"func_args": {"hit": "0", "num": "367"}, "return_value": "'0'"}, {"func_args": {"hit": "0", "num": "123"}, "return_value": "'0'"}, {"func_args": {"hit": "0", "num": "490"}, "return_value": "'0'"}], "text": "def rate(hit, num):\n    \"\"\"Return the fraction of `hit`/`num`, as a string.\"\"\"\n    if num == 0:\n        return \"1\"\n    else:\n        return \"%.4g\" % (float(hit) / num)"}, "_ellipsize": {"line": 29, "args": [{"func_args": {"s": "'<_pytest.config.Config object at 0xffffb577f1c0>'", "maxsize": "240"}, "return_value": "'<_pytest.config.Config object at 0xffffb577f1c0>'"}, {"func_args": {"s": "'<_pytest.config.Config object at 0xffffb577f1c0>'", "maxsize": "240"}, "return_value": "'<_pytest.config.Config object at 0xffffb577f1c0>'"}, {"func_args": {"s": "'<function _main at 0xffffb5b02b80>'", "maxsize": "240"}, "return_value": "'<function _main at 0xffffb5b02b80>'"}, {"func_args": {"s": "'<function _main at 0xffffb5b02b80>'", "maxsize": "240"}, "return_value": "'<function _main at 0xffffb5b02b80>'"}, {"func_args": {"s": "'<_pytest.config.Config object at 0xffffb577f1c0>'", "maxsize": "240"}, "return_value": "'<_pytest.config.Config object at 0xffffb577f1c0>'"}, {"func_args": {"s": "'<_pytest.config.Config object at 0xffffb577f1c0>'", "maxsize": "240"}, "return_value": "'<_pytest.config.Config object at 0xffffb577f1c0>'"}, {"func_args": {"s": "'<Session django-extra-views exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=0>'", "maxsize": "240"}, "return_value": "'<Session django-extra-views exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=0>'"}, {"func_args": {"s": "'<Session django-extra-views exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=0>'", "maxsize": "240"}, "return_value": "'<Session django-extra-views exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=0>'"}, {"func_args": {"s": "\"<_HookCaller 'pytest_runtestloop'>\"", "maxsize": "240"}, "return_value": "\"<_HookCaller 'pytest_runtestloop'>\""}, {"func_args": {"s": "\"<_HookCaller 'pytest_runtestloop'>\"", "maxsize": "240"}, "return_value": "\"<_HookCaller 'pytest_runtestloop'>\""}, {"func_args": {"s": "'()'", "maxsize": "240"}, "return_value": "'()'"}, {"func_args": {"s": "'<Session django-extra-views exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=0>'", "maxsize": "240"}, "return_value": "'<Session django-extra-views exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=0>'"}, {"func_args": {"s": "\"{'session': <Session django-extra-views exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=0>}\"", "maxsize": "240"}, "return_value": "\"{'session': <Session django-extra-views exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=0>}\""}, {"func_args": {"s": "\"'session'\"", "maxsize": "240"}, "return_value": "\"'session'\""}, {"func_args": {"s": "'True'", "maxsize": "240"}, "return_value": "'True'"}, {"func_args": {"s": "'True'", "maxsize": "240"}, "return_value": "'True'"}, {"func_args": {"s": "'<_pytest.config.PytestPluginManager object at 0xffffbb32bd30>'", "maxsize": "240"}, "return_value": "'<_pytest.config.PytestPluginManager object at 0xffffbb32bd30>'"}, {"func_args": {"s": "'<_pytest.config.PytestPluginManager object at 0xffffbb32bd30>'", "maxsize": "240"}, "return_value": "'<_pytest.config.PytestPluginManager object at 0xffffbb32bd30>'"}, {"func_args": {"s": "\"'pytest_runtestloop'\"", "maxsize": "240"}, "return_value": "\"'pytest_runtestloop'\""}, {"func_args": {"s": "\"<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/_pytest/main.py'>>\"", "maxsize": "240"}, "return_value": "\"<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/_pytest/main.py'>>\""}, {"func_args": {"s": "\"<HookImpl plugin_name='_cov', plugin=<pytest_cov.plugin.CovPlugin object at 0xffffb4fbc550>>\"", "maxsize": "240"}, "return_value": "\"<HookImpl plugin_name='_cov', plugin=<pytest_cov.plugin.CovPlugin object at 0xffffb4fbc550>>\""}, {"func_args": {"s": "\"<HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0xffffb3d5eee0>>\"", "maxsize": "240"}, "return_value": "\"<HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0xffffb3d5eee0>>\""}, {"func_args": {"s": "\"[<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/usr/app/src/test_repos/django-extra-views/.tox/py38/lib/python3.8/site-packages/_pytest/main.py'>>, <HookImpl plugin_name='_cov', plugin=<pytest_cov.plugin.CovPlugin object at 0xffffb4fbc550>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0xffffb3d5eee0>>]\"", "maxsize": "240"}, "return_value": "\"[<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/usr/app/src/test_repos/django-extra-views/.tox/py3...ffb4fbc550>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0xffffb3d5eee0>>]\""}, {"func_args": {"s": "'<Session django-extra-views exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=0>'", "maxsize": "240"}, "return_value": "'<Session django-extra-views exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=0>'"}, {"func_args": {"s": "\"{'session': <Session django-extra-views exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=0>}\"", "maxsize": "240"}, "return_value": "\"{'session': <Session django-extra-views exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=0>}\""}, {"func_args": {"s": "'True'", "maxsize": "240"}, "return_value": "'True'"}, {"func_args": {"s": "'True'", "maxsize": "240"}, "return_value": "'True'"}, {"func_args": {"s": "'<Session django-extra-views exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=0>'", "maxsize": "240"}, "return_value": "'<Session django-extra-views exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=0>'"}, {"func_args": {"s": "'<Session django-extra-views exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=0>'", "maxsize": "240"}, "return_value": "'<Session django-extra-views exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=0>'"}], "text": "def _ellipsize(s: str, maxsize: int) -> str:\n    if len(s) > maxsize:\n        i = max(0, (maxsize - 3) // 2)\n        j = max(0, maxsize - 3 - i)\n        return s[:i] + \"...\" + s[len(s) - j :]\n    return s"}}