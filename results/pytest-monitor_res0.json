{"_args_converter": {"line": 816, "args": [{"func_args": {"args": "['tests']"}, "return_value": "('tests',)"}], "text": "def _args_converter(args: Iterable[str]) -> Tuple[str, ...]:\n    return tuple(args)"}, "_get_plugin_specs_as_list": {"line": 715, "args": [{"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "None"}, "return_value": "[]"}, {"func_args": {"specs": "['pytester']"}, "return_value": "['pytester']"}, {"func_args": {"specs": "['pytester_assertions']"}, "return_value": "['pytester_assertions']"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}], "text": "def _get_plugin_specs_as_list(\n    specs: Union[None, types.ModuleType, str, Sequence[str]]\n) -> List[str]:\n    \"\"\"Parse a plugins specification into a list of plugin names.\"\"\"\n    # None means empty.\n    if specs is None:\n        return []\n    # Workaround for #3899 - a submodule which happens to be called \"pytest_plugins\".\n    if isinstance(specs, types.ModuleType):\n        return []\n    # Comma-separated list.\n    if isinstance(specs, str):\n        return specs.split(\",\") if specs else []\n    # Direct specification.\n    if isinstance(specs, collections.abc.Sequence):\n        return list(specs)\n    raise UsageError(\n        \"Plugins may be specified as a sequence or a ','-separated string of plugin names. Got: %r\"\n        % specs\n    )"}, "_assertion_supported": {"line": 1511, "args": [{"func_args": {}, "return_value": "True"}], "text": "def _assertion_supported() -> bool:\n    try:\n        assert False\n    except AssertionError:\n        return True\n    else:\n        return False"}, "_get_auto_indent": {"line": 113, "args": [{"func_args": {"auto_indent_option": "None"}, "return_value": "0"}, {"func_args": {"auto_indent_option": "None"}, "return_value": "0"}]}, "_get_stderr_fileno": {"line": 68, "args": [{"func_args": {}, "return_value": "2"}, {"func_args": {}, "return_value": "2"}]}, "get_terminal_width": {"line": 15, "args": [{"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}], "text": "def get_terminal_width() -> int:\n    width, _ = shutil.get_terminal_size(fallback=(80, 24))\n\n    # The Windows get_terminal_size may be bogus, let's sanify a bit.\n    if width < 40:\n        width = 80\n\n    return width"}, "is_option": {"line": 135, "args": [{"func_args": {"x": "'tests'"}, "return_value": "False"}], "text": "def is_option(x: str) -> bool:\n        return x.startswith(\"-\")"}, "get_file_part_from_node_id": {"line": 138, "args": [{"func_args": {"x": "'tests'"}, "return_value": "'tests'"}], "text": "def get_file_part_from_node_id(x: str) -> str:\n        return x.split(\"::\")[0]"}, "_is_same": {"line": 558, "args": [{"func_args": {"f1": "'/usr/app/src/test_repos/pytest-monitor/tests/conftest.py'", "f2": "'/usr/app/src/test_repos/pytest-monitor/tests/conftest.py'"}, "return_value": "True"}], "text": "def _is_same(f1: str, f2: str) -> bool:\n        return os.path.samefile(f1, f2)"}, "iscommentline": {"line": 162, "args": [{"func_args": {"line": "'[tox]\\n'"}, "return_value": "False"}, {"func_args": {"line": "'envlist = py27,py34,py35,py36,py37,pypy,flake8\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\n'"}, "return_value": "True"}, {"func_args": {"line": "'[testenv]\\n'"}, "return_value": "False"}, {"func_args": {"line": "'deps = pytest>=3.0\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tviztracer \\n'"}, "return_value": "False"}, {"func_args": {"line": "'commands = viztracer --ignore_frozen --log_func_args --log_func_retval -o result0.json -- pytest {posargs:tests}\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\n'"}, "return_value": "True"}, {"func_args": {"line": "'[testenv:flake8]\\n'"}, "return_value": "False"}, {"func_args": {"line": "'skip_install = true\\n'"}, "return_value": "False"}, {"func_args": {"line": "'deps = flake8\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tviztracer \\n'"}, "return_value": "False"}, {"func_args": {"line": "'commands = flake8 viztracer --ignore_frozen --log_func_args --log_func_retval -o result1.json -- pytest_monitor.py setup.py tests\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\n'"}, "return_value": "True"}], "text": "def iscommentline(line):\n    c = line.lstrip()[:1]\n    return c in COMMENTCHARS"}, "is_rewrite_disabled": {"line": 754, "args": [{"func_args": {"docstring": "'(Disabled by default) support for testing pytest and pytest plugins.\\n\\nPYTEST_DONT_REWRITE\\n'"}, "return_value": "True"}]}, "get_procfs_path": {"line": 747, "args": [{"func_args": {}, "return_value": "'/proc'"}, {"func_args": {}, "return_value": "'/proc'"}, {"func_args": {}, "return_value": "'/proc'"}, {"func_args": {}, "return_value": "'/proc'"}, {"func_args": {}, "return_value": "'/proc'"}, {"func_args": {}, "return_value": "'/proc'"}], "text": "def get_procfs_path():\n    \"\"\"Return updated psutil.PROCFS_PATH constant.\"\"\"\n    return sys.modules['psutil'].PROCFS_PATH"}, "boot_time": {"line": 1575, "args": [{"func_args": {}, "return_value": "1642610225.0"}], "text": "def boot_time():\n    \"\"\"Return the system boot time expressed in seconds since the epoch.\"\"\"\n    global BOOT_TIME\n    path = '%s/stat' % get_procfs_path()\n    with open_binary(path) as f:\n        for line in f:\n            if line.startswith(b'btime'):\n                ret = float(line.strip().split()[1])\n                BOOT_TIME = ret\n                return ret\n        raise RuntimeError(\n            \"line 'btime' not found in %s\" % path)"}, "_cpu_get_cpuinfo_freq": {"line": 722, "args": [{"func_args": {}, "return_value": "[]"}], "text": "def _cpu_get_cpuinfo_freq():\n    \"\"\"Return current CPU frequency from cpuinfo if available.\n    \"\"\"\n    ret = []\n    with open_binary('%s/cpuinfo' % get_procfs_path()) as f:\n        for line in f:\n            if line.lower().startswith(b'cpu mhz'):\n                ret.append(float(line.split(b':', 1)[1]))\n    return ret"}, "cpu_freq": {"line": 768, "args": [{"func_args": {}, "return_value": "[]"}], "text": "def cpu_freq():\n        \"\"\"Alternate implementation using /proc/cpuinfo.\n        min and max frequencies are not available and are set to None.\n        \"\"\"\n        return [_common.scpufreq(x, 0., 0.) for x in _cpu_get_cpuinfo_freq()]"}, "dummy": {"line": 115, "args": [{"func_args": {}, "return_value": "True"}], "text": "def dummy():\n            return True"}, "determine_scm_revision": {"line": 36, "args": [{"func_args": {}, "return_value": "'a73b055bf3e79b2cee17cda9b7a5e8f0e04e761b'"}], "text": "def determine_scm_revision():\n    for cmd in [r'git rev-parse HEAD', r'p4 changes -m1 \\#have']:\n        p = subprocess.Popen(cmd, shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n        p_out, _ = p.communicate()\n        if p.returncode == 0:\n            return p_out.decode().split('\\n')[0]\n    return ''"}, "collect_ci_info": {"line": 10, "args": [{"func_args": {}, "return_value": "{}"}], "text": "def collect_ci_info():\n    d = dict()\n    # Test for jenkins\n    if \"BUILD_NUMBER\" in os.environ:\n        if \"BRANCH_NAME\" in os.environ or \"JOB_NAME\" in os.environ:\n            br = os.environ[\"BRANCH_NAME\"] if \"BRANCH_NAME\" in os.environ else os.environ[\"JOB_NAME\"]\n            d = dict(pipeline_branch=br, pipeline_build_no=os.environ[\"BUILD_NUMBER\"], __ci__='jenkinsci')\n    # Test for CircleCI\n    if \"CIRCLE_JOB\" in os.environ and \"CIRCLE_BUILD_NUM\" in os.environ:\n        d = dict(pipeline_branch=os.environ[\"CIRCLE_JOB\"], pipeline_build_no=os.environ[\"CIRCLE_BUILD_NUM\"],\n                 __ci__='circleci')\n    # Test for TravisCI\n    if \"TRAVIS_BUILD_NUMBER\" in os.environ and \"TRAVIS_BUILD_ID\" in os.environ:\n        d = dict(pipeline_branch=os.environ[\"TRAVIS_BUILD_ID\"], pipeline_build_no=os.environ[\"TRAVIS_BUILD_NUMBER\"],\n                 __ci__='travisci')\n    # Test for DroneCI\n    if \"DRONE_REPO_BRANCH\" in os.environ and \"DRONE_BUILD_NUMBER\" in os.environ:\n        d = dict(pipeline_branch=os.environ[\"DRONE_REPO_BRANCH\"], pipeline_build_no=os.environ[\"DRONE_BUILD_NUMBER\"],\n                 __ci__='droneci')\n    # Test for Gitlab CI\n    if \"CI_JOB_NAME\" in os.environ and \"CI_PIPELINE_ID\" in os.environ:\n        d = dict(pipeline_branch=os.environ[\"CI_JOB_NAME\"], pipeline_build_no=os.environ[\"CI_PIPELINE_ID\"],\n                 __ci__='gitlabci')\n    return d"}, "_get_cpu_string": {"line": 45, "args": [{"func_args": {}, "return_value": "''"}], "text": "def _get_cpu_string():\n    if platform.system().lower() == \"darwin\":\n        old_path = os.environ['PATH']\n        os.environ['PATH'] = old_path + ':' + '/usr/sbin'\n        ret = subprocess.check_output('sysctl -n machdep.cpu.brand_string', shell=True).decode().strip()\n        os.environ['PATH'] = old_path\n        return ret\n    elif platform.system().lower() == 'linux':\n        with open('/proc/cpuinfo', 'r', encoding='utf-8') as f:\n            lines = [i for i in f if i.startswith('model name')]\n        if lines:\n            return lines[0].split(':')[1].strip()\n    return platform.processor()"}, "choose_backend": {"line": 1198, "args": [{"func_args": {"new_backend": "None"}, "return_value": "'psutil'"}], "text": "def choose_backend(new_backend=None):\n    \"\"\"\n    Function that tries to setup backend, chosen by user, and if failed,\n    setup one of the allowable backends\n    \"\"\"\n\n    _backend = 'no_backend'\n    all_backends = [\n        ('psutil', True),\n        ('psutil_pss', True),\n        ('psutil_uss', True),\n        ('posix', os.name == 'posix'),\n        ('tracemalloc', has_tracemalloc),\n    ]\n    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))\n\n    if new_backend is not None:\n        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))\n\n    for n_backend, is_available in all_backends:\n        if is_available:\n            _backend = n_backend\n            break\n    if _backend != new_backend and new_backend is not None:\n        warnings.warn('{0} can not be used, {1} used instead'.format(\n            new_backend, _backend))\n    return _backend"}, "ps_util_tool": {"line": 129, "args": [{"func_args": {}, "return_value": "66.56640625"}, {"func_args": {}, "return_value": "66.60546875"}, {"func_args": {}, "return_value": "66.60546875"}], "text": "def ps_util_tool():\n        # .. cross-platform but but requires psutil ..\n        process = psutil.Process(pid)\n        try:\n            # avoid using get_memory_info since it does not exists\n            # in psutil > 2.0 and accessing it will cause exception.\n            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \\\n                else 'get_memory_info'\n            mem = getattr(process, meminfo_attr)()[0] / _TWO_20\n            if include_children:\n                mem +=  sum(_get_child_memory(process, meminfo_attr))\n            if timestamps:\n                return mem, time.time()\n            else:\n                return mem\n        except psutil.AccessDenied:\n            pass\n            # continue and try to get this from ps"}, "_get_memory": {"line": 114, "args": [{"func_args": {"pid": "60530", "backend": "'psutil'", "timestamps": "False", "include_children": "False", "filename": "None"}, "return_value": "66.56640625"}, {"func_args": {"pid": "60530", "backend": "'psutil'", "timestamps": "False", "include_children": "False", "filename": "None"}, "return_value": "66.60546875"}, {"func_args": {"pid": "60530", "backend": "'psutil'", "timestamps": "False", "include_children": "False", "filename": "None"}, "return_value": "66.60546875"}], "text": "def _get_memory(pid, backend, timestamps=False, include_children=False, filename=None):\n    # .. low function to get memory consumption ..\n    if pid == -1:\n        pid = os.getpid()\n\n    def tracemalloc_tool():\n        # .. cross-platform but but requires Python 3.4 or higher ..\n        stat = next(filter(lambda item: str(item).startswith(filename),\n                           tracemalloc.take_snapshot().statistics('filename')))\n        mem = stat.size / _TWO_20\n        if timestamps:\n            return mem, time.time()\n        else:\n            return mem\n\n    def ps_util_tool():\n        # .. cross-platform but but requires psutil ..\n        process = psutil.Process(pid)\n        try:\n            # avoid using get_memory_info since it does not exists\n            # in psutil > 2.0 and accessing it will cause exception.\n            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \\\n                else 'get_memory_info'\n            mem = getattr(process, meminfo_attr)()[0] / _TWO_20\n            if include_children:\n                mem +=  sum(_get_child_memory(process, meminfo_attr))\n            if timestamps:\n                return mem, time.time()\n            else:\n                return mem\n        except psutil.AccessDenied:\n            pass\n            # continue and try to get this from ps\n\n    def _ps_util_full_tool(memory_metric):\n\n        # .. cross-platform but requires psutil > 4.0.0 ..\n        process = psutil.Process(pid)\n        try:\n            if not hasattr(process, 'memory_full_info'):\n                raise NotImplementedError(\"Backend `{}` requires psutil > 4.0.0\".format(memory_metric))\n\n            meminfo_attr = 'memory_full_info'\n            meminfo = getattr(process, meminfo_attr)()\n\n            if not hasattr(meminfo, memory_metric):\n                raise NotImplementedError(\n                    \"Metric `{}` not available. For details, see:\".format(memory_metric) +\n                    \"https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info\")\n            mem = getattr(meminfo, memory_metric) / _TWO_20\n\n            if include_children:\n                mem +=  sum(_get_child_memory(process, meminfo_attr, memory_metric))\n\n            if timestamps:\n                return mem, time.time()\n            else:\n                return mem\n        \n        except psutil.AccessDenied:\n            pass\n            # continue and try to get this from ps\n\n    def posix_tool():\n        # .. scary stuff ..\n        if include_children:\n            raise NotImplementedError((\n                \"The psutil module is required to monitor the \"\n                \"memory usage of child processes.\"\n            ))\n\n        warnings.warn(\"psutil module not found. memory_profiler will be slow\")\n        # ..\n        # .. memory usage in MiB ..\n        # .. this should work on both Mac and Linux ..\n        # .. subprocess.check_output appeared in 2.7, using Popen ..\n        # .. for backwards compatibility ..\n        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],\n                               stdout=subprocess.PIPE\n                               ).communicate()[0].split(b'\\n')\n        try:\n            vsz_index = out[0].split().index(b'RSS')\n            mem = float(out[1].split()[vsz_index]) / 1024\n            if timestamps:\n                return mem, time.time()\n            else:\n                return mem\n        except:\n            if timestamps:\n                return -1, time.time()\n            else:\n                return -1\n\n    if backend == 'tracemalloc' and \\\n            (filename is None or filename == '<unknown>'):\n        raise RuntimeError(\n            'There is no access to source file of the profiled function'\n        )\n\n    tools = {'tracemalloc': tracemalloc_tool,\n             'psutil': ps_util_tool,\n             'psutil_pss': lambda: _ps_util_full_tool(memory_metric=\"pss\"),\n             'psutil_uss': lambda: _ps_util_full_tool(memory_metric=\"uss\"),\n             'posix': posix_tool}\n    return tools[backend]()"}}