{"_args_converter": {"line": 816, "args": [{"func_args": {"args": "['--cov', 'overpy', '--cov-report=term-missing', '-v', 'tests/']"}, "return_value": "('--cov', 'overpy', '--cov-report=term-missing', '-v', 'tests/')"}], "text": "def _args_converter(args: Iterable[str]) -> Tuple[str, ...]:\n    return tuple(args)"}, "_get_plugin_specs_as_list": {"line": 715, "args": [{"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "None"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}, {"func_args": {"specs": "[]"}, "return_value": "[]"}], "text": "def _get_plugin_specs_as_list(\n    specs: Union[None, types.ModuleType, str, Sequence[str]]\n) -> List[str]:\n    \"\"\"Parse a plugins specification into a list of plugin names.\"\"\"\n    # None means empty.\n    if specs is None:\n        return []\n    # Workaround for #3899 - a submodule which happens to be called \"pytest_plugins\".\n    if isinstance(specs, types.ModuleType):\n        return []\n    # Comma-separated list.\n    if isinstance(specs, str):\n        return specs.split(\",\") if specs else []\n    # Direct specification.\n    if isinstance(specs, collections.abc.Sequence):\n        return list(specs)\n    raise UsageError(\n        \"Plugins may be specified as a sequence or a ','-separated string of plugin names. Got: %r\"\n        % specs\n    )"}, "_assertion_supported": {"line": 1511, "args": [{"func_args": {}, "return_value": "True"}], "text": "def _assertion_supported() -> bool:\n    try:\n        assert False\n    except AssertionError:\n        return True\n    else:\n        return False"}, "scope2index": {"line": 803, "args": [{"func_args": {"scope": "'session'", "descr": "\"Fixture 'pytestconfig'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'capfd'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'capfdbinary'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'capsys'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'capsysbinary'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'tmp_path'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'tmp_path_factory'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'tmpdir'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'tmpdir_factory'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'monkeypatch'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'recwarn'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'record_property'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'record_testsuite_property'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'record_xml_attribute'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'session'", "descr": "\"Fixture 'doctest_namespace'\"", "where": "None"}, "return_value": "0"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'cache'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'caplog'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'cov'\"", "where": "None"}, "return_value": "4"}, {"func_args": {"scope": "'function'", "descr": "\"Fixture 'no_cover'\"", "where": "None"}, "return_value": "4"}], "text": "def scope2index(scope: str, descr: str, where: Optional[str] = None) -> int:\n    \"\"\"Look up the index of ``scope`` and raise a descriptive value error\n    if not defined.\"\"\"\n    strscopes: Sequence[str] = scopes\n    try:\n        return strscopes.index(scope)\n    except ValueError:\n        fail(\n            \"{} {}got an unexpected scope value '{}'\".format(\n                descr, f\"from {where} \" if where else \"\", scope\n            ),\n            pytrace=False,\n        )"}, "mkrel": {"line": 859, "args": [{"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_element_data_wrong_type'"}, "return_value": "'tests/test_exception.py::TestExceptions::test_element_data_wrong_type'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_element_data_wrong_type'"}, "return_value": "'tests/test_exception.py::TestExceptions::test_element_data_wrong_type'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_bad_request'"}, "return_value": "'tests/test_exception.py::TestExceptions::test_overpass_bad_request'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_bad_request'"}, "return_value": "'tests/test_exception.py::TestExceptions::test_overpass_bad_request'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_content_type'"}, "return_value": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_content_type'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_content_type'"}, "return_value": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_content_type'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_http_status_code'"}, "return_value": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_http_status_code'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_http_status_code'"}, "return_value": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_http_status_code'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_error'"}, "return_value": "'tests/test_exception.py::TestExceptions::test_overpass_error'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_error'"}, "return_value": "'tests/test_exception.py::TestExceptions::test_overpass_error'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestAreas::test_area01'"}, "return_value": "'tests/test_json.py::TestAreas::test_area01'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestAreas::test_area01'"}, "return_value": "'tests/test_json.py::TestAreas::test_area01'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestNodes::test_node01'"}, "return_value": "'tests/test_json.py::TestNodes::test_node01'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestNodes::test_node01'"}, "return_value": "'tests/test_json.py::TestNodes::test_node01'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation01'"}, "return_value": "'tests/test_json.py::TestRelation::test_relation01'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation01'"}, "return_value": "'tests/test_json.py::TestRelation::test_relation01'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation02'"}, "return_value": "'tests/test_json.py::TestRelation::test_relation02'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation02'"}, "return_value": "'tests/test_json.py::TestRelation::test_relation02'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation03'"}, "return_value": "'tests/test_json.py::TestRelation::test_relation03'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation03'"}, "return_value": "'tests/test_json.py::TestRelation::test_relation03'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation04'"}, "return_value": "'tests/test_json.py::TestRelation::test_relation04'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation04'"}, "return_value": "'tests/test_json.py::TestRelation::test_relation04'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way01'"}, "return_value": "'tests/test_json.py::TestWay::test_way01'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way01'"}, "return_value": "'tests/test_json.py::TestWay::test_way01'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way02'"}, "return_value": "'tests/test_json.py::TestWay::test_way02'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way02'"}, "return_value": "'tests/test_json.py::TestWay::test_way02'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way03'"}, "return_value": "'tests/test_json.py::TestWay::test_way03'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way03'"}, "return_value": "'tests/test_json.py::TestWay::test_way03'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way04'"}, "return_value": "'tests/test_json.py::TestWay::test_way04'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way04'"}, "return_value": "'tests/test_json.py::TestWay::test_way04'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestDataError::test_element_wrong_type'"}, "return_value": "'tests/test_json.py::TestDataError::test_element_wrong_type'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestDataError::test_element_wrong_type'"}, "return_value": "'tests/test_json.py::TestDataError::test_element_wrong_type'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_runtime_error'"}, "return_value": "'tests/test_json.py::TestRemark::test_remark_runtime_error'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_runtime_error'"}, "return_value": "'tests/test_json.py::TestRemark::test_remark_runtime_error'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_runtime_remark'"}, "return_value": "'tests/test_json.py::TestRemark::test_remark_runtime_remark'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_runtime_remark'"}, "return_value": "'tests/test_json.py::TestRemark::test_remark_runtime_remark'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_unknown'"}, "return_value": "'tests/test_json.py::TestRemark::test_remark_unknown'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_unknown'"}, "return_value": "'tests/test_json.py::TestRemark::test_remark_unknown'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_chunk_size'"}, "return_value": "'tests/test_request.py::TestQuery::test_chunk_size'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_chunk_size'"}, "return_value": "'tests/test_request.py::TestQuery::test_chunk_size'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_syntax_error'"}, "return_value": "'tests/test_request.py::TestQuery::test_overpass_syntax_error'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_syntax_error'"}, "return_value": "'tests/test_request.py::TestQuery::test_overpass_syntax_error'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_syntax_error_encoding_error'"}, "return_value": "'tests/test_request.py::TestQuery::test_overpass_syntax_error_encoding_error'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_syntax_error_encoding_error'"}, "return_value": "'tests/test_request.py::TestQuery::test_overpass_syntax_error_encoding_error'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_too_many_requests'"}, "return_value": "'tests/test_request.py::TestQuery::test_overpass_too_many_requests'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_too_many_requests'"}, "return_value": "'tests/test_request.py::TestQuery::test_overpass_too_many_requests'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_gateway_timeout'"}, "return_value": "'tests/test_request.py::TestQuery::test_overpass_gateway_timeout'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_gateway_timeout'"}, "return_value": "'tests/test_request.py::TestQuery::test_overpass_gateway_timeout'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_unknown_status_code'"}, "return_value": "'tests/test_request.py::TestQuery::test_overpass_unknown_status_code'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_unknown_status_code'"}, "return_value": "'tests/test_request.py::TestQuery::test_overpass_unknown_status_code'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_json'"}, "return_value": "'tests/test_request.py::TestQuery::test_response_json'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_json'"}, "return_value": "'tests/test_request.py::TestQuery::test_response_json'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_unknown'"}, "return_value": "'tests/test_request.py::TestQuery::test_response_unknown'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_unknown'"}, "return_value": "'tests/test_request.py::TestQuery::test_response_unknown'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_xml'"}, "return_value": "'tests/test_request.py::TestQuery::test_response_xml'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_xml'"}, "return_value": "'tests/test_request.py::TestQuery::test_response_xml'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_retry'"}, "return_value": "'tests/test_request.py::TestQuery::test_retry'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_retry'"}, "return_value": "'tests/test_request.py::TestQuery::test_retry'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestResult::test_expand_error'"}, "return_value": "'tests/test_result.py::TestResult::test_expand_error'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestResult::test_expand_error'"}, "return_value": "'tests/test_result.py::TestResult::test_expand_error'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestResult::test_expand_01'"}, "return_value": "'tests/test_result.py::TestResult::test_expand_01'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestResult::test_expand_01'"}, "return_value": "'tests/test_result.py::TestResult::test_expand_01'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestArea::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py::TestArea::test_missing_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestArea::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py::TestArea::test_missing_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestArea::test_missing_resolvable'"}, "return_value": "'tests/test_result.py::TestArea::test_missing_resolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestArea::test_missing_resolvable'"}, "return_value": "'tests/test_result.py::TestArea::test_missing_resolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestNode::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py::TestNode::test_missing_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestNode::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py::TestNode::test_missing_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestNode::test_missing_resolvable'"}, "return_value": "'tests/test_result.py::TestNode::test_missing_resolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestNode::test_missing_resolvable'"}, "return_value": "'tests/test_result.py::TestNode::test_missing_resolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestPickle::test_way02'"}, "return_value": "'tests/test_result.py::TestPickle::test_way02'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestPickle::test_way02'"}, "return_value": "'tests/test_result.py::TestPickle::test_way02'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestRelation::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py::TestRelation::test_missing_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestRelation::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py::TestRelation::test_missing_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestRelation::test_missing_resolvable'"}, "return_value": "'tests/test_result.py::TestRelation::test_missing_resolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestRelation::test_missing_resolvable'"}, "return_value": "'tests/test_result.py::TestRelation::test_missing_resolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestWay::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py::TestWay::test_missing_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestWay::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py::TestWay::test_missing_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestWay::test_missing_resolvable'"}, "return_value": "'tests/test_result.py::TestWay::test_missing_resolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestWay::test_missing_resolvable'"}, "return_value": "'tests/test_result.py::TestWay::test_missing_resolvable'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_unresolvable'"}, "return_value": "'tests/test_result_way.py::TestNodes::test_missing_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_unresolvable'"}, "return_value": "'tests/test_result_way.py::TestNodes::test_missing_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_partly_unresolvable'"}, "return_value": "'tests/test_result_way.py::TestNodes::test_missing_partly_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_partly_unresolvable'"}, "return_value": "'tests/test_result_way.py::TestNodes::test_missing_partly_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_resolvable'"}, "return_value": "'tests/test_result_way.py::TestNodes::test_missing_resolvable'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_resolvable'"}, "return_value": "'tests/test_result_way.py::TestNodes::test_missing_resolvable'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestAreas::test_node01'"}, "return_value": "'tests/test_xml.py::TestAreas::test_node01'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestAreas::test_node01'"}, "return_value": "'tests/test_xml.py::TestAreas::test_node01'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestNodes::test_node01'"}, "return_value": "'tests/test_xml.py::TestNodes::test_node01'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestNodes::test_node01'"}, "return_value": "'tests/test_xml.py::TestNodes::test_node01'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation01'"}, "return_value": "'tests/test_xml.py::TestRelation::test_relation01'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation01'"}, "return_value": "'tests/test_xml.py::TestRelation::test_relation01'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation02'"}, "return_value": "'tests/test_xml.py::TestRelation::test_relation02'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation02'"}, "return_value": "'tests/test_xml.py::TestRelation::test_relation02'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation03'"}, "return_value": "'tests/test_xml.py::TestRelation::test_relation03'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation03'"}, "return_value": "'tests/test_xml.py::TestRelation::test_relation03'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation04'"}, "return_value": "'tests/test_xml.py::TestRelation::test_relation04'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation04'"}, "return_value": "'tests/test_xml.py::TestRelation::test_relation04'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way01'"}, "return_value": "'tests/test_xml.py::TestWay::test_way01'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way01'"}, "return_value": "'tests/test_xml.py::TestWay::test_way01'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way02'"}, "return_value": "'tests/test_xml.py::TestWay::test_way02'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way02'"}, "return_value": "'tests/test_xml.py::TestWay::test_way02'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way03'"}, "return_value": "'tests/test_xml.py::TestWay::test_way03'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way03'"}, "return_value": "'tests/test_xml.py::TestWay::test_way03'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way04'"}, "return_value": "'tests/test_xml.py::TestWay::test_way04'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way04'"}, "return_value": "'tests/test_xml.py::TestWay::test_way04'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_element_wrong_type'"}, "return_value": "'tests/test_xml.py::TestDataError::test_element_wrong_type'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_element_wrong_type'"}, "return_value": "'tests/test_xml.py::TestDataError::test_element_wrong_type'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_node_missing_data'"}, "return_value": "'tests/test_xml.py::TestDataError::test_node_missing_data'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_node_missing_data'"}, "return_value": "'tests/test_xml.py::TestDataError::test_node_missing_data'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_relation_missing_data'"}, "return_value": "'tests/test_xml.py::TestDataError::test_relation_missing_data'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_relation_missing_data'"}, "return_value": "'tests/test_xml.py::TestDataError::test_relation_missing_data'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_way_missing_data'"}, "return_value": "'tests/test_xml.py::TestDataError::test_way_missing_data'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_way_missing_data'"}, "return_value": "'tests/test_xml.py::TestDataError::test_way_missing_data'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_exception'"}, "return_value": "'tests/test_xml.py::TestParser::test_exception'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_exception'"}, "return_value": "'tests/test_xml.py::TestParser::test_exception'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_xml_element'"}, "return_value": "'tests/test_xml.py::TestParser::test_xml_element'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_xml_element'"}, "return_value": "'tests/test_xml.py::TestParser::test_xml_element'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_xml_autodetect_parser'"}, "return_value": "'tests/test_xml.py::TestParser::test_xml_autodetect_parser'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_xml_autodetect_parser'"}, "return_value": "'tests/test_xml.py::TestParser::test_xml_autodetect_parser'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_runtime_error'"}, "return_value": "'tests/test_xml.py::TestRemark::test_remark_runtime_error'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_runtime_error'"}, "return_value": "'tests/test_xml.py::TestRemark::test_remark_runtime_error'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_runtime_remark'"}, "return_value": "'tests/test_xml.py::TestRemark::test_remark_runtime_remark'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_runtime_remark'"}, "return_value": "'tests/test_xml.py::TestRemark::test_remark_runtime_remark'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_unknown'"}, "return_value": "'tests/test_xml.py::TestRemark::test_remark_unknown'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_unknown'"}, "return_value": "'tests/test_xml.py::TestRemark::test_remark_unknown'"}], "text": "def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line"}, "pluralize": {"line": 1350, "args": [{"func_args": {"count": "63", "noun": "'passed'"}, "return_value": "(63, 'passed')"}], "text": "def pluralize(count: int, noun: str) -> Tuple[int, str]:\n    # No need to pluralize words such as `failed` or `passed`.\n    if noun not in [\"error\", \"warnings\", \"test\"]:\n        return count, noun\n\n    # The `warnings` key is plural. To avoid API breakage, we keep it that way but\n    # set it to singular here so we can determine plurality in the same way as we do\n    # for `error`.\n    noun = noun.replace(\"warnings\", \"warning\")\n\n    return count, noun + \"s\" if count != 1 else noun"}, "format_session_duration": {"line": 1377, "args": [{"func_args": {"seconds": "14.479352951049805"}, "return_value": "'14.48s'"}], "text": "def format_session_duration(seconds: float) -> str:\n    \"\"\"Format the given seconds in a human readable manner to show in the final summary.\"\"\"\n    if seconds < 60:\n        return f\"{seconds:.2f}s\"\n    else:\n        dt = datetime.timedelta(seconds=int(seconds))\n        return f\"{seconds:.2f}s ({dt})\""}, "_get_auto_indent": {"line": 113, "args": [{"func_args": {"auto_indent_option": "None"}, "return_value": "0"}, {"func_args": {"auto_indent_option": "None"}, "return_value": "0"}]}, "_get_stderr_fileno": {"line": 68, "args": [{"func_args": {}, "return_value": "2"}, {"func_args": {}, "return_value": "2"}]}, "get_terminal_width": {"line": 15, "args": [{"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}, {"func_args": {}, "return_value": "80"}], "text": "def get_terminal_width() -> int:\n    width, _ = shutil.get_terminal_size(fallback=(80, 24))\n\n    # The Windows get_terminal_size may be bogus, let's sanify a bit.\n    if width < 40:\n        width = 80\n\n    return width"}, "is_option": {"line": 135, "args": [{"func_args": {"x": "'overpy'"}, "return_value": "False"}, {"func_args": {"x": "'--cov'"}, "return_value": "True"}, {"func_args": {"x": "'--cov-report=term-missing'"}, "return_value": "True"}, {"func_args": {"x": "'tests/'"}, "return_value": "False"}], "text": "def is_option(x: str) -> bool:\n        return x.startswith(\"-\")"}, "get_file_part_from_node_id": {"line": 138, "args": [{"func_args": {"x": "'overpy'"}, "return_value": "'overpy'"}, {"func_args": {"x": "'tests/'"}, "return_value": "'tests/'"}], "text": "def get_file_part_from_node_id(x: str) -> str:\n        return x.split(\"::\")[0]"}, "parts": {"line": 420, "args": [{"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/README.md'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/README.md', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/base_class.py'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos/python-overpy/tests/base_class.py', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/response'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/response', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/test_exception.py'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/test_exception.py', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/test_json.py'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos/python-overpy/tests/test_json.py', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/test_request.py'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/test_request.py', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/test_result.py'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos/python-overpy/tests/test_result.py', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/test_result_way.py'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/test_result_way.py', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/test_xml.py'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/test_xml.py', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/xml'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/xml', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/area-01.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/json/area-01.json', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/node-01.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/json/node-01.json', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/relation-01.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/json/relation-01.json', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/relation-02.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/json/relation-02.json', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/relation-03.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/json/relation-03.json', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/relation-04.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/json/relation-04.json', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/remark-runtime-error-01.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos/python-overpy/tests/json/remark-runtime-error-01.json', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/remark-runtime-remark-01.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/json/remark-runtime-remark-01.json', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/remark-unknown-01.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos/python-overpy/tests/json/remark-unknown-01.json', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/result-expand-01.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/json/result-expand-01.json', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/result-expand-02.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos/python-overpy/tests/json/result-expand-02.json', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/result-way-01.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/json/result-way-01.json', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/result-way-02.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/json/result-way-02.json', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/result-way-03.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos/python-overpy/tests/json/result-way-03.json', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/way-01.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/json/way-01.json', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/way-02.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/json/way-02.json', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/way-03.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/json/way-03.json', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/json/way-04.json'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/json', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/json/way-04.json', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/response/bad-request-encoding.html'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/response', '/usr/app', '/usr/app/src/test_repos/python-overpy/tests/response/bad-request-encoding.html', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/response/bad-request.html'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/response', '/usr/app/src/test_repos/python-overpy/tests/response/bad-request.html', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/xml/area-01.xml'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/xml', '/usr/app/src/test_repos/python-overpy/tests/xml/area-01.xml', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/xml/node-01.xml'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/xml', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/xml/node-01.xml', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/xml/relation-01.xml'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/xml', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos/python-overpy/tests/xml/relation-01.xml', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/xml/relation-02.xml'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy/tests/xml/relation-02.xml', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/xml', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/xml/relation-03.xml'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/xml', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/xml/relation-03.xml', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/xml/relation-04.xml'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/xml', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/xml/relation-04.xml', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/xml/remark-runtime-error-01.xml'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/xml', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/xml/remark-runtime-error-01.xml', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/xml/remark-runtime-remark-01.xml'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/xml', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/xml/remark-runtime-remark-01.xml', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/xml/remark-unknown-01.xml'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/xml', '/usr/app/src/test_repos/python-overpy/tests/xml/remark-unknown-01.xml', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/xml/way-01.xml'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/xml', '/usr/app/src', '/usr/app/src/test_repos/python-overpy/tests/xml/way-01.xml', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/xml/way-02.xml'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/xml', '/usr/app/src/test_repos/python-overpy/tests/xml/way-02.xml', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/xml/way-03.xml'"}, "return_value": "{'/usr/app/src/test_repos/python-overpy/tests/xml/way-03.xml', '/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/xml', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos'}"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/tests/xml/way-04.xml'"}, "return_value": "{'/', '/usr/app/src/test_repos/python-overpy/tests', '/usr/app/src/test_repos/python-overpy', '/usr', '/usr/app/src/test_repos/python-overpy/tests/xml', '/usr/app/src/test_repos/python-overpy/tests/xml/way-04.xml', '/usr/app/src', '/usr/app', '/usr/app/src/test_repos'}"}], "text": "def parts(s: str) -> Set[str]:\n    parts = s.split(sep)\n    return {sep.join(parts[: i + 1]) or sep for i in range(len(parts))}"}, "_is_same": {"line": 558, "args": [{"func_args": {"f1": "'/usr/app/src/test_repos/python-overpy/tests/base_class.py'", "f2": "'/usr/app/src/test_repos/python-overpy/tests/base_class.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/python-overpy/tests/test_exception.py'", "f2": "'/usr/app/src/test_repos/python-overpy/tests/test_exception.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/python-overpy/tests/test_json.py'", "f2": "'/usr/app/src/test_repos/python-overpy/tests/test_json.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/python-overpy/tests/test_request.py'", "f2": "'/usr/app/src/test_repos/python-overpy/tests/test_request.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/python-overpy/tests/test_result.py'", "f2": "'/usr/app/src/test_repos/python-overpy/tests/test_result.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/python-overpy/tests/test_result_way.py'", "f2": "'/usr/app/src/test_repos/python-overpy/tests/test_result_way.py'"}, "return_value": "True"}, {"func_args": {"f1": "'/usr/app/src/test_repos/python-overpy/tests/test_xml.py'", "f2": "'/usr/app/src/test_repos/python-overpy/tests/test_xml.py'"}, "return_value": "True"}], "text": "def _is_same(f1: str, f2: str) -> bool:\n        return os.path.samefile(f1, f2)"}, "iscommentline": {"line": 162, "args": [{"func_args": {"line": "'[tox]\\n'"}, "return_value": "False"}, {"func_args": {"line": "'envlist = py36,py37,py38,py39,pypy3\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\n'"}, "return_value": "True"}, {"func_args": {"line": "'[testenv]\\n'"}, "return_value": "False"}, {"func_args": {"line": "'deps = \\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tpytest\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tpytest-cov\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tviztracer \\n'"}, "return_value": "False"}, {"func_args": {"line": "'commands = viztracer --ignore_frozen --log_func_args --log_func_retval -o result0.json -- pytest --cov overpy --cov-report=term-missing -v tests/\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\n'"}, "return_value": "True"}, {"func_args": {"line": "'[gh-actions]\\n'"}, "return_value": "False"}, {"func_args": {"line": "'python = \\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\t3.6: py36\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\t3.7: py37\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\t3.8: py38\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\t3.9: py39\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\tpypy3: pypy3\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\n'"}, "return_value": "True"}, {"func_args": {"line": "'[metadata]\\n'"}, "return_value": "False"}, {"func_args": {"line": "'license-file = LICENSE\\n'"}, "return_value": "False"}, {"func_args": {"line": "'long_description = file: README.rst\\n'"}, "return_value": "False"}, {"func_args": {"line": "'long_description_content_type = text/x-rst\\n'"}, "return_value": "False"}, {"func_args": {"line": "'classifiers =\\n'"}, "return_value": "False"}, {"func_args": {"line": "'    Development Status :: 4 - Beta\\n'"}, "return_value": "False"}, {"func_args": {"line": "'    License :: OSI Approved :: MIT License\\n'"}, "return_value": "False"}, {"func_args": {"line": "'    Operating System :: OS Independent\\n'"}, "return_value": "False"}, {"func_args": {"line": "'    Programming Language :: Python\\n'"}, "return_value": "False"}, {"func_args": {"line": "'    Programming Language :: Python :: 3\\n'"}, "return_value": "False"}, {"func_args": {"line": "'    Programming Language :: Python :: 3.6\\n'"}, "return_value": "False"}, {"func_args": {"line": "'    Programming Language :: Python :: 3.7\\n'"}, "return_value": "False"}, {"func_args": {"line": "'    Programming Language :: Python :: 3.8\\n'"}, "return_value": "False"}, {"func_args": {"line": "'    Programming Language :: Python :: 3.9\\n'"}, "return_value": "False"}, {"func_args": {"line": "'    Programming Language :: Python :: Implementation :: CPython\\n'"}, "return_value": "False"}, {"func_args": {"line": "'    Programming Language :: Python :: Implementation :: PyPy\\n'"}, "return_value": "False"}, {"func_args": {"line": "'project_urls =\\n'"}, "return_value": "False"}, {"func_args": {"line": "'    Documentation = https://python-overpy.readthedocs.io/\\n'"}, "return_value": "False"}, {"func_args": {"line": "'    Source = https://github.com/DinoTools/python-overpy\\n'"}, "return_value": "False"}, {"func_args": {"line": "'    Issue Tracker = https://github.com/DinoTools/python-overpy/issues\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\n'"}, "return_value": "True"}, {"func_args": {"line": "'[options]\\n'"}, "return_value": "False"}, {"func_args": {"line": "'python_requires = >=3.6\\n'"}, "return_value": "False"}, {"func_args": {"line": "'include_package_data = true\\n'"}, "return_value": "False"}, {"func_args": {"line": "'zip_safe = false\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\n'"}, "return_value": "True"}, {"func_args": {"line": "'[aliases]\\n'"}, "return_value": "False"}, {"func_args": {"line": "'test=pytest\\n'"}, "return_value": "False"}, {"func_args": {"line": "'\\n'"}, "return_value": "True"}, {"func_args": {"line": "'[tool:pytest]\\n'"}, "return_value": "False"}, {"func_args": {"line": "'python_files = tests/*.py\\n'"}, "return_value": "False"}], "text": "def iscommentline(line):\n    c = line.lstrip()[:1]\n    return c in COMMENTCHARS"}, "validate_report": {"line": 30, "args": [{"func_args": {"arg": "'term-missing'"}, "return_value": "('term-missing', None)"}, {"func_args": {"arg": "'term-missing'"}, "return_value": "('term-missing', None)"}], "text": "def validate_report(arg):\n    file_choices = ['annotate', 'html', 'xml']\n    term_choices = ['term', 'term-missing']\n    term_modifier_choices = ['skip-covered']\n    all_choices = term_choices + file_choices\n    values = arg.split(\":\", 1)\n    report_type = values[0]\n    if report_type not in all_choices + ['']:\n        msg = f'invalid choice: \"{arg}\" (choose from \"{all_choices}\")'\n        raise argparse.ArgumentTypeError(msg)\n\n    if len(values) == 1:\n        return report_type, None\n\n    report_modifier = values[1]\n    if report_type in term_choices and report_modifier in term_modifier_choices:\n        return report_type, report_modifier\n\n    if report_type not in file_choices:\n        msg = 'output specifier not supported for: \"{}\" (choose from \"{}\")'.format(arg,\n                                                                                   file_choices)\n        raise argparse.ArgumentTypeError(msg)\n\n    return values"}, "_prepare_cov_source": {"line": 125, "args": [{"func_args": {"cov_source": "['overpy']"}, "return_value": "['overpy']"}], "text": "def _prepare_cov_source(cov_source):\n    \"\"\"\n    Prepare cov_source so that:\n\n     --cov --cov=foobar is equivalent to --cov (cov_source=None)\n     --cov=foo --cov=bar is equivalent to cov_source=['foo', 'bar']\n    \"\"\"\n    return None if True in cov_source else [path for path in cov_source if path is not True]"}, "bool_or_none": {"line": 174, "args": [{"func_args": {"b": "True"}, "return_value": "True"}, {"func_args": {"b": "True"}, "return_value": "True"}], "text": "def bool_or_none(b):\n    \"\"\"Return bool(b), but preserve None.\"\"\"\n    if b is None:\n        return None\n    else:\n        return bool(b)"}, "tryint": {"line": 370, "args": [{"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/overpy'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy'"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/.tox/py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/.tox/py'"}, {"func_args": {"s": "'38'"}, "return_value": "38"}, {"func_args": {"s": "'/lib/python'"}, "return_value": "'/lib/python'"}, {"func_args": {"s": "'3'"}, "return_value": "3"}, {"func_args": {"s": "'.'"}, "return_value": "'.'"}, {"func_args": {"s": "'8'"}, "return_value": "8"}, {"func_args": {"s": "'/site-packages/coverage'"}, "return_value": "'/site-packages/coverage'"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/.tox/py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/.tox/py'"}, {"func_args": {"s": "'38'"}, "return_value": "38"}, {"func_args": {"s": "'/bin'"}, "return_value": "'/bin'"}, {"func_args": {"s": "'/root/.local/lib/python'"}, "return_value": "'/root/.local/lib/python'"}, {"func_args": {"s": "'3'"}, "return_value": "3"}, {"func_args": {"s": "'.'"}, "return_value": "'.'"}, {"func_args": {"s": "'8'"}, "return_value": "8"}, {"func_args": {"s": "'/site-packages'"}, "return_value": "'/site-packages'"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/.tox/py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/.tox/py'"}, {"func_args": {"s": "'38'"}, "return_value": "38"}, {"func_args": {"s": "'/lib/python'"}, "return_value": "'/lib/python'"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/.tox/py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/.tox/py'"}, {"func_args": {"s": "'38'"}, "return_value": "38"}, {"func_args": {"s": "'/lib/python'"}, "return_value": "'/lib/python'"}, {"func_args": {"s": "'3'"}, "return_value": "3"}, {"func_args": {"s": "'.'"}, "return_value": "'.'"}, {"func_args": {"s": "'8'"}, "return_value": "8"}, {"func_args": {"s": "'/site-packages'"}, "return_value": "'/site-packages'"}, {"func_args": {"s": "'/root/.local/bin'"}, "return_value": "'/root/.local/bin'"}, {"func_args": {"s": "'overpy/__about__.py       '"}, "return_value": "'overpy/__about__.py       '"}, {"func_args": {"s": "'9'"}, "return_value": "9"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'   '"}, "return_value": "'   '"}, {"func_args": {"s": "'100'"}, "return_value": "100"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'overpy/__init__.py      '"}, "return_value": "'overpy/__init__.py      '"}, {"func_args": {"s": "'745'"}, "return_value": "745"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'32'"}, "return_value": "32"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'96'"}, "return_value": "96"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'79'"}, "return_value": "79"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'413'"}, "return_value": "413"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'421'"}, "return_value": "421"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'665'"}, "return_value": "665"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'675'"}, "return_value": "675"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'696'"}, "return_value": "696"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'709'"}, "return_value": "709"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'723'"}, "return_value": "723"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'740'"}, "return_value": "740"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'751'"}, "return_value": "751"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'765'"}, "return_value": "765"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'796'"}, "return_value": "796"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'913'"}, "return_value": "913"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1100'"}, "return_value": "1100"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1270'"}, "return_value": "1270"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1325'"}, "return_value": "1325"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1355'"}, "return_value": "1355"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1365'"}, "return_value": "1365"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1374'"}, "return_value": "1374"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1381'"}, "return_value": "1381"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1384'"}, "return_value": "1384"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1391'"}, "return_value": "1391"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1394'"}, "return_value": "1394"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1427'"}, "return_value": "1427"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1428'"}, "return_value": "1428"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1441'"}, "return_value": "1441"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1442'"}, "return_value": "1442"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1467'"}, "return_value": "1467"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1468'"}, "return_value": "1468"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1566'"}, "return_value": "1566"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'1567'"}, "return_value": "1567"}, {"func_args": {"s": "', '"}, "return_value": "', '"}, {"func_args": {"s": "'1620'"}, "return_value": "1620"}, {"func_args": {"s": "''"}, "return_value": "''"}, {"func_args": {"s": "'overpy/exception.py      '"}, "return_value": "'overpy/exception.py      '"}, {"func_args": {"s": "'63'"}, "return_value": "63"}, {"func_args": {"s": "'      '"}, "return_value": "'      '"}, {"func_args": {"s": "'1'"}, "return_value": "1"}, {"func_args": {"s": "'    '"}, "return_value": "'    '"}, {"func_args": {"s": "'98'"}, "return_value": "98"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'49'"}, "return_value": "49"}, {"func_args": {"s": "''"}, "return_value": "''"}, {"func_args": {"s": "'overpy/helper.py         '"}, "return_value": "'overpy/helper.py         '"}, {"func_args": {"s": "'15'"}, "return_value": "15"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'15'"}, "return_value": "15"}, {"func_args": {"s": "'     '"}, "return_value": "'     '"}, {"func_args": {"s": "'0'"}, "return_value": "0"}, {"func_args": {"s": "'%   '"}, "return_value": "'%   '"}, {"func_args": {"s": "'1'"}, "return_value": "1"}, {"func_args": {"s": "'-'"}, "return_value": "'-'"}, {"func_args": {"s": "'72'"}, "return_value": "72"}, {"func_args": {"s": "''"}, "return_value": "''"}], "text": "def tryint(s):\n        \"\"\"If `s` is a number, return an int, else `s` unchanged.\"\"\"\n        try:\n            return int(s)\n        except ValueError:\n            return s"}, "human_key": {"line": 366, "args": [{"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/overpy'"}, "return_value": "['/usr/app/src/test_repos/python-overpy/overpy']"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/coverage'"}, "return_value": "['/usr/app/src/test_repos/python-overpy/.tox/py', 38, '/lib/python', 3, '.', 8, '/site-packages/coverage']"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/.tox/py38/bin'"}, "return_value": "['/usr/app/src/test_repos/python-overpy/.tox/py', 38, '/bin']"}, {"func_args": {"s": "'/root/.local/lib/python3.8/site-packages'"}, "return_value": "['/root/.local/lib/python', 3, '.', 8, '/site-packages']"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python'"}, "return_value": "['/usr/app/src/test_repos/python-overpy/.tox/py', 38, '/lib/python']"}, {"func_args": {"s": "'/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages'"}, "return_value": "['/usr/app/src/test_repos/python-overpy/.tox/py', 38, '/lib/python', 3, '.', 8, '/site-packages']"}, {"func_args": {"s": "'/root/.local/bin'"}, "return_value": "['/root/.local/bin']"}, {"func_args": {"s": "'overpy/__about__.py       9      0   100%   '"}, "return_value": "['overpy/__about__.py       ', 9, '      ', 0, '   ', 100, '%   ']"}, {"func_args": {"s": "'overpy/__init__.py      745     32    96%   79, 413, 421, 665, 675, 696, 709, 723, 740, 751, 765, 796, 913, 1100, 1270, 1325, 1355, 1365, 1374, 1381, 1384, 1391, 1394, 1427-1428, 1441-1442, 1467-1468, 1566-1567, 1620'"}, "return_value": "['overpy/__init__.py      ', 745, '     ', 32, '    ', 96, '%   ', 79, ', ', 413, ', ', 421, ', ', 665, ', ', 675, ', ', 696, ', ', 709, ', ', 723, ', ', 740, ', ', 751, ', ', 765, ', ', 796, ', ', 913, ', ', 1100, ', ', 1270, ', ', 1325, ', ', 1355, ', ', 1365, ', ', 1374, ', ', 1381, ', ', 1384, ', ', 1391, ', ', 1394, ', ', 1427, '-', 1428, ', ', 1441, '-', 1442, ', ', 1467, '-', 1468, ', ', 1566, '-', 1567, ', ', 1620, '']"}, {"func_args": {"s": "'overpy/exception.py      63      1    98%   49'"}, "return_value": "['overpy/exception.py      ', 63, '      ', 1, '    ', 98, '%   ', 49, '']"}, {"func_args": {"s": "'overpy/helper.py         15     15     0%   1-72'"}, "return_value": "['overpy/helper.py         ', 15, '     ', 15, '     ', 0, '%   ', 1, '-', 72, '']"}], "text": "def human_key(s):\n    \"\"\"Turn a string into a list of string and number chunks.\n        \"z23a\" -> [\"z\", 23, \"a\"]\n    \"\"\"\n    def tryint(s):\n        \"\"\"If `s` is a number, return an int, else `s` unchanged.\"\"\"\n        try:\n            return int(s)\n        except ValueError:\n            return s\n\n    return [tryint(c) for c in re.split(r\"(\\d+)\", s)]"}, "human_sorted": {"line": 379, "args": [{"func_args": {"strings": "['/usr/app/src/test_repos/python-overpy/overpy']"}, "return_value": "['/usr/app/src/test_repos/python-overpy/overpy']"}, {"func_args": {"strings": "{'/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/coverage'}"}, "return_value": "['/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/coverage']"}, {"func_args": {"strings": "{'/usr/app/src/test_repos/python-overpy/.tox/py38/bin', '/root/.local/lib/python3.8/site-packages', '/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python', '/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages', '/root/.local/bin'}"}, "return_value": "['/root/.local/bin', '/root/.local/lib/python3.8/site-packages', '/usr/app/src/test_repos/python-overpy/.tox/py38/bin', '/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python', '/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages']"}], "text": "def human_sorted(strings):\n    \"\"\"Sort the given iterable of strings the way that humans expect.\n\n    Numeric components in the strings are sorted as numbers.\n\n    Returns the sorted list.\n\n    \"\"\"\n    return sorted(strings, key=human_key)"}, "join_regex": {"line": 182, "args": [{"func_args": {"regexes": "['#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)']"}, "return_value": "'(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}, {"func_args": {"regexes": "('(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER))',)"}, "return_value": "'(?:(?:#\\\\s*(pragma|PRAGMA)[:\\\\s]?\\\\s*(no|NO)\\\\s*(cover|COVER)))'"}], "text": "def join_regex(regexes):\n    \"\"\"Combine a list of regexes into one that matches any of them.\"\"\"\n    return \"|\".join(f\"(?:{r})\" for r in regexes)"}, "nice_pair": {"line": 140, "args": [{"func_args": {"pair": "(79, 79)"}, "return_value": "'79'"}, {"func_args": {"pair": "(413, 413)"}, "return_value": "'413'"}, {"func_args": {"pair": "(421, 421)"}, "return_value": "'421'"}, {"func_args": {"pair": "(665, 665)"}, "return_value": "'665'"}, {"func_args": {"pair": "(675, 675)"}, "return_value": "'675'"}, {"func_args": {"pair": "(696, 696)"}, "return_value": "'696'"}, {"func_args": {"pair": "(709, 709)"}, "return_value": "'709'"}, {"func_args": {"pair": "(723, 723)"}, "return_value": "'723'"}, {"func_args": {"pair": "(740, 740)"}, "return_value": "'740'"}, {"func_args": {"pair": "(751, 751)"}, "return_value": "'751'"}, {"func_args": {"pair": "(765, 765)"}, "return_value": "'765'"}, {"func_args": {"pair": "(796, 796)"}, "return_value": "'796'"}, {"func_args": {"pair": "(913, 913)"}, "return_value": "'913'"}, {"func_args": {"pair": "(1100, 1100)"}, "return_value": "'1100'"}, {"func_args": {"pair": "(1270, 1270)"}, "return_value": "'1270'"}, {"func_args": {"pair": "(1325, 1325)"}, "return_value": "'1325'"}, {"func_args": {"pair": "(1355, 1355)"}, "return_value": "'1355'"}, {"func_args": {"pair": "(1365, 1365)"}, "return_value": "'1365'"}, {"func_args": {"pair": "(1374, 1374)"}, "return_value": "'1374'"}, {"func_args": {"pair": "(1381, 1381)"}, "return_value": "'1381'"}, {"func_args": {"pair": "(1384, 1384)"}, "return_value": "'1384'"}, {"func_args": {"pair": "(1391, 1391)"}, "return_value": "'1391'"}, {"func_args": {"pair": "(1394, 1394)"}, "return_value": "'1394'"}, {"func_args": {"pair": "(1427, 1428)"}, "return_value": "'1427-1428'"}, {"func_args": {"pair": "(1441, 1442)"}, "return_value": "'1441-1442'"}, {"func_args": {"pair": "(1467, 1468)"}, "return_value": "'1467-1468'"}, {"func_args": {"pair": "(1566, 1567)"}, "return_value": "'1566-1567'"}, {"func_args": {"pair": "(1620, 1620)"}, "return_value": "'1620'"}, {"func_args": {"pair": "(49, 49)"}, "return_value": "'49'"}, {"func_args": {"pair": "(1, 72)"}, "return_value": "'1-72'"}], "text": "def nice_pair(pair):\n    \"\"\"Make a nice string representation of a pair of numbers.\n\n    If the numbers are equal, just return the number, otherwise return the pair\n    with a dash between them, indicating the range.\n\n    \"\"\"\n    start, end = pair\n    if start == end:\n        return \"%d\" % start\n    else:\n        return \"%d-%d\" % (start, end)"}, "<lambda>": {"line": 394, "args": [{"func_args": {"pair": "('overpy/__about__.py       9      0   100%   ', ('overpy/__about__.py', 9, 0, '100', '', 100.0))"}, "return_value": "(['overpy/__about__.py       ', 9, '      ', 0, '   ', 100, '%   '], ('overpy/__about__.py', 9, 0, '100', '', 100.0))"}, {"func_args": {"pair": "('overpy/__init__.py      745     32    96%   79, 413, 421, 665, 675, 696, 709, 723, 740, 751, 765, 796, 913, 1100, 1270, 1325, 1355, 1365, 1374, 1381, 1384, 1391, 1394, 1427-1428, 1441-1442, 1467-1468, 1566-1567, 1620', ('overpy/__init__.py', 745, 32, '96', '79, 413, 421, 665, 675, 696, 709, 723, 740, 751, 765, 796, 913, 1100, 1270, 1325, 1355, 1365, 1374, 1381, 1384, 1391, 1394, 1427-1428, 1441-1442, 1467-1468, 1566-1567, 1620', 95.70469798657719))"}, "return_value": "(['overpy/__init__.py      ', 745, '     ', 32, '    ', 96, '%   ', 79, ', ', 413, ', ', 421, ', ', 665, ', ', 675, ', ', 696, ', ', 709, ', ', 723, ', ', 740, ', ', 751, ', ', 765, ', ', 796, ', ', 913, ', ', 1100, ', ', 1270, ', ', 1325, ', ', 1355, ', ', 1365, ', ', 1374, ', ', 1381, ', ', 1384, ', ', 1391, ', ', 1394, ', ', 1427, '-', 1428, ', ', 1441, '-', 1442, ', ', 1467, '-', 1468, ', ', 1566, '-', 1567, ', ', 1620, ''], ('overpy/__init__.py', 745, 32, '96', '79, 413, 421, 665, 675, 696, 709, 723, 740, 751, 765, 796, 913, 1100, 1270, 1325, 1355, 1365, 1374, 1381, 1384, 1391, 1394, 1427-1428, 1441-1442, 1467-1468, 1566-1567, 1620', 95.70469798657719))"}, {"func_args": {"pair": "('overpy/exception.py      63      1    98%   49', ('overpy/exception.py', 63, 1, '98', '49', 98.41269841269842))"}, "return_value": "(['overpy/exception.py      ', 63, '      ', 1, '    ', 98, '%   ', 49, ''], ('overpy/exception.py', 63, 1, '98', '49', 98.41269841269842))"}, {"func_args": {"pair": "('overpy/helper.py         15     15     0%   1-72', ('overpy/helper.py', 15, 15, '0', '1-72', 0.0))"}, "return_value": "(['overpy/helper.py         ', 15, '     ', 15, '     ', 0, '%   ', 1, '-', 72, ''], ('overpy/helper.py', 15, 15, '0', '1-72', 0.0))"}]}, "human_sorted_items": {"line": 389, "args": [{"func_args": {"items": "[('overpy/__about__.py       9      0   100%   ', ('overpy/__about__.py', 9, 0, '100', '', 100.0)), ('overpy/__init__.py      745     32    96%   79, 413, 421, 665, 675, 696, 709, 723, 740, 751, 765, 796, 913, 1100, 1270, 1325, 1355, 1365, 1374, 1381, 1384, 1391, 1394, 1427-1428, 1441-1442, 1467-1468, 1566-1567, 1620', ('overpy/__init__.py', 745, 32, '96', '79, 413, 421, 665, 675, 696, 709, 723, 740, 751, 765, 796, 913, 1100, 1270, 1325, 1355, 1365, 1374, 1381, 1384, 1391, 1394, 1427-1428, 1441-1442, 1467-1468, 1566-1567, 1620', 95.70469798657719)), ('overpy/exception.py      63      1    98%   49', ('overpy/exception.py', 63, 1, '98', '49', 98.41269841269842)), ('overpy/helper.py         15     15     0%   1-72', ('overpy/helper.py', 15, 15, '0', '1-72', 0.0))]", "reverse": "False"}, "return_value": "[('overpy/__about__.py       9      0   100%   ', ('overpy/__about__.py', 9, 0, '100', '', 100.0)), ('overpy/__init__.py      745     32    96%   79, 413, 421, 665, 675, 696, 709, 723, 740, 751, 765, 796, 913, 1100, 1270, 1325, 1355, 1365, 1374, 1381, 1384, 1391, 1394, 1427-1428, 1441-1442, 1467-1468, 1566-1567, 1620', ('overpy/__init__.py', 745, 32, '96', '79, 413, 421, 665, 675, 696, 709, 723, 740, 751, 765, 796, 913, 1100, 1270, 1325, 1355, 1365, 1374, 1381, 1384, 1391, 1394, 1427-1428, 1441-1442, 1467-1468, 1566-1567, 1620', 95.70469798657719)), ('overpy/exception.py      63      1    98%   49', ('overpy/exception.py', 63, 1, '98', '49', 98.41269841269842)), ('overpy/helper.py         15     15     0%   1-72', ('overpy/helper.py', 15, 15, '0', '1-72', 0.0))]"}], "text": "def human_sorted_items(items, reverse=False):\n    \"\"\"Sort the (string, value) items the way humans expect.\n\n    Returns the sorted list of items.\n    \"\"\"\n    return sorted(items, key=lambda pair: (human_key(pair[0]), pair[1]), reverse=reverse)"}, "config_files_to_try": {"line": 492, "args": [{"func_args": {"config_file": "'.coveragerc'"}, "return_value": "[('.coveragerc', True, False), ('setup.cfg', False, False), ('tox.ini', False, False), ('pyproject.toml', False, False)]"}, {"func_args": {"config_file": "'.coveragerc'"}, "return_value": "[('.coveragerc', True, False), ('setup.cfg', False, False), ('tox.ini', False, False), ('pyproject.toml', False, False)]"}], "text": "def config_files_to_try(config_file):\n    \"\"\"What config files should we try to read?\n\n    Returns a list of tuples:\n        (filename, is_our_file, was_file_specified)\n    \"\"\"\n\n    # Some API users were specifying \".coveragerc\" to mean the same as\n    # True, so make it so.\n    if config_file == \".coveragerc\":\n        config_file = True\n    specified_file = (config_file is not True)\n    if not specified_file:\n        # No file was specified. Check COVERAGE_RCFILE.\n        config_file = os.environ.get('COVERAGE_RCFILE')\n        if config_file:\n            specified_file = True\n    if not specified_file:\n        # Still no file specified. Default to .coveragerc\n        config_file = \".coveragerc\"\n    files_to_try = [\n        (config_file, True, specified_file),\n        (\"setup.cfg\", False, False),\n        (\"tox.ini\", False, False),\n        (\"pyproject.toml\", False, False),\n    ]\n    return files_to_try"}, "short_stack": {"line": 136, "args": [{"func_args": {"limit": "None", "skip": "0"}, "return_value": "'                      <module> : /usr/app/src/test_repos/python-overpy/.tox/py38/bin/viztracer:8\\n                          main : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/viztracer/main.py:523\\n                           run : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/viztracer/main.py:332\\n                   run_command : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/viztracer/main.py:438\\n                      run_code : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/viztracer/main.py:355\\n                      <module> : /usr/app/src/test_repos/python-overpy/.tox/py38/bin/pytest:8\\n                  console_main : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:185\\n                          main : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:143\\n                _prepareconfig : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:318\\n                      __call__ : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/pluggy/_hooks.py:265\\n                     _hookexec : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/pluggy/_manager.py:80\\n                    _multicall : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/pluggy/_callers.py:39\\n          pytest_cmdline_parse : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:1003\\n                         parse : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:1283\\n                     _preparse : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/_pytest/config/__init__.py:1191\\n                      __call__ : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/pluggy/_hooks.py:265\\n                     _hookexec : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/pluggy/_manager.py:80\\n                    _multicall : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/pluggy/_callers.py:39\\n pytest_load_initial_conftests : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/pytest_cov/plugin.py:149\\n                      __init__ : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/pytest_cov/plugin.py:200\\n                         start : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/pytest_cov/plugin.py:222\\n         ensure_topdir_wrapper : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/pytest_cov/engine.py:44\\n                         start : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/pytest_cov/engine.py:222\\n                         start : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/coverage/control.py:558\\n               _init_for_start : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/coverage/control.py:473\\n                      __init__ : /usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/coverage/collector.py:114'"}], "text": "def short_stack(limit=None, skip=0):\n    \"\"\"Return a string summarizing the call stack.\n\n    The string is multi-line, with one line per stack frame. Each line shows\n    the function name, the file name, and the line number:\n\n        ...\n        start_import_stop : /Users/ned/coverage/trunk/tests/coveragetest.py @95\n        import_local_file : /Users/ned/coverage/trunk/tests/coveragetest.py @81\n        import_local_file : /Users/ned/coverage/trunk/coverage/backward.py @159\n        ...\n\n    `limit` is the number of frames to include, defaulting to all of them.\n\n    `skip` is the number of frames to skip, so that debugging functions can\n    call this and not be included in the result.\n\n    \"\"\"\n    stack = inspect.stack()[limit:skip:-1]\n    return \"\\n\".join(\"%30s : %s:%d\" % (t[3], t[1], t[2]) for t in stack)"}, "actual_path": {"line": 139, "args": [{"func_args": {"path": "'/usr/app/src/test_repos/python-overpy'"}, "return_value": "'/usr/app/src/test_repos/python-overpy'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/inspect.py'"}, "return_value": "'/usr/local/lib/python3.8/inspect.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/os.py'"}, "return_value": "'/usr/local/lib/python3.8/os.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/platform.py'"}, "return_value": "'/usr/local/lib/python3.8/platform.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/re.py'"}, "return_value": "'/usr/local/lib/python3.8/re.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/sysconfig.py'"}, "return_value": "'/usr/local/lib/python3.8/sysconfig.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/traceback.py'"}, "return_value": "'/usr/local/lib/python3.8/traceback.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy'"}, "return_value": "'/usr/app/src/test_repos/python-overpy'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}], "text": "def actual_path(path):\n        \"\"\"The actual path for non-Windows platforms.\"\"\"\n        return path"}, "abs_file": {"line": 144, "args": [{"func_args": {"path": "'.'"}, "return_value": "'/usr/app/src/test_repos/python-overpy'"}, {"func_args": {"path": "'./overpy'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/inspect.py'"}, "return_value": "'/usr/local/lib/python3.8/inspect.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/os.py'"}, "return_value": "'/usr/local/lib/python3.8/os.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/platform.py'"}, "return_value": "'/usr/local/lib/python3.8/platform.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/re.py'"}, "return_value": "'/usr/local/lib/python3.8/re.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/sysconfig.py'"}, "return_value": "'/usr/local/lib/python3.8/sysconfig.py'"}, {"func_args": {"path": "'/usr/local/lib/python3.8/traceback.py'"}, "return_value": "'/usr/local/lib/python3.8/traceback.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, {"func_args": {"path": "'.'"}, "return_value": "'/usr/app/src/test_repos/python-overpy'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, {"func_args": {"path": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}]}, "canonical_filename": {"line": 53, "args": [{"func_args": {"filename": "'overpy'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/inspect.py'"}, "return_value": "'/usr/local/lib/python3.8/inspect.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/os.py'"}, "return_value": "'/usr/local/lib/python3.8/os.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/platform.py'"}, "return_value": "'/usr/local/lib/python3.8/platform.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/re.py'"}, "return_value": "'/usr/local/lib/python3.8/re.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/sysconfig.py'"}, "return_value": "'/usr/local/lib/python3.8/sysconfig.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/traceback.py'"}, "return_value": "'/usr/local/lib/python3.8/traceback.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}]}, "prep_patterns": {"line": 173, "args": [{"func_args": {"patterns": "None"}, "return_value": "[]"}, {"func_args": {"patterns": "None"}, "return_value": "[]"}], "text": "def prep_patterns(patterns):\n    \"\"\"Prepare the file patterns for use in a `FnmatchMatcher`.\n\n    If a pattern starts with a wildcard, it is used as a pattern\n    as-is.  If it does not start with a wildcard, then it is made\n    absolute with the current directory.\n\n    If `patterns` is None, an empty list is returned.\n\n    \"\"\"\n    prepped = []\n    for p in patterns or []:\n        if p.startswith((\"*\", \"?\")):\n            prepped.append(p)\n        else:\n            prepped.append(abs_file(p))\n    return prepped"}, "find_python_files": {"line": 403, "args": [{"func_args": {"dirname": "'/usr/app/src/test_repos/python-overpy/overpy'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/python-overpy/overpy'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/python-overpy/overpy'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/python-overpy/overpy'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, {"func_args": {"dirname": "'/usr/app/src/test_repos/python-overpy/overpy'"}, "return_value": "None"}], "text": "def find_python_files(dirname):\n    \"\"\"Yield all of the importable Python files in `dirname`, recursively.\n\n    To be importable, the files have to be in a directory with a __init__.py,\n    except for `dirname` itself, which isn't required to have one.  The\n    assumption is that `dirname` was specified directly, so the user knows\n    best, but sub-directories are checked for a __init__.py to be sure we only\n    find the importable files.\n\n    \"\"\"\n    for i, (dirpath, dirnames, filenames) in enumerate(os.walk(dirname)):\n        if i > 0 and '__init__.py' not in filenames:\n            # If a directory doesn't have __init__.py, then it isn't\n            # importable and neither are its files\n            del dirnames[:]\n            continue\n        for filename in filenames:\n            # We're only interested in files that look like reasonable Python\n            # files: Must end with .py or .pyw, and must not have certain funny\n            # characters that probably mean they are editor junk.\n            if re.match(r\"^[^.#~!$@%^&*()+=,]+\\.pyw?$\", filename):\n                yield os.path.join(dirpath, filename)"}, "relative_filename": {"line": 39, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, "return_value": "'overpy/helper.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, "return_value": "'overpy/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, "return_value": "'overpy/__about__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, "return_value": "'overpy/exception.py'"}]}, "filename_suffix": {"line": 1006, "args": [{"func_args": {"suffix": "None"}, "return_value": "None"}, {"func_args": {"suffix": "True"}, "return_value": "'cae2a1e14906.80484.440709'"}, {"func_args": {"suffix": "None"}, "return_value": "None"}, {"func_args": {"suffix": "None"}, "return_value": "None"}], "text": "def filename_suffix(suffix):\n    \"\"\"Compute a filename suffix for a data file.\n\n    If `suffix` is a string or None, simply return it. If `suffix` is True,\n    then build a suffix incorporating the hostname, process id, and a random\n    number.\n\n    Returns a string or None.\n\n    \"\"\"\n    if suffix is True:\n        # If data_suffix was a simple true value, then make a suffix with\n        # plenty of distinguishing information.  We do this here in\n        # `save()` at the last minute so that the pid will be correct even\n        # if the process forks.\n        dice = random.Random(os.urandom(8)).randint(0, 999999)\n        suffix = \"%s.%s.%06d\" % (socket.gethostname(), os.getpid(), dice)\n    return suffix"}, "source_for_file": {"line": 97, "args": [{"func_args": {"filename": "'/usr/local/lib/python3.8/inspect.py'"}, "return_value": "'/usr/local/lib/python3.8/inspect.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/os.py'"}, "return_value": "'/usr/local/lib/python3.8/os.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/platform.py'"}, "return_value": "'/usr/local/lib/python3.8/platform.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/re.py'"}, "return_value": "'/usr/local/lib/python3.8/re.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/sysconfig.py'"}, "return_value": "'/usr/local/lib/python3.8/sysconfig.py'"}, {"func_args": {"filename": "'/usr/local/lib/python3.8/traceback.py'"}, "return_value": "'/usr/local/lib/python3.8/traceback.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/.tox/py38/lib/python3.8/site-packages/coverage/inorout.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, "return_value": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}], "text": "def source_for_file(filename):\n    \"\"\"Return the source filename for `filename`.\n\n    Given a file name being traced, return the best guess as to the source\n    file to attribute it to.\n\n    \"\"\"\n    if filename.endswith(\".py\"):\n        # .py files are themselves source files.\n        return filename\n\n    elif filename.endswith((\".pyc\", \".pyo\")):\n        # Bytecode files probably have source files near them.\n        py_filename = filename[:-1]\n        if os.path.exists(py_filename):\n            # Found a .py file, use that.\n            return py_filename\n        if env.WINDOWS:\n            # On Windows, it could be a .pyw file.\n            pyw_filename = py_filename + \"w\"\n            if os.path.exists(pyw_filename):\n                return pyw_filename\n        # Didn't find source, but it's probably the .py file we want.\n        return py_filename\n\n    elif filename.endswith(\"$py.class\"):\n        # Jython is easy to guess.\n        return filename[:-9] + \".py\"\n\n    # No idea, just use the file name as-is.\n    return filename"}, "read_python_source": {"line": 20, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, "return_value": "b'__all__ = [\\n    \"__author__\",\\n    \"__copyright__\",\\n    \"__email__\",\\n    \"__license__\",\\n    \"__summary__\",\\n    \"__title__\",\\n    \"__uri__\",\\n    \"__version__\",\\n]\\n\\n__title__ = \"overpy\"\\n__summary__ = \"Python Wrapper to access the OpenStreepMap Overpass API\"\\n__uri__ = \"https://github.com/DinoTools/python-overpy\"\\n\\n__version__ = \"0.6\"\\n\\n__author__ = \"PhiBo (DinoTools)\"\\n__email__ = \"\"\\n\\n__license__ = \"MIT\"\\n__copyright__ = \"Copyright 2014-2021 %s\" % __author__\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, "return_value": "b'from collections import OrderedDict\\nfrom datetime import datetime\\nfrom decimal import Decimal\\nfrom urllib.request import urlopen\\nfrom urllib.error import HTTPError\\nfrom xml.sax import handler, make_parser\\nimport xml.etree.ElementTree\\nimport json\\nimport re\\nimport time\\nfrom typing import Any, Callable, ClassVar, Dict, List, NoReturn, Optional, Tuple, Type, TypeVar, Union\\n\\nfrom overpy import exception\\n# Ignore flake8 F401 warning for unused vars\\nfrom overpy.__about__ import (  # noqa: F401\\n    __author__, __copyright__, __email__, __license__, __summary__, __title__,\\n    __uri__, __version__\\n)\\n\\nElementTypeVar = TypeVar(\"ElementTypeVar\", bound=\"Element\")\\n\\nXML_PARSER_DOM = 1\\nXML_PARSER_SAX = 2\\n\\n# Try to convert some common attributes\\n# http://wiki.openstreetmap.org/wiki/Elements#Common_attributes\\nGLOBAL_ATTRIBUTE_MODIFIERS: Dict[str, Callable] = {\\n    \"changeset\": int,\\n    \"timestamp\": lambda ts: datetime.strptime(ts, \"%Y-%m-%dT%H:%M:%SZ\"),\\n    \"uid\": int,\\n    \"version\": int,\\n    \"visible\": lambda v: v.lower() == \"true\"\\n}\\n\\n\\ndef is_valid_type(\\n        element: Union[\"Area\", \"Node\", \"Relation\", \"Way\"],\\n        cls: Type[Union[\"Area\", \"Element\", \"Node\", \"Relation\", \"Way\"]]) -> bool:\\n    \"\"\"\\n    Test if an element is of a given type.\\n\\n    :param element: The element instance to test\\n    :param cls: The element class to test\\n    :return: False or True\\n    \"\"\"\\n    return isinstance(element, cls) and element.id is not None\\n\\n\\nclass Overpass:\\n    \"\"\"\\n    Class to access the Overpass API\\n\\n    :cvar default_max_retry_count: Global max number of retries (Default: 0)\\n    :cvar default_read_chunk_size: Max size of each chunk read from the server response\\n    :cvar default_retry_timeout: Global time to wait between tries (Default: 1.0s)\\n    :cvar default_url: Default URL of the Overpass server\\n    \"\"\"\\n    default_max_retry_count: ClassVar[int] = 0\\n    default_read_chunk_size: ClassVar[int] = 4096\\n    default_retry_timeout: ClassVar[float] = 1.0\\n    default_url: ClassVar[str] = \"http://overpass-api.de/api/interpreter\"\\n\\n    def __init__(\\n            self,\\n            read_chunk_size: Optional[int] = None,\\n            url: Optional[str] = None,\\n            xml_parser: int = XML_PARSER_SAX,\\n            max_retry_count: int = None,\\n            retry_timeout: float = None):\\n        \"\"\"\\n        :param read_chunk_size: Max size of each chunk read from the server response\\n        :param url: Optional URL of the Overpass server. Defaults to http://overpass-api.de/api/interpreter\\n        :param xml_parser: The xml parser to use\\n        :param max_retry_count: Max number of retries (Default: default_max_retry_count)\\n        :param retry_timeout: Time to wait between tries (Default: default_retry_timeout)\\n        \"\"\"\\n        self.url = self.default_url\\n        if url is not None:\\n            self.url = url\\n\\n        self._regex_extract_error_msg = re.compile(br\"\\\\<p\\\\>(?P<msg>\\\\<strong\\\\s.*?)\\\\</p\\\\>\")\\n        self._regex_remove_tag = re.compile(b\"<[^>]*?>\")\\n        if read_chunk_size is None:\\n            read_chunk_size = self.default_read_chunk_size\\n        self.read_chunk_size = read_chunk_size\\n\\n        if max_retry_count is None:\\n            max_retry_count = self.default_max_retry_count\\n        self.max_retry_count = max_retry_count\\n\\n        if retry_timeout is None:\\n            retry_timeout = self.default_retry_timeout\\n        self.retry_timeout = retry_timeout\\n\\n        self.xml_parser = xml_parser\\n\\n    @staticmethod\\n    def _handle_remark_msg(msg: str) -> NoReturn:\\n        \"\"\"\\n        Try to parse the message provided with the remark tag or element.\\n\\n        :param msg: The message\\n        :raises overpy.exception.OverpassRuntimeError: If message starts with \\'runtime error:\\'\\n        :raises overpy.exception.OverpassRuntimeRemark: If message starts with \\'runtime remark:\\'\\n        :raises overpy.exception.OverpassUnknownError: If we are unable to identify the error\\n        \"\"\"\\n        msg = msg.strip()\\n        if msg.startswith(\"runtime error:\"):\\n            raise exception.OverpassRuntimeError(msg=msg)\\n        elif msg.startswith(\"runtime remark:\"):\\n            raise exception.OverpassRuntimeRemark(msg=msg)\\n        raise exception.OverpassUnknownError(msg=msg)\\n\\n    def query(self, query: Union[bytes, str]) -> \"Result\":\\n        \"\"\"\\n        Query the Overpass API\\n\\n        :param query: The query string in Overpass QL\\n        :return: The parsed result\\n        \"\"\"\\n        if not isinstance(query, bytes):\\n            query = query.encode(\"utf-8\")\\n\\n        retry_num: int = 0\\n        retry_exceptions: List[exception.OverPyException] = []\\n        do_retry: bool = True if self.max_retry_count > 0 else False\\n        while retry_num <= self.max_retry_count:\\n            if retry_num > 0:\\n                time.sleep(self.retry_timeout)\\n            retry_num += 1\\n            try:\\n                f = urlopen(self.url, query)\\n            except HTTPError as e:\\n                f = e\\n\\n            response = f.read(self.read_chunk_size)\\n            while True:\\n                data = f.read(self.read_chunk_size)\\n                if len(data) == 0:\\n                    break\\n                response = response + data\\n            f.close()\\n\\n            current_exception: exception.OverPyException\\n            if f.code == 200:\\n                content_type = f.getheader(\"Content-Type\")\\n\\n                if content_type == \"application/json\":\\n                    return self.parse_json(response)\\n\\n                if content_type == \"application/osm3s+xml\":\\n                    return self.parse_xml(response)\\n\\n                current_exception = exception.OverpassUnknownContentType(content_type)\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            if f.code == 400:\\n                msgs: List[str] = []\\n                for msg_raw in self._regex_extract_error_msg.finditer(response):\\n                    msg_clean_bytes = self._regex_remove_tag.sub(b\"\", msg_raw.group(\"msg\"))\\n                    try:\\n                        msg = msg_clean_bytes.decode(\"utf-8\")\\n                    except UnicodeDecodeError:\\n                        msg = repr(msg_clean_bytes)\\n                    msgs.append(msg)\\n\\n                current_exception = exception.OverpassBadRequest(\\n                    query,\\n                    msgs=msgs\\n                )\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            if f.code == 429:\\n                current_exception = exception.OverpassTooManyRequests()\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            if f.code == 504:\\n                current_exception = exception.OverpassGatewayTimeout()\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            current_exception = exception.OverpassUnknownHTTPStatusCode(f.code)\\n            if not do_retry:\\n                raise current_exception\\n            retry_exceptions.append(current_exception)\\n            continue\\n\\n        raise exception.MaxRetriesReached(retry_count=retry_num, exceptions=retry_exceptions)\\n\\n    def parse_json(self, data: Union[bytes, str], encoding: str = \"utf-8\") -> \"Result\":\\n        \"\"\"\\n        Parse raw response from Overpass service.\\n\\n        :param data: Raw JSON Data\\n        :param encoding: Encoding to decode byte string\\n        :return: Result object\\n        \"\"\"\\n        if isinstance(data, bytes):\\n            data = data.decode(encoding)\\n        data_parsed: dict = json.loads(data, parse_float=Decimal)\\n        if \"remark\" in data_parsed:\\n            self._handle_remark_msg(msg=data_parsed.get(\"remark\"))\\n        return Result.from_json(data_parsed, api=self)\\n\\n    def parse_xml(self, data: Union[bytes, str], encoding: str = \"utf-8\", parser: Optional[int] = None):\\n        \"\"\"\\n\\n        :param data: Raw XML Data\\n        :param encoding: Encoding to decode byte string\\n        :param parser: The XML parser to use\\n        :return: Result object\\n        \"\"\"\\n        if parser is None:\\n            parser = self.xml_parser\\n\\n        if isinstance(data, bytes):\\n            data = data.decode(encoding)\\n\\n        m = re.compile(\"<remark>(?P<msg>[^<>]*)</remark>\").search(data)\\n        if m:\\n            self._handle_remark_msg(m.group(\"msg\"))\\n\\n        return Result.from_xml(data, api=self, parser=parser)\\n\\n\\nclass Result:\\n    \"\"\"\\n    Class to handle the result.\\n    \"\"\"\\n\\n    def __init__(\\n            self,\\n            elements: Optional[List[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]] = None,\\n            api: Optional[Overpass] = None):\\n        \"\"\"\\n\\n        :param elements: List of elements to initialize the result with\\n        :param api: The API object to load additional resources and elements\\n        \"\"\"\\n        if elements is None:\\n            elements = []\\n        self._areas: Dict[int, Union[\"Area\", \"Node\", \"Relation\", \"Way\"]] = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Area)\\n        )\\n        self._nodes = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Node)\\n        )\\n        self._ways = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Way)\\n        )\\n        self._relations = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Relation)\\n        )\\n        self._class_collection_map: Dict[Any, Any] = {\\n            Node: self._nodes,\\n            Way: self._ways,\\n            Relation: self._relations,\\n            Area: self._areas\\n        }\\n        self.api = api\\n\\n    def expand(self, other: \"Result\"):\\n        \"\"\"\\n        Add all elements from an other result to the list of elements of this result object.\\n\\n        It is used by the auto resolve feature.\\n\\n        :param other: Expand the result with the elements from this result.\\n        :raises ValueError: If provided parameter is not instance of :class:`overpy.Result`\\n        \"\"\"\\n        if not isinstance(other, Result):\\n            raise ValueError(\"Provided argument has to be instance of overpy:Result()\")\\n\\n        other_collection_map: Dict[Type[\"Element\"], List[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]] = {\\n            Area: other.areas,\\n            Node: other.nodes,\\n            Relation: other.relations,\\n            Way: other.ways\\n        }\\n        for element_type, own_collection in self._class_collection_map.items():\\n            for element in other_collection_map[element_type]:\\n                if is_valid_type(element, element_type) and element.id not in own_collection:\\n                    own_collection[element.id] = element\\n\\n    def append(self, element: Union[\"Area\", \"Node\", \"Relation\", \"Way\"]):\\n        \"\"\"\\n        Append a new element to the result.\\n\\n        :param element: The element to append\\n        \"\"\"\\n        if is_valid_type(element, Element):\\n            self._class_collection_map[element.__class__].setdefault(element.id, element)\\n\\n    def get_elements(\\n            self,\\n            filter_cls: Type[ElementTypeVar],\\n            elem_id: Optional[int] = None) -> List[ElementTypeVar]:\\n        \"\"\"\\n        Get a list of elements from the result and filter the element type by a class.\\n\\n        :param filter_cls:\\n        :param elem_id: ID of the object\\n        :return: List of available elements\\n        \"\"\"\\n        result: List[ElementTypeVar] = []\\n        if elem_id is not None:\\n            try:\\n                result = [self._class_collection_map[filter_cls][elem_id]]\\n            except KeyError:\\n                result = []\\n        else:\\n            for e in self._class_collection_map[filter_cls].values():\\n                result.append(e)\\n        return result\\n\\n    def get_ids(\\n            self,\\n            filter_cls: Type[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]) -> List[int]:\\n        \"\"\"\\n        Get all Element IDs\\n\\n        :param filter_cls: Only IDs of elements with this type\\n        :return: List of IDs\\n        \"\"\"\\n        return list(self._class_collection_map[filter_cls].keys())\\n\\n    def get_node_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Node)\\n\\n    def get_way_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Way)\\n\\n    def get_relation_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Relation)\\n\\n    def get_area_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Area)\\n\\n    @classmethod\\n    def from_json(cls, data: dict, api: Optional[Overpass] = None) -> \"Result\":\\n        \"\"\"\\n        Create a new instance and load data from json object.\\n\\n        :param data: JSON data returned by the Overpass API\\n        :param api:\\n        :return: New instance of Result object\\n        \"\"\"\\n        result = cls(api=api)\\n        elem_cls: Type[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]\\n        for elem_cls in [Node, Way, Relation, Area]:\\n            for element in data.get(\"elements\", []):\\n                e_type = element.get(\"type\")\\n                if hasattr(e_type, \"lower\") and e_type.lower() == elem_cls._type_value:\\n                    result.append(elem_cls.from_json(element, result=result))\\n\\n        return result\\n\\n    @classmethod\\n    def from_xml(\\n            cls,\\n            data: Union[str, xml.etree.ElementTree.Element],\\n            api: Optional[Overpass] = None,\\n            parser: Optional[int] = None) -> \"Result\":\\n        \"\"\"\\n        Create a new instance and load data from xml data or object.\\n\\n        .. note::\\n            If parser is set to None, the functions tries to find the best parse.\\n            By default the SAX parser is chosen if a string is provided as data.\\n            The parser is set to DOM if an xml.etree.ElementTree.Element is provided as data value.\\n\\n        :param data: Root element\\n        :param api: The instance to query additional information if required.\\n        :param parser: Specify the parser to use(DOM or SAX)(Default: None = autodetect, defaults to SAX)\\n        :return: New instance of Result object\\n        \"\"\"\\n        if parser is None:\\n            if isinstance(data, str):\\n                parser = XML_PARSER_SAX\\n            else:\\n                parser = XML_PARSER_DOM\\n\\n        result = cls(api=api)\\n        if parser == XML_PARSER_DOM:\\n            import xml.etree.ElementTree as ET\\n            if isinstance(data, str):\\n                root = ET.fromstring(data)\\n            elif isinstance(data, ET.Element):\\n                root = data\\n            else:\\n                raise exception.OverPyException(\"Unable to detect data type.\")\\n\\n            elem_cls: Type[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]\\n            for elem_cls in [Node, Way, Relation, Area]:\\n                for child in root:\\n                    if child.tag.lower() == elem_cls._type_value:\\n                        result.append(elem_cls.from_xml(child, result=result))\\n\\n        elif parser == XML_PARSER_SAX:\\n            from io import StringIO\\n            if not isinstance(data, str):\\n                raise ValueError(\"data must be of type str if using the SAX parser\")\\n            source = StringIO(data)\\n            sax_handler = OSMSAXHandler(result)\\n            sax_parser = make_parser()\\n            sax_parser.setContentHandler(sax_handler)\\n            sax_parser.parse(source)\\n        else:\\n            # ToDo: better exception\\n            raise Exception(\"Unknown XML parser\")\\n        return result\\n\\n    def get_area(self, area_id: int, resolve_missing: bool = False) -> \"Area\":\\n        \"\"\"\\n        Get an area by its ID.\\n\\n        :param area_id: The area ID\\n        :param resolve_missing: Query the Overpass API if the area is missing in the result set.\\n        :return: The area\\n        :raises overpy.exception.DataIncomplete: The requested way is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and the area can\\'t be resolved.\\n        \"\"\"\\n        areas = self.get_areas(area_id=area_id)\\n        if len(areas) == 0:\\n            if resolve_missing is False:\\n                raise exception.DataIncomplete(\"Resolve missing area is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"area({area_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                area_id=area_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            areas = self.get_areas(area_id=area_id)\\n\\n        if len(areas) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve requested areas\")\\n\\n        return areas[0]\\n\\n    def get_areas(self, area_id: Optional[int] = None) -> List[\"Area\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Area\\n\\n        :param area_id: The Id of the area\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Area, elem_id=area_id)\\n\\n    def get_node(self, node_id: int, resolve_missing: bool = False) -> \"Node\":\\n        \"\"\"\\n        Get a node by its ID.\\n\\n        :param node_id: The node ID\\n        :param resolve_missing: Query the Overpass API if the node is missing in the result set.\\n        :return: The node\\n        :raises overpy.exception.DataIncomplete: At least one referenced node is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and at least one node can\\'t be resolved.\\n        \"\"\"\\n        nodes = self.get_nodes(node_id=node_id)\\n        if len(nodes) == 0:\\n            if not resolve_missing:\\n                raise exception.DataIncomplete(\"Resolve missing nodes is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"node({node_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                node_id=node_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            nodes = self.get_nodes(node_id=node_id)\\n\\n        if len(nodes) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve all nodes\")\\n\\n        return nodes[0]\\n\\n    def get_nodes(self, node_id: Optional[int] = None) -> List[\"Node\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Node()\\n\\n        :param node_id: The Id of the node\\n        :type node_id: Integer\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Node, elem_id=node_id)\\n\\n    def get_relation(self, rel_id: int, resolve_missing: bool = False) -> \"Relation\":\\n        \"\"\"\\n        Get a relation by its ID.\\n\\n        :param rel_id: The relation ID\\n        :param resolve_missing: Query the Overpass API if the relation is missing in the result set.\\n        :return: The relation\\n        :raises overpy.exception.DataIncomplete: The requested relation is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and the relation can\\'t be resolved.\\n        \"\"\"\\n        relations = self.get_relations(rel_id=rel_id)\\n        if len(relations) == 0:\\n            if resolve_missing is False:\\n                raise exception.DataIncomplete(\"Resolve missing relations is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"relation({relation_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                relation_id=rel_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            relations = self.get_relations(rel_id=rel_id)\\n\\n        if len(relations) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve requested reference\")\\n\\n        return relations[0]\\n\\n    def get_relations(self, rel_id: int = None) -> List[\"Relation\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Relation\\n\\n        :param rel_id: Id of the relation\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Relation, elem_id=rel_id)\\n\\n    def get_way(self, way_id: int, resolve_missing: bool = False) -> \"Way\":\\n        \"\"\"\\n        Get a way by its ID.\\n\\n        :param way_id: The way ID\\n        :param resolve_missing: Query the Overpass API if the way is missing in the result set.\\n        :return: The way\\n        :raises overpy.exception.DataIncomplete: The requested way is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and the way can\\'t be resolved.\\n        \"\"\"\\n        ways = self.get_ways(way_id=way_id)\\n        if len(ways) == 0:\\n            if resolve_missing is False:\\n                raise exception.DataIncomplete(\"Resolve missing way is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"way({way_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                way_id=way_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            ways = self.get_ways(way_id=way_id)\\n\\n        if len(ways) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve requested way\")\\n\\n        return ways[0]\\n\\n    def get_ways(self, way_id: Optional[int] = None) -> List[\"Way\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Way\\n\\n        :param way_id: The Id of the way\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Way, elem_id=way_id)\\n\\n    area_ids = property(get_area_ids)\\n    areas = property(get_areas)\\n    node_ids = property(get_node_ids)\\n    nodes = property(get_nodes)\\n    relation_ids = property(get_relation_ids)\\n    relations = property(get_relations)\\n    way_ids = property(get_way_ids)\\n    ways = property(get_ways)\\n\\n\\nclass Element:\\n    \"\"\"\\n    Base element\\n    \"\"\"\\n\\n    _type_value: str\\n\\n    def __init__(self, attributes: Optional[dict] = None, result: Optional[Result] = None, tags: Optional[Dict] = None):\\n        \"\"\"\\n        :param attributes: Additional attributes\\n        :param result: The result object this element belongs to\\n        :param tags: List of tags\\n        \"\"\"\\n\\n        self._result = result\\n        self.attributes = attributes\\n        # ToDo: Add option to modify attribute modifiers\\n        attribute_modifiers: Dict[str, Callable] = dict(GLOBAL_ATTRIBUTE_MODIFIERS.items())\\n        for n, m in attribute_modifiers.items():\\n            if n in self.attributes:\\n                self.attributes[n] = m(self.attributes[n])\\n        self.id: int\\n        self.tags = tags\\n\\n    @classmethod\\n    def get_center_from_json(cls, data: dict) -> Tuple[Decimal, Decimal]:\\n        \"\"\"\\n        Get center information from json data\\n\\n        :param data: json data\\n        :return: tuple with two elements: lat and lon\\n        \"\"\"\\n        center_lat = None\\n        center_lon = None\\n        center = data.get(\"center\")\\n        if isinstance(center, dict):\\n            center_lat = center.get(\"lat\")\\n            center_lon = center.get(\"lon\")\\n            if center_lat is None or center_lon is None:\\n                raise ValueError(\"Unable to get lat or lon of way center.\")\\n            center_lat = Decimal(center_lat)\\n            center_lon = Decimal(center_lon)\\n        return center_lat, center_lon\\n\\n    @classmethod\\n    def get_center_from_xml_dom(cls, sub_child: xml.etree.ElementTree.Element) -> Tuple[Decimal, Decimal]:\\n        center_lat_str: str = sub_child.attrib.get(\"lat\")\\n        center_lon_str: str = sub_child.attrib.get(\"lon\")\\n        if center_lat_str is None or center_lon_str is None:\\n            raise ValueError(\"Unable to get lat or lon of way center.\")\\n        center_lat = Decimal(center_lat_str)\\n        center_lon = Decimal(center_lon_str)\\n        return center_lat, center_lon\\n\\n    @classmethod\\n    def from_json(cls: Type[ElementTypeVar], data: dict, result: Optional[Result] = None) -> ElementTypeVar:\\n        \"\"\"\\n        Create new Element() from json data\\n        :param data:\\n        :param result:\\n        :return:\\n        \"\"\"\\n        raise NotImplementedError\\n\\n    @classmethod\\n    def from_xml(\\n            cls: Type[ElementTypeVar],\\n            child: xml.etree.ElementTree.Element,\\n            result: Optional[Result] = None) -> ElementTypeVar:\\n        \"\"\"\\n        Create new Element() element from XML data\\n        \"\"\"\\n        raise NotImplementedError\\n\\n\\nclass Area(Element):\\n    \"\"\"\\n    Class to represent an element of type area\\n    \"\"\"\\n\\n    _type_value = \"area\"\\n\\n    def __init__(self, area_id: Optional[int] = None, **kwargs):\\n        \"\"\"\\n        :param area_id: Id of the area element\\n        :param kwargs: Additional arguments are passed directly to the parent class\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        #: The id of the way\\n        self.id = area_id\\n\\n    def __repr__(self) -> str:\\n        return f\"<overpy.Area id={self.id}>\"\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Area\":\\n        \"\"\"\\n        Create new Area element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Way\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        area_id = data.get(\"id\")\\n\\n        attributes = {}\\n        ignore = [\"id\", \"tags\", \"type\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(area_id=area_id, attributes=attributes, tags=tags, result=result)\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Area\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If the ref attribute of the xml node is not provided\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n\\n        area_id_str: Optional[str] = child.attrib.get(\"id\")\\n        area_id: Optional[int] = None\\n        if area_id_str is not None:\\n            area_id = int(area_id_str)\\n\\n        attributes = {}\\n        ignore = [\"id\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(area_id=area_id, attributes=attributes, tags=tags, result=result)\\n\\n\\nclass Node(Element):\\n    \"\"\"\\n    Class to represent an element of type node\\n    \"\"\"\\n\\n    _type_value = \"node\"\\n\\n    def __init__(\\n            self,\\n            node_id: Optional[int] = None,\\n            lat: Optional[Union[Decimal, float]] = None,\\n            lon: Optional[Union[Decimal, float]] = None,\\n            **kwargs):\\n        \"\"\"\\n        :param lat: Latitude\\n        :param lon: Longitude\\n        :param node_id: Id of the node element\\n        :param kwargs: Additional arguments are passed directly to the parent class\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        self.id = node_id\\n        self.lat = lat\\n        self.lon = lon\\n\\n    def __repr__(self) -> str:\\n        return f\"<overpy.Node id={self.id} lat={self.lat} lon={self.lon}>\"\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Node\":\\n        \"\"\"\\n        Create new Node element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Node\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        node_id = data.get(\"id\")\\n        lat = data.get(\"lat\")\\n        lon = data.get(\"lon\")\\n\\n        attributes = {}\\n        ignore = [\"type\", \"id\", \"lat\", \"lon\", \"tags\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(node_id=node_id, lat=lat, lon=lon, tags=tags, attributes=attributes, result=result)\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Node\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n\\n        node_id: Optional[int] = None\\n        node_id_str: Optional[str] = child.attrib.get(\"id\")\\n        if node_id_str is not None:\\n            node_id = int(node_id_str)\\n\\n        lat: Optional[Decimal] = None\\n        lat_str: Optional[str] = child.attrib.get(\"lat\")\\n        if lat_str is not None:\\n            lat = Decimal(lat_str)\\n\\n        lon: Optional[Decimal] = None\\n        lon_str: Optional[str] = child.attrib.get(\"lon\")\\n        if lon_str is not None:\\n            lon = Decimal(lon_str)\\n\\n        attributes = {}\\n        ignore = [\"id\", \"lat\", \"lon\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(node_id=node_id, lat=lat, lon=lon, tags=tags, attributes=attributes, result=result)\\n\\n\\nclass Way(Element):\\n    \"\"\"\\n    Class to represent an element of type way\\n    \"\"\"\\n\\n    _type_value = \"way\"\\n\\n    def __init__(\\n            self,\\n            way_id: Optional[int] = None,\\n            center_lat: Optional[Union[Decimal, float]] = None,\\n            center_lon: Optional[Union[Decimal, float]] = None,\\n            node_ids: Optional[Union[List[int], Tuple[int]]] = None,\\n            **kwargs):\\n        \"\"\"\\n        :param node_ids: List of node IDs\\n        :param way_id: Id of the way element\\n        :param kwargs: Additional arguments are passed directly to the parent class\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        #: The id of the way\\n        self.id = way_id\\n\\n        #: List of Ids of the associated nodes\\n        self._node_ids = node_ids\\n\\n        #: The lat/lon of the center of the way (optional depending on query)\\n        self.center_lat = center_lat\\n        self.center_lon = center_lon\\n\\n    def __repr__(self):\\n        return f\"<overpy.Way id={self.id} nodes={self._node_ids}>\"\\n\\n    @property\\n    def nodes(self) -> List[Node]:\\n        \"\"\"\\n        List of nodes associated with the way.\\n        \"\"\"\\n        return self.get_nodes()\\n\\n    def get_nodes(self, resolve_missing: bool = False) -> List[Node]:\\n        \"\"\"\\n        Get the nodes defining the geometry of the way\\n\\n        :param resolve_missing: Try to resolve missing nodes.\\n        :return: List of nodes\\n        :raises overpy.exception.DataIncomplete: At least one referenced node is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and at least one node can\\'t be resolved.\\n        \"\"\"\\n        result = []\\n        resolved = False\\n\\n        for node_id in self._node_ids:\\n            try:\\n                node = self._result.get_node(node_id)\\n            except exception.DataIncomplete:\\n                node = None\\n\\n            if node is not None:\\n                result.append(node)\\n                continue\\n\\n            if not resolve_missing:\\n                raise exception.DataIncomplete(\"Resolve missing nodes is disabled\")\\n\\n            # We tried to resolve the data but some nodes are still missing\\n            if resolved:\\n                raise exception.DataIncomplete(\"Unable to resolve all nodes\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"way({way_id});\\\\n\"\\n                     \"node(w);\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                way_id=self.id\\n            )\\n            tmp_result = self._result.api.query(query)\\n            self._result.expand(tmp_result)\\n            resolved = True\\n\\n            try:\\n                node = self._result.get_node(node_id)\\n            except exception.DataIncomplete:\\n                node = None\\n\\n            if node is None:\\n                raise exception.DataIncomplete(\"Unable to resolve all nodes\")\\n\\n            result.append(node)\\n\\n        return result\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Way\":\\n        \"\"\"\\n        Create new Way element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Way\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        way_id = data.get(\"id\")\\n        node_ids = data.get(\"nodes\")\\n        (center_lat, center_lon) = cls.get_center_from_json(data=data)\\n\\n        attributes = {}\\n        ignore = [\"center\", \"id\", \"nodes\", \"tags\", \"type\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(\\n            attributes=attributes,\\n            center_lat=center_lat,\\n            center_lon=center_lon,\\n            node_ids=node_ids,\\n            tags=tags,\\n            result=result,\\n            way_id=way_id\\n        )\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Way\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If the ref attribute of the xml node is not provided\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n        node_ids = []\\n        center_lat = None\\n        center_lon = None\\n\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n            if sub_child.tag.lower() == \"nd\":\\n                ref_id_str = sub_child.attrib.get(\"ref\")\\n                if ref_id_str is None:\\n                    raise ValueError(\"Unable to find required ref value.\")\\n                ref_id: int = int(ref_id_str)\\n                node_ids.append(ref_id)\\n            if sub_child.tag.lower() == \"center\":\\n                (center_lat, center_lon) = cls.get_center_from_xml_dom(sub_child=sub_child)\\n\\n        way_id: Optional[int] = None\\n        way_id_str: Optional[str] = child.attrib.get(\"id\")\\n        if way_id_str is not None:\\n            way_id = int(way_id_str)\\n\\n        attributes = {}\\n        ignore = [\"id\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(way_id=way_id, center_lat=center_lat, center_lon=center_lon,\\n                   attributes=attributes, node_ids=node_ids, tags=tags, result=result)\\n\\n\\nclass Relation(Element):\\n    \"\"\"\\n    Class to represent an element of type relation\\n    \"\"\"\\n\\n    _type_value = \"relation\"\\n\\n    def __init__(\\n            self,\\n            rel_id: Optional[int] = None,\\n            center_lat: Optional[Union[Decimal, float]] = None,\\n            center_lon: Optional[Union[Decimal, float]] = None,\\n            members: Optional[List[\"RelationMember\"]] = None,\\n            **kwargs):\\n        \"\"\"\\n        :param members:\\n        :param rel_id: Id of the relation element\\n        :param kwargs:\\n        :return:\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        self.id = rel_id\\n        self.members = members\\n\\n        #: The lat/lon of the center of the way (optional depending on query)\\n        self.center_lat = center_lat\\n        self.center_lon = center_lon\\n\\n    def __repr__(self):\\n        return f\"<overpy.Relation id={self.id}>\"\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Relation\":\\n        \"\"\"\\n        Create new Relation element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Relation\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        rel_id = data.get(\"id\")\\n        (center_lat, center_lon) = cls.get_center_from_json(data=data)\\n\\n        members = []\\n\\n        supported_members = [RelationNode, RelationWay, RelationRelation]\\n        for member in data.get(\"members\", []):\\n            type_value = member.get(\"type\")\\n            for member_cls in supported_members:\\n                if member_cls._type_value == type_value:\\n                    members.append(\\n                        member_cls.from_json(\\n                            member,\\n                            result=result\\n                        )\\n                    )\\n\\n        attributes = {}\\n        ignore = [\"id\", \"members\", \"tags\", \"type\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(\\n            rel_id=rel_id,\\n            attributes=attributes,\\n            center_lat=center_lat,\\n            center_lon=center_lon,\\n            members=members,\\n            tags=tags,\\n            result=result\\n        )\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Relation\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n        members = []\\n        center_lat = None\\n        center_lon = None\\n\\n        supported_members = [RelationNode, RelationWay, RelationRelation, RelationArea]\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n            if sub_child.tag.lower() == \"member\":\\n                type_value = sub_child.attrib.get(\"type\")\\n                for member_cls in supported_members:\\n                    if member_cls._type_value == type_value:\\n                        members.append(\\n                            member_cls.from_xml(\\n                                sub_child,\\n                                result=result\\n                            )\\n                        )\\n            if sub_child.tag.lower() == \"center\":\\n                (center_lat, center_lon) = cls.get_center_from_xml_dom(sub_child=sub_child)\\n\\n        rel_id: Optional[int] = None\\n        rel_id_str: Optional[str] = child.attrib.get(\"id\")\\n        if rel_id_str is not None:\\n            rel_id = int(rel_id_str)\\n\\n        attributes = {}\\n        ignore = [\"id\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(\\n            rel_id=rel_id,\\n            attributes=attributes,\\n            center_lat=center_lat,\\n            center_lon=center_lon,\\n            members=members,\\n            tags=tags,\\n            result=result\\n        )\\n\\n\\nclass RelationMember:\\n    \"\"\"\\n    Base class to represent a member of a relation.\\n    \"\"\"\\n    _type_value: Optional[str] = None\\n\\n    def __init__(\\n            self,\\n            attributes: Optional[dict] = None,\\n            geometry: Optional[List[\"RelationWayGeometryValue\"]] = None,\\n            ref: Optional[int] = None,\\n            role: Optional[str] = None,\\n            result: Optional[Result] = None):\\n        \"\"\"\\n        :param ref: Reference Id\\n        :type ref: Integer\\n        :param role: The role of the relation member\\n        :type role: String\\n        :param result:\\n        \"\"\"\\n        self.ref = ref\\n        self._result = result\\n        self.role = role\\n        self.attributes = attributes\\n        self.geometry = geometry\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"RelationMember\":\\n        \"\"\"\\n        Create new RelationMember element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of RelationMember\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        ref = data.get(\"ref\")\\n        role = data.get(\"role\")\\n\\n        attributes = {}\\n        ignore = [\"geometry\", \"type\", \"ref\", \"role\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        geometry = data.get(\"geometry\")\\n        if isinstance(geometry, list):\\n            geometry_orig = geometry\\n            geometry = []\\n            for v in geometry_orig:\\n                geometry.append(\\n                    RelationWayGeometryValue(\\n                        lat=v.get(\"lat\"),\\n                        lon=v.get(\"lon\")\\n                    )\\n                )\\n        else:\\n            geometry = None\\n\\n        return cls(\\n            attributes=attributes,\\n            geometry=geometry,\\n            ref=ref,\\n            role=role,\\n            result=result\\n        )\\n\\n    @classmethod\\n    def from_xml(\\n            cls,\\n            child: xml.etree.ElementTree.Element,\\n            result: Optional[Result] = None) -> \"RelationMember\":\\n        \"\"\"\\n        Create new RelationMember from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this element belongs to\\n        :return: New relation member oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        \"\"\"\\n        if child.attrib.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        ref: Optional[int] = None\\n        ref_str: Optional[str] = child.attrib.get(\"ref\")\\n        if ref_str is not None:\\n            ref = int(ref_str)\\n\\n        role: Optional[str] = child.attrib.get(\"role\")\\n\\n        attributes = {}\\n        ignore = [\"geometry\", \"ref\", \"role\", \"type\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        geometry = None\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"nd\":\\n                if geometry is None:\\n                    geometry = []\\n                geometry.append(\\n                    RelationWayGeometryValue(\\n                        lat=Decimal(sub_child.attrib[\"lat\"]),\\n                        lon=Decimal(sub_child.attrib[\"lon\"])\\n                    )\\n                )\\n\\n        return cls(\\n            attributes=attributes,\\n            geometry=geometry,\\n            ref=ref,\\n            role=role,\\n            result=result\\n        )\\n\\n\\nclass RelationNode(RelationMember):\\n    _type_value = \"node\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Node:\\n        return self._result.get_node(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationNode ref={self.ref} role={self.role}>\"\\n\\n\\nclass RelationWay(RelationMember):\\n    _type_value = \"way\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Way:\\n        return self._result.get_way(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationWay ref={self.ref} role={self.role}>\"\\n\\n\\nclass RelationWayGeometryValue:\\n    def __init__(self, lat: Union[Decimal, float], lon: Union[Decimal, float]):\\n        self.lat = lat\\n        self.lon = lon\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationWayGeometryValue lat={self.lat} lon={self.lon}>\"\\n\\n\\nclass RelationRelation(RelationMember):\\n    _type_value = \"relation\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Relation:\\n        return self._result.get_relation(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationRelation ref={self.ref} role={self.role}>\"\\n\\n\\nclass RelationArea(RelationMember):\\n    _type_value = \"area\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Area:\\n        return self._result.get_area(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationArea ref={self.ref} role={self.role}>\"\\n\\n\\nclass OSMSAXHandler(handler.ContentHandler):\\n    \"\"\"\\n    SAX parser for Overpass XML response.\\n    \"\"\"\\n    #: Tuple of opening elements to ignore\\n    ignore_start: ClassVar = (\\'osm\\', \\'meta\\', \\'note\\', \\'bounds\\', \\'remark\\')\\n    #: Tuple of closing elements to ignore\\n    ignore_end: ClassVar = (\\'osm\\', \\'meta\\', \\'note\\', \\'bounds\\', \\'remark\\', \\'tag\\', \\'nd\\', \\'center\\')\\n\\n    def __init__(self, result: Result):\\n        \"\"\"\\n        :param result: Append results to this result set.\\n        \"\"\"\\n        handler.ContentHandler.__init__(self)\\n        self._result = result\\n        self._curr: Dict[str, Any] = {}\\n        #: Current relation member object\\n        self.cur_relation_member: Optional[RelationMember] = None\\n\\n    def startElement(self, name: str, attrs: dict):\\n        \"\"\"\\n        Handle opening elements.\\n\\n        :param name: Name of the element\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        if name in self.ignore_start:\\n            return\\n        try:\\n            handler = getattr(self, \\'_handle_start_%s\\' % name)\\n        except AttributeError:\\n            raise KeyError(\"Unknown element start \\'%s\\'\" % name)\\n        handler(attrs)\\n\\n    def endElement(self, name: str):\\n        \"\"\"\\n        Handle closing elements\\n\\n        :param name: Name of the element\\n        \"\"\"\\n        if name in self.ignore_end:\\n            return\\n        try:\\n            handler = getattr(self, \\'_handle_end_%s\\' % name)\\n        except AttributeError:\\n            raise KeyError(\"Unknown element end \\'%s\\'\" % name)\\n        handler()\\n\\n    def _handle_start_center(self, attrs: dict):\\n        \"\"\"\\n        Handle opening center element\\n\\n        :param attrs: Attributes of the element\\n        :type attrs: Dict\\n        \"\"\"\\n        center_lat = attrs.get(\"lat\")\\n        center_lon = attrs.get(\"lon\")\\n        if center_lat is None or center_lon is None:\\n            raise ValueError(\"Unable to get lat or lon of way center.\")\\n        self._curr[\"center_lat\"] = Decimal(center_lat)\\n        self._curr[\"center_lon\"] = Decimal(center_lon)\\n\\n    def _handle_start_tag(self, attrs: dict):\\n        \"\"\"\\n        Handle opening tag element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        try:\\n            tag_key = attrs[\\'k\\']\\n        except KeyError:\\n            raise ValueError(\"Tag without name/key.\")\\n        self._curr[\\'tags\\'][tag_key] = attrs.get(\\'v\\')\\n\\n    def _handle_start_node(self, attrs: dict):\\n        \"\"\"\\n        Handle opening node element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'attributes\\': dict(attrs),\\n            \\'lat\\': None,\\n            \\'lon\\': None,\\n            \\'node_id\\': None,\\n            \\'tags\\': {}\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'node_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n        if attrs.get(\\'lat\\', None) is not None:\\n            self._curr[\\'lat\\'] = Decimal(attrs[\\'lat\\'])\\n            del self._curr[\\'attributes\\'][\\'lat\\']\\n        if attrs.get(\\'lon\\', None) is not None:\\n            self._curr[\\'lon\\'] = Decimal(attrs[\\'lon\\'])\\n            del self._curr[\\'attributes\\'][\\'lon\\']\\n\\n    def _handle_end_node(self):\\n        \"\"\"\\n        Handle closing node element\\n        \"\"\"\\n        self._result.append(Node(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_way(self, attrs: dict):\\n        \"\"\"\\n        Handle opening way element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'center_lat\\': None,\\n            \\'center_lon\\': None,\\n            \\'attributes\\': dict(attrs),\\n            \\'node_ids\\': [],\\n            \\'tags\\': {},\\n            \\'way_id\\': None\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'way_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n\\n    def _handle_end_way(self):\\n        \"\"\"\\n        Handle closing way element\\n        \"\"\"\\n        self._result.append(Way(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_area(self, attrs: dict):\\n        \"\"\"\\n        Handle opening area element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'attributes\\': dict(attrs),\\n            \\'tags\\': {},\\n            \\'area_id\\': None\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'area_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n\\n    def _handle_end_area(self):\\n        \"\"\"\\n        Handle closing area element\\n        \"\"\"\\n        self._result.append(Area(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_nd(self, attrs: dict):\\n        \"\"\"\\n        Handle opening nd element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        if isinstance(self.cur_relation_member, RelationWay):\\n            if self.cur_relation_member.geometry is None:\\n                self.cur_relation_member.geometry = []\\n            self.cur_relation_member.geometry.append(\\n                RelationWayGeometryValue(\\n                    lat=Decimal(attrs[\"lat\"]),\\n                    lon=Decimal(attrs[\"lon\"])\\n                )\\n            )\\n        else:\\n            try:\\n                node_ref = attrs[\\'ref\\']\\n            except KeyError:\\n                raise ValueError(\"Unable to find required ref value.\")\\n            self._curr[\\'node_ids\\'].append(int(node_ref))\\n\\n    def _handle_start_relation(self, attrs: dict):\\n        \"\"\"\\n        Handle opening relation element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'attributes\\': dict(attrs),\\n            \\'members\\': [],\\n            \\'rel_id\\': None,\\n            \\'tags\\': {}\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'rel_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n\\n    def _handle_end_relation(self):\\n        \"\"\"\\n        Handle closing relation element\\n        \"\"\"\\n        self._result.append(Relation(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_member(self, attrs: dict):\\n        \"\"\"\\n        Handle opening member element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n\\n        params: Dict[str, Any] = {\\n            # ToDo: Parse attributes\\n            \\'attributes\\': {},\\n            \\'ref\\': None,\\n            \\'result\\': self._result,\\n            \\'role\\': None\\n        }\\n        if attrs.get(\\'ref\\', None):\\n            params[\\'ref\\'] = int(attrs[\\'ref\\'])\\n        if attrs.get(\\'role\\', None):\\n            params[\\'role\\'] = attrs[\\'role\\']\\n\\n        cls_map = {\\n            \"area\": RelationArea,\\n            \"node\": RelationNode,\\n            \"relation\": RelationRelation,\\n            \"way\": RelationWay\\n        }\\n        cls: Type[RelationMember] = cls_map.get(attrs[\"type\"])\\n        if cls is None:\\n            raise ValueError(\"Undefined type for member: \\'%s\\'\" % attrs[\\'type\\'])\\n\\n        self.cur_relation_member = cls(**params)\\n        self._curr[\\'members\\'].append(self.cur_relation_member)\\n\\n    def _handle_end_member(self):\\n        self.cur_relation_member = None\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, "return_value": "b'class OverPyException(Exception):\\n    \"\"\"OverPy base exception\"\"\"\\n    pass\\n\\n\\nclass DataIncomplete(OverPyException):\\n    \"\"\"\\n    Raised if the requested data isn\\'t available in the result.\\n    Try to improve the query or to resolve the missing data.\\n    \"\"\"\\n    def __init__(self, *args, **kwargs):\\n        OverPyException.__init__(\\n            self,\\n            \"Data incomplete try to improve the query to resolve the missing data\",\\n            *args,\\n            **kwargs\\n        )\\n\\n\\nclass ElementDataWrongType(OverPyException):\\n    \"\"\"\\n    Raised if the provided element does not match the expected type.\\n\\n    :param type_expected: The expected element type\\n    :type type_expected: String\\n    :param type_provided: The provided element type\\n    :type type_provided: String|None\\n    \"\"\"\\n    def __init__(self, type_expected, type_provided=None):\\n        self.type_expected = type_expected\\n        self.type_provided = type_provided\\n\\n    def __str__(self) -> str:\\n        return \"Type expected \\'{}\\' but \\'{}\\' provided\".format(\\n            self.type_expected,\\n            str(self.type_provided)\\n        )\\n\\n\\nclass MaxRetriesReached(OverPyException):\\n    \"\"\"\\n    Raised if max retries reached and the Overpass server didn\\'t respond with a result.\\n    \"\"\"\\n    def __init__(self, retry_count, exceptions):\\n        self.exceptions = exceptions\\n        self.retry_count = retry_count\\n\\n    def __str__(self) -> str:\\n        return \"Unable get any result from the Overpass API server after %d retries.\" % self.retry_count\\n\\n\\nclass OverpassBadRequest(OverPyException):\\n    \"\"\"\\n    Raised if the Overpass API service returns a syntax error.\\n\\n    :param query: The encoded query how it was send to the server\\n    :type query: Bytes\\n    :param msgs: List of error messages\\n    :type msgs: List\\n    \"\"\"\\n    def __init__(self, query, msgs=None):\\n        self.query = query\\n        if msgs is None:\\n            msgs = []\\n        self.msgs = msgs\\n\\n    def __str__(self) -> str:\\n        tmp_msgs = []\\n        for tmp_msg in self.msgs:\\n            if not isinstance(tmp_msg, str):\\n                tmp_msg = str(tmp_msg)\\n            tmp_msgs.append(tmp_msg)\\n\\n        return \"\\\\n\".join(tmp_msgs)\\n\\n\\nclass OverpassError(OverPyException):\\n    \"\"\"\\n    Base exception to report errors if the response returns a remark tag or element.\\n\\n    .. note::\\n        If you are not sure which of the subexceptions you should use, use this one and try to parse the message.\\n\\n        For more information have a look at https://github.com/DinoTools/python-overpy/issues/62\\n\\n    :param str msg: The message from the remark tag or element\\n    \"\"\"\\n    def __init__(self, msg=None):\\n        #: The message from the remark tag or element\\n        self.msg = msg\\n\\n    def __str__(self) -> str:\\n        if self.msg is None:\\n            return \"No error message provided\"\\n        if not isinstance(self.msg, str):\\n            return str(self.msg)\\n        return self.msg\\n\\n\\nclass OverpassGatewayTimeout(OverPyException):\\n    \"\"\"\\n    Raised if load of the Overpass API service is too high and it can\\'t handle the request.\\n    \"\"\"\\n    def __init__(self):\\n        OverPyException.__init__(self, \"Server load too high\")\\n\\n\\nclass OverpassRuntimeError(OverpassError):\\n    \"\"\"\\n    Raised if the server returns a remark-tag(xml) or remark element(json) with a message starting with\\n    \\'runtime error:\\'.\\n    \"\"\"\\n    pass\\n\\n\\nclass OverpassRuntimeRemark(OverpassError):\\n    \"\"\"\\n    Raised if the server returns a remark-tag(xml) or remark element(json) with a message starting with\\n    \\'runtime remark:\\'.\\n    \"\"\"\\n    pass\\n\\n\\nclass OverpassTooManyRequests(OverPyException):\\n    \"\"\"\\n    Raised if the Overpass API service returns a 429 status code.\\n    \"\"\"\\n    def __init__(self):\\n        OverPyException.__init__(self, \"Too many requests\")\\n\\n\\nclass OverpassUnknownContentType(OverPyException):\\n    \"\"\"\\n    Raised if the reported content type isn\\'t handled by OverPy.\\n\\n    :param content_type: The reported content type\\n    :type content_type: None or String\\n    \"\"\"\\n    def __init__(self, content_type):\\n        self.content_type = content_type\\n\\n    def __str__(self) -> str:\\n        if self.content_type is None:\\n            return \"No content type returned\"\\n        return \"Unknown content type: %s\" % self.content_type\\n\\n\\nclass OverpassUnknownError(OverpassError):\\n    \"\"\"\\n    Raised if the server returns a remark-tag(xml) or remark element(json) and we are unable to find any reason.\\n    \"\"\"\\n    pass\\n\\n\\nclass OverpassUnknownHTTPStatusCode(OverPyException):\\n    \"\"\"\\n    Raised if the returned HTTP status code isn\\'t handled by OverPy.\\n\\n    :param code: The HTTP status code\\n    :type code: Integer\\n    \"\"\"\\n    def __init__(self, code):\\n        self.code = code\\n\\n    def __str__(self) -> str:\\n        return \"Unknown/Unhandled status code: %d\" % self.code\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, "return_value": "b'from typing import List, Optional\\n__author__ = \\'mjob\\'\\n\\nimport overpy\\n\\n\\ndef get_street(\\n        street: str,\\n        areacode: str,\\n        api: Optional[overpy.Overpass] = None) -> overpy.Result:\\n    \"\"\"\\n    Retrieve streets in a given bounding area\\n\\n    :param street: Name of street\\n    :param areacode: The OSM id of the bounding area\\n    :param api: API object to fetch missing elements\\n    :return: Parsed result\\n    :raises overpy.exception.OverPyException: If something bad happens.\\n    \"\"\"\\n    if api is None:\\n        api = overpy.Overpass()\\n\\n    query = \"\"\"\\n        area(%s)->.location;\\n        (\\n            way[highway][name=\"%s\"](area.location);\\n            - (\\n                way[highway=service](area.location);\\n                way[highway=track](area.location);\\n            );\\n        );\\n        out body;\\n        >;\\n        out skel qt;\\n    \"\"\"\\n\\n    data = api.query(query % (areacode, street))\\n\\n    return data\\n\\n\\ndef get_intersection(\\n        street1: str,\\n        street2: str,\\n        areacode: str,\\n        api: Optional[overpy.Overpass] = None) -> List[overpy.Node]:\\n    \"\"\"\\n    Retrieve intersection of two streets in a given bounding area\\n\\n    :param street1: Name of first street of intersection\\n    :param street2: Name of second street of intersection\\n    :param areacode: The OSM id of the bounding area\\n    :param api: API object to fetch missing elements\\n    :return: List of intersections\\n    :raises overpy.exception.OverPyException: If something bad happens.\\n    \"\"\"\\n    if api is None:\\n        api = overpy.Overpass()\\n\\n    query = \"\"\"\\n        area(%s)->.location;\\n        (\\n            way[highway][name=\"%s\"](area.location); node(w)->.n1;\\n            way[highway][name=\"%s\"](area.location); node(w)->.n2;\\n        );\\n        node.n1.n2;\\n        out meta;\\n    \"\"\"\\n\\n    data = api.query(query % (areacode, street1, street2))\\n\\n    return data.get_nodes()\\n'"}]}, "get_python_source": {"line": 37, "args": [{"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/__about__.py'"}, "return_value": "'__all__ = [\\n    \"__author__\",\\n    \"__copyright__\",\\n    \"__email__\",\\n    \"__license__\",\\n    \"__summary__\",\\n    \"__title__\",\\n    \"__uri__\",\\n    \"__version__\",\\n]\\n\\n__title__ = \"overpy\"\\n__summary__ = \"Python Wrapper to access the OpenStreepMap Overpass API\"\\n__uri__ = \"https://github.com/DinoTools/python-overpy\"\\n\\n__version__ = \"0.6\"\\n\\n__author__ = \"PhiBo (DinoTools)\"\\n__email__ = \"\"\\n\\n__license__ = \"MIT\"\\n__copyright__ = \"Copyright 2014-2021 %s\" % __author__\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/__init__.py'"}, "return_value": "'from collections import OrderedDict\\nfrom datetime import datetime\\nfrom decimal import Decimal\\nfrom urllib.request import urlopen\\nfrom urllib.error import HTTPError\\nfrom xml.sax import handler, make_parser\\nimport xml.etree.ElementTree\\nimport json\\nimport re\\nimport time\\nfrom typing import Any, Callable, ClassVar, Dict, List, NoReturn, Optional, Tuple, Type, TypeVar, Union\\n\\nfrom overpy import exception\\n# Ignore flake8 F401 warning for unused vars\\nfrom overpy.__about__ import (  # noqa: F401\\n    __author__, __copyright__, __email__, __license__, __summary__, __title__,\\n    __uri__, __version__\\n)\\n\\nElementTypeVar = TypeVar(\"ElementTypeVar\", bound=\"Element\")\\n\\nXML_PARSER_DOM = 1\\nXML_PARSER_SAX = 2\\n\\n# Try to convert some common attributes\\n# http://wiki.openstreetmap.org/wiki/Elements#Common_attributes\\nGLOBAL_ATTRIBUTE_MODIFIERS: Dict[str, Callable] = {\\n    \"changeset\": int,\\n    \"timestamp\": lambda ts: datetime.strptime(ts, \"%Y-%m-%dT%H:%M:%SZ\"),\\n    \"uid\": int,\\n    \"version\": int,\\n    \"visible\": lambda v: v.lower() == \"true\"\\n}\\n\\n\\ndef is_valid_type(\\n        element: Union[\"Area\", \"Node\", \"Relation\", \"Way\"],\\n        cls: Type[Union[\"Area\", \"Element\", \"Node\", \"Relation\", \"Way\"]]) -> bool:\\n    \"\"\"\\n    Test if an element is of a given type.\\n\\n    :param element: The element instance to test\\n    :param cls: The element class to test\\n    :return: False or True\\n    \"\"\"\\n    return isinstance(element, cls) and element.id is not None\\n\\n\\nclass Overpass:\\n    \"\"\"\\n    Class to access the Overpass API\\n\\n    :cvar default_max_retry_count: Global max number of retries (Default: 0)\\n    :cvar default_read_chunk_size: Max size of each chunk read from the server response\\n    :cvar default_retry_timeout: Global time to wait between tries (Default: 1.0s)\\n    :cvar default_url: Default URL of the Overpass server\\n    \"\"\"\\n    default_max_retry_count: ClassVar[int] = 0\\n    default_read_chunk_size: ClassVar[int] = 4096\\n    default_retry_timeout: ClassVar[float] = 1.0\\n    default_url: ClassVar[str] = \"http://overpass-api.de/api/interpreter\"\\n\\n    def __init__(\\n            self,\\n            read_chunk_size: Optional[int] = None,\\n            url: Optional[str] = None,\\n            xml_parser: int = XML_PARSER_SAX,\\n            max_retry_count: int = None,\\n            retry_timeout: float = None):\\n        \"\"\"\\n        :param read_chunk_size: Max size of each chunk read from the server response\\n        :param url: Optional URL of the Overpass server. Defaults to http://overpass-api.de/api/interpreter\\n        :param xml_parser: The xml parser to use\\n        :param max_retry_count: Max number of retries (Default: default_max_retry_count)\\n        :param retry_timeout: Time to wait between tries (Default: default_retry_timeout)\\n        \"\"\"\\n        self.url = self.default_url\\n        if url is not None:\\n            self.url = url\\n\\n        self._regex_extract_error_msg = re.compile(br\"\\\\<p\\\\>(?P<msg>\\\\<strong\\\\s.*?)\\\\</p\\\\>\")\\n        self._regex_remove_tag = re.compile(b\"<[^>]*?>\")\\n        if read_chunk_size is None:\\n            read_chunk_size = self.default_read_chunk_size\\n        self.read_chunk_size = read_chunk_size\\n\\n        if max_retry_count is None:\\n            max_retry_count = self.default_max_retry_count\\n        self.max_retry_count = max_retry_count\\n\\n        if retry_timeout is None:\\n            retry_timeout = self.default_retry_timeout\\n        self.retry_timeout = retry_timeout\\n\\n        self.xml_parser = xml_parser\\n\\n    @staticmethod\\n    def _handle_remark_msg(msg: str) -> NoReturn:\\n        \"\"\"\\n        Try to parse the message provided with the remark tag or element.\\n\\n        :param msg: The message\\n        :raises overpy.exception.OverpassRuntimeError: If message starts with \\'runtime error:\\'\\n        :raises overpy.exception.OverpassRuntimeRemark: If message starts with \\'runtime remark:\\'\\n        :raises overpy.exception.OverpassUnknownError: If we are unable to identify the error\\n        \"\"\"\\n        msg = msg.strip()\\n        if msg.startswith(\"runtime error:\"):\\n            raise exception.OverpassRuntimeError(msg=msg)\\n        elif msg.startswith(\"runtime remark:\"):\\n            raise exception.OverpassRuntimeRemark(msg=msg)\\n        raise exception.OverpassUnknownError(msg=msg)\\n\\n    def query(self, query: Union[bytes, str]) -> \"Result\":\\n        \"\"\"\\n        Query the Overpass API\\n\\n        :param query: The query string in Overpass QL\\n        :return: The parsed result\\n        \"\"\"\\n        if not isinstance(query, bytes):\\n            query = query.encode(\"utf-8\")\\n\\n        retry_num: int = 0\\n        retry_exceptions: List[exception.OverPyException] = []\\n        do_retry: bool = True if self.max_retry_count > 0 else False\\n        while retry_num <= self.max_retry_count:\\n            if retry_num > 0:\\n                time.sleep(self.retry_timeout)\\n            retry_num += 1\\n            try:\\n                f = urlopen(self.url, query)\\n            except HTTPError as e:\\n                f = e\\n\\n            response = f.read(self.read_chunk_size)\\n            while True:\\n                data = f.read(self.read_chunk_size)\\n                if len(data) == 0:\\n                    break\\n                response = response + data\\n            f.close()\\n\\n            current_exception: exception.OverPyException\\n            if f.code == 200:\\n                content_type = f.getheader(\"Content-Type\")\\n\\n                if content_type == \"application/json\":\\n                    return self.parse_json(response)\\n\\n                if content_type == \"application/osm3s+xml\":\\n                    return self.parse_xml(response)\\n\\n                current_exception = exception.OverpassUnknownContentType(content_type)\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            if f.code == 400:\\n                msgs: List[str] = []\\n                for msg_raw in self._regex_extract_error_msg.finditer(response):\\n                    msg_clean_bytes = self._regex_remove_tag.sub(b\"\", msg_raw.group(\"msg\"))\\n                    try:\\n                        msg = msg_clean_bytes.decode(\"utf-8\")\\n                    except UnicodeDecodeError:\\n                        msg = repr(msg_clean_bytes)\\n                    msgs.append(msg)\\n\\n                current_exception = exception.OverpassBadRequest(\\n                    query,\\n                    msgs=msgs\\n                )\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            if f.code == 429:\\n                current_exception = exception.OverpassTooManyRequests()\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            if f.code == 504:\\n                current_exception = exception.OverpassGatewayTimeout()\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            current_exception = exception.OverpassUnknownHTTPStatusCode(f.code)\\n            if not do_retry:\\n                raise current_exception\\n            retry_exceptions.append(current_exception)\\n            continue\\n\\n        raise exception.MaxRetriesReached(retry_count=retry_num, exceptions=retry_exceptions)\\n\\n    def parse_json(self, data: Union[bytes, str], encoding: str = \"utf-8\") -> \"Result\":\\n        \"\"\"\\n        Parse raw response from Overpass service.\\n\\n        :param data: Raw JSON Data\\n        :param encoding: Encoding to decode byte string\\n        :return: Result object\\n        \"\"\"\\n        if isinstance(data, bytes):\\n            data = data.decode(encoding)\\n        data_parsed: dict = json.loads(data, parse_float=Decimal)\\n        if \"remark\" in data_parsed:\\n            self._handle_remark_msg(msg=data_parsed.get(\"remark\"))\\n        return Result.from_json(data_parsed, api=self)\\n\\n    def parse_xml(self, data: Union[bytes, str], encoding: str = \"utf-8\", parser: Optional[int] = None):\\n        \"\"\"\\n\\n        :param data: Raw XML Data\\n        :param encoding: Encoding to decode byte string\\n        :param parser: The XML parser to use\\n        :return: Result object\\n        \"\"\"\\n        if parser is None:\\n            parser = self.xml_parser\\n\\n        if isinstance(data, bytes):\\n            data = data.decode(encoding)\\n\\n        m = re.compile(\"<remark>(?P<msg>[^<>]*)</remark>\").search(data)\\n        if m:\\n            self._handle_remark_msg(m.group(\"msg\"))\\n\\n        return Result.from_xml(data, api=self, parser=parser)\\n\\n\\nclass Result:\\n    \"\"\"\\n    Class to handle the result.\\n    \"\"\"\\n\\n    def __init__(\\n            self,\\n            elements: Optional[List[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]] = None,\\n            api: Optional[Overpass] = None):\\n        \"\"\"\\n\\n        :param elements: List of elements to initialize the result with\\n        :param api: The API object to load additional resources and elements\\n        \"\"\"\\n        if elements is None:\\n            elements = []\\n        self._areas: Dict[int, Union[\"Area\", \"Node\", \"Relation\", \"Way\"]] = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Area)\\n        )\\n        self._nodes = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Node)\\n        )\\n        self._ways = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Way)\\n        )\\n        self._relations = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Relation)\\n        )\\n        self._class_collection_map: Dict[Any, Any] = {\\n            Node: self._nodes,\\n            Way: self._ways,\\n            Relation: self._relations,\\n            Area: self._areas\\n        }\\n        self.api = api\\n\\n    def expand(self, other: \"Result\"):\\n        \"\"\"\\n        Add all elements from an other result to the list of elements of this result object.\\n\\n        It is used by the auto resolve feature.\\n\\n        :param other: Expand the result with the elements from this result.\\n        :raises ValueError: If provided parameter is not instance of :class:`overpy.Result`\\n        \"\"\"\\n        if not isinstance(other, Result):\\n            raise ValueError(\"Provided argument has to be instance of overpy:Result()\")\\n\\n        other_collection_map: Dict[Type[\"Element\"], List[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]] = {\\n            Area: other.areas,\\n            Node: other.nodes,\\n            Relation: other.relations,\\n            Way: other.ways\\n        }\\n        for element_type, own_collection in self._class_collection_map.items():\\n            for element in other_collection_map[element_type]:\\n                if is_valid_type(element, element_type) and element.id not in own_collection:\\n                    own_collection[element.id] = element\\n\\n    def append(self, element: Union[\"Area\", \"Node\", \"Relation\", \"Way\"]):\\n        \"\"\"\\n        Append a new element to the result.\\n\\n        :param element: The element to append\\n        \"\"\"\\n        if is_valid_type(element, Element):\\n            self._class_collection_map[element.__class__].setdefault(element.id, element)\\n\\n    def get_elements(\\n            self,\\n            filter_cls: Type[ElementTypeVar],\\n            elem_id: Optional[int] = None) -> List[ElementTypeVar]:\\n        \"\"\"\\n        Get a list of elements from the result and filter the element type by a class.\\n\\n        :param filter_cls:\\n        :param elem_id: ID of the object\\n        :return: List of available elements\\n        \"\"\"\\n        result: List[ElementTypeVar] = []\\n        if elem_id is not None:\\n            try:\\n                result = [self._class_collection_map[filter_cls][elem_id]]\\n            except KeyError:\\n                result = []\\n        else:\\n            for e in self._class_collection_map[filter_cls].values():\\n                result.append(e)\\n        return result\\n\\n    def get_ids(\\n            self,\\n            filter_cls: Type[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]) -> List[int]:\\n        \"\"\"\\n        Get all Element IDs\\n\\n        :param filter_cls: Only IDs of elements with this type\\n        :return: List of IDs\\n        \"\"\"\\n        return list(self._class_collection_map[filter_cls].keys())\\n\\n    def get_node_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Node)\\n\\n    def get_way_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Way)\\n\\n    def get_relation_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Relation)\\n\\n    def get_area_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Area)\\n\\n    @classmethod\\n    def from_json(cls, data: dict, api: Optional[Overpass] = None) -> \"Result\":\\n        \"\"\"\\n        Create a new instance and load data from json object.\\n\\n        :param data: JSON data returned by the Overpass API\\n        :param api:\\n        :return: New instance of Result object\\n        \"\"\"\\n        result = cls(api=api)\\n        elem_cls: Type[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]\\n        for elem_cls in [Node, Way, Relation, Area]:\\n            for element in data.get(\"elements\", []):\\n                e_type = element.get(\"type\")\\n                if hasattr(e_type, \"lower\") and e_type.lower() == elem_cls._type_value:\\n                    result.append(elem_cls.from_json(element, result=result))\\n\\n        return result\\n\\n    @classmethod\\n    def from_xml(\\n            cls,\\n            data: Union[str, xml.etree.ElementTree.Element],\\n            api: Optional[Overpass] = None,\\n            parser: Optional[int] = None) -> \"Result\":\\n        \"\"\"\\n        Create a new instance and load data from xml data or object.\\n\\n        .. note::\\n            If parser is set to None, the functions tries to find the best parse.\\n            By default the SAX parser is chosen if a string is provided as data.\\n            The parser is set to DOM if an xml.etree.ElementTree.Element is provided as data value.\\n\\n        :param data: Root element\\n        :param api: The instance to query additional information if required.\\n        :param parser: Specify the parser to use(DOM or SAX)(Default: None = autodetect, defaults to SAX)\\n        :return: New instance of Result object\\n        \"\"\"\\n        if parser is None:\\n            if isinstance(data, str):\\n                parser = XML_PARSER_SAX\\n            else:\\n                parser = XML_PARSER_DOM\\n\\n        result = cls(api=api)\\n        if parser == XML_PARSER_DOM:\\n            import xml.etree.ElementTree as ET\\n            if isinstance(data, str):\\n                root = ET.fromstring(data)\\n            elif isinstance(data, ET.Element):\\n                root = data\\n            else:\\n                raise exception.OverPyException(\"Unable to detect data type.\")\\n\\n            elem_cls: Type[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]\\n            for elem_cls in [Node, Way, Relation, Area]:\\n                for child in root:\\n                    if child.tag.lower() == elem_cls._type_value:\\n                        result.append(elem_cls.from_xml(child, result=result))\\n\\n        elif parser == XML_PARSER_SAX:\\n            from io import StringIO\\n            if not isinstance(data, str):\\n                raise ValueError(\"data must be of type str if using the SAX parser\")\\n            source = StringIO(data)\\n            sax_handler = OSMSAXHandler(result)\\n            sax_parser = make_parser()\\n            sax_parser.setContentHandler(sax_handler)\\n            sax_parser.parse(source)\\n        else:\\n            # ToDo: better exception\\n            raise Exception(\"Unknown XML parser\")\\n        return result\\n\\n    def get_area(self, area_id: int, resolve_missing: bool = False) -> \"Area\":\\n        \"\"\"\\n        Get an area by its ID.\\n\\n        :param area_id: The area ID\\n        :param resolve_missing: Query the Overpass API if the area is missing in the result set.\\n        :return: The area\\n        :raises overpy.exception.DataIncomplete: The requested way is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and the area can\\'t be resolved.\\n        \"\"\"\\n        areas = self.get_areas(area_id=area_id)\\n        if len(areas) == 0:\\n            if resolve_missing is False:\\n                raise exception.DataIncomplete(\"Resolve missing area is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"area({area_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                area_id=area_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            areas = self.get_areas(area_id=area_id)\\n\\n        if len(areas) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve requested areas\")\\n\\n        return areas[0]\\n\\n    def get_areas(self, area_id: Optional[int] = None) -> List[\"Area\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Area\\n\\n        :param area_id: The Id of the area\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Area, elem_id=area_id)\\n\\n    def get_node(self, node_id: int, resolve_missing: bool = False) -> \"Node\":\\n        \"\"\"\\n        Get a node by its ID.\\n\\n        :param node_id: The node ID\\n        :param resolve_missing: Query the Overpass API if the node is missing in the result set.\\n        :return: The node\\n        :raises overpy.exception.DataIncomplete: At least one referenced node is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and at least one node can\\'t be resolved.\\n        \"\"\"\\n        nodes = self.get_nodes(node_id=node_id)\\n        if len(nodes) == 0:\\n            if not resolve_missing:\\n                raise exception.DataIncomplete(\"Resolve missing nodes is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"node({node_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                node_id=node_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            nodes = self.get_nodes(node_id=node_id)\\n\\n        if len(nodes) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve all nodes\")\\n\\n        return nodes[0]\\n\\n    def get_nodes(self, node_id: Optional[int] = None) -> List[\"Node\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Node()\\n\\n        :param node_id: The Id of the node\\n        :type node_id: Integer\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Node, elem_id=node_id)\\n\\n    def get_relation(self, rel_id: int, resolve_missing: bool = False) -> \"Relation\":\\n        \"\"\"\\n        Get a relation by its ID.\\n\\n        :param rel_id: The relation ID\\n        :param resolve_missing: Query the Overpass API if the relation is missing in the result set.\\n        :return: The relation\\n        :raises overpy.exception.DataIncomplete: The requested relation is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and the relation can\\'t be resolved.\\n        \"\"\"\\n        relations = self.get_relations(rel_id=rel_id)\\n        if len(relations) == 0:\\n            if resolve_missing is False:\\n                raise exception.DataIncomplete(\"Resolve missing relations is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"relation({relation_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                relation_id=rel_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            relations = self.get_relations(rel_id=rel_id)\\n\\n        if len(relations) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve requested reference\")\\n\\n        return relations[0]\\n\\n    def get_relations(self, rel_id: int = None) -> List[\"Relation\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Relation\\n\\n        :param rel_id: Id of the relation\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Relation, elem_id=rel_id)\\n\\n    def get_way(self, way_id: int, resolve_missing: bool = False) -> \"Way\":\\n        \"\"\"\\n        Get a way by its ID.\\n\\n        :param way_id: The way ID\\n        :param resolve_missing: Query the Overpass API if the way is missing in the result set.\\n        :return: The way\\n        :raises overpy.exception.DataIncomplete: The requested way is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and the way can\\'t be resolved.\\n        \"\"\"\\n        ways = self.get_ways(way_id=way_id)\\n        if len(ways) == 0:\\n            if resolve_missing is False:\\n                raise exception.DataIncomplete(\"Resolve missing way is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"way({way_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                way_id=way_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            ways = self.get_ways(way_id=way_id)\\n\\n        if len(ways) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve requested way\")\\n\\n        return ways[0]\\n\\n    def get_ways(self, way_id: Optional[int] = None) -> List[\"Way\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Way\\n\\n        :param way_id: The Id of the way\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Way, elem_id=way_id)\\n\\n    area_ids = property(get_area_ids)\\n    areas = property(get_areas)\\n    node_ids = property(get_node_ids)\\n    nodes = property(get_nodes)\\n    relation_ids = property(get_relation_ids)\\n    relations = property(get_relations)\\n    way_ids = property(get_way_ids)\\n    ways = property(get_ways)\\n\\n\\nclass Element:\\n    \"\"\"\\n    Base element\\n    \"\"\"\\n\\n    _type_value: str\\n\\n    def __init__(self, attributes: Optional[dict] = None, result: Optional[Result] = None, tags: Optional[Dict] = None):\\n        \"\"\"\\n        :param attributes: Additional attributes\\n        :param result: The result object this element belongs to\\n        :param tags: List of tags\\n        \"\"\"\\n\\n        self._result = result\\n        self.attributes = attributes\\n        # ToDo: Add option to modify attribute modifiers\\n        attribute_modifiers: Dict[str, Callable] = dict(GLOBAL_ATTRIBUTE_MODIFIERS.items())\\n        for n, m in attribute_modifiers.items():\\n            if n in self.attributes:\\n                self.attributes[n] = m(self.attributes[n])\\n        self.id: int\\n        self.tags = tags\\n\\n    @classmethod\\n    def get_center_from_json(cls, data: dict) -> Tuple[Decimal, Decimal]:\\n        \"\"\"\\n        Get center information from json data\\n\\n        :param data: json data\\n        :return: tuple with two elements: lat and lon\\n        \"\"\"\\n        center_lat = None\\n        center_lon = None\\n        center = data.get(\"center\")\\n        if isinstance(center, dict):\\n            center_lat = center.get(\"lat\")\\n            center_lon = center.get(\"lon\")\\n            if center_lat is None or center_lon is None:\\n                raise ValueError(\"Unable to get lat or lon of way center.\")\\n            center_lat = Decimal(center_lat)\\n            center_lon = Decimal(center_lon)\\n        return center_lat, center_lon\\n\\n    @classmethod\\n    def get_center_from_xml_dom(cls, sub_child: xml.etree.ElementTree.Element) -> Tuple[Decimal, Decimal]:\\n        center_lat_str: str = sub_child.attrib.get(\"lat\")\\n        center_lon_str: str = sub_child.attrib.get(\"lon\")\\n        if center_lat_str is None or center_lon_str is None:\\n            raise ValueError(\"Unable to get lat or lon of way center.\")\\n        center_lat = Decimal(center_lat_str)\\n        center_lon = Decimal(center_lon_str)\\n        return center_lat, center_lon\\n\\n    @classmethod\\n    def from_json(cls: Type[ElementTypeVar], data: dict, result: Optional[Result] = None) -> ElementTypeVar:\\n        \"\"\"\\n        Create new Element() from json data\\n        :param data:\\n        :param result:\\n        :return:\\n        \"\"\"\\n        raise NotImplementedError\\n\\n    @classmethod\\n    def from_xml(\\n            cls: Type[ElementTypeVar],\\n            child: xml.etree.ElementTree.Element,\\n            result: Optional[Result] = None) -> ElementTypeVar:\\n        \"\"\"\\n        Create new Element() element from XML data\\n        \"\"\"\\n        raise NotImplementedError\\n\\n\\nclass Area(Element):\\n    \"\"\"\\n    Class to represent an element of type area\\n    \"\"\"\\n\\n    _type_value = \"area\"\\n\\n    def __init__(self, area_id: Optional[int] = None, **kwargs):\\n        \"\"\"\\n        :param area_id: Id of the area element\\n        :param kwargs: Additional arguments are passed directly to the parent class\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        #: The id of the way\\n        self.id = area_id\\n\\n    def __repr__(self) -> str:\\n        return f\"<overpy.Area id={self.id}>\"\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Area\":\\n        \"\"\"\\n        Create new Area element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Way\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        area_id = data.get(\"id\")\\n\\n        attributes = {}\\n        ignore = [\"id\", \"tags\", \"type\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(area_id=area_id, attributes=attributes, tags=tags, result=result)\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Area\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If the ref attribute of the xml node is not provided\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n\\n        area_id_str: Optional[str] = child.attrib.get(\"id\")\\n        area_id: Optional[int] = None\\n        if area_id_str is not None:\\n            area_id = int(area_id_str)\\n\\n        attributes = {}\\n        ignore = [\"id\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(area_id=area_id, attributes=attributes, tags=tags, result=result)\\n\\n\\nclass Node(Element):\\n    \"\"\"\\n    Class to represent an element of type node\\n    \"\"\"\\n\\n    _type_value = \"node\"\\n\\n    def __init__(\\n            self,\\n            node_id: Optional[int] = None,\\n            lat: Optional[Union[Decimal, float]] = None,\\n            lon: Optional[Union[Decimal, float]] = None,\\n            **kwargs):\\n        \"\"\"\\n        :param lat: Latitude\\n        :param lon: Longitude\\n        :param node_id: Id of the node element\\n        :param kwargs: Additional arguments are passed directly to the parent class\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        self.id = node_id\\n        self.lat = lat\\n        self.lon = lon\\n\\n    def __repr__(self) -> str:\\n        return f\"<overpy.Node id={self.id} lat={self.lat} lon={self.lon}>\"\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Node\":\\n        \"\"\"\\n        Create new Node element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Node\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        node_id = data.get(\"id\")\\n        lat = data.get(\"lat\")\\n        lon = data.get(\"lon\")\\n\\n        attributes = {}\\n        ignore = [\"type\", \"id\", \"lat\", \"lon\", \"tags\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(node_id=node_id, lat=lat, lon=lon, tags=tags, attributes=attributes, result=result)\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Node\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n\\n        node_id: Optional[int] = None\\n        node_id_str: Optional[str] = child.attrib.get(\"id\")\\n        if node_id_str is not None:\\n            node_id = int(node_id_str)\\n\\n        lat: Optional[Decimal] = None\\n        lat_str: Optional[str] = child.attrib.get(\"lat\")\\n        if lat_str is not None:\\n            lat = Decimal(lat_str)\\n\\n        lon: Optional[Decimal] = None\\n        lon_str: Optional[str] = child.attrib.get(\"lon\")\\n        if lon_str is not None:\\n            lon = Decimal(lon_str)\\n\\n        attributes = {}\\n        ignore = [\"id\", \"lat\", \"lon\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(node_id=node_id, lat=lat, lon=lon, tags=tags, attributes=attributes, result=result)\\n\\n\\nclass Way(Element):\\n    \"\"\"\\n    Class to represent an element of type way\\n    \"\"\"\\n\\n    _type_value = \"way\"\\n\\n    def __init__(\\n            self,\\n            way_id: Optional[int] = None,\\n            center_lat: Optional[Union[Decimal, float]] = None,\\n            center_lon: Optional[Union[Decimal, float]] = None,\\n            node_ids: Optional[Union[List[int], Tuple[int]]] = None,\\n            **kwargs):\\n        \"\"\"\\n        :param node_ids: List of node IDs\\n        :param way_id: Id of the way element\\n        :param kwargs: Additional arguments are passed directly to the parent class\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        #: The id of the way\\n        self.id = way_id\\n\\n        #: List of Ids of the associated nodes\\n        self._node_ids = node_ids\\n\\n        #: The lat/lon of the center of the way (optional depending on query)\\n        self.center_lat = center_lat\\n        self.center_lon = center_lon\\n\\n    def __repr__(self):\\n        return f\"<overpy.Way id={self.id} nodes={self._node_ids}>\"\\n\\n    @property\\n    def nodes(self) -> List[Node]:\\n        \"\"\"\\n        List of nodes associated with the way.\\n        \"\"\"\\n        return self.get_nodes()\\n\\n    def get_nodes(self, resolve_missing: bool = False) -> List[Node]:\\n        \"\"\"\\n        Get the nodes defining the geometry of the way\\n\\n        :param resolve_missing: Try to resolve missing nodes.\\n        :return: List of nodes\\n        :raises overpy.exception.DataIncomplete: At least one referenced node is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and at least one node can\\'t be resolved.\\n        \"\"\"\\n        result = []\\n        resolved = False\\n\\n        for node_id in self._node_ids:\\n            try:\\n                node = self._result.get_node(node_id)\\n            except exception.DataIncomplete:\\n                node = None\\n\\n            if node is not None:\\n                result.append(node)\\n                continue\\n\\n            if not resolve_missing:\\n                raise exception.DataIncomplete(\"Resolve missing nodes is disabled\")\\n\\n            # We tried to resolve the data but some nodes are still missing\\n            if resolved:\\n                raise exception.DataIncomplete(\"Unable to resolve all nodes\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"way({way_id});\\\\n\"\\n                     \"node(w);\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                way_id=self.id\\n            )\\n            tmp_result = self._result.api.query(query)\\n            self._result.expand(tmp_result)\\n            resolved = True\\n\\n            try:\\n                node = self._result.get_node(node_id)\\n            except exception.DataIncomplete:\\n                node = None\\n\\n            if node is None:\\n                raise exception.DataIncomplete(\"Unable to resolve all nodes\")\\n\\n            result.append(node)\\n\\n        return result\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Way\":\\n        \"\"\"\\n        Create new Way element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Way\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        way_id = data.get(\"id\")\\n        node_ids = data.get(\"nodes\")\\n        (center_lat, center_lon) = cls.get_center_from_json(data=data)\\n\\n        attributes = {}\\n        ignore = [\"center\", \"id\", \"nodes\", \"tags\", \"type\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(\\n            attributes=attributes,\\n            center_lat=center_lat,\\n            center_lon=center_lon,\\n            node_ids=node_ids,\\n            tags=tags,\\n            result=result,\\n            way_id=way_id\\n        )\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Way\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If the ref attribute of the xml node is not provided\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n        node_ids = []\\n        center_lat = None\\n        center_lon = None\\n\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n            if sub_child.tag.lower() == \"nd\":\\n                ref_id_str = sub_child.attrib.get(\"ref\")\\n                if ref_id_str is None:\\n                    raise ValueError(\"Unable to find required ref value.\")\\n                ref_id: int = int(ref_id_str)\\n                node_ids.append(ref_id)\\n            if sub_child.tag.lower() == \"center\":\\n                (center_lat, center_lon) = cls.get_center_from_xml_dom(sub_child=sub_child)\\n\\n        way_id: Optional[int] = None\\n        way_id_str: Optional[str] = child.attrib.get(\"id\")\\n        if way_id_str is not None:\\n            way_id = int(way_id_str)\\n\\n        attributes = {}\\n        ignore = [\"id\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(way_id=way_id, center_lat=center_lat, center_lon=center_lon,\\n                   attributes=attributes, node_ids=node_ids, tags=tags, result=result)\\n\\n\\nclass Relation(Element):\\n    \"\"\"\\n    Class to represent an element of type relation\\n    \"\"\"\\n\\n    _type_value = \"relation\"\\n\\n    def __init__(\\n            self,\\n            rel_id: Optional[int] = None,\\n            center_lat: Optional[Union[Decimal, float]] = None,\\n            center_lon: Optional[Union[Decimal, float]] = None,\\n            members: Optional[List[\"RelationMember\"]] = None,\\n            **kwargs):\\n        \"\"\"\\n        :param members:\\n        :param rel_id: Id of the relation element\\n        :param kwargs:\\n        :return:\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        self.id = rel_id\\n        self.members = members\\n\\n        #: The lat/lon of the center of the way (optional depending on query)\\n        self.center_lat = center_lat\\n        self.center_lon = center_lon\\n\\n    def __repr__(self):\\n        return f\"<overpy.Relation id={self.id}>\"\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Relation\":\\n        \"\"\"\\n        Create new Relation element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Relation\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        rel_id = data.get(\"id\")\\n        (center_lat, center_lon) = cls.get_center_from_json(data=data)\\n\\n        members = []\\n\\n        supported_members = [RelationNode, RelationWay, RelationRelation]\\n        for member in data.get(\"members\", []):\\n            type_value = member.get(\"type\")\\n            for member_cls in supported_members:\\n                if member_cls._type_value == type_value:\\n                    members.append(\\n                        member_cls.from_json(\\n                            member,\\n                            result=result\\n                        )\\n                    )\\n\\n        attributes = {}\\n        ignore = [\"id\", \"members\", \"tags\", \"type\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(\\n            rel_id=rel_id,\\n            attributes=attributes,\\n            center_lat=center_lat,\\n            center_lon=center_lon,\\n            members=members,\\n            tags=tags,\\n            result=result\\n        )\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Relation\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n        members = []\\n        center_lat = None\\n        center_lon = None\\n\\n        supported_members = [RelationNode, RelationWay, RelationRelation, RelationArea]\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n            if sub_child.tag.lower() == \"member\":\\n                type_value = sub_child.attrib.get(\"type\")\\n                for member_cls in supported_members:\\n                    if member_cls._type_value == type_value:\\n                        members.append(\\n                            member_cls.from_xml(\\n                                sub_child,\\n                                result=result\\n                            )\\n                        )\\n            if sub_child.tag.lower() == \"center\":\\n                (center_lat, center_lon) = cls.get_center_from_xml_dom(sub_child=sub_child)\\n\\n        rel_id: Optional[int] = None\\n        rel_id_str: Optional[str] = child.attrib.get(\"id\")\\n        if rel_id_str is not None:\\n            rel_id = int(rel_id_str)\\n\\n        attributes = {}\\n        ignore = [\"id\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(\\n            rel_id=rel_id,\\n            attributes=attributes,\\n            center_lat=center_lat,\\n            center_lon=center_lon,\\n            members=members,\\n            tags=tags,\\n            result=result\\n        )\\n\\n\\nclass RelationMember:\\n    \"\"\"\\n    Base class to represent a member of a relation.\\n    \"\"\"\\n    _type_value: Optional[str] = None\\n\\n    def __init__(\\n            self,\\n            attributes: Optional[dict] = None,\\n            geometry: Optional[List[\"RelationWayGeometryValue\"]] = None,\\n            ref: Optional[int] = None,\\n            role: Optional[str] = None,\\n            result: Optional[Result] = None):\\n        \"\"\"\\n        :param ref: Reference Id\\n        :type ref: Integer\\n        :param role: The role of the relation member\\n        :type role: String\\n        :param result:\\n        \"\"\"\\n        self.ref = ref\\n        self._result = result\\n        self.role = role\\n        self.attributes = attributes\\n        self.geometry = geometry\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"RelationMember\":\\n        \"\"\"\\n        Create new RelationMember element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of RelationMember\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        ref = data.get(\"ref\")\\n        role = data.get(\"role\")\\n\\n        attributes = {}\\n        ignore = [\"geometry\", \"type\", \"ref\", \"role\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        geometry = data.get(\"geometry\")\\n        if isinstance(geometry, list):\\n            geometry_orig = geometry\\n            geometry = []\\n            for v in geometry_orig:\\n                geometry.append(\\n                    RelationWayGeometryValue(\\n                        lat=v.get(\"lat\"),\\n                        lon=v.get(\"lon\")\\n                    )\\n                )\\n        else:\\n            geometry = None\\n\\n        return cls(\\n            attributes=attributes,\\n            geometry=geometry,\\n            ref=ref,\\n            role=role,\\n            result=result\\n        )\\n\\n    @classmethod\\n    def from_xml(\\n            cls,\\n            child: xml.etree.ElementTree.Element,\\n            result: Optional[Result] = None) -> \"RelationMember\":\\n        \"\"\"\\n        Create new RelationMember from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this element belongs to\\n        :return: New relation member oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        \"\"\"\\n        if child.attrib.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        ref: Optional[int] = None\\n        ref_str: Optional[str] = child.attrib.get(\"ref\")\\n        if ref_str is not None:\\n            ref = int(ref_str)\\n\\n        role: Optional[str] = child.attrib.get(\"role\")\\n\\n        attributes = {}\\n        ignore = [\"geometry\", \"ref\", \"role\", \"type\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        geometry = None\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"nd\":\\n                if geometry is None:\\n                    geometry = []\\n                geometry.append(\\n                    RelationWayGeometryValue(\\n                        lat=Decimal(sub_child.attrib[\"lat\"]),\\n                        lon=Decimal(sub_child.attrib[\"lon\"])\\n                    )\\n                )\\n\\n        return cls(\\n            attributes=attributes,\\n            geometry=geometry,\\n            ref=ref,\\n            role=role,\\n            result=result\\n        )\\n\\n\\nclass RelationNode(RelationMember):\\n    _type_value = \"node\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Node:\\n        return self._result.get_node(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationNode ref={self.ref} role={self.role}>\"\\n\\n\\nclass RelationWay(RelationMember):\\n    _type_value = \"way\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Way:\\n        return self._result.get_way(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationWay ref={self.ref} role={self.role}>\"\\n\\n\\nclass RelationWayGeometryValue:\\n    def __init__(self, lat: Union[Decimal, float], lon: Union[Decimal, float]):\\n        self.lat = lat\\n        self.lon = lon\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationWayGeometryValue lat={self.lat} lon={self.lon}>\"\\n\\n\\nclass RelationRelation(RelationMember):\\n    _type_value = \"relation\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Relation:\\n        return self._result.get_relation(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationRelation ref={self.ref} role={self.role}>\"\\n\\n\\nclass RelationArea(RelationMember):\\n    _type_value = \"area\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Area:\\n        return self._result.get_area(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationArea ref={self.ref} role={self.role}>\"\\n\\n\\nclass OSMSAXHandler(handler.ContentHandler):\\n    \"\"\"\\n    SAX parser for Overpass XML response.\\n    \"\"\"\\n    #: Tuple of opening elements to ignore\\n    ignore_start: ClassVar = (\\'osm\\', \\'meta\\', \\'note\\', \\'bounds\\', \\'remark\\')\\n    #: Tuple of closing elements to ignore\\n    ignore_end: ClassVar = (\\'osm\\', \\'meta\\', \\'note\\', \\'bounds\\', \\'remark\\', \\'tag\\', \\'nd\\', \\'center\\')\\n\\n    def __init__(self, result: Result):\\n        \"\"\"\\n        :param result: Append results to this result set.\\n        \"\"\"\\n        handler.ContentHandler.__init__(self)\\n        self._result = result\\n        self._curr: Dict[str, Any] = {}\\n        #: Current relation member object\\n        self.cur_relation_member: Optional[RelationMember] = None\\n\\n    def startElement(self, name: str, attrs: dict):\\n        \"\"\"\\n        Handle opening elements.\\n\\n        :param name: Name of the element\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        if name in self.ignore_start:\\n            return\\n        try:\\n            handler = getattr(self, \\'_handle_start_%s\\' % name)\\n        except AttributeError:\\n            raise KeyError(\"Unknown element start \\'%s\\'\" % name)\\n        handler(attrs)\\n\\n    def endElement(self, name: str):\\n        \"\"\"\\n        Handle closing elements\\n\\n        :param name: Name of the element\\n        \"\"\"\\n        if name in self.ignore_end:\\n            return\\n        try:\\n            handler = getattr(self, \\'_handle_end_%s\\' % name)\\n        except AttributeError:\\n            raise KeyError(\"Unknown element end \\'%s\\'\" % name)\\n        handler()\\n\\n    def _handle_start_center(self, attrs: dict):\\n        \"\"\"\\n        Handle opening center element\\n\\n        :param attrs: Attributes of the element\\n        :type attrs: Dict\\n        \"\"\"\\n        center_lat = attrs.get(\"lat\")\\n        center_lon = attrs.get(\"lon\")\\n        if center_lat is None or center_lon is None:\\n            raise ValueError(\"Unable to get lat or lon of way center.\")\\n        self._curr[\"center_lat\"] = Decimal(center_lat)\\n        self._curr[\"center_lon\"] = Decimal(center_lon)\\n\\n    def _handle_start_tag(self, attrs: dict):\\n        \"\"\"\\n        Handle opening tag element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        try:\\n            tag_key = attrs[\\'k\\']\\n        except KeyError:\\n            raise ValueError(\"Tag without name/key.\")\\n        self._curr[\\'tags\\'][tag_key] = attrs.get(\\'v\\')\\n\\n    def _handle_start_node(self, attrs: dict):\\n        \"\"\"\\n        Handle opening node element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'attributes\\': dict(attrs),\\n            \\'lat\\': None,\\n            \\'lon\\': None,\\n            \\'node_id\\': None,\\n            \\'tags\\': {}\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'node_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n        if attrs.get(\\'lat\\', None) is not None:\\n            self._curr[\\'lat\\'] = Decimal(attrs[\\'lat\\'])\\n            del self._curr[\\'attributes\\'][\\'lat\\']\\n        if attrs.get(\\'lon\\', None) is not None:\\n            self._curr[\\'lon\\'] = Decimal(attrs[\\'lon\\'])\\n            del self._curr[\\'attributes\\'][\\'lon\\']\\n\\n    def _handle_end_node(self):\\n        \"\"\"\\n        Handle closing node element\\n        \"\"\"\\n        self._result.append(Node(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_way(self, attrs: dict):\\n        \"\"\"\\n        Handle opening way element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'center_lat\\': None,\\n            \\'center_lon\\': None,\\n            \\'attributes\\': dict(attrs),\\n            \\'node_ids\\': [],\\n            \\'tags\\': {},\\n            \\'way_id\\': None\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'way_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n\\n    def _handle_end_way(self):\\n        \"\"\"\\n        Handle closing way element\\n        \"\"\"\\n        self._result.append(Way(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_area(self, attrs: dict):\\n        \"\"\"\\n        Handle opening area element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'attributes\\': dict(attrs),\\n            \\'tags\\': {},\\n            \\'area_id\\': None\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'area_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n\\n    def _handle_end_area(self):\\n        \"\"\"\\n        Handle closing area element\\n        \"\"\"\\n        self._result.append(Area(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_nd(self, attrs: dict):\\n        \"\"\"\\n        Handle opening nd element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        if isinstance(self.cur_relation_member, RelationWay):\\n            if self.cur_relation_member.geometry is None:\\n                self.cur_relation_member.geometry = []\\n            self.cur_relation_member.geometry.append(\\n                RelationWayGeometryValue(\\n                    lat=Decimal(attrs[\"lat\"]),\\n                    lon=Decimal(attrs[\"lon\"])\\n                )\\n            )\\n        else:\\n            try:\\n                node_ref = attrs[\\'ref\\']\\n            except KeyError:\\n                raise ValueError(\"Unable to find required ref value.\")\\n            self._curr[\\'node_ids\\'].append(int(node_ref))\\n\\n    def _handle_start_relation(self, attrs: dict):\\n        \"\"\"\\n        Handle opening relation element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'attributes\\': dict(attrs),\\n            \\'members\\': [],\\n            \\'rel_id\\': None,\\n            \\'tags\\': {}\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'rel_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n\\n    def _handle_end_relation(self):\\n        \"\"\"\\n        Handle closing relation element\\n        \"\"\"\\n        self._result.append(Relation(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_member(self, attrs: dict):\\n        \"\"\"\\n        Handle opening member element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n\\n        params: Dict[str, Any] = {\\n            # ToDo: Parse attributes\\n            \\'attributes\\': {},\\n            \\'ref\\': None,\\n            \\'result\\': self._result,\\n            \\'role\\': None\\n        }\\n        if attrs.get(\\'ref\\', None):\\n            params[\\'ref\\'] = int(attrs[\\'ref\\'])\\n        if attrs.get(\\'role\\', None):\\n            params[\\'role\\'] = attrs[\\'role\\']\\n\\n        cls_map = {\\n            \"area\": RelationArea,\\n            \"node\": RelationNode,\\n            \"relation\": RelationRelation,\\n            \"way\": RelationWay\\n        }\\n        cls: Type[RelationMember] = cls_map.get(attrs[\"type\"])\\n        if cls is None:\\n            raise ValueError(\"Undefined type for member: \\'%s\\'\" % attrs[\\'type\\'])\\n\\n        self.cur_relation_member = cls(**params)\\n        self._curr[\\'members\\'].append(self.cur_relation_member)\\n\\n    def _handle_end_member(self):\\n        self.cur_relation_member = None\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/exception.py'"}, "return_value": "'class OverPyException(Exception):\\n    \"\"\"OverPy base exception\"\"\"\\n    pass\\n\\n\\nclass DataIncomplete(OverPyException):\\n    \"\"\"\\n    Raised if the requested data isn\\'t available in the result.\\n    Try to improve the query or to resolve the missing data.\\n    \"\"\"\\n    def __init__(self, *args, **kwargs):\\n        OverPyException.__init__(\\n            self,\\n            \"Data incomplete try to improve the query to resolve the missing data\",\\n            *args,\\n            **kwargs\\n        )\\n\\n\\nclass ElementDataWrongType(OverPyException):\\n    \"\"\"\\n    Raised if the provided element does not match the expected type.\\n\\n    :param type_expected: The expected element type\\n    :type type_expected: String\\n    :param type_provided: The provided element type\\n    :type type_provided: String|None\\n    \"\"\"\\n    def __init__(self, type_expected, type_provided=None):\\n        self.type_expected = type_expected\\n        self.type_provided = type_provided\\n\\n    def __str__(self) -> str:\\n        return \"Type expected \\'{}\\' but \\'{}\\' provided\".format(\\n            self.type_expected,\\n            str(self.type_provided)\\n        )\\n\\n\\nclass MaxRetriesReached(OverPyException):\\n    \"\"\"\\n    Raised if max retries reached and the Overpass server didn\\'t respond with a result.\\n    \"\"\"\\n    def __init__(self, retry_count, exceptions):\\n        self.exceptions = exceptions\\n        self.retry_count = retry_count\\n\\n    def __str__(self) -> str:\\n        return \"Unable get any result from the Overpass API server after %d retries.\" % self.retry_count\\n\\n\\nclass OverpassBadRequest(OverPyException):\\n    \"\"\"\\n    Raised if the Overpass API service returns a syntax error.\\n\\n    :param query: The encoded query how it was send to the server\\n    :type query: Bytes\\n    :param msgs: List of error messages\\n    :type msgs: List\\n    \"\"\"\\n    def __init__(self, query, msgs=None):\\n        self.query = query\\n        if msgs is None:\\n            msgs = []\\n        self.msgs = msgs\\n\\n    def __str__(self) -> str:\\n        tmp_msgs = []\\n        for tmp_msg in self.msgs:\\n            if not isinstance(tmp_msg, str):\\n                tmp_msg = str(tmp_msg)\\n            tmp_msgs.append(tmp_msg)\\n\\n        return \"\\\\n\".join(tmp_msgs)\\n\\n\\nclass OverpassError(OverPyException):\\n    \"\"\"\\n    Base exception to report errors if the response returns a remark tag or element.\\n\\n    .. note::\\n        If you are not sure which of the subexceptions you should use, use this one and try to parse the message.\\n\\n        For more information have a look at https://github.com/DinoTools/python-overpy/issues/62\\n\\n    :param str msg: The message from the remark tag or element\\n    \"\"\"\\n    def __init__(self, msg=None):\\n        #: The message from the remark tag or element\\n        self.msg = msg\\n\\n    def __str__(self) -> str:\\n        if self.msg is None:\\n            return \"No error message provided\"\\n        if not isinstance(self.msg, str):\\n            return str(self.msg)\\n        return self.msg\\n\\n\\nclass OverpassGatewayTimeout(OverPyException):\\n    \"\"\"\\n    Raised if load of the Overpass API service is too high and it can\\'t handle the request.\\n    \"\"\"\\n    def __init__(self):\\n        OverPyException.__init__(self, \"Server load too high\")\\n\\n\\nclass OverpassRuntimeError(OverpassError):\\n    \"\"\"\\n    Raised if the server returns a remark-tag(xml) or remark element(json) with a message starting with\\n    \\'runtime error:\\'.\\n    \"\"\"\\n    pass\\n\\n\\nclass OverpassRuntimeRemark(OverpassError):\\n    \"\"\"\\n    Raised if the server returns a remark-tag(xml) or remark element(json) with a message starting with\\n    \\'runtime remark:\\'.\\n    \"\"\"\\n    pass\\n\\n\\nclass OverpassTooManyRequests(OverPyException):\\n    \"\"\"\\n    Raised if the Overpass API service returns a 429 status code.\\n    \"\"\"\\n    def __init__(self):\\n        OverPyException.__init__(self, \"Too many requests\")\\n\\n\\nclass OverpassUnknownContentType(OverPyException):\\n    \"\"\"\\n    Raised if the reported content type isn\\'t handled by OverPy.\\n\\n    :param content_type: The reported content type\\n    :type content_type: None or String\\n    \"\"\"\\n    def __init__(self, content_type):\\n        self.content_type = content_type\\n\\n    def __str__(self) -> str:\\n        if self.content_type is None:\\n            return \"No content type returned\"\\n        return \"Unknown content type: %s\" % self.content_type\\n\\n\\nclass OverpassUnknownError(OverpassError):\\n    \"\"\"\\n    Raised if the server returns a remark-tag(xml) or remark element(json) and we are unable to find any reason.\\n    \"\"\"\\n    pass\\n\\n\\nclass OverpassUnknownHTTPStatusCode(OverPyException):\\n    \"\"\"\\n    Raised if the returned HTTP status code isn\\'t handled by OverPy.\\n\\n    :param code: The HTTP status code\\n    :type code: Integer\\n    \"\"\"\\n    def __init__(self, code):\\n        self.code = code\\n\\n    def __str__(self) -> str:\\n        return \"Unknown/Unhandled status code: %d\" % self.code\\n'"}, {"func_args": {"filename": "'/usr/app/src/test_repos/python-overpy/overpy/helper.py'"}, "return_value": "'from typing import List, Optional\\n__author__ = \\'mjob\\'\\n\\nimport overpy\\n\\n\\ndef get_street(\\n        street: str,\\n        areacode: str,\\n        api: Optional[overpy.Overpass] = None) -> overpy.Result:\\n    \"\"\"\\n    Retrieve streets in a given bounding area\\n\\n    :param street: Name of street\\n    :param areacode: The OSM id of the bounding area\\n    :param api: API object to fetch missing elements\\n    :return: Parsed result\\n    :raises overpy.exception.OverPyException: If something bad happens.\\n    \"\"\"\\n    if api is None:\\n        api = overpy.Overpass()\\n\\n    query = \"\"\"\\n        area(%s)->.location;\\n        (\\n            way[highway][name=\"%s\"](area.location);\\n            - (\\n                way[highway=service](area.location);\\n                way[highway=track](area.location);\\n            );\\n        );\\n        out body;\\n        >;\\n        out skel qt;\\n    \"\"\"\\n\\n    data = api.query(query % (areacode, street))\\n\\n    return data\\n\\n\\ndef get_intersection(\\n        street1: str,\\n        street2: str,\\n        areacode: str,\\n        api: Optional[overpy.Overpass] = None) -> List[overpy.Node]:\\n    \"\"\"\\n    Retrieve intersection of two streets in a given bounding area\\n\\n    :param street1: Name of first street of intersection\\n    :param street2: Name of second street of intersection\\n    :param areacode: The OSM id of the bounding area\\n    :param api: API object to fetch missing elements\\n    :return: List of intersections\\n    :raises overpy.exception.OverPyException: If something bad happens.\\n    \"\"\"\\n    if api is None:\\n        api = overpy.Overpass()\\n\\n    query = \"\"\"\\n        area(%s)->.location;\\n        (\\n            way[highway][name=\"%s\"](area.location); node(w)->.n1;\\n            way[highway][name=\"%s\"](area.location); node(w)->.n2;\\n        );\\n        node.n1.n2;\\n        out meta;\\n    \"\"\"\\n\\n    data = api.query(query % (areacode, street1, street2))\\n\\n    return data.get_nodes()\\n'"}]}, "normalize_mark_list": {"line": 355, "args": [{"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}, {"func_args": {"mark_list": "[]"}, "return_value": "[]"}], "text": "def normalize_mark_list(mark_list: Iterable[Union[Mark, MarkDecorator]]) -> List[Mark]:\n    \"\"\"Normalize marker decorating helpers to mark objects.\n\n    :type List[Union[Mark, Markdecorator]] mark_list:\n    :rtype: List[Mark]\n    \"\"\"\n    extracted = [\n        getattr(mark, \"mark\", mark) for mark in mark_list\n    ]  # unpack MarkDecorator\n    for mark in extracted:\n        if not isinstance(mark, Mark):\n            raise TypeError(f\"got {mark!r} instead of Mark\")\n    return [x for x in extracted if isinstance(x, Mark)]"}, "iterparentnodeids": {"line": 44, "args": [{"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_element_data_wrong_type'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_element_data_wrong_type'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_element_data_wrong_type'"}, "return_value": "'tests/test_exception.py'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_element_data_wrong_type'"}, "return_value": "'tests/test_exception.py::TestExceptions'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_element_data_wrong_type'"}, "return_value": "'tests/test_exception.py::TestExceptions::test_element_data_wrong_type'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_element_data_wrong_type'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_bad_request'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_bad_request'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_bad_request'"}, "return_value": "'tests/test_exception.py'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_bad_request'"}, "return_value": "'tests/test_exception.py::TestExceptions'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_bad_request'"}, "return_value": "'tests/test_exception.py::TestExceptions::test_overpass_bad_request'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_bad_request'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_content_type'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_content_type'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_content_type'"}, "return_value": "'tests/test_exception.py'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_content_type'"}, "return_value": "'tests/test_exception.py::TestExceptions'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_content_type'"}, "return_value": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_content_type'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_content_type'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_http_status_code'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_http_status_code'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_http_status_code'"}, "return_value": "'tests/test_exception.py'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_http_status_code'"}, "return_value": "'tests/test_exception.py::TestExceptions'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_http_status_code'"}, "return_value": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_http_status_code'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_http_status_code'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_error'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_error'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_error'"}, "return_value": "'tests/test_exception.py'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_error'"}, "return_value": "'tests/test_exception.py::TestExceptions'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_error'"}, "return_value": "'tests/test_exception.py::TestExceptions::test_overpass_error'"}, {"func_args": {"nodeid": "'tests/test_exception.py::TestExceptions::test_overpass_error'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_json.py::TestAreas::test_area01'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_json.py::TestAreas::test_area01'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestAreas::test_area01'"}, "return_value": "'tests/test_json.py'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestAreas::test_area01'"}, "return_value": "'tests/test_json.py::TestAreas'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestAreas::test_area01'"}, "return_value": "'tests/test_json.py::TestAreas::test_area01'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestAreas::test_area01'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_json.py::TestNodes::test_node01'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_json.py::TestNodes::test_node01'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestNodes::test_node01'"}, "return_value": "'tests/test_json.py'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestNodes::test_node01'"}, "return_value": "'tests/test_json.py::TestNodes'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestNodes::test_node01'"}, "return_value": "'tests/test_json.py::TestNodes::test_node01'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestNodes::test_node01'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation01'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation01'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation01'"}, "return_value": "'tests/test_json.py'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation01'"}, "return_value": "'tests/test_json.py::TestRelation'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation01'"}, "return_value": "'tests/test_json.py::TestRelation::test_relation01'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation01'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation02'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation02'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation02'"}, "return_value": "'tests/test_json.py'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation02'"}, "return_value": "'tests/test_json.py::TestRelation'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation02'"}, "return_value": "'tests/test_json.py::TestRelation::test_relation02'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation02'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation03'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation03'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation03'"}, "return_value": "'tests/test_json.py'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation03'"}, "return_value": "'tests/test_json.py::TestRelation'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation03'"}, "return_value": "'tests/test_json.py::TestRelation::test_relation03'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation03'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation04'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation04'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation04'"}, "return_value": "'tests/test_json.py'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation04'"}, "return_value": "'tests/test_json.py::TestRelation'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation04'"}, "return_value": "'tests/test_json.py::TestRelation::test_relation04'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRelation::test_relation04'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way01'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way01'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way01'"}, "return_value": "'tests/test_json.py'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way01'"}, "return_value": "'tests/test_json.py::TestWay'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way01'"}, "return_value": "'tests/test_json.py::TestWay::test_way01'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way01'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way02'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way02'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way02'"}, "return_value": "'tests/test_json.py'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way02'"}, "return_value": "'tests/test_json.py::TestWay'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way02'"}, "return_value": "'tests/test_json.py::TestWay::test_way02'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way02'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way03'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way03'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way03'"}, "return_value": "'tests/test_json.py'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way03'"}, "return_value": "'tests/test_json.py::TestWay'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way03'"}, "return_value": "'tests/test_json.py::TestWay::test_way03'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way03'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way04'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way04'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way04'"}, "return_value": "'tests/test_json.py'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way04'"}, "return_value": "'tests/test_json.py::TestWay'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way04'"}, "return_value": "'tests/test_json.py::TestWay::test_way04'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestWay::test_way04'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_json.py::TestDataError::test_element_wrong_type'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_json.py::TestDataError::test_element_wrong_type'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestDataError::test_element_wrong_type'"}, "return_value": "'tests/test_json.py'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestDataError::test_element_wrong_type'"}, "return_value": "'tests/test_json.py::TestDataError'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestDataError::test_element_wrong_type'"}, "return_value": "'tests/test_json.py::TestDataError::test_element_wrong_type'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestDataError::test_element_wrong_type'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_runtime_error'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_runtime_error'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_runtime_error'"}, "return_value": "'tests/test_json.py'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_runtime_error'"}, "return_value": "'tests/test_json.py::TestRemark'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_runtime_error'"}, "return_value": "'tests/test_json.py::TestRemark::test_remark_runtime_error'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_runtime_error'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_runtime_remark'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_runtime_remark'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_runtime_remark'"}, "return_value": "'tests/test_json.py'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_runtime_remark'"}, "return_value": "'tests/test_json.py::TestRemark'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_runtime_remark'"}, "return_value": "'tests/test_json.py::TestRemark::test_remark_runtime_remark'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_runtime_remark'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_unknown'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_unknown'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_unknown'"}, "return_value": "'tests/test_json.py'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_unknown'"}, "return_value": "'tests/test_json.py::TestRemark'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_unknown'"}, "return_value": "'tests/test_json.py::TestRemark::test_remark_unknown'"}, {"func_args": {"nodeid": "'tests/test_json.py::TestRemark::test_remark_unknown'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_chunk_size'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_chunk_size'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_chunk_size'"}, "return_value": "'tests/test_request.py'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_chunk_size'"}, "return_value": "'tests/test_request.py::TestQuery'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_chunk_size'"}, "return_value": "'tests/test_request.py::TestQuery::test_chunk_size'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_chunk_size'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_syntax_error'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_syntax_error'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_syntax_error'"}, "return_value": "'tests/test_request.py'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_syntax_error'"}, "return_value": "'tests/test_request.py::TestQuery'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_syntax_error'"}, "return_value": "'tests/test_request.py::TestQuery::test_overpass_syntax_error'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_syntax_error'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_syntax_error_encoding_error'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_syntax_error_encoding_error'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_syntax_error_encoding_error'"}, "return_value": "'tests/test_request.py'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_syntax_error_encoding_error'"}, "return_value": "'tests/test_request.py::TestQuery'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_syntax_error_encoding_error'"}, "return_value": "'tests/test_request.py::TestQuery::test_overpass_syntax_error_encoding_error'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_syntax_error_encoding_error'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_too_many_requests'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_too_many_requests'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_too_many_requests'"}, "return_value": "'tests/test_request.py'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_too_many_requests'"}, "return_value": "'tests/test_request.py::TestQuery'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_too_many_requests'"}, "return_value": "'tests/test_request.py::TestQuery::test_overpass_too_many_requests'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_too_many_requests'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_gateway_timeout'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_gateway_timeout'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_gateway_timeout'"}, "return_value": "'tests/test_request.py'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_gateway_timeout'"}, "return_value": "'tests/test_request.py::TestQuery'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_gateway_timeout'"}, "return_value": "'tests/test_request.py::TestQuery::test_overpass_gateway_timeout'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_gateway_timeout'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_unknown_status_code'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_unknown_status_code'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_unknown_status_code'"}, "return_value": "'tests/test_request.py'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_unknown_status_code'"}, "return_value": "'tests/test_request.py::TestQuery'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_unknown_status_code'"}, "return_value": "'tests/test_request.py::TestQuery::test_overpass_unknown_status_code'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_overpass_unknown_status_code'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_json'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_json'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_json'"}, "return_value": "'tests/test_request.py'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_json'"}, "return_value": "'tests/test_request.py::TestQuery'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_json'"}, "return_value": "'tests/test_request.py::TestQuery::test_response_json'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_json'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_unknown'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_unknown'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_unknown'"}, "return_value": "'tests/test_request.py'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_unknown'"}, "return_value": "'tests/test_request.py::TestQuery'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_unknown'"}, "return_value": "'tests/test_request.py::TestQuery::test_response_unknown'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_unknown'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_xml'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_xml'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_xml'"}, "return_value": "'tests/test_request.py'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_xml'"}, "return_value": "'tests/test_request.py::TestQuery'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_xml'"}, "return_value": "'tests/test_request.py::TestQuery::test_response_xml'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_response_xml'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_retry'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_retry'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_retry'"}, "return_value": "'tests/test_request.py'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_retry'"}, "return_value": "'tests/test_request.py::TestQuery'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_retry'"}, "return_value": "'tests/test_request.py::TestQuery::test_retry'"}, {"func_args": {"nodeid": "'tests/test_request.py::TestQuery::test_retry'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_result.py::TestResult::test_expand_error'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_result.py::TestResult::test_expand_error'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestResult::test_expand_error'"}, "return_value": "'tests/test_result.py'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestResult::test_expand_error'"}, "return_value": "'tests/test_result.py::TestResult'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestResult::test_expand_error'"}, "return_value": "'tests/test_result.py::TestResult::test_expand_error'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestResult::test_expand_error'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_result.py::TestResult::test_expand_01'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_result.py::TestResult::test_expand_01'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestResult::test_expand_01'"}, "return_value": "'tests/test_result.py'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestResult::test_expand_01'"}, "return_value": "'tests/test_result.py::TestResult'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestResult::test_expand_01'"}, "return_value": "'tests/test_result.py::TestResult::test_expand_01'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestResult::test_expand_01'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_result.py::TestArea::test_missing_unresolvable'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_result.py::TestArea::test_missing_unresolvable'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestArea::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestArea::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py::TestArea'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestArea::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py::TestArea::test_missing_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestArea::test_missing_unresolvable'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_result.py::TestArea::test_missing_resolvable'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_result.py::TestArea::test_missing_resolvable'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestArea::test_missing_resolvable'"}, "return_value": "'tests/test_result.py'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestArea::test_missing_resolvable'"}, "return_value": "'tests/test_result.py::TestArea'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestArea::test_missing_resolvable'"}, "return_value": "'tests/test_result.py::TestArea::test_missing_resolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestArea::test_missing_resolvable'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_result.py::TestNode::test_missing_unresolvable'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_result.py::TestNode::test_missing_unresolvable'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestNode::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestNode::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py::TestNode'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestNode::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py::TestNode::test_missing_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestNode::test_missing_unresolvable'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_result.py::TestNode::test_missing_resolvable'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_result.py::TestNode::test_missing_resolvable'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestNode::test_missing_resolvable'"}, "return_value": "'tests/test_result.py'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestNode::test_missing_resolvable'"}, "return_value": "'tests/test_result.py::TestNode'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestNode::test_missing_resolvable'"}, "return_value": "'tests/test_result.py::TestNode::test_missing_resolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestNode::test_missing_resolvable'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_result.py::TestPickle::test_way02'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_result.py::TestPickle::test_way02'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestPickle::test_way02'"}, "return_value": "'tests/test_result.py'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestPickle::test_way02'"}, "return_value": "'tests/test_result.py::TestPickle'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestPickle::test_way02'"}, "return_value": "'tests/test_result.py::TestPickle::test_way02'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestPickle::test_way02'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_result.py::TestRelation::test_missing_unresolvable'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_result.py::TestRelation::test_missing_unresolvable'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestRelation::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestRelation::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py::TestRelation'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestRelation::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py::TestRelation::test_missing_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestRelation::test_missing_unresolvable'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_result.py::TestRelation::test_missing_resolvable'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_result.py::TestRelation::test_missing_resolvable'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestRelation::test_missing_resolvable'"}, "return_value": "'tests/test_result.py'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestRelation::test_missing_resolvable'"}, "return_value": "'tests/test_result.py::TestRelation'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestRelation::test_missing_resolvable'"}, "return_value": "'tests/test_result.py::TestRelation::test_missing_resolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestRelation::test_missing_resolvable'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_result.py::TestWay::test_missing_unresolvable'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_result.py::TestWay::test_missing_unresolvable'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestWay::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestWay::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py::TestWay'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestWay::test_missing_unresolvable'"}, "return_value": "'tests/test_result.py::TestWay::test_missing_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestWay::test_missing_unresolvable'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_result.py::TestWay::test_missing_resolvable'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_result.py::TestWay::test_missing_resolvable'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestWay::test_missing_resolvable'"}, "return_value": "'tests/test_result.py'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestWay::test_missing_resolvable'"}, "return_value": "'tests/test_result.py::TestWay'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestWay::test_missing_resolvable'"}, "return_value": "'tests/test_result.py::TestWay::test_missing_resolvable'"}, {"func_args": {"nodeid": "'tests/test_result.py::TestWay::test_missing_resolvable'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_unresolvable'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_unresolvable'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_unresolvable'"}, "return_value": "'tests/test_result_way.py'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_unresolvable'"}, "return_value": "'tests/test_result_way.py::TestNodes'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_unresolvable'"}, "return_value": "'tests/test_result_way.py::TestNodes::test_missing_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_unresolvable'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_partly_unresolvable'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_partly_unresolvable'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_partly_unresolvable'"}, "return_value": "'tests/test_result_way.py'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_partly_unresolvable'"}, "return_value": "'tests/test_result_way.py::TestNodes'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_partly_unresolvable'"}, "return_value": "'tests/test_result_way.py::TestNodes::test_missing_partly_unresolvable'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_partly_unresolvable'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_resolvable'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_resolvable'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_resolvable'"}, "return_value": "'tests/test_result_way.py'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_resolvable'"}, "return_value": "'tests/test_result_way.py::TestNodes'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_resolvable'"}, "return_value": "'tests/test_result_way.py::TestNodes::test_missing_resolvable'"}, {"func_args": {"nodeid": "'tests/test_result_way.py::TestNodes::test_missing_resolvable'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestAreas::test_node01'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestAreas::test_node01'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestAreas::test_node01'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestAreas::test_node01'"}, "return_value": "'tests/test_xml.py::TestAreas'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestAreas::test_node01'"}, "return_value": "'tests/test_xml.py::TestAreas::test_node01'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestAreas::test_node01'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestNodes::test_node01'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestNodes::test_node01'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestNodes::test_node01'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestNodes::test_node01'"}, "return_value": "'tests/test_xml.py::TestNodes'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestNodes::test_node01'"}, "return_value": "'tests/test_xml.py::TestNodes::test_node01'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestNodes::test_node01'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation01'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation01'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation01'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation01'"}, "return_value": "'tests/test_xml.py::TestRelation'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation01'"}, "return_value": "'tests/test_xml.py::TestRelation::test_relation01'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation01'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation02'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation02'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation02'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation02'"}, "return_value": "'tests/test_xml.py::TestRelation'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation02'"}, "return_value": "'tests/test_xml.py::TestRelation::test_relation02'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation02'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation03'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation03'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation03'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation03'"}, "return_value": "'tests/test_xml.py::TestRelation'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation03'"}, "return_value": "'tests/test_xml.py::TestRelation::test_relation03'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation03'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation04'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation04'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation04'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation04'"}, "return_value": "'tests/test_xml.py::TestRelation'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation04'"}, "return_value": "'tests/test_xml.py::TestRelation::test_relation04'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRelation::test_relation04'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way01'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way01'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way01'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way01'"}, "return_value": "'tests/test_xml.py::TestWay'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way01'"}, "return_value": "'tests/test_xml.py::TestWay::test_way01'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way01'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way02'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way02'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way02'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way02'"}, "return_value": "'tests/test_xml.py::TestWay'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way02'"}, "return_value": "'tests/test_xml.py::TestWay::test_way02'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way02'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way03'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way03'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way03'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way03'"}, "return_value": "'tests/test_xml.py::TestWay'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way03'"}, "return_value": "'tests/test_xml.py::TestWay::test_way03'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way03'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way04'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way04'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way04'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way04'"}, "return_value": "'tests/test_xml.py::TestWay'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way04'"}, "return_value": "'tests/test_xml.py::TestWay::test_way04'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestWay::test_way04'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_element_wrong_type'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_element_wrong_type'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_element_wrong_type'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_element_wrong_type'"}, "return_value": "'tests/test_xml.py::TestDataError'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_element_wrong_type'"}, "return_value": "'tests/test_xml.py::TestDataError::test_element_wrong_type'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_element_wrong_type'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_node_missing_data'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_node_missing_data'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_node_missing_data'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_node_missing_data'"}, "return_value": "'tests/test_xml.py::TestDataError'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_node_missing_data'"}, "return_value": "'tests/test_xml.py::TestDataError::test_node_missing_data'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_node_missing_data'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_relation_missing_data'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_relation_missing_data'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_relation_missing_data'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_relation_missing_data'"}, "return_value": "'tests/test_xml.py::TestDataError'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_relation_missing_data'"}, "return_value": "'tests/test_xml.py::TestDataError::test_relation_missing_data'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_relation_missing_data'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_way_missing_data'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_way_missing_data'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_way_missing_data'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_way_missing_data'"}, "return_value": "'tests/test_xml.py::TestDataError'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_way_missing_data'"}, "return_value": "'tests/test_xml.py::TestDataError::test_way_missing_data'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestDataError::test_way_missing_data'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_exception'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_exception'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_exception'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_exception'"}, "return_value": "'tests/test_xml.py::TestParser'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_exception'"}, "return_value": "'tests/test_xml.py::TestParser::test_exception'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_exception'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_xml_element'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_xml_element'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_xml_element'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_xml_element'"}, "return_value": "'tests/test_xml.py::TestParser'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_xml_element'"}, "return_value": "'tests/test_xml.py::TestParser::test_xml_element'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_xml_element'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_xml_autodetect_parser'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_xml_autodetect_parser'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_xml_autodetect_parser'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_xml_autodetect_parser'"}, "return_value": "'tests/test_xml.py::TestParser'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_xml_autodetect_parser'"}, "return_value": "'tests/test_xml.py::TestParser::test_xml_autodetect_parser'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestParser::test_xml_autodetect_parser'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_runtime_error'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_runtime_error'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_runtime_error'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_runtime_error'"}, "return_value": "'tests/test_xml.py::TestRemark'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_runtime_error'"}, "return_value": "'tests/test_xml.py::TestRemark::test_remark_runtime_error'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_runtime_error'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_runtime_remark'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_runtime_remark'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_runtime_remark'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_runtime_remark'"}, "return_value": "'tests/test_xml.py::TestRemark'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_runtime_remark'"}, "return_value": "'tests/test_xml.py::TestRemark::test_remark_runtime_remark'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_runtime_remark'"}, "return_value": "None"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_unknown'"}, "return_value": "''"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_unknown'"}, "return_value": "'tests'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_unknown'"}, "return_value": "'tests/test_xml.py'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_unknown'"}, "return_value": "'tests/test_xml.py::TestRemark'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_unknown'"}, "return_value": "'tests/test_xml.py::TestRemark::test_remark_unknown'"}, {"func_args": {"nodeid": "'tests/test_xml.py::TestRemark::test_remark_unknown'"}, "return_value": "None"}], "text": "def iterparentnodeids(nodeid: str) -> Iterator[str]:\n    \"\"\"Return the parent node IDs of a given node ID, inclusive.\n\n    For the node ID\n\n        \"testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source\"\n\n    the result would be\n\n        \"\"\n        \"testing\"\n        \"testing/code\"\n        \"testing/code/test_excinfo.py\"\n        \"testing/code/test_excinfo.py::TestFormattedExcinfo\"\n        \"testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source\"\n\n    Note that :: parts are only considered at the last / component.\n    \"\"\"\n    pos = 0\n    sep = SEP\n    yield \"\"\n    while True:\n        at = nodeid.find(sep, pos)\n        if at == -1 and sep == SEP:\n            sep = \"::\"\n        elif at == -1:\n            if nodeid:\n                yield nodeid\n            break\n        else:\n            if at:\n                yield nodeid[:at]\n            pos = at + len(sep)"}, "wcswidth": {"line": 43, "args": [{"func_args": {"s": "''"}, "return_value": "0"}, {"func_args": {"s": "'tests/test_exception.py::TestExceptions::test_element_data_wrong_type PASSED'"}, "return_value": "76"}, {"func_args": {"s": "'tests/test_exception.py::TestExceptions::test_overpass_bad_request PASSED'"}, "return_value": "73"}, {"func_args": {"s": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_content_type PASSED'"}, "return_value": "82"}, {"func_args": {"s": "'tests/test_exception.py::TestExceptions::test_overpass_unknown_http_status_code PASSED'"}, "return_value": "86"}, {"func_args": {"s": "'tests/test_exception.py::TestExceptions::test_overpass_error PASSED'"}, "return_value": "67"}, {"func_args": {"s": "'tests/test_json.py::TestAreas::test_area01 PASSED'"}, "return_value": "49"}, {"func_args": {"s": "'tests/test_json.py::TestNodes::test_node01 PASSED'"}, "return_value": "49"}, {"func_args": {"s": "'tests/test_json.py::TestRelation::test_relation01 PASSED'"}, "return_value": "56"}, {"func_args": {"s": "'tests/test_json.py::TestRelation::test_relation02 PASSED'"}, "return_value": "56"}, {"func_args": {"s": "'tests/test_json.py::TestRelation::test_relation03 PASSED'"}, "return_value": "56"}, {"func_args": {"s": "'tests/test_json.py::TestRelation::test_relation04 PASSED'"}, "return_value": "56"}, {"func_args": {"s": "'tests/test_json.py::TestWay::test_way01 PASSED'"}, "return_value": "46"}, {"func_args": {"s": "'tests/test_json.py::TestWay::test_way02 PASSED'"}, "return_value": "46"}, {"func_args": {"s": "'tests/test_json.py::TestWay::test_way03 PASSED'"}, "return_value": "46"}, {"func_args": {"s": "'tests/test_json.py::TestWay::test_way04 PASSED'"}, "return_value": "46"}, {"func_args": {"s": "'tests/test_json.py::TestDataError::test_element_wrong_type PASSED'"}, "return_value": "65"}, {"func_args": {"s": "'tests/test_json.py::TestRemark::test_remark_runtime_error PASSED'"}, "return_value": "64"}, {"func_args": {"s": "'tests/test_json.py::TestRemark::test_remark_runtime_remark PASSED'"}, "return_value": "65"}, {"func_args": {"s": "'tests/test_json.py::TestRemark::test_remark_unknown PASSED'"}, "return_value": "58"}, {"func_args": {"s": "'tests/test_request.py::TestQuery::test_chunk_size PASSED'"}, "return_value": "56"}, {"func_args": {"s": "'tests/test_request.py::TestQuery::test_overpass_syntax_error PASSED'"}, "return_value": "67"}, {"func_args": {"s": "'tests/test_request.py::TestQuery::test_overpass_syntax_error_encoding_error PASSED'"}, "return_value": "82"}, {"func_args": {"s": "'tests/test_request.py::TestQuery::test_overpass_too_many_requests PASSED'"}, "return_value": "72"}, {"func_args": {"s": "'tests/test_request.py::TestQuery::test_overpass_gateway_timeout PASSED'"}, "return_value": "70"}, {"func_args": {"s": "'tests/test_request.py::TestQuery::test_overpass_unknown_status_code PASSED'"}, "return_value": "74"}, {"func_args": {"s": "'tests/test_request.py::TestQuery::test_response_json PASSED'"}, "return_value": "59"}, {"func_args": {"s": "'tests/test_request.py::TestQuery::test_response_unknown PASSED'"}, "return_value": "62"}, {"func_args": {"s": "'tests/test_request.py::TestQuery::test_response_xml PASSED'"}, "return_value": "58"}, {"func_args": {"s": "'tests/test_request.py::TestQuery::test_retry PASSED'"}, "return_value": "51"}, {"func_args": {"s": "'tests/test_result.py::TestResult::test_expand_error PASSED'"}, "return_value": "58"}, {"func_args": {"s": "'tests/test_result.py::TestResult::test_expand_01 PASSED'"}, "return_value": "55"}, {"func_args": {"s": "'tests/test_result.py::TestArea::test_missing_unresolvable PASSED'"}, "return_value": "64"}, {"func_args": {"s": "'tests/test_result.py::TestArea::test_missing_resolvable PASSED'"}, "return_value": "62"}, {"func_args": {"s": "'tests/test_result.py::TestNode::test_missing_unresolvable PASSED'"}, "return_value": "64"}, {"func_args": {"s": "'tests/test_result.py::TestNode::test_missing_resolvable PASSED'"}, "return_value": "62"}, {"func_args": {"s": "'tests/test_result.py::TestPickle::test_way02 PASSED'"}, "return_value": "51"}, {"func_args": {"s": "'tests/test_result.py::TestRelation::test_missing_unresolvable PASSED'"}, "return_value": "68"}, {"func_args": {"s": "'tests/test_result.py::TestRelation::test_missing_resolvable PASSED'"}, "return_value": "66"}, {"func_args": {"s": "'tests/test_result.py::TestWay::test_missing_unresolvable PASSED'"}, "return_value": "63"}, {"func_args": {"s": "'tests/test_result.py::TestWay::test_missing_resolvable PASSED'"}, "return_value": "61"}, {"func_args": {"s": "'tests/test_result_way.py::TestNodes::test_missing_unresolvable PASSED'"}, "return_value": "69"}, {"func_args": {"s": "'tests/test_result_way.py::TestNodes::test_missing_partly_unresolvable PASSED'"}, "return_value": "76"}, {"func_args": {"s": "'tests/test_result_way.py::TestNodes::test_missing_resolvable PASSED'"}, "return_value": "67"}, {"func_args": {"s": "'tests/test_xml.py::TestAreas::test_node01 PASSED'"}, "return_value": "48"}, {"func_args": {"s": "'tests/test_xml.py::TestNodes::test_node01 PASSED'"}, "return_value": "48"}, {"func_args": {"s": "'tests/test_xml.py::TestRelation::test_relation01 PASSED'"}, "return_value": "55"}, {"func_args": {"s": "'tests/test_xml.py::TestRelation::test_relation02 PASSED'"}, "return_value": "55"}, {"func_args": {"s": "'tests/test_xml.py::TestRelation::test_relation03 PASSED'"}, "return_value": "55"}, {"func_args": {"s": "'tests/test_xml.py::TestRelation::test_relation04 PASSED'"}, "return_value": "55"}, {"func_args": {"s": "'tests/test_xml.py::TestWay::test_way01 PASSED'"}, "return_value": "45"}, {"func_args": {"s": "'tests/test_xml.py::TestWay::test_way02 PASSED'"}, "return_value": "45"}, {"func_args": {"s": "'tests/test_xml.py::TestWay::test_way03 PASSED'"}, "return_value": "45"}, {"func_args": {"s": "'tests/test_xml.py::TestWay::test_way04 PASSED'"}, "return_value": "45"}, {"func_args": {"s": "'tests/test_xml.py::TestDataError::test_element_wrong_type PASSED'"}, "return_value": "64"}, {"func_args": {"s": "'tests/test_xml.py::TestDataError::test_node_missing_data PASSED'"}, "return_value": "63"}, {"func_args": {"s": "'tests/test_xml.py::TestDataError::test_relation_missing_data PASSED'"}, "return_value": "67"}, {"func_args": {"s": "'tests/test_xml.py::TestDataError::test_way_missing_data PASSED'"}, "return_value": "62"}, {"func_args": {"s": "'tests/test_xml.py::TestParser::test_exception PASSED'"}, "return_value": "52"}, {"func_args": {"s": "'tests/test_xml.py::TestParser::test_xml_element PASSED'"}, "return_value": "54"}, {"func_args": {"s": "'tests/test_xml.py::TestParser::test_xml_autodetect_parser PASSED'"}, "return_value": "64"}, {"func_args": {"s": "'tests/test_xml.py::TestRemark::test_remark_runtime_error PASSED'"}, "return_value": "63"}, {"func_args": {"s": "'tests/test_xml.py::TestRemark::test_remark_runtime_remark PASSED'"}, "return_value": "64"}, {"func_args": {"s": "'tests/test_xml.py::TestRemark::test_remark_unknown PASSED'"}, "return_value": "57"}], "text": "def wcswidth(s: str) -> int:\n    \"\"\"Determine how many columns are needed to display a string in a terminal.\n\n    Returns -1 if the string contains non-printable characters.\n    \"\"\"\n    width = 0\n    for c in unicodedata.normalize(\"NFC\", s):\n        wc = wcwidth(c)\n        if wc < 0:\n            return -1\n        width += wc\n    return width"}, "wcwidth": {"line": 4, "args": [{"func_args": {"c": "'t'"}, "return_value": "1"}, {"func_args": {"c": "'e'"}, "return_value": "1"}, {"func_args": {"c": "'s'"}, "return_value": "1"}, {"func_args": {"c": "'/'"}, "return_value": "1"}, {"func_args": {"c": "'_'"}, "return_value": "1"}, {"func_args": {"c": "'x'"}, "return_value": "1"}, {"func_args": {"c": "'c'"}, "return_value": "1"}, {"func_args": {"c": "'p'"}, "return_value": "1"}, {"func_args": {"c": "'i'"}, "return_value": "1"}, {"func_args": {"c": "'o'"}, "return_value": "1"}, {"func_args": {"c": "'n'"}, "return_value": "1"}, {"func_args": {"c": "'.'"}, "return_value": "1"}, {"func_args": {"c": "'y'"}, "return_value": "1"}, {"func_args": {"c": "':'"}, "return_value": "1"}, {"func_args": {"c": "'T'"}, "return_value": "1"}, {"func_args": {"c": "'E'"}, "return_value": "1"}, {"func_args": {"c": "'l'"}, "return_value": "1"}, {"func_args": {"c": "'m'"}, "return_value": "1"}, {"func_args": {"c": "'d'"}, "return_value": "1"}, {"func_args": {"c": "'a'"}, "return_value": "1"}, {"func_args": {"c": "'w'"}, "return_value": "1"}, {"func_args": {"c": "'r'"}, "return_value": "1"}, {"func_args": {"c": "'g'"}, "return_value": "1"}, {"func_args": {"c": "' '"}, "return_value": "1"}, {"func_args": {"c": "'P'"}, "return_value": "1"}, {"func_args": {"c": "'A'"}, "return_value": "1"}, {"func_args": {"c": "'S'"}, "return_value": "1"}, {"func_args": {"c": "'D'"}, "return_value": "1"}, {"func_args": {"c": "'v'"}, "return_value": "1"}, {"func_args": {"c": "'b'"}, "return_value": "1"}, {"func_args": {"c": "'q'"}, "return_value": "1"}, {"func_args": {"c": "'u'"}, "return_value": "1"}, {"func_args": {"c": "'k'"}, "return_value": "1"}, {"func_args": {"c": "'h'"}, "return_value": "1"}, {"func_args": {"c": "'j'"}, "return_value": "1"}, {"func_args": {"c": "'0'"}, "return_value": "1"}, {"func_args": {"c": "'1'"}, "return_value": "1"}, {"func_args": {"c": "'N'"}, "return_value": "1"}, {"func_args": {"c": "'R'"}, "return_value": "1"}, {"func_args": {"c": "'2'"}, "return_value": "1"}, {"func_args": {"c": "'3'"}, "return_value": "1"}, {"func_args": {"c": "'4'"}, "return_value": "1"}, {"func_args": {"c": "'W'"}, "return_value": "1"}, {"func_args": {"c": "'Q'"}, "return_value": "1"}, {"func_args": {"c": "'z'"}, "return_value": "1"}]}, "read_file": {"line": 27, "args": [{"func_args": {"filename": "'json/area-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2016-11-22T21:04:02Z\",\\n    \"timestamp_areas_base\": \"2016-11-22T20:25:03Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n\\n{\\n  \"type\": \"area\",\\n  \"id\": 2448756446,\\n  \"tags\": {\\n    \"addr:city\": \"Troisdorf\",\\n    \"addr:postcode\": \"53840\",\\n    \"area\": \"yes\",\\n    \"description\": \"Troisdorf Bahnsteig Gleis 9\",\\n    \"name\": \"Troisdorf\",\\n    \"public_transport\": \"platform\",\\n    \"railway\": \"platform\",\\n    \"ref\": \"9\",\\n    \"train\": \"yes\",\\n    \"wheelchair\": \"no\",\\n    \"wheelchair:description\": \"Plattformlift ist vorhanden, Betriebsbereitschaft nach 8 Jahren stillstand fraglich.\",\\n    \"width\": \"5\"\\n  }\\n}\\n,\\n{\\n  \"type\": \"area\",\\n  \"id\": 3600055060,\\n  \"tags\": {\\n    \"TMC:cid_58:tabcd_1:Class\": \"Area\",\\n    \"TMC:cid_58:tabcd_1:LCLversion\": \"8.00\",\\n    \"TMC:cid_58:tabcd_1:LocationCode\": \"2550\",\\n    \"admin_level\": \"8\",\\n    \"boundary\": \"administrative\",\\n    \"de:amtlicher_gemeindeschluessel\": \"05382068\",\\n    \"de:place\": \"town\",\\n    \"de:regionalschluessel\": \"053820068068\",\\n    \"name\": \"Troisdorf\",\\n    \"name:prefix\": \"Stadt\",\\n    \"type\": \"boundary\",\\n    \"wikidata\": \"Q3900\",\\n    \"wikipedia\": \"de:Troisdorf\"\\n  }\\n}\\n,\\n{\\n  \"type\": \"area\",\\n  \"id\": 3605945175,\\n  \"tags\": {\\n    \"addr:city\": \"Troisdorf\",\\n    \"addr:postcode\": \"53840\",\\n    \"description\": \"Troisdorf Bahnsteig Gleis 1+2\",\\n    \"local_ref\": \"1;2\",\\n    \"name\": \"Troisdorf\",\\n    \"public_transport\": \"platform\",\\n    \"railway\": \"platform\",\\n    \"ref\": \"1/2\",\\n    \"tactile_paving\": \"yes\",\\n    \"train\": \"yes\",\\n    \"type\": \"multipolygon\",\\n    \"wheelchair\": \"yes\"\\n  }\\n}\\n,\\n{\\n  \"type\": \"area\",\\n  \"id\": 3605945176,\\n  \"tags\": {\\n    \"addr:city\": \"Troisdorf\",\\n    \"addr:postcode\": \"53840\",\\n    \"description\": \"Troisdorf Bahnsteig Gleis 5+6\",\\n    \"name\": \"Troisdorf\",\\n    \"phone\": \"+49 221 1411055\",\\n    \"public_transport\": \"platform\",\\n    \"railway\": \"platform\",\\n    \"ref\": \"5/6\",\\n    \"tactile_paving\": \"yes\",\\n    \"train\": \"yes\",\\n    \"type\": \"multipolygon\",\\n    \"wheelchair\": \"yes\",\\n    \"wheelchair:description\": \"Der Aufzug zu diesem Bahnsteig ist oft defekt, bitte informieren. Betriebszustand kann bei 3S-Zentrale erfragt werden (siehe Telefonnummer, aber Vorsicht, die sind nicht immer informiert!)\",\\n    \"width\": \"6\"\\n  }\\n}\\n\\n\\n  ]\\n}\\n'"}, {"func_args": {"filename": "'json/node-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T12:58:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n\\n{\\n  \"type\": \"node\",\\n  \"id\": 50878400,\\n  \"lat\": 50.7461788,\\n  \"lon\": 7.1742257\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 100793192,\\n  \"lat\": 50.7468472,\\n  \"lon\": 7.1709376,\\n  \"tags\": {\\n    \"highway\": \"turning_circle\"\\n  }\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854234,\\n  \"lat\": 50.7494236,\\n  \"lon\": 7.1757664,\\n  \"timestamp\": \"2014-12-14T07:27:19Z\",\\n  \"version\": 1,\\n  \"changeset\": 23456789,\\n  \"user\": \"TestUser\",\\n  \"uid\": 345678\\n}\\n  ]\\n}'"}, {"func_args": {"filename": "'json/relation-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-21T20:00:03Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"relation\",\\n      \"id\": 2046898,\\n      \"timestamp\": \"2014-12-15T13:13:11Z\",\\n      \"version\": 12,\\n      \"changeset\": 17433822,\\n      \"user\": \"Username\",\\n      \"uid\": 12345,\\n      \"members\": [\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 507464632,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 2252681768,\\n          \"role\": \"stop\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 507464636,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 1620886108,\\n          \"role\": \"stop\"\\n        },\\n        {\\n          \"type\": \"way\",\\n          \"ref\": 4893348,\\n          \"role\": \"\"\\n        }\\n      ],\\n      \"tags\": {\\n        \"from\": \"Here\",\\n        \"name\": \"Test relation\",\\n        \"ref\": \"609\",\\n        \"route\": \"bus\",\\n        \"to\": \"There\",\\n        \"type\": \"route\"\\n      }\\n    }\\n  ]\\n}\\n'"}, {"func_args": {"filename": "'json/relation-02.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854234,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854235,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146078,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234,\\n        3233854235\\n      ]\\n    },\\n    {\\n      \"type\": \"relation\",\\n      \"id\": 2046898,\\n      \"timestamp\": \"2014-12-15T13:13:11Z\",\\n      \"version\": 12,\\n      \"changeset\": 17433822,\\n      \"user\": \"Username\",\\n      \"uid\": 12345,\\n      \"members\": [\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854233,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854234,\\n          \"role\": \"stop\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854235,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"way\",\\n          \"ref\": 317146078,\\n          \"role\": \"\"\\n        }\\n      ],\\n      \"tags\": {\\n        \"from\": \"Here\",\\n        \"name\": \"Test relation\",\\n        \"ref\": \"609\",\\n        \"route\": \"bus\",\\n        \"to\": \"There\",\\n        \"type\": \"route\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/relation-03.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2016-11-23T20:28:03Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n\\n{\\n  \"type\": \"relation\",\\n  \"id\": 23092,\\n  \"center\": {\\n    \"lat\": 50.8176646,\\n    \"lon\": 7.0208539\\n  },\\n  \"members\": [\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 4334856,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 234434903,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 37881522,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 37881521,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 4356491,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235363211,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 48290877,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 210683519,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 42743961,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 210683522,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 48290881,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235363214,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 4400137,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 230940375,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 4400140,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 4400142,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235824476,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 4400143,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235824475,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 178797123,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 233553030,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 4829989,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 99834112,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 133081219,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 234434905,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 20661567,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 230941900,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 20661568,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 20661572,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 230940374,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 20661573,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 20662817,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 230941903,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 20662819,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 20662824,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 20662827,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 27492515,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 129125122,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 234434901,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 234434904,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 27492542,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 27492543,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 29233646,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235820561,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 29233647,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235820559,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235820562,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 29233648,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 29382960,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008229,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008238,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008230,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008226,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 40033062,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 40033063,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 29384561,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 29384563,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008224,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008227,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008237,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008232,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008239,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 29384564,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31282638,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31282787,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 383262762,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31304443,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 128541594,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31304503,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31363881,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31363891,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31363892,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31363898,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31363910,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364152,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364158,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364178,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364384,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364387,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364484,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364512,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364656,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364667,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008234,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364888,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 122158730,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364985,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008235,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008231,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008233,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31365377,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31365425,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008236,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 36447898,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008228,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31366812,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31366880,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31367017,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31367443,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31367449,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31367526,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31367534,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31369852,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 449397558,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31797389,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31798039,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235363212,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 156492546,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 156492545,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 130749935,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 32472877,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31798988,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31798989,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235820560,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235820563,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235820564,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235820570,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 32472855,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 32472856,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 37881520,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 37881519,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 234434902,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 32472875,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 32473071,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 128522486,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 36447896,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 32473075,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 32473086,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 32473087,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 40033064,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 189189059,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008225,\\n      \"role\": \"\"\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 41550921,\\n      \"role\": \"\"\\n    }\\n  ],\\n  \"tags\": {\\n    \"TMC:cid_58:tabcd_1:Class\": \"Road\",\\n    \"TMC:cid_58:tabcd_1:LCLversion\": \"8.00\",\\n    \"TMC:cid_58:tabcd_1:LocationCode\": \"7142\",\\n    \"name\": \"Bundesautobahn 555\",\\n    \"network\": \"BAB\",\\n    \"operator\": \"Bundesrepublik Deutschland\",\\n    \"ref\": \"A 555\",\\n    \"route\": \"road\",\\n    \"type\": \"route\",\\n    \"wikipedia\": \"de:Bundesautobahn 555\"\\n  }\\n}\\n\\n  ]\\n}\\n'"}, {"func_args": {"filename": "'json/relation-04.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2016-11-24T21:40:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n\\n{\\n  \"type\": \"relation\",\\n  \"id\": 23092,\\n  \"bounds\": {\\n    \"minlat\": 50.7432318,\\n    \"minlon\": 6.9639432,\\n    \"maxlat\": 50.8920975,\\n    \"maxlon\": 7.0777645\\n  },\\n  \"members\": [\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 4334856,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8104598, \"lon\": 6.9871803 },\\n         { \"lat\": 50.8117239, \"lon\": 6.9849282 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 234434903,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8117239, \"lon\": 6.9849282 },\\n         { \"lat\": 50.8137408, \"lon\": 6.9813352 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 37881522,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8137408, \"lon\": 6.9813352 },\\n         { \"lat\": 50.8140146, \"lon\": 6.9808445 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 37881521,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8140146, \"lon\": 6.9808445 },\\n         { \"lat\": 50.8193541, \"lon\": 6.9713457 },\\n         { \"lat\": 50.8203182, \"lon\": 6.9697248 },\\n         { \"lat\": 50.8210652, \"lon\": 6.9685758 },\\n         { \"lat\": 50.8217885, \"lon\": 6.9676136 },\\n         { \"lat\": 50.8225495, \"lon\": 6.9667439 },\\n         { \"lat\": 50.8233005, \"lon\": 6.9660515 },\\n         { \"lat\": 50.8238128, \"lon\": 6.9656463 },\\n         { \"lat\": 50.8243279, \"lon\": 6.9653077 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 4356491,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7433997, \"lon\": 7.0777645 },\\n         { \"lat\": 50.7434097, \"lon\": 7.0775890 },\\n         { \"lat\": 50.7434629, \"lon\": 7.0774402 },\\n         { \"lat\": 50.7435198, \"lon\": 7.0773718 },\\n         { \"lat\": 50.7437507, \"lon\": 7.0771524 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235363211,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7437507, \"lon\": 7.0771524 },\\n         { \"lat\": 50.7446592, \"lon\": 7.0762926 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 48290877,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7446592, \"lon\": 7.0762926 },\\n         { \"lat\": 50.7450803, \"lon\": 7.0757571 },\\n         { \"lat\": 50.7453888, \"lon\": 7.0753312 },\\n         { \"lat\": 50.7457125, \"lon\": 7.0748518 },\\n         { \"lat\": 50.7460370, \"lon\": 7.0743265 },\\n         { \"lat\": 50.7462718, \"lon\": 7.0739425 },\\n         { \"lat\": 50.7464798, \"lon\": 7.0735173 },\\n         { \"lat\": 50.7468359, \"lon\": 7.0727449 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 210683519,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7468359, \"lon\": 7.0727449 },\\n         { \"lat\": 50.7471006, \"lon\": 7.0720546 },\\n         { \"lat\": 50.7473135, \"lon\": 7.0714640 },\\n         { \"lat\": 50.7475199, \"lon\": 7.0708095 },\\n         { \"lat\": 50.7479418, \"lon\": 7.0693723 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 42743961,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7464112, \"lon\": 7.0734310 },\\n         { \"lat\": 50.7459053, \"lon\": 7.0743560 },\\n         { \"lat\": 50.7457638, \"lon\": 7.0745740 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 210683522,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7457638, \"lon\": 7.0745740 },\\n         { \"lat\": 50.7456300, \"lon\": 7.0747409 },\\n         { \"lat\": 50.7454858, \"lon\": 7.0749187 },\\n         { \"lat\": 50.7452550, \"lon\": 7.0752554 },\\n         { \"lat\": 50.7450000, \"lon\": 7.0756385 },\\n         { \"lat\": 50.7448878, \"lon\": 7.0758027 },\\n         { \"lat\": 50.7447522, \"lon\": 7.0759730 },\\n         { \"lat\": 50.7445514, \"lon\": 7.0762032 },\\n         { \"lat\": 50.7443577, \"lon\": 7.0764098 },\\n         { \"lat\": 50.7441185, \"lon\": 7.0766490 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 48290881,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7441185, \"lon\": 7.0766490 },\\n         { \"lat\": 50.7439033, \"lon\": 7.0768575 },\\n         { \"lat\": 50.7437722, \"lon\": 7.0769631 },\\n         { \"lat\": 50.7436609, \"lon\": 7.0770394 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235363214,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7436609, \"lon\": 7.0770394 },\\n         { \"lat\": 50.7435688, \"lon\": 7.0771154 },\\n         { \"lat\": 50.7434662, \"lon\": 7.0771906 },\\n         { \"lat\": 50.7434058, \"lon\": 7.0772230 },\\n         { \"lat\": 50.7433331, \"lon\": 7.0772525 },\\n         { \"lat\": 50.7432822, \"lon\": 7.0772636 },\\n         { \"lat\": 50.7432318, \"lon\": 7.0772601 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 4400137,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8887155, \"lon\": 6.9676900 },\\n         { \"lat\": 50.8876384, \"lon\": 6.9678150 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 230940375,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8876384, \"lon\": 6.9678150 },\\n         { \"lat\": 50.8870572, \"lon\": 6.9679058 },\\n         { \"lat\": 50.8858563, \"lon\": 6.9680103 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 4400140,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8797318, \"lon\": 6.9690108 },\\n         { \"lat\": 50.8799208, \"lon\": 6.9689396 },\\n         { \"lat\": 50.8807058, \"lon\": 6.9688470 },\\n         { \"lat\": 50.8824762, \"lon\": 6.9687068 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 4400142,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8919691, \"lon\": 6.9670292 },\\n         { \"lat\": 50.8918982, \"lon\": 6.9671419 },\\n         { \"lat\": 50.8918068, \"lon\": 6.9672404 },\\n         { \"lat\": 50.8917186, \"lon\": 6.9673001 },\\n         { \"lat\": 50.8916153, \"lon\": 6.9673480 },\\n         { \"lat\": 50.8914588, \"lon\": 6.9673816 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235824476,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8914588, \"lon\": 6.9673816 },\\n         { \"lat\": 50.8892470, \"lon\": 6.9676302 },\\n         { \"lat\": 50.8887155, \"lon\": 6.9676900 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 4400143,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8887787, \"lon\": 6.9681629 },\\n         { \"lat\": 50.8896224, \"lon\": 6.9680604 },\\n         { \"lat\": 50.8897525, \"lon\": 6.9680446 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235824475,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8897525, \"lon\": 6.9680446 },\\n         { \"lat\": 50.8906556, \"lon\": 6.9679349 },\\n         { \"lat\": 50.8912013, \"lon\": 6.9678862 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 178797123,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8912013, \"lon\": 6.9678862 },\\n         { \"lat\": 50.8913492, \"lon\": 6.9678648 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 233553030,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8913492, \"lon\": 6.9678648 },\\n         { \"lat\": 50.8916648, \"lon\": 6.9677762 },\\n         { \"lat\": 50.8917895, \"lon\": 6.9677694 },\\n         { \"lat\": 50.8919294, \"lon\": 6.9677947 },\\n         { \"lat\": 50.8920975, \"lon\": 6.9678618 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 4829989,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8105743, \"lon\": 6.9865001 },\\n         { \"lat\": 50.8088268, \"lon\": 6.9896207 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 99834112,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8088268, \"lon\": 6.9896207 },\\n         { \"lat\": 50.8066272, \"lon\": 6.9935457 },\\n         { \"lat\": 50.8057165, \"lon\": 6.9951151 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 133081219,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8057165, \"lon\": 6.9951151 },\\n         { \"lat\": 50.8050332, \"lon\": 6.9962100 },\\n         { \"lat\": 50.8043133, \"lon\": 6.9972614 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 234434905,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8043133, \"lon\": 6.9972614 },\\n         { \"lat\": 50.8038004, \"lon\": 6.9979304 },\\n         { \"lat\": 50.8032120, \"lon\": 6.9986363 },\\n         { \"lat\": 50.8029818, \"lon\": 6.9989181 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 20661567,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8849681, \"lon\": 6.9681126 },\\n         { \"lat\": 50.8839667, \"lon\": 6.9682524 },\\n         { \"lat\": 50.8829770, \"lon\": 6.9684059 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 230941900,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8829770, \"lon\": 6.9684059 },\\n         { \"lat\": 50.8826286, \"lon\": 6.9684595 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 20661568,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8850872, \"lon\": 6.9685052 },\\n         { \"lat\": 50.8859127, \"lon\": 6.9684079 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 20661572,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8859127, \"lon\": 6.9684079 },\\n         { \"lat\": 50.8872823, \"lon\": 6.9682592 },\\n         { \"lat\": 50.8876807, \"lon\": 6.9682539 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 230940374,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8876807, \"lon\": 6.9682539 },\\n         { \"lat\": 50.8887787, \"lon\": 6.9681629 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 20661573,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8858563, \"lon\": 6.9680103 },\\n         { \"lat\": 50.8849681, \"lon\": 6.9681126 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 20662817,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8823655, \"lon\": 6.9684998 },\\n         { \"lat\": 50.8806620, \"lon\": 6.9686453 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 230941903,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8806620, \"lon\": 6.9686453 },\\n         { \"lat\": 50.8793943, \"lon\": 6.9687847 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 20662819,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8824762, \"lon\": 6.9687068 },\\n         { \"lat\": 50.8827522, \"lon\": 6.9686901 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 20662824,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8827522, \"lon\": 6.9686901 },\\n         { \"lat\": 50.8839133, \"lon\": 6.9686122 },\\n         { \"lat\": 50.8850872, \"lon\": 6.9685052 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 20662827,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8826286, \"lon\": 6.9684595 },\\n         { \"lat\": 50.8823655, \"lon\": 6.9684998 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 27492515,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8029818, \"lon\": 6.9989181 },\\n         { \"lat\": 50.8026288, \"lon\": 6.9992932 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 129125122,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8093979, \"lon\": 6.9890430 },\\n         { \"lat\": 50.8104598, \"lon\": 6.9871803 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 234434901,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8063753, \"lon\": 6.9944172 },\\n         { \"lat\": 50.8093979, \"lon\": 6.9890430 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 234434904,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8053262, \"lon\": 6.9961817 },\\n         { \"lat\": 50.8058108, \"lon\": 6.9953914 },\\n         { \"lat\": 50.8063753, \"lon\": 6.9944172 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 27492542,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8029899, \"lon\": 6.9991939 },\\n         { \"lat\": 50.8032828, \"lon\": 6.9988807 },\\n         { \"lat\": 50.8038702, \"lon\": 6.9982129 },\\n         { \"lat\": 50.8044350, \"lon\": 6.9974695 },\\n         { \"lat\": 50.8053262, \"lon\": 6.9961817 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 27492543,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8026483, \"lon\": 6.9995590 },\\n         { \"lat\": 50.8029899, \"lon\": 6.9991939 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 29233646,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8793943, \"lon\": 6.9687847 },\\n         { \"lat\": 50.8716935, \"lon\": 6.9696241 },\\n         { \"lat\": 50.8701666, \"lon\": 6.9697243 },\\n         { \"lat\": 50.8688585, \"lon\": 6.9697057 },\\n         { \"lat\": 50.8652424, \"lon\": 6.9693872 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235820561,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8652424, \"lon\": 6.9693872 },\\n         { \"lat\": 50.8636340, \"lon\": 6.9692339 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 29233647,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8636340, \"lon\": 6.9692339 },\\n         { \"lat\": 50.8608791, \"lon\": 6.9689787 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235820559,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8608791, \"lon\": 6.9689787 },\\n         { \"lat\": 50.8590168, \"lon\": 6.9688055 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235820562,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8590168, \"lon\": 6.9688055 },\\n         { \"lat\": 50.8523854, \"lon\": 6.9681888 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 29233648,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8522171, \"lon\": 6.9684787 },\\n         { \"lat\": 50.8590359, \"lon\": 6.9691023 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 29382960,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8391695, \"lon\": 6.9667285 },\\n         { \"lat\": 50.8411491, \"lon\": 6.9672118 },\\n         { \"lat\": 50.8425706, \"lon\": 6.9674985 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008229,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8425706, \"lon\": 6.9674985 },\\n         { \"lat\": 50.8443277, \"lon\": 6.9677563 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008238,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8443277, \"lon\": 6.9677563 },\\n         { \"lat\": 50.8453254, \"lon\": 6.9678465 },\\n         { \"lat\": 50.8468114, \"lon\": 6.9679862 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008230,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8468114, \"lon\": 6.9679862 },\\n         { \"lat\": 50.8491169, \"lon\": 6.9681907 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008226,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8491169, \"lon\": 6.9681907 },\\n         { \"lat\": 50.8518181, \"lon\": 6.9684403 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 40033062,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8391857, \"lon\": 6.9664246 },\\n         { \"lat\": 50.8386690, \"lon\": 6.9662911 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 40033063,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8386690, \"lon\": 6.9662911 },\\n         { \"lat\": 50.8314332, \"lon\": 6.9644546 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 29384561,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8523854, \"lon\": 6.9681888 },\\n         { \"lat\": 50.8519590, \"lon\": 6.9681595 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 29384563,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8519590, \"lon\": 6.9681595 },\\n         { \"lat\": 50.8506534, \"lon\": 6.9680320 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008224,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8506534, \"lon\": 6.9680320 },\\n         { \"lat\": 50.8490308, \"lon\": 6.9678717 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008227,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8490308, \"lon\": 6.9678717 },\\n         { \"lat\": 50.8478121, \"lon\": 6.9677589 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008237,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8478121, \"lon\": 6.9677589 },\\n         { \"lat\": 50.8459552, \"lon\": 6.9676249 },\\n         { \"lat\": 50.8451822, \"lon\": 6.9675256 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008232,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8451822, \"lon\": 6.9675256 },\\n         { \"lat\": 50.8433946, \"lon\": 6.9673373 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008239,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8433946, \"lon\": 6.9673373 },\\n         { \"lat\": 50.8424071, \"lon\": 6.9671724 },\\n         { \"lat\": 50.8411984, \"lon\": 6.9669289 },\\n         { \"lat\": 50.8391857, \"lon\": 6.9664246 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 29384564,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8518181, \"lon\": 6.9684403 },\\n         { \"lat\": 50.8522171, \"lon\": 6.9684787 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31282638,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7547305, \"lon\": 7.0468957 },\\n         { \"lat\": 50.7550333, \"lon\": 7.0462257 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31282787,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7548175, \"lon\": 7.0462659 },\\n         { \"lat\": 50.7545192, \"lon\": 7.0469416 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 383262762,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7545192, \"lon\": 7.0469416 },\\n         { \"lat\": 50.7522859, \"lon\": 7.0519784 },\\n         { \"lat\": 50.7519030, \"lon\": 7.0528750 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31304443,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7519030, \"lon\": 7.0528750 },\\n         { \"lat\": 50.7514373, \"lon\": 7.0540731 },\\n         { \"lat\": 50.7512408, \"lon\": 7.0546346 },\\n         { \"lat\": 50.7511231, \"lon\": 7.0549962 },\\n         { \"lat\": 50.7508172, \"lon\": 7.0560135 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 128541594,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7508172, \"lon\": 7.0560135 },\\n         { \"lat\": 50.7504938, \"lon\": 7.0572440 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31304503,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7509429, \"lon\": 7.0561605 },\\n         { \"lat\": 50.7512483, \"lon\": 7.0551357 },\\n         { \"lat\": 50.7513759, \"lon\": 7.0547500 },\\n         { \"lat\": 50.7515670, \"lon\": 7.0542197 },\\n         { \"lat\": 50.7520213, \"lon\": 7.0530348 },\\n         { \"lat\": 50.7524214, \"lon\": 7.0520935 },\\n         { \"lat\": 50.7547305, \"lon\": 7.0468957 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31363881,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8026288, \"lon\": 6.9992932 },\\n         { \"lat\": 50.8018617, \"lon\": 7.0000625 },\\n         { \"lat\": 50.8010270, \"lon\": 7.0007950 },\\n         { \"lat\": 50.8001164, \"lon\": 7.0015291 },\\n         { \"lat\": 50.7928343, \"lon\": 7.0072406 },\\n         { \"lat\": 50.7832350, \"lon\": 7.0147268 },\\n         { \"lat\": 50.7826087, \"lon\": 7.0151803 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31363891,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7826087, \"lon\": 7.0151803 },\\n         { \"lat\": 50.7823221, \"lon\": 7.0153822 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31363892,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7823221, \"lon\": 7.0153822 },\\n         { \"lat\": 50.7802850, \"lon\": 7.0170023 },\\n         { \"lat\": 50.7782200, \"lon\": 7.0186241 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31363898,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7826777, \"lon\": 7.0153975 },\\n         { \"lat\": 50.7833048, \"lon\": 7.0149295 },\\n         { \"lat\": 50.8001641, \"lon\": 7.0017836 },\\n         { \"lat\": 50.8010947, \"lon\": 7.0010142 },\\n         { \"lat\": 50.8019538, \"lon\": 7.0002540 },\\n         { \"lat\": 50.8026483, \"lon\": 6.9995590 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31363910,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7823930, \"lon\": 7.0156008 },\\n         { \"lat\": 50.7826777, \"lon\": 7.0153975 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364152,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7782200, \"lon\": 7.0186241 },\\n         { \"lat\": 50.7779774, \"lon\": 7.0188037 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364158,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7783056, \"lon\": 7.0188240 },\\n         { \"lat\": 50.7788577, \"lon\": 7.0183860 },\\n         { \"lat\": 50.7803473, \"lon\": 7.0172040 },\\n         { \"lat\": 50.7816582, \"lon\": 7.0161766 },\\n         { \"lat\": 50.7823930, \"lon\": 7.0156008 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364178,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7780676, \"lon\": 7.0190054 },\\n         { \"lat\": 50.7783056, \"lon\": 7.0188240 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364384,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7749036, \"lon\": 7.0214625 },\\n         { \"lat\": 50.7780676, \"lon\": 7.0190054 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364387,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7744886, \"lon\": 7.0214841 },\\n         { \"lat\": 50.7712930, \"lon\": 7.0240315 },\\n         { \"lat\": 50.7695809, \"lon\": 7.0254447 },\\n         { \"lat\": 50.7686243, \"lon\": 7.0263151 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364484,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7748248, \"lon\": 7.0212347 },\\n         { \"lat\": 50.7744886, \"lon\": 7.0214841 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364512,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7745735, \"lon\": 7.0217089 },\\n         { \"lat\": 50.7749036, \"lon\": 7.0214625 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364656,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7686546, \"lon\": 7.0266216 },\\n         { \"lat\": 50.7696586, \"lon\": 7.0256891 },\\n         { \"lat\": 50.7713905, \"lon\": 7.0242565 },\\n         { \"lat\": 50.7745735, \"lon\": 7.0217089 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364667,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7686243, \"lon\": 7.0263151 },\\n         { \"lat\": 50.7676165, \"lon\": 7.0273126 },\\n         { \"lat\": 50.7665957, \"lon\": 7.0283332 },\\n         { \"lat\": 50.7653333, \"lon\": 7.0297134 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008234,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7653333, \"lon\": 7.0297134 },\\n         { \"lat\": 50.7643799, \"lon\": 7.0308081 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364888,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7635269, \"lon\": 7.0321873 },\\n         { \"lat\": 50.7641966, \"lon\": 7.0313729 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 122158730,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7641966, \"lon\": 7.0313729 },\\n         { \"lat\": 50.7644716, \"lon\": 7.0310241 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31364985,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7644716, \"lon\": 7.0310241 },\\n         { \"lat\": 50.7648596, \"lon\": 7.0305814 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008235,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7648596, \"lon\": 7.0305814 },\\n         { \"lat\": 50.7657812, \"lon\": 7.0295145 },\\n         { \"lat\": 50.7666465, \"lon\": 7.0285903 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008231,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7666465, \"lon\": 7.0285903 },\\n         { \"lat\": 50.7679887, \"lon\": 7.0272481 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008233,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7679887, \"lon\": 7.0272481 },\\n         { \"lat\": 50.7686546, \"lon\": 7.0266216 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31365377,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7643799, \"lon\": 7.0308081 },\\n         { \"lat\": 50.7640807, \"lon\": 7.0311662 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31365425,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7640807, \"lon\": 7.0311662 },\\n         { \"lat\": 50.7638566, \"lon\": 7.0314272 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008236,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7638566, \"lon\": 7.0314272 },\\n         { \"lat\": 50.7628914, \"lon\": 7.0326760 },\\n         { \"lat\": 50.7621053, \"lon\": 7.0336961 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 36447898,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7621053, \"lon\": 7.0336961 },\\n         { \"lat\": 50.7613433, \"lon\": 7.0347526 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008228,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7613433, \"lon\": 7.0347526 },\\n         { \"lat\": 50.7608295, \"lon\": 7.0354890 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31366812,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7588227, \"lon\": 7.0386254 },\\n         { \"lat\": 50.7583011, \"lon\": 7.0394929 },\\n         { \"lat\": 50.7576749, \"lon\": 7.0405773 },\\n         { \"lat\": 50.7569096, \"lon\": 7.0419812 },\\n         { \"lat\": 50.7558745, \"lon\": 7.0439976 },\\n         { \"lat\": 50.7548175, \"lon\": 7.0462659 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31366880,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7550333, \"lon\": 7.0462257 },\\n         { \"lat\": 50.7559939, \"lon\": 7.0442408 },\\n         { \"lat\": 50.7570656, \"lon\": 7.0421620 },\\n         { \"lat\": 50.7578037, \"lon\": 7.0408023 },\\n         { \"lat\": 50.7584541, \"lon\": 7.0396561 },\\n         { \"lat\": 50.7589669, \"lon\": 7.0387984 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31367017,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7609333, \"lon\": 7.0356976 },\\n         { \"lat\": 50.7619690, \"lon\": 7.0342371 },\\n         { \"lat\": 50.7630051, \"lon\": 7.0328461 },\\n         { \"lat\": 50.7635269, \"lon\": 7.0321873 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31367443,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7607331, \"lon\": 7.0359794 },\\n         { \"lat\": 50.7609333, \"lon\": 7.0356976 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31367449,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7589669, \"lon\": 7.0387984 },\\n         { \"lat\": 50.7602933, \"lon\": 7.0366481 },\\n         { \"lat\": 50.7607331, \"lon\": 7.0359794 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31367526,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7606164, \"lon\": 7.0358121 },\\n         { \"lat\": 50.7601681, \"lon\": 7.0365126 },\\n         { \"lat\": 50.7588227, \"lon\": 7.0386254 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31367534,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7608295, \"lon\": 7.0354890 },\\n         { \"lat\": 50.7606164, \"lon\": 7.0358121 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31369852,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7779774, \"lon\": 7.0188037 },\\n         { \"lat\": 50.7748248, \"lon\": 7.0212347 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 449397558,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7479418, \"lon\": 7.0693723 },\\n         { \"lat\": 50.7494783, \"lon\": 7.0624630 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31797389,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7494783, \"lon\": 7.0624630 },\\n         { \"lat\": 50.7502727, \"lon\": 7.0588905 },\\n         { \"lat\": 50.7506441, \"lon\": 7.0572942 },\\n         { \"lat\": 50.7509429, \"lon\": 7.0561605 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31798039,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7504938, \"lon\": 7.0572440 },\\n         { \"lat\": 50.7501306, \"lon\": 7.0588140 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235363212,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7501306, \"lon\": 7.0588140 },\\n         { \"lat\": 50.7492636, \"lon\": 7.0626737 },\\n         { \"lat\": 50.7489407, \"lon\": 7.0641605 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 156492546,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7489407, \"lon\": 7.0641605 },\\n         { \"lat\": 50.7488307, \"lon\": 7.0647205 },\\n         { \"lat\": 50.7483739, \"lon\": 7.0668216 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 156492545,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7483739, \"lon\": 7.0668216 },\\n         { \"lat\": 50.7483009, \"lon\": 7.0672440 },\\n         { \"lat\": 50.7478400, \"lon\": 7.0692844 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 130749935,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.7478400, \"lon\": 7.0692844 },\\n         { \"lat\": 50.7477294, \"lon\": 7.0697394 },\\n         { \"lat\": 50.7476187, \"lon\": 7.0701855 },\\n         { \"lat\": 50.7474997, \"lon\": 7.0706232 },\\n         { \"lat\": 50.7473468, \"lon\": 7.0711189 },\\n         { \"lat\": 50.7472087, \"lon\": 7.0715434 },\\n         { \"lat\": 50.7470472, \"lon\": 7.0719838 },\\n         { \"lat\": 50.7469114, \"lon\": 7.0723163 },\\n         { \"lat\": 50.7467733, \"lon\": 7.0726489 },\\n         { \"lat\": 50.7465937, \"lon\": 7.0730580 },\\n         { \"lat\": 50.7464112, \"lon\": 7.0734310 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 32472877,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8246828, \"lon\": 6.9651077 },\\n         { \"lat\": 50.8253375, \"lon\": 6.9647718 },\\n         { \"lat\": 50.8260000, \"lon\": 6.9645354 },\\n         { \"lat\": 50.8266134, \"lon\": 6.9643649 },\\n         { \"lat\": 50.8272671, \"lon\": 6.9642646 },\\n         { \"lat\": 50.8278017, \"lon\": 6.9642349 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31798988,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8278017, \"lon\": 6.9642349 },\\n         { \"lat\": 50.8284805, \"lon\": 6.9642342 },\\n         { \"lat\": 50.8294617, \"lon\": 6.9643395 },\\n         { \"lat\": 50.8302437, \"lon\": 6.9644810 },\\n         { \"lat\": 50.8309474, \"lon\": 6.9646345 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 31798989,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8590359, \"lon\": 6.9691023 },\\n         { \"lat\": 50.8634113, \"lon\": 6.9695191 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235820560,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8634113, \"lon\": 6.9695191 },\\n         { \"lat\": 50.8656224, \"lon\": 6.9697185 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235820563,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8656224, \"lon\": 6.9697185 },\\n         { \"lat\": 50.8679633, \"lon\": 6.9699314 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235820564,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8679633, \"lon\": 6.9699314 },\\n         { \"lat\": 50.8691580, \"lon\": 6.9700171 },\\n         { \"lat\": 50.8699302, \"lon\": 6.9700221 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 235820570,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8699302, \"lon\": 6.9700221 },\\n         { \"lat\": 50.8717399, \"lon\": 6.9699121 },\\n         { \"lat\": 50.8746263, \"lon\": 6.9695939 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 32472855,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8246253, \"lon\": 6.9648384 },\\n         { \"lat\": 50.8242516, \"lon\": 6.9650453 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 32472856,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8242516, \"lon\": 6.9650453 },\\n         { \"lat\": 50.8237235, \"lon\": 6.9653841 },\\n         { \"lat\": 50.8232034, \"lon\": 6.9657948 },\\n         { \"lat\": 50.8224317, \"lon\": 6.9665263 },\\n         { \"lat\": 50.8216642, \"lon\": 6.9673886 },\\n         { \"lat\": 50.8209037, \"lon\": 6.9684049 },\\n         { \"lat\": 50.8201541, \"lon\": 6.9695500 },\\n         { \"lat\": 50.8192181, \"lon\": 6.9711445 },\\n         { \"lat\": 50.8138575, \"lon\": 6.9806731 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 37881520,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8138575, \"lon\": 6.9806731 },\\n         { \"lat\": 50.8135770, \"lon\": 6.9811721 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 37881519,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8135770, \"lon\": 6.9811721 },\\n         { \"lat\": 50.8113547, \"lon\": 6.9851361 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 234434902,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8113547, \"lon\": 6.9851361 },\\n         { \"lat\": 50.8105743, \"lon\": 6.9865001 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 32472875,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8243279, \"lon\": 6.9653077 },\\n         { \"lat\": 50.8246828, \"lon\": 6.9651077 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 32473071,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8309464, \"lon\": 6.9643368 },\\n         { \"lat\": 50.8302815, \"lon\": 6.9641912 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 128522486,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8302815, \"lon\": 6.9641912 },\\n         { \"lat\": 50.8294728, \"lon\": 6.9640448 },\\n         { \"lat\": 50.8284964, \"lon\": 6.9639463 },\\n         { \"lat\": 50.8277970, \"lon\": 6.9639432 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 36447896,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8277970, \"lon\": 6.9639432 },\\n         { \"lat\": 50.8272631, \"lon\": 6.9639682 },\\n         { \"lat\": 50.8265661, \"lon\": 6.9640827 },\\n         { \"lat\": 50.8259717, \"lon\": 6.9642405 },\\n         { \"lat\": 50.8252714, \"lon\": 6.9645096 },\\n         { \"lat\": 50.8246253, \"lon\": 6.9648384 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 32473075,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8314332, \"lon\": 6.9644546 },\\n         { \"lat\": 50.8309464, \"lon\": 6.9643368 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 32473086,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8309474, \"lon\": 6.9646345 },\\n         { \"lat\": 50.8314534, \"lon\": 6.9647679 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 32473087,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8314534, \"lon\": 6.9647679 },\\n         { \"lat\": 50.8386440, \"lon\": 6.9665955 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 40033064,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8386440, \"lon\": 6.9665955 },\\n         { \"lat\": 50.8391695, \"lon\": 6.9667285 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 189189059,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8746263, \"lon\": 6.9695939 },\\n         { \"lat\": 50.8760907, \"lon\": 6.9694358 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 271008225,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8760907, \"lon\": 6.9694358 },\\n         { \"lat\": 50.8775484, \"lon\": 6.9692784 }\\n      ]\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"ref\": 41550921,\\n      \"role\": \"\",\\n      \"geometry\": [\\n         { \"lat\": 50.8775484, \"lon\": 6.9692784 },\\n         { \"lat\": 50.8797318, \"lon\": 6.9690108 }\\n      ]\\n    }\\n  ],\\n  \"tags\": {\\n    \"TMC:cid_58:tabcd_1:Class\": \"Road\",\\n    \"TMC:cid_58:tabcd_1:LCLversion\": \"8.00\",\\n    \"TMC:cid_58:tabcd_1:LocationCode\": \"7142\",\\n    \"name\": \"Bundesautobahn 555\",\\n    \"network\": \"BAB\",\\n    \"operator\": \"Bundesrepublik Deutschland\",\\n    \"ref\": \"A 555\",\\n    \"route\": \"road\",\\n    \"type\": \"route\",\\n    \"wikipedia\": \"de:Bundesautobahn 555\"\\n  }\\n}\\n\\n  ]\\n}\\n'"}, {"func_args": {"filename": "'json/way-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:33:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n\\n{\\n  \"type\": \"way\",\\n  \"id\": 317146077,\\n  \"nodes\": [\\n    3233854241,\\n    3233854238,\\n    3233854233,\\n    3233854234,\\n    3233854236,\\n    3233854237,\\n    3233854241\\n  ],\\n  \"tags\": {\\n    \"building\": \"yes\"\\n  }\\n},\\n{\\n  \"type\": \"way\",\\n  \"id\": 317146078,\\n  \"timestamp\": \"2014-12-14T07:27:21Z\",\\n  \"version\": 1,\\n  \"changeset\": 23456789,\\n  \"user\": \"TestUser\",\\n  \"uid\": 345678,\\n  \"nodes\": [\\n    3233854241,\\n    3233854238,\\n    3233854233,\\n    3233854234,\\n    3233854236,\\n    3233854237,\\n    3233854241\\n  ]\\n}\\n\\n  ]\\n}'"}, {"func_args": {"filename": "'json/way-02.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854233,\\n  \"lat\": 50.7494187,\\n  \"lon\": 7.1758731\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854234,\\n  \"lat\": 50.7494236,\\n  \"lon\": 7.1757664\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854236,\\n  \"lat\": 50.7494909,\\n  \"lon\": 7.1757741\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854237,\\n  \"lat\": 50.7494985,\\n  \"lon\": 7.1756064\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854238,\\n  \"lat\": 50.7495391,\\n  \"lon\": 7.1758868\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854241,\\n  \"lat\": 50.7495516,\\n  \"lon\": 7.1756125\\n},\\n{\\n  \"type\": \"way\",\\n  \"id\": 317146077,\\n  \"nodes\": [\\n    3233854241,\\n    3233854238,\\n    3233854233,\\n    3233854234,\\n    3233854236,\\n    3233854237,\\n    3233854241\\n  ],\\n  \"tags\": {\\n    \"building\": \"yes\"\\n  }\\n}\\n\\n  ]\\n}'"}, {"func_args": {"filename": "'json/way-03.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2016-11-22T22:33:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n\\n{\\n  \"type\": \"node\",\\n  \"id\": 2343425523,\\n  \"lat\": 41.8954452,\\n  \"lon\": 12.5032169,\\n  \"timestamp\": \"2013-06-13T15:34:01Z\",\\n  \"version\": 1,\\n  \"changeset\": 16539126,\\n  \"user\": \"Giardia\",\\n  \"uid\": 113909\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 2343425525,\\n  \"lat\": 41.8954752,\\n  \"lon\": 12.5031604,\\n  \"timestamp\": \"2013-06-13T15:34:01Z\",\\n  \"version\": 1,\\n  \"changeset\": 16539126,\\n  \"user\": \"Giardia\",\\n  \"uid\": 113909\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 2343425526,\\n  \"lat\": 41.8955244,\\n  \"lon\": 12.5032926,\\n  \"timestamp\": \"2013-06-13T15:34:01Z\",\\n  \"version\": 1,\\n  \"changeset\": 16539126,\\n  \"user\": \"Giardia\",\\n  \"uid\": 113909\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 2343425528,\\n  \"lat\": 41.8955543,\\n  \"lon\": 12.5032362,\\n  \"timestamp\": \"2013-06-13T15:34:01Z\",\\n  \"version\": 1,\\n  \"changeset\": 16539126,\\n  \"user\": \"Giardia\",\\n  \"uid\": 113909\\n},\\n{\\n  \"type\": \"way\",\\n  \"id\": 225576797,\\n  \"timestamp\": \"2013-06-13T15:34:01Z\",\\n  \"version\": 1,\\n  \"changeset\": 16539126,\\n  \"user\": \"Giardia\",\\n  \"uid\": 113909,\\n  \"center\": {\\n    \"lat\": 41.8954998,\\n    \"lon\": 12.5032265\\n  },\\n  \"nodes\": [\\n    2343425525,\\n    2343425528,\\n    2343425526,\\n    2343425523,\\n    2343425525\\n  ],\\n  \"tags\": {\\n    \"building\": \"kiosk\",\\n    \"shop\": \"florist\"\\n  }\\n}\\n\\n  ]\\n}\\n'"}, {"func_args": {"filename": "'json/way-04.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2016-11-22T23:25:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n\\n{\\n  \"type\": \"way\",\\n  \"id\": 225576797,\\n  \"center\": {},\\n  \"nodes\": [\\n    2343425525,\\n    2343425528,\\n    2343425526,\\n    2343425523,\\n    2343425525\\n  ],\\n  \"tags\": {\\n    \"building\": \"kiosk\",\\n    \"shop\": \"florist\"\\n  }\\n}\\n\\n  ]\\n}'"}, {"func_args": {"filename": "'json/remark-runtime-error-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2017-03-17T22:05:02Z\",\\n    \"timestamp_areas_base\": \"2017-03-17T18:38:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n\\n\\n\\n  ],\\n\"remark\": \"runtime error: Query timed out in \\\\\"query\\\\\" at line 4 after 2 seconds.\"\\n}\\n'"}, {"func_args": {"filename": "'json/remark-runtime-remark-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2017-03-17T22:05:02Z\",\\n    \"timestamp_areas_base\": \"2017-03-17T18:38:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n\\n\\n\\n  ],\\n\"remark\": \"runtime remark: Test\"\\n}\\n'"}, {"func_args": {"filename": "'json/remark-unknown-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2017-03-17T22:05:02Z\",\\n    \"timestamp_areas_base\": \"2017-03-17T18:38:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n\\n\\n\\n  ],\\n\"remark\": \"Test remark\"\\n}\\n'"}, {"func_args": {"filename": "'json/way-02.json'", "mode": "'rb'"}, "return_value": "b'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854233,\\n  \"lat\": 50.7494187,\\n  \"lon\": 7.1758731\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854234,\\n  \"lat\": 50.7494236,\\n  \"lon\": 7.1757664\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854236,\\n  \"lat\": 50.7494909,\\n  \"lon\": 7.1757741\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854237,\\n  \"lat\": 50.7494985,\\n  \"lon\": 7.1756064\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854238,\\n  \"lat\": 50.7495391,\\n  \"lon\": 7.1758868\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854241,\\n  \"lat\": 50.7495516,\\n  \"lon\": 7.1756125\\n},\\n{\\n  \"type\": \"way\",\\n  \"id\": 317146077,\\n  \"nodes\": [\\n    3233854241,\\n    3233854238,\\n    3233854233,\\n    3233854234,\\n    3233854236,\\n    3233854237,\\n    3233854241\\n  ],\\n  \"tags\": {\\n    \"building\": \"yes\"\\n  }\\n}\\n\\n  ]\\n}'"}, {"func_args": {"filename": "'response/bad-request.html'", "mode": "'rb'"}, "return_value": "b'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\\n    \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\\n<head>\\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" lang=\"en\"/>\\n  <title>OSM3S Response</title>\\n</head>\\n<body>\\n\\n<p>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</p>\\n<p><strong style=\"color:#FF0000\">Error</strong>: line 2: parse error: \\';\\' expected - \\'out\\' found. </p>\\n\\n</body>\\n</html>'"}, {"func_args": {"filename": "'response/bad-request-encoding.html'", "mode": "'rb'"}, "return_value": "b'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\\n    \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\\n<head>\\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" lang=\"en\"/>\\n  <title>OSM3S Response</title>\\n</head>\\n<body>\\n\\n<p>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</p>\\n<!-- Wrong encoding iso8859-15 -->\\n<p><strong style=\"color:#FF0000\">Error</strong>: line 2: parse error: \\';\\' expected - \\'out\\' found. \\xe4\\xf6\\xfc</p>\\n\\n</body>\\n</html>\\n'"}, {"func_args": {"filename": "'response/bad-request-encoding.html'", "mode": "'rb'"}, "return_value": "b'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\\n    \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\\n<head>\\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" lang=\"en\"/>\\n  <title>OSM3S Response</title>\\n</head>\\n<body>\\n\\n<p>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</p>\\n<!-- Wrong encoding iso8859-15 -->\\n<p><strong style=\"color:#FF0000\">Error</strong>: line 2: parse error: \\';\\' expected - \\'out\\' found. \\xe4\\xf6\\xfc</p>\\n\\n</body>\\n</html>\\n'"}, {"func_args": {"filename": "'json/way-02.json'", "mode": "'rb'"}, "return_value": "b'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854233,\\n  \"lat\": 50.7494187,\\n  \"lon\": 7.1758731\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854234,\\n  \"lat\": 50.7494236,\\n  \"lon\": 7.1757664\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854236,\\n  \"lat\": 50.7494909,\\n  \"lon\": 7.1757741\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854237,\\n  \"lat\": 50.7494985,\\n  \"lon\": 7.1756064\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854238,\\n  \"lat\": 50.7495391,\\n  \"lon\": 7.1758868\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854241,\\n  \"lat\": 50.7495516,\\n  \"lon\": 7.1756125\\n},\\n{\\n  \"type\": \"way\",\\n  \"id\": 317146077,\\n  \"nodes\": [\\n    3233854241,\\n    3233854238,\\n    3233854233,\\n    3233854234,\\n    3233854236,\\n    3233854237,\\n    3233854241\\n  ],\\n  \"tags\": {\\n    \"building\": \"yes\"\\n  }\\n}\\n\\n  ]\\n}'"}, {"func_args": {"filename": "'xml/way-02.xml'", "mode": "'rb'"}, "return_value": "b'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2014-12-14T13:34:02Z\"/>\\n  <node id=\"3233854233\" lat=\"50.7494187\" lon=\"7.1758731\"/>\\n  <node id=\"3233854234\" lat=\"50.7494236\" lon=\"7.1757664\"/>\\n  <node id=\"3233854236\" lat=\"50.7494909\" lon=\"7.1757741\"/>\\n  <node id=\"3233854237\" lat=\"50.7494985\" lon=\"7.1756064\"/>\\n  <node id=\"3233854238\" lat=\"50.7495391\" lon=\"7.1758868\"/>\\n  <node id=\"3233854241\" lat=\"50.7495516\" lon=\"7.1756125\"/>\\n  <way id=\"317146077\">\\n    <nd ref=\"3233854241\"/>\\n    <nd ref=\"3233854238\"/>\\n    <nd ref=\"3233854233\"/>\\n    <nd ref=\"3233854234\"/>\\n    <nd ref=\"3233854236\"/>\\n    <nd ref=\"3233854237\"/>\\n    <nd ref=\"3233854241\"/>\\n    <tag k=\"building\" v=\"yes\"/>\\n  </way>\\n\\n</osm>'"}, {"func_args": {"filename": "'xml/way-02.xml'", "mode": "'rb'"}, "return_value": "b'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2014-12-14T13:34:02Z\"/>\\n  <node id=\"3233854233\" lat=\"50.7494187\" lon=\"7.1758731\"/>\\n  <node id=\"3233854234\" lat=\"50.7494236\" lon=\"7.1757664\"/>\\n  <node id=\"3233854236\" lat=\"50.7494909\" lon=\"7.1757741\"/>\\n  <node id=\"3233854237\" lat=\"50.7494985\" lon=\"7.1756064\"/>\\n  <node id=\"3233854238\" lat=\"50.7495391\" lon=\"7.1758868\"/>\\n  <node id=\"3233854241\" lat=\"50.7495516\" lon=\"7.1756125\"/>\\n  <way id=\"317146077\">\\n    <nd ref=\"3233854241\"/>\\n    <nd ref=\"3233854238\"/>\\n    <nd ref=\"3233854233\"/>\\n    <nd ref=\"3233854234\"/>\\n    <nd ref=\"3233854236\"/>\\n    <nd ref=\"3233854237\"/>\\n    <nd ref=\"3233854241\"/>\\n    <tag k=\"building\" v=\"yes\"/>\\n  </way>\\n\\n</osm>'"}, {"func_args": {"filename": "'response/bad-request.html'", "mode": "'rb'"}, "return_value": "b'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\\n    \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\\n<head>\\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" lang=\"en\"/>\\n  <title>OSM3S Response</title>\\n</head>\\n<body>\\n\\n<p>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</p>\\n<p><strong style=\"color:#FF0000\">Error</strong>: line 2: parse error: \\';\\' expected - \\'out\\' found. </p>\\n\\n</body>\\n</html>'"}, {"func_args": {"filename": "'response/bad-request-encoding.html'", "mode": "'rb'"}, "return_value": "b'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\\n    \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\\n<head>\\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" lang=\"en\"/>\\n  <title>OSM3S Response</title>\\n</head>\\n<body>\\n\\n<p>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</p>\\n<!-- Wrong encoding iso8859-15 -->\\n<p><strong style=\"color:#FF0000\">Error</strong>: line 2: parse error: \\';\\' expected - \\'out\\' found. \\xe4\\xf6\\xfc</p>\\n\\n</body>\\n</html>\\n'"}, {"func_args": {"filename": "'xml/way-02.xml'", "mode": "'rb'"}, "return_value": "b'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2014-12-14T13:34:02Z\"/>\\n  <node id=\"3233854233\" lat=\"50.7494187\" lon=\"7.1758731\"/>\\n  <node id=\"3233854234\" lat=\"50.7494236\" lon=\"7.1757664\"/>\\n  <node id=\"3233854236\" lat=\"50.7494909\" lon=\"7.1757741\"/>\\n  <node id=\"3233854237\" lat=\"50.7494985\" lon=\"7.1756064\"/>\\n  <node id=\"3233854238\" lat=\"50.7495391\" lon=\"7.1758868\"/>\\n  <node id=\"3233854241\" lat=\"50.7495516\" lon=\"7.1756125\"/>\\n  <way id=\"317146077\">\\n    <nd ref=\"3233854241\"/>\\n    <nd ref=\"3233854238\"/>\\n    <nd ref=\"3233854233\"/>\\n    <nd ref=\"3233854234\"/>\\n    <nd ref=\"3233854236\"/>\\n    <nd ref=\"3233854237\"/>\\n    <nd ref=\"3233854241\"/>\\n    <tag k=\"building\" v=\"yes\"/>\\n  </way>\\n\\n</osm>'"}, {"func_args": {"filename": "'json/result-expand-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854234,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146077,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854234,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146077,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-02.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"area\",\\n      \"id\": 3605945176\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854235,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146078,\\n      \"nodes\": [\\n        3233854233,\\n        3233854235\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    },\\n    {\\n      \"type\": \"relation\",\\n      \"id\": 2046898,\\n      \"timestamp\": \"2014-12-15T13:13:11Z\",\\n      \"version\": 12,\\n      \"changeset\": 17433822,\\n      \"user\": \"Username\",\\n      \"uid\": 12345,\\n      \"members\": [\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854233,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854234,\\n          \"role\": \"stop\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854235,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"way\",\\n          \"ref\": 317146078,\\n          \"role\": \"\"\\n        }\\n      ],\\n      \"tags\": {\\n        \"from\": \"Here\",\\n        \"name\": \"Test relation\",\\n        \"ref\": \"609\",\\n        \"route\": \"bus\",\\n        \"to\": \"There\",\\n        \"type\": \"route\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854234,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146077,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-02.json'", "mode": "'rb'"}, "return_value": "b'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"area\",\\n      \"id\": 3605945176\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854235,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146078,\\n      \"nodes\": [\\n        3233854233,\\n        3233854235\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    },\\n    {\\n      \"type\": \"relation\",\\n      \"id\": 2046898,\\n      \"timestamp\": \"2014-12-15T13:13:11Z\",\\n      \"version\": 12,\\n      \"changeset\": 17433822,\\n      \"user\": \"Username\",\\n      \"uid\": 12345,\\n      \"members\": [\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854233,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854234,\\n          \"role\": \"stop\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854235,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"way\",\\n          \"ref\": 317146078,\\n          \"role\": \"\"\\n        }\\n      ],\\n      \"tags\": {\\n        \"from\": \"Here\",\\n        \"name\": \"Test relation\",\\n        \"ref\": \"609\",\\n        \"route\": \"bus\",\\n        \"to\": \"There\",\\n        \"type\": \"route\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854234,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146077,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-02.json'", "mode": "'rb'"}, "return_value": "b'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"area\",\\n      \"id\": 3605945176\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854235,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146078,\\n      \"nodes\": [\\n        3233854233,\\n        3233854235\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    },\\n    {\\n      \"type\": \"relation\",\\n      \"id\": 2046898,\\n      \"timestamp\": \"2014-12-15T13:13:11Z\",\\n      \"version\": 12,\\n      \"changeset\": 17433822,\\n      \"user\": \"Username\",\\n      \"uid\": 12345,\\n      \"members\": [\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854233,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854234,\\n          \"role\": \"stop\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854235,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"way\",\\n          \"ref\": 317146078,\\n          \"role\": \"\"\\n        }\\n      ],\\n      \"tags\": {\\n        \"from\": \"Here\",\\n        \"name\": \"Test relation\",\\n        \"ref\": \"609\",\\n        \"route\": \"bus\",\\n        \"to\": \"There\",\\n        \"type\": \"route\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854234,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146077,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-02.json'", "mode": "'rb'"}, "return_value": "b'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"area\",\\n      \"id\": 3605945176\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854235,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146078,\\n      \"nodes\": [\\n        3233854233,\\n        3233854235\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    },\\n    {\\n      \"type\": \"relation\",\\n      \"id\": 2046898,\\n      \"timestamp\": \"2014-12-15T13:13:11Z\",\\n      \"version\": 12,\\n      \"changeset\": 17433822,\\n      \"user\": \"Username\",\\n      \"uid\": 12345,\\n      \"members\": [\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854233,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854234,\\n          \"role\": \"stop\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854235,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"way\",\\n          \"ref\": 317146078,\\n          \"role\": \"\"\\n        }\\n      ],\\n      \"tags\": {\\n        \"from\": \"Here\",\\n        \"name\": \"Test relation\",\\n        \"ref\": \"609\",\\n        \"route\": \"bus\",\\n        \"to\": \"There\",\\n        \"type\": \"route\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854234,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146077,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-02.json'", "mode": "'rb'"}, "return_value": "b'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"area\",\\n      \"id\": 3605945176\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854235,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146078,\\n      \"nodes\": [\\n        3233854233,\\n        3233854235\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    },\\n    {\\n      \"type\": \"relation\",\\n      \"id\": 2046898,\\n      \"timestamp\": \"2014-12-15T13:13:11Z\",\\n      \"version\": 12,\\n      \"changeset\": 17433822,\\n      \"user\": \"Username\",\\n      \"uid\": 12345,\\n      \"members\": [\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854233,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854234,\\n          \"role\": \"stop\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854235,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"way\",\\n          \"ref\": 317146078,\\n          \"role\": \"\"\\n        }\\n      ],\\n      \"tags\": {\\n        \"from\": \"Here\",\\n        \"name\": \"Test relation\",\\n        \"ref\": \"609\",\\n        \"route\": \"bus\",\\n        \"to\": \"There\",\\n        \"type\": \"route\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/way-02.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854233,\\n  \"lat\": 50.7494187,\\n  \"lon\": 7.1758731\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854234,\\n  \"lat\": 50.7494236,\\n  \"lon\": 7.1757664\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854236,\\n  \"lat\": 50.7494909,\\n  \"lon\": 7.1757741\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854237,\\n  \"lat\": 50.7494985,\\n  \"lon\": 7.1756064\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854238,\\n  \"lat\": 50.7495391,\\n  \"lon\": 7.1758868\\n},\\n{\\n  \"type\": \"node\",\\n  \"id\": 3233854241,\\n  \"lat\": 50.7495516,\\n  \"lon\": 7.1756125\\n},\\n{\\n  \"type\": \"way\",\\n  \"id\": 317146077,\\n  \"nodes\": [\\n    3233854241,\\n    3233854238,\\n    3233854233,\\n    3233854234,\\n    3233854236,\\n    3233854237,\\n    3233854241\\n  ],\\n  \"tags\": {\\n    \"building\": \"yes\"\\n  }\\n}\\n\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854234,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146077,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-02.json'", "mode": "'rb'"}, "return_value": "b'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"area\",\\n      \"id\": 3605945176\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854235,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146078,\\n      \"nodes\": [\\n        3233854233,\\n        3233854235\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    },\\n    {\\n      \"type\": \"relation\",\\n      \"id\": 2046898,\\n      \"timestamp\": \"2014-12-15T13:13:11Z\",\\n      \"version\": 12,\\n      \"changeset\": 17433822,\\n      \"user\": \"Username\",\\n      \"uid\": 12345,\\n      \"members\": [\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854233,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854234,\\n          \"role\": \"stop\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854235,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"way\",\\n          \"ref\": 317146078,\\n          \"role\": \"\"\\n        }\\n      ],\\n      \"tags\": {\\n        \"from\": \"Here\",\\n        \"name\": \"Test relation\",\\n        \"ref\": \"609\",\\n        \"route\": \"bus\",\\n        \"to\": \"There\",\\n        \"type\": \"route\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854234,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146077,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-02.json'", "mode": "'rb'"}, "return_value": "b'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"area\",\\n      \"id\": 3605945176\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854235,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146078,\\n      \"nodes\": [\\n        3233854233,\\n        3233854235\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    },\\n    {\\n      \"type\": \"relation\",\\n      \"id\": 2046898,\\n      \"timestamp\": \"2014-12-15T13:13:11Z\",\\n      \"version\": 12,\\n      \"changeset\": 17433822,\\n      \"user\": \"Username\",\\n      \"uid\": 12345,\\n      \"members\": [\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854233,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854234,\\n          \"role\": \"stop\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854235,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"way\",\\n          \"ref\": 317146078,\\n          \"role\": \"\"\\n        }\\n      ],\\n      \"tags\": {\\n        \"from\": \"Here\",\\n        \"name\": \"Test relation\",\\n        \"ref\": \"609\",\\n        \"route\": \"bus\",\\n        \"to\": \"There\",\\n        \"type\": \"route\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854234,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146077,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-02.json'", "mode": "'rb'"}, "return_value": "b'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"area\",\\n      \"id\": 3605945176\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854235,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146078,\\n      \"nodes\": [\\n        3233854233,\\n        3233854235\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    },\\n    {\\n      \"type\": \"relation\",\\n      \"id\": 2046898,\\n      \"timestamp\": \"2014-12-15T13:13:11Z\",\\n      \"version\": 12,\\n      \"changeset\": 17433822,\\n      \"user\": \"Username\",\\n      \"uid\": 12345,\\n      \"members\": [\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854233,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854234,\\n          \"role\": \"stop\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854235,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"way\",\\n          \"ref\": 317146078,\\n          \"role\": \"\"\\n        }\\n      ],\\n      \"tags\": {\\n        \"from\": \"Here\",\\n        \"name\": \"Test relation\",\\n        \"ref\": \"609\",\\n        \"route\": \"bus\",\\n        \"to\": \"There\",\\n        \"type\": \"route\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854234,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146077,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-expand-02.json'", "mode": "'rb'"}, "return_value": "b'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"area\",\\n      \"id\": 3605945176\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854235,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146078,\\n      \"nodes\": [\\n        3233854233,\\n        3233854235\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    },\\n    {\\n      \"type\": \"relation\",\\n      \"id\": 2046898,\\n      \"timestamp\": \"2014-12-15T13:13:11Z\",\\n      \"version\": 12,\\n      \"changeset\": 17433822,\\n      \"user\": \"Username\",\\n      \"uid\": 12345,\\n      \"members\": [\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854233,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854234,\\n          \"role\": \"stop\"\\n        },\\n        {\\n          \"type\": \"node\",\\n          \"ref\": 3233854235,\\n          \"role\": \"platform\"\\n        },\\n        {\\n          \"type\": \"way\",\\n          \"ref\": 317146078,\\n          \"role\": \"\"\\n        }\\n      ],\\n      \"tags\": {\\n        \"from\": \"Here\",\\n        \"name\": \"Test relation\",\\n        \"ref\": \"609\",\\n        \"route\": \"bus\",\\n        \"to\": \"There\",\\n        \"type\": \"route\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-way-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146077,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-way-01.json'", "mode": "'rb'"}, "return_value": "b'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146077,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-way-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146077,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-way-02.json'", "mode": "'rb'"}, "return_value": "b'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146077,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-way-01.json'", "mode": "'r'"}, "return_value": "'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146077,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'json/result-way-03.json'", "mode": "'rb'"}, "return_value": "b'{\\n  \"version\": 0.6,\\n  \"generator\": \"Overpass API\",\\n  \"osm3s\": {\\n    \"timestamp_osm_base\": \"2014-12-14T13:34:02Z\",\\n    \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\"\\n  },\\n  \"elements\": [\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854233,\\n      \"lat\": 50.7494187,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"node\",\\n      \"id\": 3233854234,\\n      \"lat\": 50.7494287,\\n      \"lon\": 7.1758731\\n    },\\n    {\\n      \"type\": \"way\",\\n      \"id\": 317146077,\\n      \"nodes\": [\\n        3233854233,\\n        3233854234\\n      ],\\n      \"tags\": {\\n        \"building\": \"yes\"\\n      }\\n    }\\n  ]\\n}'"}, {"func_args": {"filename": "'xml/area-01.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2016-11-22T20:23:03Z\" areas=\"2016-11-22T19:07:02Z\"/>\\n\\n  <area id=\"2448756446\">\\n    <tag k=\"addr:city\" v=\"Troisdorf\"/>\\n    <tag k=\"addr:postcode\" v=\"53840\"/>\\n    <tag k=\"area\" v=\"yes\"/>\\n    <tag k=\"description\" v=\"Troisdorf Bahnsteig Gleis 9\"/>\\n    <tag k=\"name\" v=\"Troisdorf\"/>\\n    <tag k=\"public_transport\" v=\"platform\"/>\\n    <tag k=\"railway\" v=\"platform\"/>\\n    <tag k=\"ref\" v=\"9\"/>\\n    <tag k=\"train\" v=\"yes\"/>\\n    <tag k=\"wheelchair\" v=\"no\"/>\\n    <tag k=\"wheelchair:description\" v=\"Plattformlift ist vorhanden, Betriebsbereitschaft nach 8 Jahren stillstand fraglich.\"/>\\n    <tag k=\"width\" v=\"5\"/>\\n  </area>\\n  <area id=\"3600055060\">\\n    <tag k=\"TMC:cid_58:tabcd_1:Class\" v=\"Area\"/>\\n    <tag k=\"TMC:cid_58:tabcd_1:LCLversion\" v=\"8.00\"/>\\n    <tag k=\"TMC:cid_58:tabcd_1:LocationCode\" v=\"2550\"/>\\n    <tag k=\"admin_level\" v=\"8\"/>\\n    <tag k=\"boundary\" v=\"administrative\"/>\\n    <tag k=\"de:amtlicher_gemeindeschluessel\" v=\"05382068\"/>\\n    <tag k=\"de:place\" v=\"town\"/>\\n    <tag k=\"de:regionalschluessel\" v=\"053820068068\"/>\\n    <tag k=\"name\" v=\"Troisdorf\"/>\\n    <tag k=\"name:prefix\" v=\"Stadt\"/>\\n    <tag k=\"type\" v=\"boundary\"/>\\n    <tag k=\"wikidata\" v=\"Q3900\"/>\\n    <tag k=\"wikipedia\" v=\"de:Troisdorf\"/>\\n  </area>\\n  <area id=\"3605945175\">\\n    <tag k=\"addr:city\" v=\"Troisdorf\"/>\\n    <tag k=\"addr:postcode\" v=\"53840\"/>\\n    <tag k=\"description\" v=\"Troisdorf Bahnsteig Gleis 1+2\"/>\\n    <tag k=\"local_ref\" v=\"1;2\"/>\\n    <tag k=\"name\" v=\"Troisdorf\"/>\\n    <tag k=\"public_transport\" v=\"platform\"/>\\n    <tag k=\"railway\" v=\"platform\"/>\\n    <tag k=\"ref\" v=\"1/2\"/>\\n    <tag k=\"tactile_paving\" v=\"yes\"/>\\n    <tag k=\"train\" v=\"yes\"/>\\n    <tag k=\"type\" v=\"multipolygon\"/>\\n    <tag k=\"wheelchair\" v=\"yes\"/>\\n  </area>\\n  <area id=\"3605945176\">\\n    <tag k=\"addr:city\" v=\"Troisdorf\"/>\\n    <tag k=\"addr:postcode\" v=\"53840\"/>\\n    <tag k=\"description\" v=\"Troisdorf Bahnsteig Gleis 5+6\"/>\\n    <tag k=\"name\" v=\"Troisdorf\"/>\\n    <tag k=\"phone\" v=\"+49 221 1411055\"/>\\n    <tag k=\"public_transport\" v=\"platform\"/>\\n    <tag k=\"railway\" v=\"platform\"/>\\n    <tag k=\"ref\" v=\"5/6\"/>\\n    <tag k=\"tactile_paving\" v=\"yes\"/>\\n    <tag k=\"train\" v=\"yes\"/>\\n    <tag k=\"type\" v=\"multipolygon\"/>\\n    <tag k=\"wheelchair\" v=\"yes\"/>\\n    <tag k=\"wheelchair:description\" v=\"Der Aufzug zu diesem Bahnsteig ist oft defekt, bitte informieren. Betriebszustand kann bei 3S-Zentrale erfragt werden (siehe Telefonnummer, aber Vorsicht, die sind nicht immer informiert!)\"/>\\n    <tag k=\"width\" v=\"6\"/>\\n  </area>\\n\\n</osm>\\n'"}, {"func_args": {"filename": "'xml/area-01.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2016-11-22T20:23:03Z\" areas=\"2016-11-22T19:07:02Z\"/>\\n\\n  <area id=\"2448756446\">\\n    <tag k=\"addr:city\" v=\"Troisdorf\"/>\\n    <tag k=\"addr:postcode\" v=\"53840\"/>\\n    <tag k=\"area\" v=\"yes\"/>\\n    <tag k=\"description\" v=\"Troisdorf Bahnsteig Gleis 9\"/>\\n    <tag k=\"name\" v=\"Troisdorf\"/>\\n    <tag k=\"public_transport\" v=\"platform\"/>\\n    <tag k=\"railway\" v=\"platform\"/>\\n    <tag k=\"ref\" v=\"9\"/>\\n    <tag k=\"train\" v=\"yes\"/>\\n    <tag k=\"wheelchair\" v=\"no\"/>\\n    <tag k=\"wheelchair:description\" v=\"Plattformlift ist vorhanden, Betriebsbereitschaft nach 8 Jahren stillstand fraglich.\"/>\\n    <tag k=\"width\" v=\"5\"/>\\n  </area>\\n  <area id=\"3600055060\">\\n    <tag k=\"TMC:cid_58:tabcd_1:Class\" v=\"Area\"/>\\n    <tag k=\"TMC:cid_58:tabcd_1:LCLversion\" v=\"8.00\"/>\\n    <tag k=\"TMC:cid_58:tabcd_1:LocationCode\" v=\"2550\"/>\\n    <tag k=\"admin_level\" v=\"8\"/>\\n    <tag k=\"boundary\" v=\"administrative\"/>\\n    <tag k=\"de:amtlicher_gemeindeschluessel\" v=\"05382068\"/>\\n    <tag k=\"de:place\" v=\"town\"/>\\n    <tag k=\"de:regionalschluessel\" v=\"053820068068\"/>\\n    <tag k=\"name\" v=\"Troisdorf\"/>\\n    <tag k=\"name:prefix\" v=\"Stadt\"/>\\n    <tag k=\"type\" v=\"boundary\"/>\\n    <tag k=\"wikidata\" v=\"Q3900\"/>\\n    <tag k=\"wikipedia\" v=\"de:Troisdorf\"/>\\n  </area>\\n  <area id=\"3605945175\">\\n    <tag k=\"addr:city\" v=\"Troisdorf\"/>\\n    <tag k=\"addr:postcode\" v=\"53840\"/>\\n    <tag k=\"description\" v=\"Troisdorf Bahnsteig Gleis 1+2\"/>\\n    <tag k=\"local_ref\" v=\"1;2\"/>\\n    <tag k=\"name\" v=\"Troisdorf\"/>\\n    <tag k=\"public_transport\" v=\"platform\"/>\\n    <tag k=\"railway\" v=\"platform\"/>\\n    <tag k=\"ref\" v=\"1/2\"/>\\n    <tag k=\"tactile_paving\" v=\"yes\"/>\\n    <tag k=\"train\" v=\"yes\"/>\\n    <tag k=\"type\" v=\"multipolygon\"/>\\n    <tag k=\"wheelchair\" v=\"yes\"/>\\n  </area>\\n  <area id=\"3605945176\">\\n    <tag k=\"addr:city\" v=\"Troisdorf\"/>\\n    <tag k=\"addr:postcode\" v=\"53840\"/>\\n    <tag k=\"description\" v=\"Troisdorf Bahnsteig Gleis 5+6\"/>\\n    <tag k=\"name\" v=\"Troisdorf\"/>\\n    <tag k=\"phone\" v=\"+49 221 1411055\"/>\\n    <tag k=\"public_transport\" v=\"platform\"/>\\n    <tag k=\"railway\" v=\"platform\"/>\\n    <tag k=\"ref\" v=\"5/6\"/>\\n    <tag k=\"tactile_paving\" v=\"yes\"/>\\n    <tag k=\"train\" v=\"yes\"/>\\n    <tag k=\"type\" v=\"multipolygon\"/>\\n    <tag k=\"wheelchair\" v=\"yes\"/>\\n    <tag k=\"wheelchair:description\" v=\"Der Aufzug zu diesem Bahnsteig ist oft defekt, bitte informieren. Betriebszustand kann bei 3S-Zentrale erfragt werden (siehe Telefonnummer, aber Vorsicht, die sind nicht immer informiert!)\"/>\\n    <tag k=\"width\" v=\"6\"/>\\n  </area>\\n\\n</osm>\\n'"}, {"func_args": {"filename": "'xml/node-01.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2014-12-14T12:58:02Z\"/>\\n  <node id=\"50878400\" lat=\"50.7461788\" lon=\"7.1742257\"/>\\n  <node id=\"100793192\" lat=\"50.7468472\" lon=\"7.1709376\">\\n    <tag k=\"highway\" v=\"turning_circle\"/>\\n  </node>\\n  <node id=\"3233854234\" lat=\"50.7494236\" lon=\"7.1757664\" version=\"1\" timestamp=\"2014-12-14T07:27:19Z\" changeset=\"23456789\" uid=\"345678\" user=\"TestUser\"/>\\n\\n</osm>'"}, {"func_args": {"filename": "'xml/node-01.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2014-12-14T12:58:02Z\"/>\\n  <node id=\"50878400\" lat=\"50.7461788\" lon=\"7.1742257\"/>\\n  <node id=\"100793192\" lat=\"50.7468472\" lon=\"7.1709376\">\\n    <tag k=\"highway\" v=\"turning_circle\"/>\\n  </node>\\n  <node id=\"3233854234\" lat=\"50.7494236\" lon=\"7.1757664\" version=\"1\" timestamp=\"2014-12-14T07:27:19Z\" changeset=\"23456789\" uid=\"345678\" user=\"TestUser\"/>\\n\\n</osm>'"}, {"func_args": {"filename": "'xml/relation-01.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2014-12-21T20:00:03Z\"/>\\n  <relation id=\"2046898\" version=\"12\" timestamp=\"2014-12-15T13:13:11Z\" changeset=\"17433822\" uid=\"12345\" user=\"Username\">\\n    <member type=\"node\" ref=\"507464632\" role=\"platform\"/>\\n    <member type=\"node\" ref=\"2252681768\" role=\"stop\"/>\\n    <member type=\"node\" ref=\"507464636\" role=\"platform\"/>\\n    <member type=\"node\" ref=\"1620886108\" role=\"stop\"/>\\n    <member type=\"way\" ref=\"4893348\" role=\"\"/>\\n    <tag k=\"from\" v=\"Here\"/>\\n    <tag k=\"name\" v=\"Test relation\"/>\\n    <tag k=\"ref\" v=\"609\"/>\\n    <tag k=\"route\" v=\"bus\"/>\\n    <tag k=\"to\" v=\"There\"/>\\n    <tag k=\"type\" v=\"route\"/>\\n  </relation>\\n</osm>'"}, {"func_args": {"filename": "'xml/relation-01.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2014-12-21T20:00:03Z\"/>\\n  <relation id=\"2046898\" version=\"12\" timestamp=\"2014-12-15T13:13:11Z\" changeset=\"17433822\" uid=\"12345\" user=\"Username\">\\n    <member type=\"node\" ref=\"507464632\" role=\"platform\"/>\\n    <member type=\"node\" ref=\"2252681768\" role=\"stop\"/>\\n    <member type=\"node\" ref=\"507464636\" role=\"platform\"/>\\n    <member type=\"node\" ref=\"1620886108\" role=\"stop\"/>\\n    <member type=\"way\" ref=\"4893348\" role=\"\"/>\\n    <tag k=\"from\" v=\"Here\"/>\\n    <tag k=\"name\" v=\"Test relation\"/>\\n    <tag k=\"ref\" v=\"609\"/>\\n    <tag k=\"route\" v=\"bus\"/>\\n    <tag k=\"to\" v=\"There\"/>\\n    <tag k=\"type\" v=\"route\"/>\\n  </relation>\\n</osm>'"}, {"func_args": {"filename": "'xml/relation-02.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2014-12-14T13:34:02Z\"/>\\n  <node id=\"3233854233\" lat=\"50.7494187\" lon=\"7.1758731\"/>\\n  <node id=\"3233854234\" lat=\"50.7494287\" lon=\"7.1758731\"/>\\n  <node id=\"3233854235\" lat=\"50.7494287\" lon=\"7.1758731\"/>\\n  <way id=\"317146078\">\\n    <nd ref=\"3233854233\"/>\\n    <nd ref=\"3233854234\"/>\\n    <nd ref=\"3233854235\"/>\\n  </way>\\n  <relation id=\"2046898\" version=\"12\" timestamp=\"2014-12-15T13:13:11Z\" changeset=\"17433822\" uid=\"12345\" user=\"Username\">\\n    <member type=\"node\" ref=\"3233854233\" role=\"platform\"/>\\n    <member type=\"node\" ref=\"3233854234\" role=\"stop\"/>\\n    <member type=\"node\" ref=\"3233854235\" role=\"platform\"/>\\n    <member type=\"way\" ref=\"317146078\" role=\"\"/>\\n    <tag k=\"from\" v=\"Here\"/>\\n    <tag k=\"name\" v=\"Test relation\"/>\\n    <tag k=\"ref\" v=\"609\"/>\\n    <tag k=\"route\" v=\"bus\"/>\\n    <tag k=\"to\" v=\"There\"/>\\n    <tag k=\"type\" v=\"route\"/>\\n  </relation>\\n</osm>'"}, {"func_args": {"filename": "'xml/relation-02.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2014-12-14T13:34:02Z\"/>\\n  <node id=\"3233854233\" lat=\"50.7494187\" lon=\"7.1758731\"/>\\n  <node id=\"3233854234\" lat=\"50.7494287\" lon=\"7.1758731\"/>\\n  <node id=\"3233854235\" lat=\"50.7494287\" lon=\"7.1758731\"/>\\n  <way id=\"317146078\">\\n    <nd ref=\"3233854233\"/>\\n    <nd ref=\"3233854234\"/>\\n    <nd ref=\"3233854235\"/>\\n  </way>\\n  <relation id=\"2046898\" version=\"12\" timestamp=\"2014-12-15T13:13:11Z\" changeset=\"17433822\" uid=\"12345\" user=\"Username\">\\n    <member type=\"node\" ref=\"3233854233\" role=\"platform\"/>\\n    <member type=\"node\" ref=\"3233854234\" role=\"stop\"/>\\n    <member type=\"node\" ref=\"3233854235\" role=\"platform\"/>\\n    <member type=\"way\" ref=\"317146078\" role=\"\"/>\\n    <tag k=\"from\" v=\"Here\"/>\\n    <tag k=\"name\" v=\"Test relation\"/>\\n    <tag k=\"ref\" v=\"609\"/>\\n    <tag k=\"route\" v=\"bus\"/>\\n    <tag k=\"to\" v=\"There\"/>\\n    <tag k=\"type\" v=\"route\"/>\\n  </relation>\\n</osm>'"}, {"func_args": {"filename": "'xml/relation-03.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2016-11-23T20:27:02Z\"/>\\n\\n  <relation id=\"23092\">\\n    <center lat=\"50.8176646\" lon=\"7.0208539\"/>\\n    <member type=\"way\" ref=\"4334856\" role=\"\"/>\\n    <member type=\"way\" ref=\"234434903\" role=\"\"/>\\n    <member type=\"way\" ref=\"37881522\" role=\"\"/>\\n    <member type=\"way\" ref=\"37881521\" role=\"\"/>\\n    <member type=\"way\" ref=\"4356491\" role=\"\"/>\\n    <member type=\"way\" ref=\"235363211\" role=\"\"/>\\n    <member type=\"way\" ref=\"48290877\" role=\"\"/>\\n    <member type=\"way\" ref=\"210683519\" role=\"\"/>\\n    <member type=\"way\" ref=\"42743961\" role=\"\"/>\\n    <member type=\"way\" ref=\"210683522\" role=\"\"/>\\n    <member type=\"way\" ref=\"48290881\" role=\"\"/>\\n    <member type=\"way\" ref=\"235363214\" role=\"\"/>\\n    <member type=\"way\" ref=\"4400137\" role=\"\"/>\\n    <member type=\"way\" ref=\"230940375\" role=\"\"/>\\n    <member type=\"way\" ref=\"4400140\" role=\"\"/>\\n    <member type=\"way\" ref=\"4400142\" role=\"\"/>\\n    <member type=\"way\" ref=\"235824476\" role=\"\"/>\\n    <member type=\"way\" ref=\"4400143\" role=\"\"/>\\n    <member type=\"way\" ref=\"235824475\" role=\"\"/>\\n    <member type=\"way\" ref=\"178797123\" role=\"\"/>\\n    <member type=\"way\" ref=\"233553030\" role=\"\"/>\\n    <member type=\"way\" ref=\"4829989\" role=\"\"/>\\n    <member type=\"way\" ref=\"99834112\" role=\"\"/>\\n    <member type=\"way\" ref=\"133081219\" role=\"\"/>\\n    <member type=\"way\" ref=\"234434905\" role=\"\"/>\\n    <member type=\"way\" ref=\"20661567\" role=\"\"/>\\n    <member type=\"way\" ref=\"230941900\" role=\"\"/>\\n    <member type=\"way\" ref=\"20661568\" role=\"\"/>\\n    <member type=\"way\" ref=\"20661572\" role=\"\"/>\\n    <member type=\"way\" ref=\"230940374\" role=\"\"/>\\n    <member type=\"way\" ref=\"20661573\" role=\"\"/>\\n    <member type=\"way\" ref=\"20662817\" role=\"\"/>\\n    <member type=\"way\" ref=\"230941903\" role=\"\"/>\\n    <member type=\"way\" ref=\"20662819\" role=\"\"/>\\n    <member type=\"way\" ref=\"20662824\" role=\"\"/>\\n    <member type=\"way\" ref=\"20662827\" role=\"\"/>\\n    <member type=\"way\" ref=\"27492515\" role=\"\"/>\\n    <member type=\"way\" ref=\"129125122\" role=\"\"/>\\n    <member type=\"way\" ref=\"234434901\" role=\"\"/>\\n    <member type=\"way\" ref=\"234434904\" role=\"\"/>\\n    <member type=\"way\" ref=\"27492542\" role=\"\"/>\\n    <member type=\"way\" ref=\"27492543\" role=\"\"/>\\n    <member type=\"way\" ref=\"29233646\" role=\"\"/>\\n    <member type=\"way\" ref=\"235820561\" role=\"\"/>\\n    <member type=\"way\" ref=\"29233647\" role=\"\"/>\\n    <member type=\"way\" ref=\"235820559\" role=\"\"/>\\n    <member type=\"way\" ref=\"235820562\" role=\"\"/>\\n    <member type=\"way\" ref=\"29233648\" role=\"\"/>\\n    <member type=\"way\" ref=\"29382960\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008229\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008238\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008230\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008226\" role=\"\"/>\\n    <member type=\"way\" ref=\"40033062\" role=\"\"/>\\n    <member type=\"way\" ref=\"40033063\" role=\"\"/>\\n    <member type=\"way\" ref=\"29384561\" role=\"\"/>\\n    <member type=\"way\" ref=\"29384563\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008224\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008227\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008237\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008232\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008239\" role=\"\"/>\\n    <member type=\"way\" ref=\"29384564\" role=\"\"/>\\n    <member type=\"way\" ref=\"31282638\" role=\"\"/>\\n    <member type=\"way\" ref=\"31282787\" role=\"\"/>\\n    <member type=\"way\" ref=\"383262762\" role=\"\"/>\\n    <member type=\"way\" ref=\"31304443\" role=\"\"/>\\n    <member type=\"way\" ref=\"128541594\" role=\"\"/>\\n    <member type=\"way\" ref=\"31304503\" role=\"\"/>\\n    <member type=\"way\" ref=\"31363881\" role=\"\"/>\\n    <member type=\"way\" ref=\"31363891\" role=\"\"/>\\n    <member type=\"way\" ref=\"31363892\" role=\"\"/>\\n    <member type=\"way\" ref=\"31363898\" role=\"\"/>\\n    <member type=\"way\" ref=\"31363910\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364152\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364158\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364178\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364384\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364387\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364484\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364512\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364656\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364667\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008234\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364888\" role=\"\"/>\\n    <member type=\"way\" ref=\"122158730\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364985\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008235\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008231\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008233\" role=\"\"/>\\n    <member type=\"way\" ref=\"31365377\" role=\"\"/>\\n    <member type=\"way\" ref=\"31365425\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008236\" role=\"\"/>\\n    <member type=\"way\" ref=\"36447898\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008228\" role=\"\"/>\\n    <member type=\"way\" ref=\"31366812\" role=\"\"/>\\n    <member type=\"way\" ref=\"31366880\" role=\"\"/>\\n    <member type=\"way\" ref=\"31367017\" role=\"\"/>\\n    <member type=\"way\" ref=\"31367443\" role=\"\"/>\\n    <member type=\"way\" ref=\"31367449\" role=\"\"/>\\n    <member type=\"way\" ref=\"31367526\" role=\"\"/>\\n    <member type=\"way\" ref=\"31367534\" role=\"\"/>\\n    <member type=\"way\" ref=\"31369852\" role=\"\"/>\\n    <member type=\"way\" ref=\"449397558\" role=\"\"/>\\n    <member type=\"way\" ref=\"31797389\" role=\"\"/>\\n    <member type=\"way\" ref=\"31798039\" role=\"\"/>\\n    <member type=\"way\" ref=\"235363212\" role=\"\"/>\\n    <member type=\"way\" ref=\"156492546\" role=\"\"/>\\n    <member type=\"way\" ref=\"156492545\" role=\"\"/>\\n    <member type=\"way\" ref=\"130749935\" role=\"\"/>\\n    <member type=\"way\" ref=\"32472877\" role=\"\"/>\\n    <member type=\"way\" ref=\"31798988\" role=\"\"/>\\n    <member type=\"way\" ref=\"31798989\" role=\"\"/>\\n    <member type=\"way\" ref=\"235820560\" role=\"\"/>\\n    <member type=\"way\" ref=\"235820563\" role=\"\"/>\\n    <member type=\"way\" ref=\"235820564\" role=\"\"/>\\n    <member type=\"way\" ref=\"235820570\" role=\"\"/>\\n    <member type=\"way\" ref=\"32472855\" role=\"\"/>\\n    <member type=\"way\" ref=\"32472856\" role=\"\"/>\\n    <member type=\"way\" ref=\"37881520\" role=\"\"/>\\n    <member type=\"way\" ref=\"37881519\" role=\"\"/>\\n    <member type=\"way\" ref=\"234434902\" role=\"\"/>\\n    <member type=\"way\" ref=\"32472875\" role=\"\"/>\\n    <member type=\"way\" ref=\"32473071\" role=\"\"/>\\n    <member type=\"way\" ref=\"128522486\" role=\"\"/>\\n    <member type=\"way\" ref=\"36447896\" role=\"\"/>\\n    <member type=\"way\" ref=\"32473075\" role=\"\"/>\\n    <member type=\"way\" ref=\"32473086\" role=\"\"/>\\n    <member type=\"way\" ref=\"32473087\" role=\"\"/>\\n    <member type=\"way\" ref=\"40033064\" role=\"\"/>\\n    <member type=\"way\" ref=\"189189059\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008225\" role=\"\"/>\\n    <member type=\"way\" ref=\"41550921\" role=\"\"/>\\n    <tag k=\"TMC:cid_58:tabcd_1:Class\" v=\"Road\"/>\\n    <tag k=\"TMC:cid_58:tabcd_1:LCLversion\" v=\"8.00\"/>\\n    <tag k=\"TMC:cid_58:tabcd_1:LocationCode\" v=\"7142\"/>\\n    <tag k=\"name\" v=\"Bundesautobahn 555\"/>\\n    <tag k=\"network\" v=\"BAB\"/>\\n    <tag k=\"operator\" v=\"Bundesrepublik Deutschland\"/>\\n    <tag k=\"ref\" v=\"A 555\"/>\\n    <tag k=\"route\" v=\"road\"/>\\n    <tag k=\"type\" v=\"route\"/>\\n    <tag k=\"wikipedia\" v=\"de:Bundesautobahn 555\"/>\\n  </relation>\\n\\n</osm>\\n'"}, {"func_args": {"filename": "'xml/relation-03.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2016-11-23T20:27:02Z\"/>\\n\\n  <relation id=\"23092\">\\n    <center lat=\"50.8176646\" lon=\"7.0208539\"/>\\n    <member type=\"way\" ref=\"4334856\" role=\"\"/>\\n    <member type=\"way\" ref=\"234434903\" role=\"\"/>\\n    <member type=\"way\" ref=\"37881522\" role=\"\"/>\\n    <member type=\"way\" ref=\"37881521\" role=\"\"/>\\n    <member type=\"way\" ref=\"4356491\" role=\"\"/>\\n    <member type=\"way\" ref=\"235363211\" role=\"\"/>\\n    <member type=\"way\" ref=\"48290877\" role=\"\"/>\\n    <member type=\"way\" ref=\"210683519\" role=\"\"/>\\n    <member type=\"way\" ref=\"42743961\" role=\"\"/>\\n    <member type=\"way\" ref=\"210683522\" role=\"\"/>\\n    <member type=\"way\" ref=\"48290881\" role=\"\"/>\\n    <member type=\"way\" ref=\"235363214\" role=\"\"/>\\n    <member type=\"way\" ref=\"4400137\" role=\"\"/>\\n    <member type=\"way\" ref=\"230940375\" role=\"\"/>\\n    <member type=\"way\" ref=\"4400140\" role=\"\"/>\\n    <member type=\"way\" ref=\"4400142\" role=\"\"/>\\n    <member type=\"way\" ref=\"235824476\" role=\"\"/>\\n    <member type=\"way\" ref=\"4400143\" role=\"\"/>\\n    <member type=\"way\" ref=\"235824475\" role=\"\"/>\\n    <member type=\"way\" ref=\"178797123\" role=\"\"/>\\n    <member type=\"way\" ref=\"233553030\" role=\"\"/>\\n    <member type=\"way\" ref=\"4829989\" role=\"\"/>\\n    <member type=\"way\" ref=\"99834112\" role=\"\"/>\\n    <member type=\"way\" ref=\"133081219\" role=\"\"/>\\n    <member type=\"way\" ref=\"234434905\" role=\"\"/>\\n    <member type=\"way\" ref=\"20661567\" role=\"\"/>\\n    <member type=\"way\" ref=\"230941900\" role=\"\"/>\\n    <member type=\"way\" ref=\"20661568\" role=\"\"/>\\n    <member type=\"way\" ref=\"20661572\" role=\"\"/>\\n    <member type=\"way\" ref=\"230940374\" role=\"\"/>\\n    <member type=\"way\" ref=\"20661573\" role=\"\"/>\\n    <member type=\"way\" ref=\"20662817\" role=\"\"/>\\n    <member type=\"way\" ref=\"230941903\" role=\"\"/>\\n    <member type=\"way\" ref=\"20662819\" role=\"\"/>\\n    <member type=\"way\" ref=\"20662824\" role=\"\"/>\\n    <member type=\"way\" ref=\"20662827\" role=\"\"/>\\n    <member type=\"way\" ref=\"27492515\" role=\"\"/>\\n    <member type=\"way\" ref=\"129125122\" role=\"\"/>\\n    <member type=\"way\" ref=\"234434901\" role=\"\"/>\\n    <member type=\"way\" ref=\"234434904\" role=\"\"/>\\n    <member type=\"way\" ref=\"27492542\" role=\"\"/>\\n    <member type=\"way\" ref=\"27492543\" role=\"\"/>\\n    <member type=\"way\" ref=\"29233646\" role=\"\"/>\\n    <member type=\"way\" ref=\"235820561\" role=\"\"/>\\n    <member type=\"way\" ref=\"29233647\" role=\"\"/>\\n    <member type=\"way\" ref=\"235820559\" role=\"\"/>\\n    <member type=\"way\" ref=\"235820562\" role=\"\"/>\\n    <member type=\"way\" ref=\"29233648\" role=\"\"/>\\n    <member type=\"way\" ref=\"29382960\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008229\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008238\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008230\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008226\" role=\"\"/>\\n    <member type=\"way\" ref=\"40033062\" role=\"\"/>\\n    <member type=\"way\" ref=\"40033063\" role=\"\"/>\\n    <member type=\"way\" ref=\"29384561\" role=\"\"/>\\n    <member type=\"way\" ref=\"29384563\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008224\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008227\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008237\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008232\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008239\" role=\"\"/>\\n    <member type=\"way\" ref=\"29384564\" role=\"\"/>\\n    <member type=\"way\" ref=\"31282638\" role=\"\"/>\\n    <member type=\"way\" ref=\"31282787\" role=\"\"/>\\n    <member type=\"way\" ref=\"383262762\" role=\"\"/>\\n    <member type=\"way\" ref=\"31304443\" role=\"\"/>\\n    <member type=\"way\" ref=\"128541594\" role=\"\"/>\\n    <member type=\"way\" ref=\"31304503\" role=\"\"/>\\n    <member type=\"way\" ref=\"31363881\" role=\"\"/>\\n    <member type=\"way\" ref=\"31363891\" role=\"\"/>\\n    <member type=\"way\" ref=\"31363892\" role=\"\"/>\\n    <member type=\"way\" ref=\"31363898\" role=\"\"/>\\n    <member type=\"way\" ref=\"31363910\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364152\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364158\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364178\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364384\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364387\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364484\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364512\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364656\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364667\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008234\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364888\" role=\"\"/>\\n    <member type=\"way\" ref=\"122158730\" role=\"\"/>\\n    <member type=\"way\" ref=\"31364985\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008235\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008231\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008233\" role=\"\"/>\\n    <member type=\"way\" ref=\"31365377\" role=\"\"/>\\n    <member type=\"way\" ref=\"31365425\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008236\" role=\"\"/>\\n    <member type=\"way\" ref=\"36447898\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008228\" role=\"\"/>\\n    <member type=\"way\" ref=\"31366812\" role=\"\"/>\\n    <member type=\"way\" ref=\"31366880\" role=\"\"/>\\n    <member type=\"way\" ref=\"31367017\" role=\"\"/>\\n    <member type=\"way\" ref=\"31367443\" role=\"\"/>\\n    <member type=\"way\" ref=\"31367449\" role=\"\"/>\\n    <member type=\"way\" ref=\"31367526\" role=\"\"/>\\n    <member type=\"way\" ref=\"31367534\" role=\"\"/>\\n    <member type=\"way\" ref=\"31369852\" role=\"\"/>\\n    <member type=\"way\" ref=\"449397558\" role=\"\"/>\\n    <member type=\"way\" ref=\"31797389\" role=\"\"/>\\n    <member type=\"way\" ref=\"31798039\" role=\"\"/>\\n    <member type=\"way\" ref=\"235363212\" role=\"\"/>\\n    <member type=\"way\" ref=\"156492546\" role=\"\"/>\\n    <member type=\"way\" ref=\"156492545\" role=\"\"/>\\n    <member type=\"way\" ref=\"130749935\" role=\"\"/>\\n    <member type=\"way\" ref=\"32472877\" role=\"\"/>\\n    <member type=\"way\" ref=\"31798988\" role=\"\"/>\\n    <member type=\"way\" ref=\"31798989\" role=\"\"/>\\n    <member type=\"way\" ref=\"235820560\" role=\"\"/>\\n    <member type=\"way\" ref=\"235820563\" role=\"\"/>\\n    <member type=\"way\" ref=\"235820564\" role=\"\"/>\\n    <member type=\"way\" ref=\"235820570\" role=\"\"/>\\n    <member type=\"way\" ref=\"32472855\" role=\"\"/>\\n    <member type=\"way\" ref=\"32472856\" role=\"\"/>\\n    <member type=\"way\" ref=\"37881520\" role=\"\"/>\\n    <member type=\"way\" ref=\"37881519\" role=\"\"/>\\n    <member type=\"way\" ref=\"234434902\" role=\"\"/>\\n    <member type=\"way\" ref=\"32472875\" role=\"\"/>\\n    <member type=\"way\" ref=\"32473071\" role=\"\"/>\\n    <member type=\"way\" ref=\"128522486\" role=\"\"/>\\n    <member type=\"way\" ref=\"36447896\" role=\"\"/>\\n    <member type=\"way\" ref=\"32473075\" role=\"\"/>\\n    <member type=\"way\" ref=\"32473086\" role=\"\"/>\\n    <member type=\"way\" ref=\"32473087\" role=\"\"/>\\n    <member type=\"way\" ref=\"40033064\" role=\"\"/>\\n    <member type=\"way\" ref=\"189189059\" role=\"\"/>\\n    <member type=\"way\" ref=\"271008225\" role=\"\"/>\\n    <member type=\"way\" ref=\"41550921\" role=\"\"/>\\n    <tag k=\"TMC:cid_58:tabcd_1:Class\" v=\"Road\"/>\\n    <tag k=\"TMC:cid_58:tabcd_1:LCLversion\" v=\"8.00\"/>\\n    <tag k=\"TMC:cid_58:tabcd_1:LocationCode\" v=\"7142\"/>\\n    <tag k=\"name\" v=\"Bundesautobahn 555\"/>\\n    <tag k=\"network\" v=\"BAB\"/>\\n    <tag k=\"operator\" v=\"Bundesrepublik Deutschland\"/>\\n    <tag k=\"ref\" v=\"A 555\"/>\\n    <tag k=\"route\" v=\"road\"/>\\n    <tag k=\"type\" v=\"route\"/>\\n    <tag k=\"wikipedia\" v=\"de:Bundesautobahn 555\"/>\\n  </relation>\\n\\n</osm>\\n'"}, {"func_args": {"filename": "'xml/relation-04.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2016-11-24T22:22:03Z\"/>\\n\\n  <relation id=\"23092\">\\n    <bounds minlat=\"50.7432318\" minlon=\"6.9639432\" maxlat=\"50.8920975\" maxlon=\"7.0777645\"/>\\n    <member type=\"way\" ref=\"4334856\" role=\"\">\\n      <nd lat=\"50.8104598\" lon=\"6.9871803\"/>\\n      <nd lat=\"50.8117239\" lon=\"6.9849282\"/>\\n    </member>\\n    <member type=\"way\" ref=\"234434903\" role=\"\">\\n      <nd lat=\"50.8117239\" lon=\"6.9849282\"/>\\n      <nd lat=\"50.8137408\" lon=\"6.9813352\"/>\\n    </member>\\n    <member type=\"way\" ref=\"37881522\" role=\"\">\\n      <nd lat=\"50.8137408\" lon=\"6.9813352\"/>\\n      <nd lat=\"50.8140146\" lon=\"6.9808445\"/>\\n    </member>\\n    <member type=\"way\" ref=\"37881521\" role=\"\">\\n      <nd lat=\"50.8140146\" lon=\"6.9808445\"/>\\n      <nd lat=\"50.8193541\" lon=\"6.9713457\"/>\\n      <nd lat=\"50.8203182\" lon=\"6.9697248\"/>\\n      <nd lat=\"50.8210652\" lon=\"6.9685758\"/>\\n      <nd lat=\"50.8217885\" lon=\"6.9676136\"/>\\n      <nd lat=\"50.8225495\" lon=\"6.9667439\"/>\\n      <nd lat=\"50.8233005\" lon=\"6.9660515\"/>\\n      <nd lat=\"50.8238128\" lon=\"6.9656463\"/>\\n      <nd lat=\"50.8243279\" lon=\"6.9653077\"/>\\n    </member>\\n    <member type=\"way\" ref=\"4356491\" role=\"\">\\n      <nd lat=\"50.7433997\" lon=\"7.0777645\"/>\\n      <nd lat=\"50.7434097\" lon=\"7.0775890\"/>\\n      <nd lat=\"50.7434629\" lon=\"7.0774402\"/>\\n      <nd lat=\"50.7435198\" lon=\"7.0773718\"/>\\n      <nd lat=\"50.7437507\" lon=\"7.0771524\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235363211\" role=\"\">\\n      <nd lat=\"50.7437507\" lon=\"7.0771524\"/>\\n      <nd lat=\"50.7446592\" lon=\"7.0762926\"/>\\n    </member>\\n    <member type=\"way\" ref=\"48290877\" role=\"\">\\n      <nd lat=\"50.7446592\" lon=\"7.0762926\"/>\\n      <nd lat=\"50.7450803\" lon=\"7.0757571\"/>\\n      <nd lat=\"50.7453888\" lon=\"7.0753312\"/>\\n      <nd lat=\"50.7457125\" lon=\"7.0748518\"/>\\n      <nd lat=\"50.7460370\" lon=\"7.0743265\"/>\\n      <nd lat=\"50.7462718\" lon=\"7.0739425\"/>\\n      <nd lat=\"50.7464798\" lon=\"7.0735173\"/>\\n      <nd lat=\"50.7468359\" lon=\"7.0727449\"/>\\n    </member>\\n    <member type=\"way\" ref=\"210683519\" role=\"\">\\n      <nd lat=\"50.7468359\" lon=\"7.0727449\"/>\\n      <nd lat=\"50.7471006\" lon=\"7.0720546\"/>\\n      <nd lat=\"50.7473135\" lon=\"7.0714640\"/>\\n      <nd lat=\"50.7475199\" lon=\"7.0708095\"/>\\n      <nd lat=\"50.7479418\" lon=\"7.0693723\"/>\\n    </member>\\n    <member type=\"way\" ref=\"42743961\" role=\"\">\\n      <nd lat=\"50.7464112\" lon=\"7.0734310\"/>\\n      <nd lat=\"50.7459053\" lon=\"7.0743560\"/>\\n      <nd lat=\"50.7457638\" lon=\"7.0745740\"/>\\n    </member>\\n    <member type=\"way\" ref=\"210683522\" role=\"\">\\n      <nd lat=\"50.7457638\" lon=\"7.0745740\"/>\\n      <nd lat=\"50.7456300\" lon=\"7.0747409\"/>\\n      <nd lat=\"50.7454858\" lon=\"7.0749187\"/>\\n      <nd lat=\"50.7452550\" lon=\"7.0752554\"/>\\n      <nd lat=\"50.7450000\" lon=\"7.0756385\"/>\\n      <nd lat=\"50.7448878\" lon=\"7.0758027\"/>\\n      <nd lat=\"50.7447522\" lon=\"7.0759730\"/>\\n      <nd lat=\"50.7445514\" lon=\"7.0762032\"/>\\n      <nd lat=\"50.7443577\" lon=\"7.0764098\"/>\\n      <nd lat=\"50.7441185\" lon=\"7.0766490\"/>\\n    </member>\\n    <member type=\"way\" ref=\"48290881\" role=\"\">\\n      <nd lat=\"50.7441185\" lon=\"7.0766490\"/>\\n      <nd lat=\"50.7439033\" lon=\"7.0768575\"/>\\n      <nd lat=\"50.7437722\" lon=\"7.0769631\"/>\\n      <nd lat=\"50.7436609\" lon=\"7.0770394\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235363214\" role=\"\">\\n      <nd lat=\"50.7436609\" lon=\"7.0770394\"/>\\n      <nd lat=\"50.7435688\" lon=\"7.0771154\"/>\\n      <nd lat=\"50.7434662\" lon=\"7.0771906\"/>\\n      <nd lat=\"50.7434058\" lon=\"7.0772230\"/>\\n      <nd lat=\"50.7433331\" lon=\"7.0772525\"/>\\n      <nd lat=\"50.7432822\" lon=\"7.0772636\"/>\\n      <nd lat=\"50.7432318\" lon=\"7.0772601\"/>\\n    </member>\\n    <member type=\"way\" ref=\"4400137\" role=\"\">\\n      <nd lat=\"50.8887155\" lon=\"6.9676900\"/>\\n      <nd lat=\"50.8876384\" lon=\"6.9678150\"/>\\n    </member>\\n    <member type=\"way\" ref=\"230940375\" role=\"\">\\n      <nd lat=\"50.8876384\" lon=\"6.9678150\"/>\\n      <nd lat=\"50.8870572\" lon=\"6.9679058\"/>\\n      <nd lat=\"50.8858563\" lon=\"6.9680103\"/>\\n    </member>\\n    <member type=\"way\" ref=\"4400140\" role=\"\">\\n      <nd lat=\"50.8797318\" lon=\"6.9690108\"/>\\n      <nd lat=\"50.8799208\" lon=\"6.9689396\"/>\\n      <nd lat=\"50.8807058\" lon=\"6.9688470\"/>\\n      <nd lat=\"50.8824762\" lon=\"6.9687068\"/>\\n    </member>\\n    <member type=\"way\" ref=\"4400142\" role=\"\">\\n      <nd lat=\"50.8919691\" lon=\"6.9670292\"/>\\n      <nd lat=\"50.8918982\" lon=\"6.9671419\"/>\\n      <nd lat=\"50.8918068\" lon=\"6.9672404\"/>\\n      <nd lat=\"50.8917186\" lon=\"6.9673001\"/>\\n      <nd lat=\"50.8916153\" lon=\"6.9673480\"/>\\n      <nd lat=\"50.8914588\" lon=\"6.9673816\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235824476\" role=\"\">\\n      <nd lat=\"50.8914588\" lon=\"6.9673816\"/>\\n      <nd lat=\"50.8892470\" lon=\"6.9676302\"/>\\n      <nd lat=\"50.8887155\" lon=\"6.9676900\"/>\\n    </member>\\n    <member type=\"way\" ref=\"4400143\" role=\"\">\\n      <nd lat=\"50.8887787\" lon=\"6.9681629\"/>\\n      <nd lat=\"50.8896224\" lon=\"6.9680604\"/>\\n      <nd lat=\"50.8897525\" lon=\"6.9680446\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235824475\" role=\"\">\\n      <nd lat=\"50.8897525\" lon=\"6.9680446\"/>\\n      <nd lat=\"50.8906556\" lon=\"6.9679349\"/>\\n      <nd lat=\"50.8912013\" lon=\"6.9678862\"/>\\n    </member>\\n    <member type=\"way\" ref=\"178797123\" role=\"\">\\n      <nd lat=\"50.8912013\" lon=\"6.9678862\"/>\\n      <nd lat=\"50.8913492\" lon=\"6.9678648\"/>\\n    </member>\\n    <member type=\"way\" ref=\"233553030\" role=\"\">\\n      <nd lat=\"50.8913492\" lon=\"6.9678648\"/>\\n      <nd lat=\"50.8916648\" lon=\"6.9677762\"/>\\n      <nd lat=\"50.8917895\" lon=\"6.9677694\"/>\\n      <nd lat=\"50.8919294\" lon=\"6.9677947\"/>\\n      <nd lat=\"50.8920975\" lon=\"6.9678618\"/>\\n    </member>\\n    <member type=\"way\" ref=\"4829989\" role=\"\">\\n      <nd lat=\"50.8105743\" lon=\"6.9865001\"/>\\n      <nd lat=\"50.8088268\" lon=\"6.9896207\"/>\\n    </member>\\n    <member type=\"way\" ref=\"99834112\" role=\"\">\\n      <nd lat=\"50.8088268\" lon=\"6.9896207\"/>\\n      <nd lat=\"50.8066272\" lon=\"6.9935457\"/>\\n      <nd lat=\"50.8057165\" lon=\"6.9951151\"/>\\n    </member>\\n    <member type=\"way\" ref=\"133081219\" role=\"\">\\n      <nd lat=\"50.8057165\" lon=\"6.9951151\"/>\\n      <nd lat=\"50.8050332\" lon=\"6.9962100\"/>\\n      <nd lat=\"50.8043133\" lon=\"6.9972614\"/>\\n    </member>\\n    <member type=\"way\" ref=\"234434905\" role=\"\">\\n      <nd lat=\"50.8043133\" lon=\"6.9972614\"/>\\n      <nd lat=\"50.8038004\" lon=\"6.9979304\"/>\\n      <nd lat=\"50.8032120\" lon=\"6.9986363\"/>\\n      <nd lat=\"50.8029818\" lon=\"6.9989181\"/>\\n    </member>\\n    <member type=\"way\" ref=\"20661567\" role=\"\">\\n      <nd lat=\"50.8849681\" lon=\"6.9681126\"/>\\n      <nd lat=\"50.8839667\" lon=\"6.9682524\"/>\\n      <nd lat=\"50.8829770\" lon=\"6.9684059\"/>\\n    </member>\\n    <member type=\"way\" ref=\"230941900\" role=\"\">\\n      <nd lat=\"50.8829770\" lon=\"6.9684059\"/>\\n      <nd lat=\"50.8826286\" lon=\"6.9684595\"/>\\n    </member>\\n    <member type=\"way\" ref=\"20661568\" role=\"\">\\n      <nd lat=\"50.8850872\" lon=\"6.9685052\"/>\\n      <nd lat=\"50.8859127\" lon=\"6.9684079\"/>\\n    </member>\\n    <member type=\"way\" ref=\"20661572\" role=\"\">\\n      <nd lat=\"50.8859127\" lon=\"6.9684079\"/>\\n      <nd lat=\"50.8872823\" lon=\"6.9682592\"/>\\n      <nd lat=\"50.8876807\" lon=\"6.9682539\"/>\\n    </member>\\n    <member type=\"way\" ref=\"230940374\" role=\"\">\\n      <nd lat=\"50.8876807\" lon=\"6.9682539\"/>\\n      <nd lat=\"50.8887787\" lon=\"6.9681629\"/>\\n    </member>\\n    <member type=\"way\" ref=\"20661573\" role=\"\">\\n      <nd lat=\"50.8858563\" lon=\"6.9680103\"/>\\n      <nd lat=\"50.8849681\" lon=\"6.9681126\"/>\\n    </member>\\n    <member type=\"way\" ref=\"20662817\" role=\"\">\\n      <nd lat=\"50.8823655\" lon=\"6.9684998\"/>\\n      <nd lat=\"50.8806620\" lon=\"6.9686453\"/>\\n    </member>\\n    <member type=\"way\" ref=\"230941903\" role=\"\">\\n      <nd lat=\"50.8806620\" lon=\"6.9686453\"/>\\n      <nd lat=\"50.8793943\" lon=\"6.9687847\"/>\\n    </member>\\n    <member type=\"way\" ref=\"20662819\" role=\"\">\\n      <nd lat=\"50.8824762\" lon=\"6.9687068\"/>\\n      <nd lat=\"50.8827522\" lon=\"6.9686901\"/>\\n    </member>\\n    <member type=\"way\" ref=\"20662824\" role=\"\">\\n      <nd lat=\"50.8827522\" lon=\"6.9686901\"/>\\n      <nd lat=\"50.8839133\" lon=\"6.9686122\"/>\\n      <nd lat=\"50.8850872\" lon=\"6.9685052\"/>\\n    </member>\\n    <member type=\"way\" ref=\"20662827\" role=\"\">\\n      <nd lat=\"50.8826286\" lon=\"6.9684595\"/>\\n      <nd lat=\"50.8823655\" lon=\"6.9684998\"/>\\n    </member>\\n    <member type=\"way\" ref=\"27492515\" role=\"\">\\n      <nd lat=\"50.8029818\" lon=\"6.9989181\"/>\\n      <nd lat=\"50.8026288\" lon=\"6.9992932\"/>\\n    </member>\\n    <member type=\"way\" ref=\"129125122\" role=\"\">\\n      <nd lat=\"50.8093979\" lon=\"6.9890430\"/>\\n      <nd lat=\"50.8104598\" lon=\"6.9871803\"/>\\n    </member>\\n    <member type=\"way\" ref=\"234434901\" role=\"\">\\n      <nd lat=\"50.8063753\" lon=\"6.9944172\"/>\\n      <nd lat=\"50.8093979\" lon=\"6.9890430\"/>\\n    </member>\\n    <member type=\"way\" ref=\"234434904\" role=\"\">\\n      <nd lat=\"50.8053262\" lon=\"6.9961817\"/>\\n      <nd lat=\"50.8058108\" lon=\"6.9953914\"/>\\n      <nd lat=\"50.8063753\" lon=\"6.9944172\"/>\\n    </member>\\n    <member type=\"way\" ref=\"27492542\" role=\"\">\\n      <nd lat=\"50.8029899\" lon=\"6.9991939\"/>\\n      <nd lat=\"50.8032828\" lon=\"6.9988807\"/>\\n      <nd lat=\"50.8038702\" lon=\"6.9982129\"/>\\n      <nd lat=\"50.8044350\" lon=\"6.9974695\"/>\\n      <nd lat=\"50.8053262\" lon=\"6.9961817\"/>\\n    </member>\\n    <member type=\"way\" ref=\"27492543\" role=\"\">\\n      <nd lat=\"50.8026483\" lon=\"6.9995590\"/>\\n      <nd lat=\"50.8029899\" lon=\"6.9991939\"/>\\n    </member>\\n    <member type=\"way\" ref=\"29233646\" role=\"\">\\n      <nd lat=\"50.8793943\" lon=\"6.9687847\"/>\\n      <nd lat=\"50.8716935\" lon=\"6.9696241\"/>\\n      <nd lat=\"50.8701666\" lon=\"6.9697243\"/>\\n      <nd lat=\"50.8688585\" lon=\"6.9697057\"/>\\n      <nd lat=\"50.8652424\" lon=\"6.9693872\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235820561\" role=\"\">\\n      <nd lat=\"50.8652424\" lon=\"6.9693872\"/>\\n      <nd lat=\"50.8636340\" lon=\"6.9692339\"/>\\n    </member>\\n    <member type=\"way\" ref=\"29233647\" role=\"\">\\n      <nd lat=\"50.8636340\" lon=\"6.9692339\"/>\\n      <nd lat=\"50.8608791\" lon=\"6.9689787\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235820559\" role=\"\">\\n      <nd lat=\"50.8608791\" lon=\"6.9689787\"/>\\n      <nd lat=\"50.8590168\" lon=\"6.9688055\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235820562\" role=\"\">\\n      <nd lat=\"50.8590168\" lon=\"6.9688055\"/>\\n      <nd lat=\"50.8523854\" lon=\"6.9681888\"/>\\n    </member>\\n    <member type=\"way\" ref=\"29233648\" role=\"\">\\n      <nd lat=\"50.8522171\" lon=\"6.9684787\"/>\\n      <nd lat=\"50.8590359\" lon=\"6.9691023\"/>\\n    </member>\\n    <member type=\"way\" ref=\"29382960\" role=\"\">\\n      <nd lat=\"50.8391695\" lon=\"6.9667285\"/>\\n      <nd lat=\"50.8411491\" lon=\"6.9672118\"/>\\n      <nd lat=\"50.8425706\" lon=\"6.9674985\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008229\" role=\"\">\\n      <nd lat=\"50.8425706\" lon=\"6.9674985\"/>\\n      <nd lat=\"50.8443277\" lon=\"6.9677563\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008238\" role=\"\">\\n      <nd lat=\"50.8443277\" lon=\"6.9677563\"/>\\n      <nd lat=\"50.8453254\" lon=\"6.9678465\"/>\\n      <nd lat=\"50.8468114\" lon=\"6.9679862\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008230\" role=\"\">\\n      <nd lat=\"50.8468114\" lon=\"6.9679862\"/>\\n      <nd lat=\"50.8491169\" lon=\"6.9681907\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008226\" role=\"\">\\n      <nd lat=\"50.8491169\" lon=\"6.9681907\"/>\\n      <nd lat=\"50.8518181\" lon=\"6.9684403\"/>\\n    </member>\\n    <member type=\"way\" ref=\"40033062\" role=\"\">\\n      <nd lat=\"50.8391857\" lon=\"6.9664246\"/>\\n      <nd lat=\"50.8386690\" lon=\"6.9662911\"/>\\n    </member>\\n    <member type=\"way\" ref=\"40033063\" role=\"\">\\n      <nd lat=\"50.8386690\" lon=\"6.9662911\"/>\\n      <nd lat=\"50.8314332\" lon=\"6.9644546\"/>\\n    </member>\\n    <member type=\"way\" ref=\"29384561\" role=\"\">\\n      <nd lat=\"50.8523854\" lon=\"6.9681888\"/>\\n      <nd lat=\"50.8519590\" lon=\"6.9681595\"/>\\n    </member>\\n    <member type=\"way\" ref=\"29384563\" role=\"\">\\n      <nd lat=\"50.8519590\" lon=\"6.9681595\"/>\\n      <nd lat=\"50.8506534\" lon=\"6.9680320\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008224\" role=\"\">\\n      <nd lat=\"50.8506534\" lon=\"6.9680320\"/>\\n      <nd lat=\"50.8490308\" lon=\"6.9678717\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008227\" role=\"\">\\n      <nd lat=\"50.8490308\" lon=\"6.9678717\"/>\\n      <nd lat=\"50.8478121\" lon=\"6.9677589\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008237\" role=\"\">\\n      <nd lat=\"50.8478121\" lon=\"6.9677589\"/>\\n      <nd lat=\"50.8459552\" lon=\"6.9676249\"/>\\n      <nd lat=\"50.8451822\" lon=\"6.9675256\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008232\" role=\"\">\\n      <nd lat=\"50.8451822\" lon=\"6.9675256\"/>\\n      <nd lat=\"50.8433946\" lon=\"6.9673373\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008239\" role=\"\">\\n      <nd lat=\"50.8433946\" lon=\"6.9673373\"/>\\n      <nd lat=\"50.8424071\" lon=\"6.9671724\"/>\\n      <nd lat=\"50.8411984\" lon=\"6.9669289\"/>\\n      <nd lat=\"50.8391857\" lon=\"6.9664246\"/>\\n    </member>\\n    <member type=\"way\" ref=\"29384564\" role=\"\">\\n      <nd lat=\"50.8518181\" lon=\"6.9684403\"/>\\n      <nd lat=\"50.8522171\" lon=\"6.9684787\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31282638\" role=\"\">\\n      <nd lat=\"50.7547305\" lon=\"7.0468957\"/>\\n      <nd lat=\"50.7550333\" lon=\"7.0462257\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31282787\" role=\"\">\\n      <nd lat=\"50.7548175\" lon=\"7.0462659\"/>\\n      <nd lat=\"50.7545192\" lon=\"7.0469416\"/>\\n    </member>\\n    <member type=\"way\" ref=\"383262762\" role=\"\">\\n      <nd lat=\"50.7545192\" lon=\"7.0469416\"/>\\n      <nd lat=\"50.7522859\" lon=\"7.0519784\"/>\\n      <nd lat=\"50.7519030\" lon=\"7.0528750\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31304443\" role=\"\">\\n      <nd lat=\"50.7519030\" lon=\"7.0528750\"/>\\n      <nd lat=\"50.7514373\" lon=\"7.0540731\"/>\\n      <nd lat=\"50.7512408\" lon=\"7.0546346\"/>\\n      <nd lat=\"50.7511231\" lon=\"7.0549962\"/>\\n      <nd lat=\"50.7508172\" lon=\"7.0560135\"/>\\n    </member>\\n    <member type=\"way\" ref=\"128541594\" role=\"\">\\n      <nd lat=\"50.7508172\" lon=\"7.0560135\"/>\\n      <nd lat=\"50.7504938\" lon=\"7.0572440\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31304503\" role=\"\">\\n      <nd lat=\"50.7509429\" lon=\"7.0561605\"/>\\n      <nd lat=\"50.7512483\" lon=\"7.0551357\"/>\\n      <nd lat=\"50.7513759\" lon=\"7.0547500\"/>\\n      <nd lat=\"50.7515670\" lon=\"7.0542197\"/>\\n      <nd lat=\"50.7520213\" lon=\"7.0530348\"/>\\n      <nd lat=\"50.7524214\" lon=\"7.0520935\"/>\\n      <nd lat=\"50.7547305\" lon=\"7.0468957\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31363881\" role=\"\">\\n      <nd lat=\"50.8026288\" lon=\"6.9992932\"/>\\n      <nd lat=\"50.8018617\" lon=\"7.0000625\"/>\\n      <nd lat=\"50.8010270\" lon=\"7.0007950\"/>\\n      <nd lat=\"50.8001164\" lon=\"7.0015291\"/>\\n      <nd lat=\"50.7928343\" lon=\"7.0072406\"/>\\n      <nd lat=\"50.7832350\" lon=\"7.0147268\"/>\\n      <nd lat=\"50.7826087\" lon=\"7.0151803\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31363891\" role=\"\">\\n      <nd lat=\"50.7826087\" lon=\"7.0151803\"/>\\n      <nd lat=\"50.7823221\" lon=\"7.0153822\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31363892\" role=\"\">\\n      <nd lat=\"50.7823221\" lon=\"7.0153822\"/>\\n      <nd lat=\"50.7802850\" lon=\"7.0170023\"/>\\n      <nd lat=\"50.7782200\" lon=\"7.0186241\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31363898\" role=\"\">\\n      <nd lat=\"50.7826777\" lon=\"7.0153975\"/>\\n      <nd lat=\"50.7833048\" lon=\"7.0149295\"/>\\n      <nd lat=\"50.8001641\" lon=\"7.0017836\"/>\\n      <nd lat=\"50.8010947\" lon=\"7.0010142\"/>\\n      <nd lat=\"50.8019538\" lon=\"7.0002540\"/>\\n      <nd lat=\"50.8026483\" lon=\"6.9995590\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31363910\" role=\"\">\\n      <nd lat=\"50.7823930\" lon=\"7.0156008\"/>\\n      <nd lat=\"50.7826777\" lon=\"7.0153975\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364152\" role=\"\">\\n      <nd lat=\"50.7782200\" lon=\"7.0186241\"/>\\n      <nd lat=\"50.7779774\" lon=\"7.0188037\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364158\" role=\"\">\\n      <nd lat=\"50.7783056\" lon=\"7.0188240\"/>\\n      <nd lat=\"50.7788577\" lon=\"7.0183860\"/>\\n      <nd lat=\"50.7803473\" lon=\"7.0172040\"/>\\n      <nd lat=\"50.7816582\" lon=\"7.0161766\"/>\\n      <nd lat=\"50.7823930\" lon=\"7.0156008\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364178\" role=\"\">\\n      <nd lat=\"50.7780676\" lon=\"7.0190054\"/>\\n      <nd lat=\"50.7783056\" lon=\"7.0188240\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364384\" role=\"\">\\n      <nd lat=\"50.7749036\" lon=\"7.0214625\"/>\\n      <nd lat=\"50.7780676\" lon=\"7.0190054\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364387\" role=\"\">\\n      <nd lat=\"50.7744886\" lon=\"7.0214841\"/>\\n      <nd lat=\"50.7712930\" lon=\"7.0240315\"/>\\n      <nd lat=\"50.7695809\" lon=\"7.0254447\"/>\\n      <nd lat=\"50.7686243\" lon=\"7.0263151\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364484\" role=\"\">\\n      <nd lat=\"50.7748248\" lon=\"7.0212347\"/>\\n      <nd lat=\"50.7744886\" lon=\"7.0214841\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364512\" role=\"\">\\n      <nd lat=\"50.7745735\" lon=\"7.0217089\"/>\\n      <nd lat=\"50.7749036\" lon=\"7.0214625\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364656\" role=\"\">\\n      <nd lat=\"50.7686546\" lon=\"7.0266216\"/>\\n      <nd lat=\"50.7696586\" lon=\"7.0256891\"/>\\n      <nd lat=\"50.7713905\" lon=\"7.0242565\"/>\\n      <nd lat=\"50.7745735\" lon=\"7.0217089\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364667\" role=\"\">\\n      <nd lat=\"50.7686243\" lon=\"7.0263151\"/>\\n      <nd lat=\"50.7676165\" lon=\"7.0273126\"/>\\n      <nd lat=\"50.7665957\" lon=\"7.0283332\"/>\\n      <nd lat=\"50.7653333\" lon=\"7.0297134\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008234\" role=\"\">\\n      <nd lat=\"50.7653333\" lon=\"7.0297134\"/>\\n      <nd lat=\"50.7643799\" lon=\"7.0308081\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364888\" role=\"\">\\n      <nd lat=\"50.7635269\" lon=\"7.0321873\"/>\\n      <nd lat=\"50.7641966\" lon=\"7.0313729\"/>\\n    </member>\\n    <member type=\"way\" ref=\"122158730\" role=\"\">\\n      <nd lat=\"50.7641966\" lon=\"7.0313729\"/>\\n      <nd lat=\"50.7644716\" lon=\"7.0310241\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364985\" role=\"\">\\n      <nd lat=\"50.7644716\" lon=\"7.0310241\"/>\\n      <nd lat=\"50.7648596\" lon=\"7.0305814\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008235\" role=\"\">\\n      <nd lat=\"50.7648596\" lon=\"7.0305814\"/>\\n      <nd lat=\"50.7657812\" lon=\"7.0295145\"/>\\n      <nd lat=\"50.7666465\" lon=\"7.0285903\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008231\" role=\"\">\\n      <nd lat=\"50.7666465\" lon=\"7.0285903\"/>\\n      <nd lat=\"50.7679887\" lon=\"7.0272481\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008233\" role=\"\">\\n      <nd lat=\"50.7679887\" lon=\"7.0272481\"/>\\n      <nd lat=\"50.7686546\" lon=\"7.0266216\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31365377\" role=\"\">\\n      <nd lat=\"50.7643799\" lon=\"7.0308081\"/>\\n      <nd lat=\"50.7640807\" lon=\"7.0311662\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31365425\" role=\"\">\\n      <nd lat=\"50.7640807\" lon=\"7.0311662\"/>\\n      <nd lat=\"50.7638566\" lon=\"7.0314272\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008236\" role=\"\">\\n      <nd lat=\"50.7638566\" lon=\"7.0314272\"/>\\n      <nd lat=\"50.7628914\" lon=\"7.0326760\"/>\\n      <nd lat=\"50.7621053\" lon=\"7.0336961\"/>\\n    </member>\\n    <member type=\"way\" ref=\"36447898\" role=\"\">\\n      <nd lat=\"50.7621053\" lon=\"7.0336961\"/>\\n      <nd lat=\"50.7613433\" lon=\"7.0347526\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008228\" role=\"\">\\n      <nd lat=\"50.7613433\" lon=\"7.0347526\"/>\\n      <nd lat=\"50.7608295\" lon=\"7.0354890\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31366812\" role=\"\">\\n      <nd lat=\"50.7588227\" lon=\"7.0386254\"/>\\n      <nd lat=\"50.7583011\" lon=\"7.0394929\"/>\\n      <nd lat=\"50.7576749\" lon=\"7.0405773\"/>\\n      <nd lat=\"50.7569096\" lon=\"7.0419812\"/>\\n      <nd lat=\"50.7558745\" lon=\"7.0439976\"/>\\n      <nd lat=\"50.7548175\" lon=\"7.0462659\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31366880\" role=\"\">\\n      <nd lat=\"50.7550333\" lon=\"7.0462257\"/>\\n      <nd lat=\"50.7559939\" lon=\"7.0442408\"/>\\n      <nd lat=\"50.7570656\" lon=\"7.0421620\"/>\\n      <nd lat=\"50.7578037\" lon=\"7.0408023\"/>\\n      <nd lat=\"50.7584541\" lon=\"7.0396561\"/>\\n      <nd lat=\"50.7589669\" lon=\"7.0387984\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31367017\" role=\"\">\\n      <nd lat=\"50.7609333\" lon=\"7.0356976\"/>\\n      <nd lat=\"50.7619690\" lon=\"7.0342371\"/>\\n      <nd lat=\"50.7630051\" lon=\"7.0328461\"/>\\n      <nd lat=\"50.7635269\" lon=\"7.0321873\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31367443\" role=\"\">\\n      <nd lat=\"50.7607331\" lon=\"7.0359794\"/>\\n      <nd lat=\"50.7609333\" lon=\"7.0356976\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31367449\" role=\"\">\\n      <nd lat=\"50.7589669\" lon=\"7.0387984\"/>\\n      <nd lat=\"50.7602933\" lon=\"7.0366481\"/>\\n      <nd lat=\"50.7607331\" lon=\"7.0359794\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31367526\" role=\"\">\\n      <nd lat=\"50.7606164\" lon=\"7.0358121\"/>\\n      <nd lat=\"50.7601681\" lon=\"7.0365126\"/>\\n      <nd lat=\"50.7588227\" lon=\"7.0386254\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31367534\" role=\"\">\\n      <nd lat=\"50.7608295\" lon=\"7.0354890\"/>\\n      <nd lat=\"50.7606164\" lon=\"7.0358121\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31369852\" role=\"\">\\n      <nd lat=\"50.7779774\" lon=\"7.0188037\"/>\\n      <nd lat=\"50.7748248\" lon=\"7.0212347\"/>\\n    </member>\\n    <member type=\"way\" ref=\"449397558\" role=\"\">\\n      <nd lat=\"50.7479418\" lon=\"7.0693723\"/>\\n      <nd lat=\"50.7494783\" lon=\"7.0624630\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31797389\" role=\"\">\\n      <nd lat=\"50.7494783\" lon=\"7.0624630\"/>\\n      <nd lat=\"50.7502727\" lon=\"7.0588905\"/>\\n      <nd lat=\"50.7506441\" lon=\"7.0572942\"/>\\n      <nd lat=\"50.7509429\" lon=\"7.0561605\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31798039\" role=\"\">\\n      <nd lat=\"50.7504938\" lon=\"7.0572440\"/>\\n      <nd lat=\"50.7501306\" lon=\"7.0588140\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235363212\" role=\"\">\\n      <nd lat=\"50.7501306\" lon=\"7.0588140\"/>\\n      <nd lat=\"50.7492636\" lon=\"7.0626737\"/>\\n      <nd lat=\"50.7489407\" lon=\"7.0641605\"/>\\n    </member>\\n    <member type=\"way\" ref=\"156492546\" role=\"\">\\n      <nd lat=\"50.7489407\" lon=\"7.0641605\"/>\\n      <nd lat=\"50.7488307\" lon=\"7.0647205\"/>\\n      <nd lat=\"50.7483739\" lon=\"7.0668216\"/>\\n    </member>\\n    <member type=\"way\" ref=\"156492545\" role=\"\">\\n      <nd lat=\"50.7483739\" lon=\"7.0668216\"/>\\n      <nd lat=\"50.7483009\" lon=\"7.0672440\"/>\\n      <nd lat=\"50.7478400\" lon=\"7.0692844\"/>\\n    </member>\\n    <member type=\"way\" ref=\"130749935\" role=\"\">\\n      <nd lat=\"50.7478400\" lon=\"7.0692844\"/>\\n      <nd lat=\"50.7477294\" lon=\"7.0697394\"/>\\n      <nd lat=\"50.7476187\" lon=\"7.0701855\"/>\\n      <nd lat=\"50.7474997\" lon=\"7.0706232\"/>\\n      <nd lat=\"50.7473468\" lon=\"7.0711189\"/>\\n      <nd lat=\"50.7472087\" lon=\"7.0715434\"/>\\n      <nd lat=\"50.7470472\" lon=\"7.0719838\"/>\\n      <nd lat=\"50.7469114\" lon=\"7.0723163\"/>\\n      <nd lat=\"50.7467733\" lon=\"7.0726489\"/>\\n      <nd lat=\"50.7465937\" lon=\"7.0730580\"/>\\n      <nd lat=\"50.7464112\" lon=\"7.0734310\"/>\\n    </member>\\n    <member type=\"way\" ref=\"32472877\" role=\"\">\\n      <nd lat=\"50.8246828\" lon=\"6.9651077\"/>\\n      <nd lat=\"50.8253375\" lon=\"6.9647718\"/>\\n      <nd lat=\"50.8260000\" lon=\"6.9645354\"/>\\n      <nd lat=\"50.8266134\" lon=\"6.9643649\"/>\\n      <nd lat=\"50.8272671\" lon=\"6.9642646\"/>\\n      <nd lat=\"50.8278017\" lon=\"6.9642349\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31798988\" role=\"\">\\n      <nd lat=\"50.8278017\" lon=\"6.9642349\"/>\\n      <nd lat=\"50.8284805\" lon=\"6.9642342\"/>\\n      <nd lat=\"50.8294617\" lon=\"6.9643395\"/>\\n      <nd lat=\"50.8302437\" lon=\"6.9644810\"/>\\n      <nd lat=\"50.8309474\" lon=\"6.9646345\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31798989\" role=\"\">\\n      <nd lat=\"50.8590359\" lon=\"6.9691023\"/>\\n      <nd lat=\"50.8634113\" lon=\"6.9695191\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235820560\" role=\"\">\\n      <nd lat=\"50.8634113\" lon=\"6.9695191\"/>\\n      <nd lat=\"50.8656224\" lon=\"6.9697185\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235820563\" role=\"\">\\n      <nd lat=\"50.8656224\" lon=\"6.9697185\"/>\\n      <nd lat=\"50.8679633\" lon=\"6.9699314\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235820564\" role=\"\">\\n      <nd lat=\"50.8679633\" lon=\"6.9699314\"/>\\n      <nd lat=\"50.8691580\" lon=\"6.9700171\"/>\\n      <nd lat=\"50.8699302\" lon=\"6.9700221\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235820570\" role=\"\">\\n      <nd lat=\"50.8699302\" lon=\"6.9700221\"/>\\n      <nd lat=\"50.8717399\" lon=\"6.9699121\"/>\\n      <nd lat=\"50.8746263\" lon=\"6.9695939\"/>\\n    </member>\\n    <member type=\"way\" ref=\"32472855\" role=\"\">\\n      <nd lat=\"50.8246253\" lon=\"6.9648384\"/>\\n      <nd lat=\"50.8242516\" lon=\"6.9650453\"/>\\n    </member>\\n    <member type=\"way\" ref=\"32472856\" role=\"\">\\n      <nd lat=\"50.8242516\" lon=\"6.9650453\"/>\\n      <nd lat=\"50.8237235\" lon=\"6.9653841\"/>\\n      <nd lat=\"50.8232034\" lon=\"6.9657948\"/>\\n      <nd lat=\"50.8224317\" lon=\"6.9665263\"/>\\n      <nd lat=\"50.8216642\" lon=\"6.9673886\"/>\\n      <nd lat=\"50.8209037\" lon=\"6.9684049\"/>\\n      <nd lat=\"50.8201541\" lon=\"6.9695500\"/>\\n      <nd lat=\"50.8192181\" lon=\"6.9711445\"/>\\n      <nd lat=\"50.8138575\" lon=\"6.9806731\"/>\\n    </member>\\n    <member type=\"way\" ref=\"37881520\" role=\"\">\\n      <nd lat=\"50.8138575\" lon=\"6.9806731\"/>\\n      <nd lat=\"50.8135770\" lon=\"6.9811721\"/>\\n    </member>\\n    <member type=\"way\" ref=\"37881519\" role=\"\">\\n      <nd lat=\"50.8135770\" lon=\"6.9811721\"/>\\n      <nd lat=\"50.8113547\" lon=\"6.9851361\"/>\\n    </member>\\n    <member type=\"way\" ref=\"234434902\" role=\"\">\\n      <nd lat=\"50.8113547\" lon=\"6.9851361\"/>\\n      <nd lat=\"50.8105743\" lon=\"6.9865001\"/>\\n    </member>\\n    <member type=\"way\" ref=\"32472875\" role=\"\">\\n      <nd lat=\"50.8243279\" lon=\"6.9653077\"/>\\n      <nd lat=\"50.8246828\" lon=\"6.9651077\"/>\\n    </member>\\n    <member type=\"way\" ref=\"32473071\" role=\"\">\\n      <nd lat=\"50.8309464\" lon=\"6.9643368\"/>\\n      <nd lat=\"50.8302815\" lon=\"6.9641912\"/>\\n    </member>\\n    <member type=\"way\" ref=\"128522486\" role=\"\">\\n      <nd lat=\"50.8302815\" lon=\"6.9641912\"/>\\n      <nd lat=\"50.8294728\" lon=\"6.9640448\"/>\\n      <nd lat=\"50.8284964\" lon=\"6.9639463\"/>\\n      <nd lat=\"50.8277970\" lon=\"6.9639432\"/>\\n    </member>\\n    <member type=\"way\" ref=\"36447896\" role=\"\">\\n      <nd lat=\"50.8277970\" lon=\"6.9639432\"/>\\n      <nd lat=\"50.8272631\" lon=\"6.9639682\"/>\\n      <nd lat=\"50.8265661\" lon=\"6.9640827\"/>\\n      <nd lat=\"50.8259717\" lon=\"6.9642405\"/>\\n      <nd lat=\"50.8252714\" lon=\"6.9645096\"/>\\n      <nd lat=\"50.8246253\" lon=\"6.9648384\"/>\\n    </member>\\n    <member type=\"way\" ref=\"32473075\" role=\"\">\\n      <nd lat=\"50.8314332\" lon=\"6.9644546\"/>\\n      <nd lat=\"50.8309464\" lon=\"6.9643368\"/>\\n    </member>\\n    <member type=\"way\" ref=\"32473086\" role=\"\">\\n      <nd lat=\"50.8309474\" lon=\"6.9646345\"/>\\n      <nd lat=\"50.8314534\" lon=\"6.9647679\"/>\\n    </member>\\n    <member type=\"way\" ref=\"32473087\" role=\"\">\\n      <nd lat=\"50.8314534\" lon=\"6.9647679\"/>\\n      <nd lat=\"50.8386440\" lon=\"6.9665955\"/>\\n    </member>\\n    <member type=\"way\" ref=\"40033064\" role=\"\">\\n      <nd lat=\"50.8386440\" lon=\"6.9665955\"/>\\n      <nd lat=\"50.8391695\" lon=\"6.9667285\"/>\\n    </member>\\n    <member type=\"way\" ref=\"189189059\" role=\"\">\\n      <nd lat=\"50.8746263\" lon=\"6.9695939\"/>\\n      <nd lat=\"50.8760907\" lon=\"6.9694358\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008225\" role=\"\">\\n      <nd lat=\"50.8760907\" lon=\"6.9694358\"/>\\n      <nd lat=\"50.8775484\" lon=\"6.9692784\"/>\\n    </member>\\n    <member type=\"way\" ref=\"41550921\" role=\"\">\\n      <nd lat=\"50.8775484\" lon=\"6.9692784\"/>\\n      <nd lat=\"50.8797318\" lon=\"6.9690108\"/>\\n    </member>\\n    <tag k=\"TMC:cid_58:tabcd_1:Class\" v=\"Road\"/>\\n    <tag k=\"TMC:cid_58:tabcd_1:LCLversion\" v=\"8.00\"/>\\n    <tag k=\"TMC:cid_58:tabcd_1:LocationCode\" v=\"7142\"/>\\n    <tag k=\"name\" v=\"Bundesautobahn 555\"/>\\n    <tag k=\"network\" v=\"BAB\"/>\\n    <tag k=\"operator\" v=\"Bundesrepublik Deutschland\"/>\\n    <tag k=\"ref\" v=\"A 555\"/>\\n    <tag k=\"route\" v=\"road\"/>\\n    <tag k=\"type\" v=\"route\"/>\\n    <tag k=\"wikipedia\" v=\"de:Bundesautobahn 555\"/>\\n  </relation>\\n\\n</osm>\\n'"}, {"func_args": {"filename": "'xml/relation-04.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2016-11-24T22:22:03Z\"/>\\n\\n  <relation id=\"23092\">\\n    <bounds minlat=\"50.7432318\" minlon=\"6.9639432\" maxlat=\"50.8920975\" maxlon=\"7.0777645\"/>\\n    <member type=\"way\" ref=\"4334856\" role=\"\">\\n      <nd lat=\"50.8104598\" lon=\"6.9871803\"/>\\n      <nd lat=\"50.8117239\" lon=\"6.9849282\"/>\\n    </member>\\n    <member type=\"way\" ref=\"234434903\" role=\"\">\\n      <nd lat=\"50.8117239\" lon=\"6.9849282\"/>\\n      <nd lat=\"50.8137408\" lon=\"6.9813352\"/>\\n    </member>\\n    <member type=\"way\" ref=\"37881522\" role=\"\">\\n      <nd lat=\"50.8137408\" lon=\"6.9813352\"/>\\n      <nd lat=\"50.8140146\" lon=\"6.9808445\"/>\\n    </member>\\n    <member type=\"way\" ref=\"37881521\" role=\"\">\\n      <nd lat=\"50.8140146\" lon=\"6.9808445\"/>\\n      <nd lat=\"50.8193541\" lon=\"6.9713457\"/>\\n      <nd lat=\"50.8203182\" lon=\"6.9697248\"/>\\n      <nd lat=\"50.8210652\" lon=\"6.9685758\"/>\\n      <nd lat=\"50.8217885\" lon=\"6.9676136\"/>\\n      <nd lat=\"50.8225495\" lon=\"6.9667439\"/>\\n      <nd lat=\"50.8233005\" lon=\"6.9660515\"/>\\n      <nd lat=\"50.8238128\" lon=\"6.9656463\"/>\\n      <nd lat=\"50.8243279\" lon=\"6.9653077\"/>\\n    </member>\\n    <member type=\"way\" ref=\"4356491\" role=\"\">\\n      <nd lat=\"50.7433997\" lon=\"7.0777645\"/>\\n      <nd lat=\"50.7434097\" lon=\"7.0775890\"/>\\n      <nd lat=\"50.7434629\" lon=\"7.0774402\"/>\\n      <nd lat=\"50.7435198\" lon=\"7.0773718\"/>\\n      <nd lat=\"50.7437507\" lon=\"7.0771524\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235363211\" role=\"\">\\n      <nd lat=\"50.7437507\" lon=\"7.0771524\"/>\\n      <nd lat=\"50.7446592\" lon=\"7.0762926\"/>\\n    </member>\\n    <member type=\"way\" ref=\"48290877\" role=\"\">\\n      <nd lat=\"50.7446592\" lon=\"7.0762926\"/>\\n      <nd lat=\"50.7450803\" lon=\"7.0757571\"/>\\n      <nd lat=\"50.7453888\" lon=\"7.0753312\"/>\\n      <nd lat=\"50.7457125\" lon=\"7.0748518\"/>\\n      <nd lat=\"50.7460370\" lon=\"7.0743265\"/>\\n      <nd lat=\"50.7462718\" lon=\"7.0739425\"/>\\n      <nd lat=\"50.7464798\" lon=\"7.0735173\"/>\\n      <nd lat=\"50.7468359\" lon=\"7.0727449\"/>\\n    </member>\\n    <member type=\"way\" ref=\"210683519\" role=\"\">\\n      <nd lat=\"50.7468359\" lon=\"7.0727449\"/>\\n      <nd lat=\"50.7471006\" lon=\"7.0720546\"/>\\n      <nd lat=\"50.7473135\" lon=\"7.0714640\"/>\\n      <nd lat=\"50.7475199\" lon=\"7.0708095\"/>\\n      <nd lat=\"50.7479418\" lon=\"7.0693723\"/>\\n    </member>\\n    <member type=\"way\" ref=\"42743961\" role=\"\">\\n      <nd lat=\"50.7464112\" lon=\"7.0734310\"/>\\n      <nd lat=\"50.7459053\" lon=\"7.0743560\"/>\\n      <nd lat=\"50.7457638\" lon=\"7.0745740\"/>\\n    </member>\\n    <member type=\"way\" ref=\"210683522\" role=\"\">\\n      <nd lat=\"50.7457638\" lon=\"7.0745740\"/>\\n      <nd lat=\"50.7456300\" lon=\"7.0747409\"/>\\n      <nd lat=\"50.7454858\" lon=\"7.0749187\"/>\\n      <nd lat=\"50.7452550\" lon=\"7.0752554\"/>\\n      <nd lat=\"50.7450000\" lon=\"7.0756385\"/>\\n      <nd lat=\"50.7448878\" lon=\"7.0758027\"/>\\n      <nd lat=\"50.7447522\" lon=\"7.0759730\"/>\\n      <nd lat=\"50.7445514\" lon=\"7.0762032\"/>\\n      <nd lat=\"50.7443577\" lon=\"7.0764098\"/>\\n      <nd lat=\"50.7441185\" lon=\"7.0766490\"/>\\n    </member>\\n    <member type=\"way\" ref=\"48290881\" role=\"\">\\n      <nd lat=\"50.7441185\" lon=\"7.0766490\"/>\\n      <nd lat=\"50.7439033\" lon=\"7.0768575\"/>\\n      <nd lat=\"50.7437722\" lon=\"7.0769631\"/>\\n      <nd lat=\"50.7436609\" lon=\"7.0770394\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235363214\" role=\"\">\\n      <nd lat=\"50.7436609\" lon=\"7.0770394\"/>\\n      <nd lat=\"50.7435688\" lon=\"7.0771154\"/>\\n      <nd lat=\"50.7434662\" lon=\"7.0771906\"/>\\n      <nd lat=\"50.7434058\" lon=\"7.0772230\"/>\\n      <nd lat=\"50.7433331\" lon=\"7.0772525\"/>\\n      <nd lat=\"50.7432822\" lon=\"7.0772636\"/>\\n      <nd lat=\"50.7432318\" lon=\"7.0772601\"/>\\n    </member>\\n    <member type=\"way\" ref=\"4400137\" role=\"\">\\n      <nd lat=\"50.8887155\" lon=\"6.9676900\"/>\\n      <nd lat=\"50.8876384\" lon=\"6.9678150\"/>\\n    </member>\\n    <member type=\"way\" ref=\"230940375\" role=\"\">\\n      <nd lat=\"50.8876384\" lon=\"6.9678150\"/>\\n      <nd lat=\"50.8870572\" lon=\"6.9679058\"/>\\n      <nd lat=\"50.8858563\" lon=\"6.9680103\"/>\\n    </member>\\n    <member type=\"way\" ref=\"4400140\" role=\"\">\\n      <nd lat=\"50.8797318\" lon=\"6.9690108\"/>\\n      <nd lat=\"50.8799208\" lon=\"6.9689396\"/>\\n      <nd lat=\"50.8807058\" lon=\"6.9688470\"/>\\n      <nd lat=\"50.8824762\" lon=\"6.9687068\"/>\\n    </member>\\n    <member type=\"way\" ref=\"4400142\" role=\"\">\\n      <nd lat=\"50.8919691\" lon=\"6.9670292\"/>\\n      <nd lat=\"50.8918982\" lon=\"6.9671419\"/>\\n      <nd lat=\"50.8918068\" lon=\"6.9672404\"/>\\n      <nd lat=\"50.8917186\" lon=\"6.9673001\"/>\\n      <nd lat=\"50.8916153\" lon=\"6.9673480\"/>\\n      <nd lat=\"50.8914588\" lon=\"6.9673816\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235824476\" role=\"\">\\n      <nd lat=\"50.8914588\" lon=\"6.9673816\"/>\\n      <nd lat=\"50.8892470\" lon=\"6.9676302\"/>\\n      <nd lat=\"50.8887155\" lon=\"6.9676900\"/>\\n    </member>\\n    <member type=\"way\" ref=\"4400143\" role=\"\">\\n      <nd lat=\"50.8887787\" lon=\"6.9681629\"/>\\n      <nd lat=\"50.8896224\" lon=\"6.9680604\"/>\\n      <nd lat=\"50.8897525\" lon=\"6.9680446\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235824475\" role=\"\">\\n      <nd lat=\"50.8897525\" lon=\"6.9680446\"/>\\n      <nd lat=\"50.8906556\" lon=\"6.9679349\"/>\\n      <nd lat=\"50.8912013\" lon=\"6.9678862\"/>\\n    </member>\\n    <member type=\"way\" ref=\"178797123\" role=\"\">\\n      <nd lat=\"50.8912013\" lon=\"6.9678862\"/>\\n      <nd lat=\"50.8913492\" lon=\"6.9678648\"/>\\n    </member>\\n    <member type=\"way\" ref=\"233553030\" role=\"\">\\n      <nd lat=\"50.8913492\" lon=\"6.9678648\"/>\\n      <nd lat=\"50.8916648\" lon=\"6.9677762\"/>\\n      <nd lat=\"50.8917895\" lon=\"6.9677694\"/>\\n      <nd lat=\"50.8919294\" lon=\"6.9677947\"/>\\n      <nd lat=\"50.8920975\" lon=\"6.9678618\"/>\\n    </member>\\n    <member type=\"way\" ref=\"4829989\" role=\"\">\\n      <nd lat=\"50.8105743\" lon=\"6.9865001\"/>\\n      <nd lat=\"50.8088268\" lon=\"6.9896207\"/>\\n    </member>\\n    <member type=\"way\" ref=\"99834112\" role=\"\">\\n      <nd lat=\"50.8088268\" lon=\"6.9896207\"/>\\n      <nd lat=\"50.8066272\" lon=\"6.9935457\"/>\\n      <nd lat=\"50.8057165\" lon=\"6.9951151\"/>\\n    </member>\\n    <member type=\"way\" ref=\"133081219\" role=\"\">\\n      <nd lat=\"50.8057165\" lon=\"6.9951151\"/>\\n      <nd lat=\"50.8050332\" lon=\"6.9962100\"/>\\n      <nd lat=\"50.8043133\" lon=\"6.9972614\"/>\\n    </member>\\n    <member type=\"way\" ref=\"234434905\" role=\"\">\\n      <nd lat=\"50.8043133\" lon=\"6.9972614\"/>\\n      <nd lat=\"50.8038004\" lon=\"6.9979304\"/>\\n      <nd lat=\"50.8032120\" lon=\"6.9986363\"/>\\n      <nd lat=\"50.8029818\" lon=\"6.9989181\"/>\\n    </member>\\n    <member type=\"way\" ref=\"20661567\" role=\"\">\\n      <nd lat=\"50.8849681\" lon=\"6.9681126\"/>\\n      <nd lat=\"50.8839667\" lon=\"6.9682524\"/>\\n      <nd lat=\"50.8829770\" lon=\"6.9684059\"/>\\n    </member>\\n    <member type=\"way\" ref=\"230941900\" role=\"\">\\n      <nd lat=\"50.8829770\" lon=\"6.9684059\"/>\\n      <nd lat=\"50.8826286\" lon=\"6.9684595\"/>\\n    </member>\\n    <member type=\"way\" ref=\"20661568\" role=\"\">\\n      <nd lat=\"50.8850872\" lon=\"6.9685052\"/>\\n      <nd lat=\"50.8859127\" lon=\"6.9684079\"/>\\n    </member>\\n    <member type=\"way\" ref=\"20661572\" role=\"\">\\n      <nd lat=\"50.8859127\" lon=\"6.9684079\"/>\\n      <nd lat=\"50.8872823\" lon=\"6.9682592\"/>\\n      <nd lat=\"50.8876807\" lon=\"6.9682539\"/>\\n    </member>\\n    <member type=\"way\" ref=\"230940374\" role=\"\">\\n      <nd lat=\"50.8876807\" lon=\"6.9682539\"/>\\n      <nd lat=\"50.8887787\" lon=\"6.9681629\"/>\\n    </member>\\n    <member type=\"way\" ref=\"20661573\" role=\"\">\\n      <nd lat=\"50.8858563\" lon=\"6.9680103\"/>\\n      <nd lat=\"50.8849681\" lon=\"6.9681126\"/>\\n    </member>\\n    <member type=\"way\" ref=\"20662817\" role=\"\">\\n      <nd lat=\"50.8823655\" lon=\"6.9684998\"/>\\n      <nd lat=\"50.8806620\" lon=\"6.9686453\"/>\\n    </member>\\n    <member type=\"way\" ref=\"230941903\" role=\"\">\\n      <nd lat=\"50.8806620\" lon=\"6.9686453\"/>\\n      <nd lat=\"50.8793943\" lon=\"6.9687847\"/>\\n    </member>\\n    <member type=\"way\" ref=\"20662819\" role=\"\">\\n      <nd lat=\"50.8824762\" lon=\"6.9687068\"/>\\n      <nd lat=\"50.8827522\" lon=\"6.9686901\"/>\\n    </member>\\n    <member type=\"way\" ref=\"20662824\" role=\"\">\\n      <nd lat=\"50.8827522\" lon=\"6.9686901\"/>\\n      <nd lat=\"50.8839133\" lon=\"6.9686122\"/>\\n      <nd lat=\"50.8850872\" lon=\"6.9685052\"/>\\n    </member>\\n    <member type=\"way\" ref=\"20662827\" role=\"\">\\n      <nd lat=\"50.8826286\" lon=\"6.9684595\"/>\\n      <nd lat=\"50.8823655\" lon=\"6.9684998\"/>\\n    </member>\\n    <member type=\"way\" ref=\"27492515\" role=\"\">\\n      <nd lat=\"50.8029818\" lon=\"6.9989181\"/>\\n      <nd lat=\"50.8026288\" lon=\"6.9992932\"/>\\n    </member>\\n    <member type=\"way\" ref=\"129125122\" role=\"\">\\n      <nd lat=\"50.8093979\" lon=\"6.9890430\"/>\\n      <nd lat=\"50.8104598\" lon=\"6.9871803\"/>\\n    </member>\\n    <member type=\"way\" ref=\"234434901\" role=\"\">\\n      <nd lat=\"50.8063753\" lon=\"6.9944172\"/>\\n      <nd lat=\"50.8093979\" lon=\"6.9890430\"/>\\n    </member>\\n    <member type=\"way\" ref=\"234434904\" role=\"\">\\n      <nd lat=\"50.8053262\" lon=\"6.9961817\"/>\\n      <nd lat=\"50.8058108\" lon=\"6.9953914\"/>\\n      <nd lat=\"50.8063753\" lon=\"6.9944172\"/>\\n    </member>\\n    <member type=\"way\" ref=\"27492542\" role=\"\">\\n      <nd lat=\"50.8029899\" lon=\"6.9991939\"/>\\n      <nd lat=\"50.8032828\" lon=\"6.9988807\"/>\\n      <nd lat=\"50.8038702\" lon=\"6.9982129\"/>\\n      <nd lat=\"50.8044350\" lon=\"6.9974695\"/>\\n      <nd lat=\"50.8053262\" lon=\"6.9961817\"/>\\n    </member>\\n    <member type=\"way\" ref=\"27492543\" role=\"\">\\n      <nd lat=\"50.8026483\" lon=\"6.9995590\"/>\\n      <nd lat=\"50.8029899\" lon=\"6.9991939\"/>\\n    </member>\\n    <member type=\"way\" ref=\"29233646\" role=\"\">\\n      <nd lat=\"50.8793943\" lon=\"6.9687847\"/>\\n      <nd lat=\"50.8716935\" lon=\"6.9696241\"/>\\n      <nd lat=\"50.8701666\" lon=\"6.9697243\"/>\\n      <nd lat=\"50.8688585\" lon=\"6.9697057\"/>\\n      <nd lat=\"50.8652424\" lon=\"6.9693872\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235820561\" role=\"\">\\n      <nd lat=\"50.8652424\" lon=\"6.9693872\"/>\\n      <nd lat=\"50.8636340\" lon=\"6.9692339\"/>\\n    </member>\\n    <member type=\"way\" ref=\"29233647\" role=\"\">\\n      <nd lat=\"50.8636340\" lon=\"6.9692339\"/>\\n      <nd lat=\"50.8608791\" lon=\"6.9689787\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235820559\" role=\"\">\\n      <nd lat=\"50.8608791\" lon=\"6.9689787\"/>\\n      <nd lat=\"50.8590168\" lon=\"6.9688055\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235820562\" role=\"\">\\n      <nd lat=\"50.8590168\" lon=\"6.9688055\"/>\\n      <nd lat=\"50.8523854\" lon=\"6.9681888\"/>\\n    </member>\\n    <member type=\"way\" ref=\"29233648\" role=\"\">\\n      <nd lat=\"50.8522171\" lon=\"6.9684787\"/>\\n      <nd lat=\"50.8590359\" lon=\"6.9691023\"/>\\n    </member>\\n    <member type=\"way\" ref=\"29382960\" role=\"\">\\n      <nd lat=\"50.8391695\" lon=\"6.9667285\"/>\\n      <nd lat=\"50.8411491\" lon=\"6.9672118\"/>\\n      <nd lat=\"50.8425706\" lon=\"6.9674985\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008229\" role=\"\">\\n      <nd lat=\"50.8425706\" lon=\"6.9674985\"/>\\n      <nd lat=\"50.8443277\" lon=\"6.9677563\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008238\" role=\"\">\\n      <nd lat=\"50.8443277\" lon=\"6.9677563\"/>\\n      <nd lat=\"50.8453254\" lon=\"6.9678465\"/>\\n      <nd lat=\"50.8468114\" lon=\"6.9679862\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008230\" role=\"\">\\n      <nd lat=\"50.8468114\" lon=\"6.9679862\"/>\\n      <nd lat=\"50.8491169\" lon=\"6.9681907\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008226\" role=\"\">\\n      <nd lat=\"50.8491169\" lon=\"6.9681907\"/>\\n      <nd lat=\"50.8518181\" lon=\"6.9684403\"/>\\n    </member>\\n    <member type=\"way\" ref=\"40033062\" role=\"\">\\n      <nd lat=\"50.8391857\" lon=\"6.9664246\"/>\\n      <nd lat=\"50.8386690\" lon=\"6.9662911\"/>\\n    </member>\\n    <member type=\"way\" ref=\"40033063\" role=\"\">\\n      <nd lat=\"50.8386690\" lon=\"6.9662911\"/>\\n      <nd lat=\"50.8314332\" lon=\"6.9644546\"/>\\n    </member>\\n    <member type=\"way\" ref=\"29384561\" role=\"\">\\n      <nd lat=\"50.8523854\" lon=\"6.9681888\"/>\\n      <nd lat=\"50.8519590\" lon=\"6.9681595\"/>\\n    </member>\\n    <member type=\"way\" ref=\"29384563\" role=\"\">\\n      <nd lat=\"50.8519590\" lon=\"6.9681595\"/>\\n      <nd lat=\"50.8506534\" lon=\"6.9680320\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008224\" role=\"\">\\n      <nd lat=\"50.8506534\" lon=\"6.9680320\"/>\\n      <nd lat=\"50.8490308\" lon=\"6.9678717\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008227\" role=\"\">\\n      <nd lat=\"50.8490308\" lon=\"6.9678717\"/>\\n      <nd lat=\"50.8478121\" lon=\"6.9677589\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008237\" role=\"\">\\n      <nd lat=\"50.8478121\" lon=\"6.9677589\"/>\\n      <nd lat=\"50.8459552\" lon=\"6.9676249\"/>\\n      <nd lat=\"50.8451822\" lon=\"6.9675256\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008232\" role=\"\">\\n      <nd lat=\"50.8451822\" lon=\"6.9675256\"/>\\n      <nd lat=\"50.8433946\" lon=\"6.9673373\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008239\" role=\"\">\\n      <nd lat=\"50.8433946\" lon=\"6.9673373\"/>\\n      <nd lat=\"50.8424071\" lon=\"6.9671724\"/>\\n      <nd lat=\"50.8411984\" lon=\"6.9669289\"/>\\n      <nd lat=\"50.8391857\" lon=\"6.9664246\"/>\\n    </member>\\n    <member type=\"way\" ref=\"29384564\" role=\"\">\\n      <nd lat=\"50.8518181\" lon=\"6.9684403\"/>\\n      <nd lat=\"50.8522171\" lon=\"6.9684787\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31282638\" role=\"\">\\n      <nd lat=\"50.7547305\" lon=\"7.0468957\"/>\\n      <nd lat=\"50.7550333\" lon=\"7.0462257\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31282787\" role=\"\">\\n      <nd lat=\"50.7548175\" lon=\"7.0462659\"/>\\n      <nd lat=\"50.7545192\" lon=\"7.0469416\"/>\\n    </member>\\n    <member type=\"way\" ref=\"383262762\" role=\"\">\\n      <nd lat=\"50.7545192\" lon=\"7.0469416\"/>\\n      <nd lat=\"50.7522859\" lon=\"7.0519784\"/>\\n      <nd lat=\"50.7519030\" lon=\"7.0528750\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31304443\" role=\"\">\\n      <nd lat=\"50.7519030\" lon=\"7.0528750\"/>\\n      <nd lat=\"50.7514373\" lon=\"7.0540731\"/>\\n      <nd lat=\"50.7512408\" lon=\"7.0546346\"/>\\n      <nd lat=\"50.7511231\" lon=\"7.0549962\"/>\\n      <nd lat=\"50.7508172\" lon=\"7.0560135\"/>\\n    </member>\\n    <member type=\"way\" ref=\"128541594\" role=\"\">\\n      <nd lat=\"50.7508172\" lon=\"7.0560135\"/>\\n      <nd lat=\"50.7504938\" lon=\"7.0572440\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31304503\" role=\"\">\\n      <nd lat=\"50.7509429\" lon=\"7.0561605\"/>\\n      <nd lat=\"50.7512483\" lon=\"7.0551357\"/>\\n      <nd lat=\"50.7513759\" lon=\"7.0547500\"/>\\n      <nd lat=\"50.7515670\" lon=\"7.0542197\"/>\\n      <nd lat=\"50.7520213\" lon=\"7.0530348\"/>\\n      <nd lat=\"50.7524214\" lon=\"7.0520935\"/>\\n      <nd lat=\"50.7547305\" lon=\"7.0468957\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31363881\" role=\"\">\\n      <nd lat=\"50.8026288\" lon=\"6.9992932\"/>\\n      <nd lat=\"50.8018617\" lon=\"7.0000625\"/>\\n      <nd lat=\"50.8010270\" lon=\"7.0007950\"/>\\n      <nd lat=\"50.8001164\" lon=\"7.0015291\"/>\\n      <nd lat=\"50.7928343\" lon=\"7.0072406\"/>\\n      <nd lat=\"50.7832350\" lon=\"7.0147268\"/>\\n      <nd lat=\"50.7826087\" lon=\"7.0151803\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31363891\" role=\"\">\\n      <nd lat=\"50.7826087\" lon=\"7.0151803\"/>\\n      <nd lat=\"50.7823221\" lon=\"7.0153822\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31363892\" role=\"\">\\n      <nd lat=\"50.7823221\" lon=\"7.0153822\"/>\\n      <nd lat=\"50.7802850\" lon=\"7.0170023\"/>\\n      <nd lat=\"50.7782200\" lon=\"7.0186241\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31363898\" role=\"\">\\n      <nd lat=\"50.7826777\" lon=\"7.0153975\"/>\\n      <nd lat=\"50.7833048\" lon=\"7.0149295\"/>\\n      <nd lat=\"50.8001641\" lon=\"7.0017836\"/>\\n      <nd lat=\"50.8010947\" lon=\"7.0010142\"/>\\n      <nd lat=\"50.8019538\" lon=\"7.0002540\"/>\\n      <nd lat=\"50.8026483\" lon=\"6.9995590\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31363910\" role=\"\">\\n      <nd lat=\"50.7823930\" lon=\"7.0156008\"/>\\n      <nd lat=\"50.7826777\" lon=\"7.0153975\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364152\" role=\"\">\\n      <nd lat=\"50.7782200\" lon=\"7.0186241\"/>\\n      <nd lat=\"50.7779774\" lon=\"7.0188037\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364158\" role=\"\">\\n      <nd lat=\"50.7783056\" lon=\"7.0188240\"/>\\n      <nd lat=\"50.7788577\" lon=\"7.0183860\"/>\\n      <nd lat=\"50.7803473\" lon=\"7.0172040\"/>\\n      <nd lat=\"50.7816582\" lon=\"7.0161766\"/>\\n      <nd lat=\"50.7823930\" lon=\"7.0156008\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364178\" role=\"\">\\n      <nd lat=\"50.7780676\" lon=\"7.0190054\"/>\\n      <nd lat=\"50.7783056\" lon=\"7.0188240\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364384\" role=\"\">\\n      <nd lat=\"50.7749036\" lon=\"7.0214625\"/>\\n      <nd lat=\"50.7780676\" lon=\"7.0190054\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364387\" role=\"\">\\n      <nd lat=\"50.7744886\" lon=\"7.0214841\"/>\\n      <nd lat=\"50.7712930\" lon=\"7.0240315\"/>\\n      <nd lat=\"50.7695809\" lon=\"7.0254447\"/>\\n      <nd lat=\"50.7686243\" lon=\"7.0263151\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364484\" role=\"\">\\n      <nd lat=\"50.7748248\" lon=\"7.0212347\"/>\\n      <nd lat=\"50.7744886\" lon=\"7.0214841\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364512\" role=\"\">\\n      <nd lat=\"50.7745735\" lon=\"7.0217089\"/>\\n      <nd lat=\"50.7749036\" lon=\"7.0214625\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364656\" role=\"\">\\n      <nd lat=\"50.7686546\" lon=\"7.0266216\"/>\\n      <nd lat=\"50.7696586\" lon=\"7.0256891\"/>\\n      <nd lat=\"50.7713905\" lon=\"7.0242565\"/>\\n      <nd lat=\"50.7745735\" lon=\"7.0217089\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364667\" role=\"\">\\n      <nd lat=\"50.7686243\" lon=\"7.0263151\"/>\\n      <nd lat=\"50.7676165\" lon=\"7.0273126\"/>\\n      <nd lat=\"50.7665957\" lon=\"7.0283332\"/>\\n      <nd lat=\"50.7653333\" lon=\"7.0297134\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008234\" role=\"\">\\n      <nd lat=\"50.7653333\" lon=\"7.0297134\"/>\\n      <nd lat=\"50.7643799\" lon=\"7.0308081\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364888\" role=\"\">\\n      <nd lat=\"50.7635269\" lon=\"7.0321873\"/>\\n      <nd lat=\"50.7641966\" lon=\"7.0313729\"/>\\n    </member>\\n    <member type=\"way\" ref=\"122158730\" role=\"\">\\n      <nd lat=\"50.7641966\" lon=\"7.0313729\"/>\\n      <nd lat=\"50.7644716\" lon=\"7.0310241\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31364985\" role=\"\">\\n      <nd lat=\"50.7644716\" lon=\"7.0310241\"/>\\n      <nd lat=\"50.7648596\" lon=\"7.0305814\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008235\" role=\"\">\\n      <nd lat=\"50.7648596\" lon=\"7.0305814\"/>\\n      <nd lat=\"50.7657812\" lon=\"7.0295145\"/>\\n      <nd lat=\"50.7666465\" lon=\"7.0285903\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008231\" role=\"\">\\n      <nd lat=\"50.7666465\" lon=\"7.0285903\"/>\\n      <nd lat=\"50.7679887\" lon=\"7.0272481\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008233\" role=\"\">\\n      <nd lat=\"50.7679887\" lon=\"7.0272481\"/>\\n      <nd lat=\"50.7686546\" lon=\"7.0266216\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31365377\" role=\"\">\\n      <nd lat=\"50.7643799\" lon=\"7.0308081\"/>\\n      <nd lat=\"50.7640807\" lon=\"7.0311662\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31365425\" role=\"\">\\n      <nd lat=\"50.7640807\" lon=\"7.0311662\"/>\\n      <nd lat=\"50.7638566\" lon=\"7.0314272\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008236\" role=\"\">\\n      <nd lat=\"50.7638566\" lon=\"7.0314272\"/>\\n      <nd lat=\"50.7628914\" lon=\"7.0326760\"/>\\n      <nd lat=\"50.7621053\" lon=\"7.0336961\"/>\\n    </member>\\n    <member type=\"way\" ref=\"36447898\" role=\"\">\\n      <nd lat=\"50.7621053\" lon=\"7.0336961\"/>\\n      <nd lat=\"50.7613433\" lon=\"7.0347526\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008228\" role=\"\">\\n      <nd lat=\"50.7613433\" lon=\"7.0347526\"/>\\n      <nd lat=\"50.7608295\" lon=\"7.0354890\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31366812\" role=\"\">\\n      <nd lat=\"50.7588227\" lon=\"7.0386254\"/>\\n      <nd lat=\"50.7583011\" lon=\"7.0394929\"/>\\n      <nd lat=\"50.7576749\" lon=\"7.0405773\"/>\\n      <nd lat=\"50.7569096\" lon=\"7.0419812\"/>\\n      <nd lat=\"50.7558745\" lon=\"7.0439976\"/>\\n      <nd lat=\"50.7548175\" lon=\"7.0462659\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31366880\" role=\"\">\\n      <nd lat=\"50.7550333\" lon=\"7.0462257\"/>\\n      <nd lat=\"50.7559939\" lon=\"7.0442408\"/>\\n      <nd lat=\"50.7570656\" lon=\"7.0421620\"/>\\n      <nd lat=\"50.7578037\" lon=\"7.0408023\"/>\\n      <nd lat=\"50.7584541\" lon=\"7.0396561\"/>\\n      <nd lat=\"50.7589669\" lon=\"7.0387984\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31367017\" role=\"\">\\n      <nd lat=\"50.7609333\" lon=\"7.0356976\"/>\\n      <nd lat=\"50.7619690\" lon=\"7.0342371\"/>\\n      <nd lat=\"50.7630051\" lon=\"7.0328461\"/>\\n      <nd lat=\"50.7635269\" lon=\"7.0321873\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31367443\" role=\"\">\\n      <nd lat=\"50.7607331\" lon=\"7.0359794\"/>\\n      <nd lat=\"50.7609333\" lon=\"7.0356976\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31367449\" role=\"\">\\n      <nd lat=\"50.7589669\" lon=\"7.0387984\"/>\\n      <nd lat=\"50.7602933\" lon=\"7.0366481\"/>\\n      <nd lat=\"50.7607331\" lon=\"7.0359794\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31367526\" role=\"\">\\n      <nd lat=\"50.7606164\" lon=\"7.0358121\"/>\\n      <nd lat=\"50.7601681\" lon=\"7.0365126\"/>\\n      <nd lat=\"50.7588227\" lon=\"7.0386254\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31367534\" role=\"\">\\n      <nd lat=\"50.7608295\" lon=\"7.0354890\"/>\\n      <nd lat=\"50.7606164\" lon=\"7.0358121\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31369852\" role=\"\">\\n      <nd lat=\"50.7779774\" lon=\"7.0188037\"/>\\n      <nd lat=\"50.7748248\" lon=\"7.0212347\"/>\\n    </member>\\n    <member type=\"way\" ref=\"449397558\" role=\"\">\\n      <nd lat=\"50.7479418\" lon=\"7.0693723\"/>\\n      <nd lat=\"50.7494783\" lon=\"7.0624630\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31797389\" role=\"\">\\n      <nd lat=\"50.7494783\" lon=\"7.0624630\"/>\\n      <nd lat=\"50.7502727\" lon=\"7.0588905\"/>\\n      <nd lat=\"50.7506441\" lon=\"7.0572942\"/>\\n      <nd lat=\"50.7509429\" lon=\"7.0561605\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31798039\" role=\"\">\\n      <nd lat=\"50.7504938\" lon=\"7.0572440\"/>\\n      <nd lat=\"50.7501306\" lon=\"7.0588140\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235363212\" role=\"\">\\n      <nd lat=\"50.7501306\" lon=\"7.0588140\"/>\\n      <nd lat=\"50.7492636\" lon=\"7.0626737\"/>\\n      <nd lat=\"50.7489407\" lon=\"7.0641605\"/>\\n    </member>\\n    <member type=\"way\" ref=\"156492546\" role=\"\">\\n      <nd lat=\"50.7489407\" lon=\"7.0641605\"/>\\n      <nd lat=\"50.7488307\" lon=\"7.0647205\"/>\\n      <nd lat=\"50.7483739\" lon=\"7.0668216\"/>\\n    </member>\\n    <member type=\"way\" ref=\"156492545\" role=\"\">\\n      <nd lat=\"50.7483739\" lon=\"7.0668216\"/>\\n      <nd lat=\"50.7483009\" lon=\"7.0672440\"/>\\n      <nd lat=\"50.7478400\" lon=\"7.0692844\"/>\\n    </member>\\n    <member type=\"way\" ref=\"130749935\" role=\"\">\\n      <nd lat=\"50.7478400\" lon=\"7.0692844\"/>\\n      <nd lat=\"50.7477294\" lon=\"7.0697394\"/>\\n      <nd lat=\"50.7476187\" lon=\"7.0701855\"/>\\n      <nd lat=\"50.7474997\" lon=\"7.0706232\"/>\\n      <nd lat=\"50.7473468\" lon=\"7.0711189\"/>\\n      <nd lat=\"50.7472087\" lon=\"7.0715434\"/>\\n      <nd lat=\"50.7470472\" lon=\"7.0719838\"/>\\n      <nd lat=\"50.7469114\" lon=\"7.0723163\"/>\\n      <nd lat=\"50.7467733\" lon=\"7.0726489\"/>\\n      <nd lat=\"50.7465937\" lon=\"7.0730580\"/>\\n      <nd lat=\"50.7464112\" lon=\"7.0734310\"/>\\n    </member>\\n    <member type=\"way\" ref=\"32472877\" role=\"\">\\n      <nd lat=\"50.8246828\" lon=\"6.9651077\"/>\\n      <nd lat=\"50.8253375\" lon=\"6.9647718\"/>\\n      <nd lat=\"50.8260000\" lon=\"6.9645354\"/>\\n      <nd lat=\"50.8266134\" lon=\"6.9643649\"/>\\n      <nd lat=\"50.8272671\" lon=\"6.9642646\"/>\\n      <nd lat=\"50.8278017\" lon=\"6.9642349\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31798988\" role=\"\">\\n      <nd lat=\"50.8278017\" lon=\"6.9642349\"/>\\n      <nd lat=\"50.8284805\" lon=\"6.9642342\"/>\\n      <nd lat=\"50.8294617\" lon=\"6.9643395\"/>\\n      <nd lat=\"50.8302437\" lon=\"6.9644810\"/>\\n      <nd lat=\"50.8309474\" lon=\"6.9646345\"/>\\n    </member>\\n    <member type=\"way\" ref=\"31798989\" role=\"\">\\n      <nd lat=\"50.8590359\" lon=\"6.9691023\"/>\\n      <nd lat=\"50.8634113\" lon=\"6.9695191\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235820560\" role=\"\">\\n      <nd lat=\"50.8634113\" lon=\"6.9695191\"/>\\n      <nd lat=\"50.8656224\" lon=\"6.9697185\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235820563\" role=\"\">\\n      <nd lat=\"50.8656224\" lon=\"6.9697185\"/>\\n      <nd lat=\"50.8679633\" lon=\"6.9699314\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235820564\" role=\"\">\\n      <nd lat=\"50.8679633\" lon=\"6.9699314\"/>\\n      <nd lat=\"50.8691580\" lon=\"6.9700171\"/>\\n      <nd lat=\"50.8699302\" lon=\"6.9700221\"/>\\n    </member>\\n    <member type=\"way\" ref=\"235820570\" role=\"\">\\n      <nd lat=\"50.8699302\" lon=\"6.9700221\"/>\\n      <nd lat=\"50.8717399\" lon=\"6.9699121\"/>\\n      <nd lat=\"50.8746263\" lon=\"6.9695939\"/>\\n    </member>\\n    <member type=\"way\" ref=\"32472855\" role=\"\">\\n      <nd lat=\"50.8246253\" lon=\"6.9648384\"/>\\n      <nd lat=\"50.8242516\" lon=\"6.9650453\"/>\\n    </member>\\n    <member type=\"way\" ref=\"32472856\" role=\"\">\\n      <nd lat=\"50.8242516\" lon=\"6.9650453\"/>\\n      <nd lat=\"50.8237235\" lon=\"6.9653841\"/>\\n      <nd lat=\"50.8232034\" lon=\"6.9657948\"/>\\n      <nd lat=\"50.8224317\" lon=\"6.9665263\"/>\\n      <nd lat=\"50.8216642\" lon=\"6.9673886\"/>\\n      <nd lat=\"50.8209037\" lon=\"6.9684049\"/>\\n      <nd lat=\"50.8201541\" lon=\"6.9695500\"/>\\n      <nd lat=\"50.8192181\" lon=\"6.9711445\"/>\\n      <nd lat=\"50.8138575\" lon=\"6.9806731\"/>\\n    </member>\\n    <member type=\"way\" ref=\"37881520\" role=\"\">\\n      <nd lat=\"50.8138575\" lon=\"6.9806731\"/>\\n      <nd lat=\"50.8135770\" lon=\"6.9811721\"/>\\n    </member>\\n    <member type=\"way\" ref=\"37881519\" role=\"\">\\n      <nd lat=\"50.8135770\" lon=\"6.9811721\"/>\\n      <nd lat=\"50.8113547\" lon=\"6.9851361\"/>\\n    </member>\\n    <member type=\"way\" ref=\"234434902\" role=\"\">\\n      <nd lat=\"50.8113547\" lon=\"6.9851361\"/>\\n      <nd lat=\"50.8105743\" lon=\"6.9865001\"/>\\n    </member>\\n    <member type=\"way\" ref=\"32472875\" role=\"\">\\n      <nd lat=\"50.8243279\" lon=\"6.9653077\"/>\\n      <nd lat=\"50.8246828\" lon=\"6.9651077\"/>\\n    </member>\\n    <member type=\"way\" ref=\"32473071\" role=\"\">\\n      <nd lat=\"50.8309464\" lon=\"6.9643368\"/>\\n      <nd lat=\"50.8302815\" lon=\"6.9641912\"/>\\n    </member>\\n    <member type=\"way\" ref=\"128522486\" role=\"\">\\n      <nd lat=\"50.8302815\" lon=\"6.9641912\"/>\\n      <nd lat=\"50.8294728\" lon=\"6.9640448\"/>\\n      <nd lat=\"50.8284964\" lon=\"6.9639463\"/>\\n      <nd lat=\"50.8277970\" lon=\"6.9639432\"/>\\n    </member>\\n    <member type=\"way\" ref=\"36447896\" role=\"\">\\n      <nd lat=\"50.8277970\" lon=\"6.9639432\"/>\\n      <nd lat=\"50.8272631\" lon=\"6.9639682\"/>\\n      <nd lat=\"50.8265661\" lon=\"6.9640827\"/>\\n      <nd lat=\"50.8259717\" lon=\"6.9642405\"/>\\n      <nd lat=\"50.8252714\" lon=\"6.9645096\"/>\\n      <nd lat=\"50.8246253\" lon=\"6.9648384\"/>\\n    </member>\\n    <member type=\"way\" ref=\"32473075\" role=\"\">\\n      <nd lat=\"50.8314332\" lon=\"6.9644546\"/>\\n      <nd lat=\"50.8309464\" lon=\"6.9643368\"/>\\n    </member>\\n    <member type=\"way\" ref=\"32473086\" role=\"\">\\n      <nd lat=\"50.8309474\" lon=\"6.9646345\"/>\\n      <nd lat=\"50.8314534\" lon=\"6.9647679\"/>\\n    </member>\\n    <member type=\"way\" ref=\"32473087\" role=\"\">\\n      <nd lat=\"50.8314534\" lon=\"6.9647679\"/>\\n      <nd lat=\"50.8386440\" lon=\"6.9665955\"/>\\n    </member>\\n    <member type=\"way\" ref=\"40033064\" role=\"\">\\n      <nd lat=\"50.8386440\" lon=\"6.9665955\"/>\\n      <nd lat=\"50.8391695\" lon=\"6.9667285\"/>\\n    </member>\\n    <member type=\"way\" ref=\"189189059\" role=\"\">\\n      <nd lat=\"50.8746263\" lon=\"6.9695939\"/>\\n      <nd lat=\"50.8760907\" lon=\"6.9694358\"/>\\n    </member>\\n    <member type=\"way\" ref=\"271008225\" role=\"\">\\n      <nd lat=\"50.8760907\" lon=\"6.9694358\"/>\\n      <nd lat=\"50.8775484\" lon=\"6.9692784\"/>\\n    </member>\\n    <member type=\"way\" ref=\"41550921\" role=\"\">\\n      <nd lat=\"50.8775484\" lon=\"6.9692784\"/>\\n      <nd lat=\"50.8797318\" lon=\"6.9690108\"/>\\n    </member>\\n    <tag k=\"TMC:cid_58:tabcd_1:Class\" v=\"Road\"/>\\n    <tag k=\"TMC:cid_58:tabcd_1:LCLversion\" v=\"8.00\"/>\\n    <tag k=\"TMC:cid_58:tabcd_1:LocationCode\" v=\"7142\"/>\\n    <tag k=\"name\" v=\"Bundesautobahn 555\"/>\\n    <tag k=\"network\" v=\"BAB\"/>\\n    <tag k=\"operator\" v=\"Bundesrepublik Deutschland\"/>\\n    <tag k=\"ref\" v=\"A 555\"/>\\n    <tag k=\"route\" v=\"road\"/>\\n    <tag k=\"type\" v=\"route\"/>\\n    <tag k=\"wikipedia\" v=\"de:Bundesautobahn 555\"/>\\n  </relation>\\n\\n</osm>\\n'"}, {"func_args": {"filename": "'xml/way-01.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2014-12-14T13:33:02Z\"/>\\n  <way id=\"317146077\">\\n    <nd ref=\"3233854241\"/>\\n    <nd ref=\"3233854238\"/>\\n    <nd ref=\"3233854233\"/>\\n    <nd ref=\"3233854234\"/>\\n    <nd ref=\"3233854236\"/>\\n    <nd ref=\"3233854237\"/>\\n    <nd ref=\"3233854241\"/>\\n    <tag k=\"building\" v=\"yes\"/>\\n  </way>\\n  <way id=\"317146078\" version=\"1\" timestamp=\"2014-12-14T07:27:21Z\" changeset=\"23456789\" uid=\"345678\" user=\"TestUser\">\\n    <nd ref=\"3233854241\"/>\\n    <nd ref=\"3233854238\"/>\\n    <nd ref=\"3233854233\"/>\\n    <nd ref=\"3233854234\"/>\\n    <nd ref=\"3233854236\"/>\\n    <nd ref=\"3233854237\"/>\\n    <nd ref=\"3233854241\"/>\\n  </way>\\n\\n</osm>'"}, {"func_args": {"filename": "'xml/way-01.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2014-12-14T13:33:02Z\"/>\\n  <way id=\"317146077\">\\n    <nd ref=\"3233854241\"/>\\n    <nd ref=\"3233854238\"/>\\n    <nd ref=\"3233854233\"/>\\n    <nd ref=\"3233854234\"/>\\n    <nd ref=\"3233854236\"/>\\n    <nd ref=\"3233854237\"/>\\n    <nd ref=\"3233854241\"/>\\n    <tag k=\"building\" v=\"yes\"/>\\n  </way>\\n  <way id=\"317146078\" version=\"1\" timestamp=\"2014-12-14T07:27:21Z\" changeset=\"23456789\" uid=\"345678\" user=\"TestUser\">\\n    <nd ref=\"3233854241\"/>\\n    <nd ref=\"3233854238\"/>\\n    <nd ref=\"3233854233\"/>\\n    <nd ref=\"3233854234\"/>\\n    <nd ref=\"3233854236\"/>\\n    <nd ref=\"3233854237\"/>\\n    <nd ref=\"3233854241\"/>\\n  </way>\\n\\n</osm>'"}, {"func_args": {"filename": "'xml/way-02.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2014-12-14T13:34:02Z\"/>\\n  <node id=\"3233854233\" lat=\"50.7494187\" lon=\"7.1758731\"/>\\n  <node id=\"3233854234\" lat=\"50.7494236\" lon=\"7.1757664\"/>\\n  <node id=\"3233854236\" lat=\"50.7494909\" lon=\"7.1757741\"/>\\n  <node id=\"3233854237\" lat=\"50.7494985\" lon=\"7.1756064\"/>\\n  <node id=\"3233854238\" lat=\"50.7495391\" lon=\"7.1758868\"/>\\n  <node id=\"3233854241\" lat=\"50.7495516\" lon=\"7.1756125\"/>\\n  <way id=\"317146077\">\\n    <nd ref=\"3233854241\"/>\\n    <nd ref=\"3233854238\"/>\\n    <nd ref=\"3233854233\"/>\\n    <nd ref=\"3233854234\"/>\\n    <nd ref=\"3233854236\"/>\\n    <nd ref=\"3233854237\"/>\\n    <nd ref=\"3233854241\"/>\\n    <tag k=\"building\" v=\"yes\"/>\\n  </way>\\n\\n</osm>'"}, {"func_args": {"filename": "'xml/way-02.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2014-12-14T13:34:02Z\"/>\\n  <node id=\"3233854233\" lat=\"50.7494187\" lon=\"7.1758731\"/>\\n  <node id=\"3233854234\" lat=\"50.7494236\" lon=\"7.1757664\"/>\\n  <node id=\"3233854236\" lat=\"50.7494909\" lon=\"7.1757741\"/>\\n  <node id=\"3233854237\" lat=\"50.7494985\" lon=\"7.1756064\"/>\\n  <node id=\"3233854238\" lat=\"50.7495391\" lon=\"7.1758868\"/>\\n  <node id=\"3233854241\" lat=\"50.7495516\" lon=\"7.1756125\"/>\\n  <way id=\"317146077\">\\n    <nd ref=\"3233854241\"/>\\n    <nd ref=\"3233854238\"/>\\n    <nd ref=\"3233854233\"/>\\n    <nd ref=\"3233854234\"/>\\n    <nd ref=\"3233854236\"/>\\n    <nd ref=\"3233854237\"/>\\n    <nd ref=\"3233854241\"/>\\n    <tag k=\"building\" v=\"yes\"/>\\n  </way>\\n\\n</osm>'"}, {"func_args": {"filename": "'xml/way-03.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2016-11-22T22:35:03Z\"/>\\n\\n  <node id=\"2343425523\" lat=\"41.8954452\" lon=\"12.5032169\" version=\"1\" timestamp=\"2013-06-13T15:34:01Z\" changeset=\"16539126\" uid=\"113909\" user=\"Giardia\"/>\\n  <node id=\"2343425525\" lat=\"41.8954752\" lon=\"12.5031604\" version=\"1\" timestamp=\"2013-06-13T15:34:01Z\" changeset=\"16539126\" uid=\"113909\" user=\"Giardia\"/>\\n  <node id=\"2343425526\" lat=\"41.8955244\" lon=\"12.5032926\" version=\"1\" timestamp=\"2013-06-13T15:34:01Z\" changeset=\"16539126\" uid=\"113909\" user=\"Giardia\"/>\\n  <node id=\"2343425528\" lat=\"41.8955543\" lon=\"12.5032362\" version=\"1\" timestamp=\"2013-06-13T15:34:01Z\" changeset=\"16539126\" uid=\"113909\" user=\"Giardia\"/>\\n  <way id=\"225576797\" version=\"1\" timestamp=\"2013-06-13T15:34:01Z\" changeset=\"16539126\" uid=\"113909\" user=\"Giardia\">\\n    <center lat=\"41.8954998\" lon=\"12.5032265\"/>\\n    <nd ref=\"2343425525\"/>\\n    <nd ref=\"2343425528\"/>\\n    <nd ref=\"2343425526\"/>\\n    <nd ref=\"2343425523\"/>\\n    <nd ref=\"2343425525\"/>\\n    <tag k=\"building\" v=\"kiosk\"/>\\n    <tag k=\"shop\" v=\"florist\"/>\\n  </way>\\n\\n</osm>\\n'"}, {"func_args": {"filename": "'xml/way-03.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2016-11-22T22:35:03Z\"/>\\n\\n  <node id=\"2343425523\" lat=\"41.8954452\" lon=\"12.5032169\" version=\"1\" timestamp=\"2013-06-13T15:34:01Z\" changeset=\"16539126\" uid=\"113909\" user=\"Giardia\"/>\\n  <node id=\"2343425525\" lat=\"41.8954752\" lon=\"12.5031604\" version=\"1\" timestamp=\"2013-06-13T15:34:01Z\" changeset=\"16539126\" uid=\"113909\" user=\"Giardia\"/>\\n  <node id=\"2343425526\" lat=\"41.8955244\" lon=\"12.5032926\" version=\"1\" timestamp=\"2013-06-13T15:34:01Z\" changeset=\"16539126\" uid=\"113909\" user=\"Giardia\"/>\\n  <node id=\"2343425528\" lat=\"41.8955543\" lon=\"12.5032362\" version=\"1\" timestamp=\"2013-06-13T15:34:01Z\" changeset=\"16539126\" uid=\"113909\" user=\"Giardia\"/>\\n  <way id=\"225576797\" version=\"1\" timestamp=\"2013-06-13T15:34:01Z\" changeset=\"16539126\" uid=\"113909\" user=\"Giardia\">\\n    <center lat=\"41.8954998\" lon=\"12.5032265\"/>\\n    <nd ref=\"2343425525\"/>\\n    <nd ref=\"2343425528\"/>\\n    <nd ref=\"2343425526\"/>\\n    <nd ref=\"2343425523\"/>\\n    <nd ref=\"2343425525\"/>\\n    <tag k=\"building\" v=\"kiosk\"/>\\n    <tag k=\"shop\" v=\"florist\"/>\\n  </way>\\n\\n</osm>\\n'"}, {"func_args": {"filename": "'xml/way-04.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2016-11-22T23:24:03Z\"/>\\n\\n  <way id=\"225576797\">\\n    <center/>\\n    <nd ref=\"2343425525\"/>\\n    <nd ref=\"2343425528\"/>\\n    <nd ref=\"2343425526\"/>\\n    <nd ref=\"2343425523\"/>\\n    <nd ref=\"2343425525\"/>\\n    <tag k=\"building\" v=\"kiosk\"/>\\n    <tag k=\"shop\" v=\"florist\"/>\\n  </way>\\n\\n</osm>\\n'"}, {"func_args": {"filename": "'xml/way-04.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2016-11-22T23:24:03Z\"/>\\n\\n  <way id=\"225576797\">\\n    <center/>\\n    <nd ref=\"2343425525\"/>\\n    <nd ref=\"2343425528\"/>\\n    <nd ref=\"2343425526\"/>\\n    <nd ref=\"2343425523\"/>\\n    <nd ref=\"2343425525\"/>\\n    <tag k=\"building\" v=\"kiosk\"/>\\n    <tag k=\"shop\" v=\"florist\"/>\\n  </way>\\n\\n</osm>\\n'"}, {"func_args": {"filename": "'xml/node-01.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2014-12-14T12:58:02Z\"/>\\n  <node id=\"50878400\" lat=\"50.7461788\" lon=\"7.1742257\"/>\\n  <node id=\"100793192\" lat=\"50.7468472\" lon=\"7.1709376\">\\n    <tag k=\"highway\" v=\"turning_circle\"/>\\n  </node>\\n  <node id=\"3233854234\" lat=\"50.7494236\" lon=\"7.1757664\" version=\"1\" timestamp=\"2014-12-14T07:27:19Z\" changeset=\"23456789\" uid=\"345678\" user=\"TestUser\"/>\\n\\n</osm>'"}, {"func_args": {"filename": "'xml/node-01.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2014-12-14T12:58:02Z\"/>\\n  <node id=\"50878400\" lat=\"50.7461788\" lon=\"7.1742257\"/>\\n  <node id=\"100793192\" lat=\"50.7468472\" lon=\"7.1709376\">\\n    <tag k=\"highway\" v=\"turning_circle\"/>\\n  </node>\\n  <node id=\"3233854234\" lat=\"50.7494236\" lon=\"7.1757664\" version=\"1\" timestamp=\"2014-12-14T07:27:19Z\" changeset=\"23456789\" uid=\"345678\" user=\"TestUser\"/>\\n\\n</osm>'"}, {"func_args": {"filename": "'xml/remark-runtime-error-01.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2017-03-17T22:03:02Z\" areas=\"2017-03-17T18:38:02Z\"/>\\n\\n<remark> runtime error: Query timed out in \"query\" at line 4 after 2 seconds. </remark>\\n\\n</osm>\\n'"}, {"func_args": {"filename": "'xml/remark-runtime-remark-01.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2017-03-17T22:03:02Z\" areas=\"2017-03-17T18:38:02Z\"/>\\n\\n<remark> runtime remark: Test </remark>\\n\\n</osm>\\n'"}, {"func_args": {"filename": "'xml/remark-unknown-01.xml'", "mode": "'r'"}, "return_value": "'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<osm version=\"0.6\" generator=\"Overpass API\">\\n<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>\\n<meta osm_base=\"2017-03-17T22:03:02Z\" areas=\"2017-03-17T18:38:02Z\"/>\\n\\n<remark> Test remark </remark>\\n\\n</osm>\\n'"}], "text": "def read_file(filename, mode=\"r\"):\n    return (Path(__file__).resolve().parent / filename).open(mode).read()"}, "_to_blob": {"line": 21, "args": [{"func_args": {"b": "b'\\xfe\\xaf\\xd0\\xf8q@\\x06\\xbc>`\\xbe\\xbb\\x06\\xf8\\x05\\xf6\\x7f}\\xb6}\\xff\\xdd\\xfb\\xfd\\xbe\\x02~\\x01\\xdbe4x\\xdb\\xbe\\x02\\xec{\\xc1\\x1a\\xf0\\xbb\\x02m\\xdb\\x80\\xbev\\x00p\\xfd\\xe5\\xddG\\x01\\xbc\\xb0\\xb5\\x02\\x05\\xf0\\xc2\\xd6\\n(\\x80\\x17\\xb6V\\xa0\\x00^\\xd8Z\\x81\\xfe\\x19\\x05\\xf6\\x1b\\xf8\\xbf\\xff\\x06\\xf8\\xc0(\\xa8\\x0c\\x10\\xd4\\xa7\\x01\\x08z{\\x9f\\x8c:\\xc0\\xcb\\x00O\\xf7k\\x00O\\x7f\\xef\\xbd_F=\\xa0d\\x19\\x05\\xd8w\\xb3`\\xf7V\\x03<\\xdd\\xef\\x9f\\x01x\\xde\\xff\\xdf\\xfb\\xcd\\xa8\\x078\\xcb\\x00O\\xeb?~\\xff\\x0c\\xe0y\\xff\\xff\\xec\\xfd\\xfe1\\xf5\\x01\\xdf\\x00\\xcf>\\xff\\xd1\\xcf\\x06x^\\x9f\\xff\\xf8\\xb1\\xc5\\x16/\\x96XbT\\\\\\x81\\xa7\\xe0)\\xf0\\x0b\\xa6\\xe0\\xf7_,\\xf8\\xbbX\\xf0.\\x16\\xfc1\\x05\\xdf\\xc5\\x02\\xbd\\xf7\\xcd\\x06'"}, "return_value": "b'\\xfe\\xaf\\xd0\\xf8q@\\x06\\xbc>`\\xbe\\xbb\\x06\\xf8\\x05\\xf6\\x7f}\\xb6}\\xff\\xdd\\xfb\\xfd\\xbe\\x02~\\x01\\xdbe4x\\xdb\\xbe\\x02\\xec{\\xc1\\x1a\\xf0\\xbb\\x02m\\xdb\\x80\\xbev\\x00p\\xfd\\xe5\\xddG\\x01\\xbc\\xb0\\xb5\\x02\\x05\\xf0\\xc2\\xd6\\n(\\x80\\x17\\xb6V\\xa0\\x00^\\xd8Z\\x81\\xfe\\x19\\x05\\xf6\\x1b\\xf8\\xbf\\xff\\x06\\xf8\\xc0(\\xa8\\x0c\\x10\\xd4\\xa7\\x01\\x08z{\\x9f\\x8c:\\xc0\\xcb\\x00O\\xf7k\\x00O\\x7f\\xef\\xbd_F=\\xa0d\\x19\\x05\\xd8w\\xb3`\\xf7V\\x03<\\xdd\\xef\\x9f\\x01x\\xde\\xff\\xdf\\xfb\\xcd\\xa8\\x078\\xcb\\x00O\\xeb?~\\xff\\x0c\\xe0y\\xff\\xff\\xec\\xfd\\xfe1\\xf5\\x01\\xdf\\x00\\xcf>\\xff\\xd1\\xcf\\x06x^\\x9f\\xff\\xf8\\xb1\\xc5\\x16/\\x96XbT\\\\\\x81\\xa7\\xe0)\\xf0\\x0b\\xa6\\xe0\\xf7_,\\xf8\\xbbX\\xf0.\\x16\\xfc1\\x05\\xdf\\xc5\\x02\\xbd\\xf7\\xcd\\x06'"}, {"func_args": {"b": "b'\\xce\\xf81\\xe0\\x1es1\\xe0\\xfbe\\x00\\xf533223\\xd83\\x19l'"}, "return_value": "b'\\xce\\xf81\\xe0\\x1es1\\xe0\\xfbe\\x00\\xf533223\\xd83\\x19l'"}, {"func_args": {"b": "b'\\xfesm'"}, "return_value": "b'\\xfesm'"}], "text": "def _to_blob(b):\n    \"\"\"Convert a bytestring into a type SQLite will accept for a blob.\"\"\"\n    return b"}, "nums_to_numbits": {"line": 28, "args": [{"func_args": {"nums": "{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 20, 22, 23, 27, 28, 29, 30, 31, 32, 36, 37, 38, 46, 49, 50, 58, 59, 60, 61, 63, 65, 66, 67, 68, 69, 77, 78, 81, 82, 83, 84, 85, 87, 88, 89, 91, 92, 93, 95, 97, 98, 107, 108, 109, 110, 111, 112, 114, 121, 122, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 136, 138, 139, 140, 141, 142, 145, 146, 148, 149, 151, 152, 154, 155, 156, 157, 158, 160, 161, 162, 163, 164, 165, 166, 167, 168, 170, 171, 172, 174, 175, 176, 177, 179, 180, 181, 182, 183, 184, 186, 187, 188, 189, 190, 191, 193, 194, 195, 196, 197, 199, 201, 209, 210, 211, 212, 213, 214, 216, 224, 225, 227, 228, 230, 231, 232, 234, 237, 238, 242, 244, 245, 251, 252, 253, 254, 256, 257, 259, 260, 262, 263, 265, 266, 267, 268, 269, 271, 273, 282, 283, 285, 286, 287, 288, 289, 291, 292, 293, 294, 296, 302, 303, 305, 307, 308, 316, 317, 318, 319, 320, 321, 323, 324, 325, 327, 329, 336, 338, 339, 341, 342, 344, 345, 347, 348, 350, 351, 359, 361, 362, 363, 364, 365, 367, 369, 370, 372, 373, 374, 388, 389, 390, 392, 394, 395, 396, 397, 398, 399, 400, 402, 405, 406, 407, 408, 410, 411, 412, 414, 415, 416, 417, 418, 422, 424, 434, 435, 436, 437, 439, 444, 445, 447, 448, 450, 452, 453, 455, 457, 464, 466, 476, 477, 478, 479, 481, 486, 487, 489, 490, 492, 494, 495, 497, 499, 507, 509, 519, 520, 521, 522, 524, 529, 530, 532, 533, 535, 537, 538, 540, 542, 549, 551, 561, 562, 563, 564, 566, 571, 572, 574, 575, 577, 579, 580, 582, 584, 591, 593, 594, 595, 596, 597, 598, 599, 600, 603, 604, 608, 610, 617, 618, 620, 621, 622, 623, 624, 625, 627, 628, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 647, 648, 649, 650, 651, 652, 653, 654, 655, 657, 658, 667, 668, 669, 670, 671, 678, 679, 683, 685, 691, 693, 695, 698, 699, 708, 714, 716, 718, 719, 720, 721, 722, 725, 727, 728, 739, 745, 747, 748, 749, 750, 752, 753, 755, 756, 757, 758, 760, 761, 762, 763, 764, 767, 770, 771, 775, 777, 779, 780, 781, 790, 791, 792, 793, 795, 798, 799, 808, 809, 810, 811, 814, 816, 817, 818, 820, 821, 822, 823, 824, 825, 827, 829, 830, 840, 841, 842, 843, 846, 848, 849, 850, 851, 852, 853, 854, 856, 857, 858, 859, 861, 862, 863, 864, 866, 867, 868, 869, 871, 872, 873, 874, 875, 876, 878, 881, 882, 886, 888, 890, 891, 892, 893, 901, 903, 906, 909, 910, 912, 915, 916, 920, 922, 931, 932, 934, 935, 936, 937, 938, 940, 941, 942, 944, 945, 948, 949, 951, 957, 958, 960, 961, 962, 964, 965, 966, 967, 969, 970, 972, 974, 976, 977, 986, 987, 988, 989, 992, 994, 995, 996, 998, 999, 1000, 1001, 1002, 1003, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1015, 1016, 1027, 1028, 1029, 1030, 1033, 1034, 1035, 1036, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1054, 1055, 1056, 1057, 1059, 1060, 1061, 1062, 1063, 1064, 1066, 1067, 1070, 1071, 1075, 1077, 1079, 1080, 1081, 1082, 1091, 1092, 1093, 1096, 1097, 1099, 1102, 1103, 1112, 1113, 1114, 1115, 1118, 1120, 1121, 1123, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1137, 1138, 1139, 1140, 1141, 1142, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1154, 1155, 1165, 1166, 1167, 1168, 1171, 1172, 1173, 1174, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1194, 1195, 1197, 1198, 1199, 1200, 1202, 1203, 1204, 1205, 1206, 1207, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1220, 1221, 1224, 1226, 1228, 1229, 1230, 1231, 1232, 1240, 1241, 1242, 1243, 1244, 1246, 1247, 1256, 1257, 1258, 1259, 1262, 1263, 1265, 1266, 1267, 1268, 1269, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1284, 1286, 1287, 1288, 1289, 1290, 1291, 1294, 1295, 1297, 1298, 1307, 1308, 1309, 1310, 1313, 1314, 1315, 1316, 1318, 1320, 1321, 1322, 1323, 1324, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1339, 1340, 1341, 1342, 1343, 1344, 1348, 1349, 1351, 1352, 1354, 1358, 1359, 1361, 1362, 1364, 1368, 1369, 1370, 1371, 1373, 1377, 1378, 1380, 1383, 1387, 1388, 1390, 1393, 1397, 1398, 1402, 1404, 1406, 1410, 1411, 1412, 1414, 1416, 1423, 1424, 1425, 1426, 1429, 1431, 1437, 1438, 1439, 1440, 1443, 1445, 1452, 1453, 1454, 1455, 1456, 1457, 1459, 1465, 1466, 1469, 1471, 1477, 1478, 1479, 1480, 1481, 1482, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1494, 1498, 1499, 1501, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1515, 1516, 1517, 1519, 1523, 1524, 1526, 1532, 1533, 1534, 1535, 1537, 1538, 1539, 1541, 1545, 1546, 1548, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1564, 1565, 1568, 1570, 1576, 1577, 1578, 1579, 1580, 1582, 1583, 1584, 1586, 1590, 1591, 1593, 1600, 1602, 1603, 1604, 1605, 1607, 1608, 1609, 1610, 1612, 1613, 1614, 1615, 1616, 1618, 1619, 1622, 1623, 1625, 1626}"}, "return_value": "b'\\xfe\\xaf\\xd0\\xf8q@\\x06\\xbc>`\\xbe\\xbb\\x06\\xf8\\x05\\xf6\\x7f}\\xb6}\\xff\\xdd\\xfb\\xfd\\xbe\\x02~\\x01\\xdbe4x\\xdb\\xbe\\x02\\xec{\\xc1\\x1a\\xf0\\xbb\\x02m\\xdb\\x80\\xbev\\x00p\\xfd\\xe5\\xddG\\x01\\xbc\\xb0\\xb5\\x02\\x05\\xf0\\xc2\\xd6\\n(\\x80\\x17\\xb6V\\xa0\\x00^\\xd8Z\\x81\\xfe\\x19\\x05\\xf6\\x1b\\xf8\\xbf\\xff\\x06\\xf8\\xc0(\\xa8\\x0c\\x10\\xd4\\xa7\\x01\\x08z{\\x9f\\x8c:\\xc0\\xcb\\x00O\\xf7k\\x00O\\x7f\\xef\\xbd_F=\\xa0d\\x19\\x05\\xd8w\\xb3`\\xf7V\\x03<\\xdd\\xef\\x9f\\x01x\\xde\\xff\\xdf\\xfb\\xcd\\xa8\\x078\\xcb\\x00O\\xeb?~\\xff\\x0c\\xe0y\\xff\\xff\\xec\\xfd\\xfe1\\xf5\\x01\\xdf\\x00\\xcf>\\xff\\xd1\\xcf\\x06x^\\x9f\\xff\\xf8\\xb1\\xc5\\x16/\\x96XbT\\\\\\x81\\xa7\\xe0)\\xf0\\x0b\\xa6\\xe0\\xf7_,\\xf8\\xbbX\\xf0.\\x16\\xfc1\\x05\\xdf\\xc5\\x02\\xbd\\xf7\\xcd\\x06'"}, {"func_args": {"nums": "{1, 2, 3, 6, 7, 11, 12, 13, 14, 15, 16, 20, 21, 29, 30, 31, 33, 34, 35, 36, 40, 41, 44, 45, 46, 48, 52, 53, 61, 62, 63, 64, 65, 67, 68, 69, 70, 71, 72, 74, 77, 78, 88, 90, 92, 93, 94, 95, 96, 97, 100, 101, 104, 105, 108, 109, 113, 116, 117, 121, 124, 125, 128, 129, 132, 133, 139, 140, 142, 143, 144, 145, 148, 149, 152, 155, 156, 162, 163, 165, 166}"}, "return_value": "b'\\xce\\xf81\\xe0\\x1es1\\xe0\\xfbe\\x00\\xf533223\\xd83\\x19l'"}, {"func_args": {"nums": "{1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 14, 16, 18, 19, 21, 22}"}, "return_value": "b'\\xfesm'"}]}, "numbits_to_nums": {"line": 49, "args": [{"func_args": {"numbits": "b'\\xfesm'"}, "return_value": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 14, 16, 18, 19, 21, 22]"}, {"func_args": {"numbits": "b'\\xfe\\xaf\\xd0\\xf8q@\\x06\\xbc>`\\xbe\\xbb\\x06\\xf8\\x05\\xf6\\x7f}\\xb6}\\xff\\xdd\\xfb\\xfd\\xbe\\x02~\\x01\\xdbe4x\\xdb\\xbe\\x02\\xec{\\xc1\\x1a\\xf0\\xbb\\x02m\\xdb\\x80\\xbev\\x00p\\xfd\\xe5\\xddG\\x01\\xbc\\xb0\\xb5\\x02\\x05\\xf0\\xc2\\xd6\\n(\\x80\\x17\\xb6V\\xa0\\x00^\\xd8Z\\x81\\xfe\\x19\\x05\\xf6\\x1b\\xf8\\xbf\\xff\\x06\\xf8\\xc0(\\xa8\\x0c\\x10\\xd4\\xa7\\x01\\x08z{\\x9f\\x8c:\\xc0\\xcb\\x00O\\xf7k\\x00O\\x7f\\xef\\xbd_F=\\xa0d\\x19\\x05\\xd8w\\xb3`\\xf7V\\x03<\\xdd\\xef\\x9f\\x01x\\xde\\xff\\xdf\\xfb\\xcd\\xa8\\x078\\xcb\\x00O\\xeb?~\\xff\\x0c\\xe0y\\xff\\xff\\xec\\xfd\\xfe1\\xf5\\x01\\xdf\\x00\\xcf>\\xff\\xd1\\xcf\\x06x^\\x9f\\xff\\xf8\\xb1\\xc5\\x16/\\x96XbT\\\\\\x81\\xa7\\xe0)\\xf0\\x0b\\xa6\\xe0\\xf7_,\\xf8\\xbbX\\xf0.\\x16\\xfc1\\x05\\xdf\\xc5\\x02\\xbd\\xf7\\xcd\\x06'"}, "return_value": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 20, 22, 23, 27, 28, 29, 30, 31, 32, 36, 37, 38, 46, 49, 50, 58, 59, 60, 61, 63, 65, 66, 67, 68, 69, 77, 78, 81, 82, 83, 84, 85, 87, 88, 89, 91, 92, 93, 95, 97, 98, 107, 108, 109, 110, 111, 112, 114, 121, 122, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 136, 138, 139, 140, 141, 142, 145, 146, 148, 149, 151, 152, 154, 155, 156, 157, 158, 160, 161, 162, 163, 164, 165, 166, 167, 168, 170, 171, 172, 174, 175, 176, 177, 179, 180, 181, 182, 183, 184, 186, 187, 188, 189, 190, 191, 193, 194, 195, 196, 197, 199, 201, 209, 210, 211, 212, 213, 214, 216, 224, 225, 227, 228, 230, 231, 232, 234, 237, 238, 242, 244, 245, 251, 252, 253, 254, 256, 257, 259, 260, 262, 263, 265, 266, 267, 268, 269, 271, 273, 282, 283, 285, 286, 287, 288, 289, 291, 292, 293, 294, 296, 302, 303, 305, 307, 308, 316, 317, 318, 319, 320, 321, 323, 324, 325, 327, 329, 336, 338, 339, 341, 342, 344, 345, 347, 348, 350, 351, 359, 361, 362, 363, 364, 365, 367, 369, 370, 372, 373, 374, 388, 389, 390, 392, 394, 395, 396, 397, 398, 399, 400, 402, 405, 406, 407, 408, 410, 411, 412, 414, 415, 416, 417, 418, 422, 424, 434, 435, 436, 437, 439, 444, 445, 447, 448, 450, 452, 453, 455, 457, 464, 466, 476, 477, 478, 479, 481, 486, 487, 489, 490, 492, 494, 495, 497, 499, 507, 509, 519, 520, 521, 522, 524, 529, 530, 532, 533, 535, 537, 538, 540, 542, 549, 551, 561, 562, 563, 564, 566, 571, 572, 574, 575, 577, 579, 580, 582, 584, 591, 593, 594, 595, 596, 597, 598, 599, 600, 603, 604, 608, 610, 617, 618, 620, 621, 622, 623, 624, 625, 627, 628, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 647, 648, 649, 650, 651, 652, 653, 654, 655, 657, 658, 667, 668, 669, 670, 671, 678, 679, 683, 685, 691, 693, 695, 698, 699, 708, 714, 716, 718, 719, 720, 721, 722, 725, 727, 728, 739, 745, 747, 748, 749, 750, 752, 753, 755, 756, 757, 758, 760, 761, 762, 763, 764, 767, 770, 771, 775, 777, 779, 780, 781, 790, 791, 792, 793, 795, 798, 799, 808, 809, 810, 811, 814, 816, 817, 818, 820, 821, 822, 823, 824, 825, 827, 829, 830, 840, 841, 842, 843, 846, 848, 849, 850, 851, 852, 853, 854, 856, 857, 858, 859, 861, 862, 863, 864, 866, 867, 868, 869, 871, 872, 873, 874, 875, 876, 878, 881, 882, 886, 888, 890, 891, 892, 893, 901, 903, 906, 909, 910, 912, 915, 916, 920, 922, 931, 932, 934, 935, 936, 937, 938, 940, 941, 942, 944, 945, 948, 949, 951, 957, 958, 960, 961, 962, 964, 965, 966, 967, 969, 970, 972, 974, 976, 977, 986, 987, 988, 989, 992, 994, 995, 996, 998, 999, 1000, 1001, 1002, 1003, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1015, 1016, 1027, 1028, 1029, 1030, 1033, 1034, 1035, 1036, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1054, 1055, 1056, 1057, 1059, 1060, 1061, 1062, 1063, 1064, 1066, 1067, 1070, 1071, 1075, 1077, 1079, 1080, 1081, 1082, 1091, 1092, 1093, 1096, 1097, 1099, 1102, 1103, 1112, 1113, 1114, 1115, 1118, 1120, 1121, 1123, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1137, 1138, 1139, 1140, 1141, 1142, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1154, 1155, 1165, 1166, 1167, 1168, 1171, 1172, 1173, 1174, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1194, 1195, 1197, 1198, 1199, 1200, 1202, 1203, 1204, 1205, 1206, 1207, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1220, 1221, 1224, 1226, 1228, 1229, 1230, 1231, 1232, 1240, 1241, 1242, 1243, 1244, 1246, 1247, 1256, 1257, 1258, 1259, 1262, 1263, 1265, 1266, 1267, 1268, 1269, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1284, 1286, 1287, 1288, 1289, 1290, 1291, 1294, 1295, 1297, 1298, 1307, 1308, 1309, 1310, 1313, 1314, 1315, 1316, 1318, 1320, 1321, 1322, 1323, 1324, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1339, 1340, 1341, 1342, 1343, 1344, 1348, 1349, 1351, 1352, 1354, 1358, 1359, 1361, 1362, 1364, 1368, 1369, 1370, 1371, 1373, 1377, 1378, 1380, 1383, 1387, 1388, 1390, 1393, 1397, 1398, 1402, 1404, 1406, 1410, 1411, 1412, 1414, 1416, 1423, 1424, 1425, 1426, 1429, 1431, 1437, 1438, 1439, 1440, 1443, 1445, 1452, 1453, 1454, 1455, 1456, 1457, 1459, 1465, 1466, 1469, 1471, 1477, 1478, 1479, 1480, 1481, 1482, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1494, 1498, 1499, 1501, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1515, 1516, 1517, 1519, 1523, 1524, 1526, 1532, 1533, 1534, 1535, 1537, 1538, 1539, 1541, 1545, 1546, 1548, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1564, 1565, 1568, 1570, 1576, 1577, 1578, 1579, 1580, 1582, 1583, 1584, 1586, 1590, 1591, 1593, 1600, 1602, 1603, 1604, 1605, 1607, 1608, 1609, 1610, 1612, 1613, 1614, 1615, 1616, 1618, 1619, 1622, 1623, 1625, 1626]"}, {"func_args": {"numbits": "b'\\xce\\xf81\\xe0\\x1es1\\xe0\\xfbe\\x00\\xf533223\\xd83\\x19l'"}, "return_value": "[1, 2, 3, 6, 7, 11, 12, 13, 14, 15, 16, 20, 21, 29, 30, 31, 33, 34, 35, 36, 40, 41, 44, 45, 46, 48, 52, 53, 61, 62, 63, 64, 65, 67, 68, 69, 70, 71, 72, 74, 77, 78, 88, 90, 92, 93, 94, 95, 96, 97, 100, 101, 104, 105, 108, 109, 113, 116, 117, 121, 124, 125, 128, 129, 132, 133, 139, 140, 142, 143, 144, 145, 148, 149, 152, 155, 156, 162, 163, 165, 166]"}]}, "combinable_files": {"line": 55, "args": [{"func_args": {"data_file": "'/usr/app/src/test_repos/python-overpy/.coverage'", "data_paths": "None"}, "return_value": "['/usr/app/src/test_repos/python-overpy/.coverage.cae2a1e14906.80484.440709']"}], "text": "def combinable_files(data_file, data_paths=None):\n    \"\"\"Make a list of data files to be combined.\n\n    `data_file` is a path to a data file.  `data_paths` is a list of files or\n    directories of files.\n\n    Returns a list of absolute file paths.\n    \"\"\"\n    data_dir, local = os.path.split(os.path.abspath(data_file))\n\n    data_paths = data_paths or [data_dir]\n    files_to_combine = []\n    for p in data_paths:\n        if os.path.isfile(p):\n            files_to_combine.append(os.path.abspath(p))\n        elif os.path.isdir(p):\n            pattern = os.path.join(os.path.abspath(p), f\"{local}.*\")\n            files_to_combine.extend(glob.glob(pattern))\n        else:\n            raise NoDataError(f\"Couldn't combine from non-existent path '{p}'\")\n    return files_to_combine"}, "_line_ranges": {"line": 270, "args": [{"func_args": {"statements": "{1, 12, 13, 14, 16, 18, 19, 21, 22}", "lines": "set()"}, "return_value": "[]"}, {"func_args": {"statements": "{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 20, 22, 23, 27, 36, 46, 49, 58, 59, 60, 61, 63, 77, 78, 79, 81, 82, 83, 84, 85, 87, 88, 89, 91, 92, 93, 95, 97, 98, 107, 108, 109, 110, 111, 112, 114, 121, 122, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 136, 138, 139, 140, 141, 142, 145, 146, 148, 149, 151, 152, 154, 155, 156, 157, 158, 160, 161, 162, 163, 164, 165, 166, 167, 168, 170, 174, 175, 176, 177, 179, 180, 181, 182, 183, 184, 186, 187, 188, 189, 190, 191, 193, 194, 195, 196, 197, 199, 201, 209, 210, 211, 212, 213, 214, 216, 224, 225, 227, 228, 230, 231, 232, 234, 237, 242, 251, 252, 253, 256, 259, 262, 265, 271, 273, 282, 283, 285, 291, 292, 293, 294, 296, 302, 303, 305, 316, 317, 318, 319, 320, 321, 323, 324, 325, 327, 336, 338, 339, 341, 342, 344, 345, 347, 348, 350, 351, 359, 361, 362, 363, 364, 365, 367, 369, 370, 388, 389, 390, 392, 394, 395, 396, 397, 398, 399, 400, 402, 405, 406, 407, 408, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 424, 434, 435, 436, 437, 439, 444, 447, 448, 450, 452, 453, 455, 457, 464, 466, 476, 477, 478, 479, 481, 486, 489, 490, 492, 494, 495, 497, 499, 507, 509, 519, 520, 521, 522, 524, 529, 532, 533, 535, 537, 538, 540, 542, 549, 551, 561, 562, 563, 564, 566, 571, 574, 575, 577, 579, 580, 582, 584, 591, 593, 594, 595, 596, 597, 598, 599, 600, 603, 608, 610, 617, 618, 620, 621, 622, 623, 624, 625, 627, 628, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 647, 648, 649, 650, 651, 652, 653, 654, 655, 657, 658, 665, 667, 668, 675, 678, 683, 685, 691, 693, 695, 696, 698, 699, 708, 709, 714, 716, 718, 719, 720, 721, 722, 723, 725, 727, 728, 739, 740, 745, 747, 748, 749, 750, 751, 752, 753, 755, 756, 757, 758, 760, 761, 762, 763, 764, 765, 767, 770, 775, 777, 790, 791, 792, 793, 795, 796, 798, 799, 808, 809, 814, 816, 817, 818, 820, 821, 822, 823, 824, 825, 827, 829, 830, 840, 841, 846, 848, 849, 850, 851, 852, 853, 854, 856, 857, 858, 859, 861, 862, 863, 864, 866, 867, 868, 869, 871, 872, 873, 874, 875, 876, 878, 881, 886, 888, 901, 903, 906, 909, 910, 912, 913, 915, 916, 920, 922, 931, 932, 934, 935, 936, 937, 938, 940, 941, 942, 944, 945, 948, 949, 951, 957, 960, 961, 962, 964, 965, 966, 967, 969, 970, 972, 974, 976, 977, 986, 987, 992, 994, 995, 996, 998, 999, 1000, 1001, 1002, 1003, 1005, 1015, 1016, 1027, 1028, 1033, 1034, 1035, 1036, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1054, 1055, 1056, 1057, 1059, 1060, 1061, 1062, 1063, 1064, 1066, 1070, 1075, 1077, 1091, 1092, 1093, 1096, 1097, 1099, 1100, 1102, 1103, 1112, 1113, 1118, 1120, 1121, 1123, 1125, 1126, 1127, 1128, 1129, 1130, 1137, 1138, 1139, 1140, 1141, 1142, 1144, 1154, 1155, 1165, 1166, 1171, 1172, 1173, 1174, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1194, 1195, 1197, 1198, 1199, 1200, 1202, 1203, 1204, 1205, 1206, 1207, 1209, 1220, 1224, 1226, 1240, 1241, 1242, 1243, 1244, 1246, 1247, 1256, 1257, 1262, 1263, 1265, 1266, 1267, 1268, 1269, 1270, 1272, 1273, 1274, 1275, 1276, 1277, 1284, 1286, 1294, 1295, 1307, 1308, 1313, 1314, 1315, 1316, 1318, 1320, 1321, 1322, 1323, 1324, 1325, 1327, 1328, 1329, 1330, 1331, 1332, 1339, 1348, 1349, 1351, 1352, 1354, 1355, 1358, 1359, 1361, 1362, 1364, 1365, 1368, 1369, 1370, 1371, 1373, 1374, 1377, 1378, 1380, 1381, 1383, 1384, 1387, 1388, 1390, 1391, 1393, 1394, 1397, 1402, 1404, 1406, 1410, 1411, 1412, 1414, 1416, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1431, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1445, 1452, 1453, 1454, 1455, 1456, 1457, 1459, 1465, 1466, 1467, 1468, 1469, 1471, 1477, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1494, 1498, 1499, 1501, 1507, 1515, 1516, 1517, 1519, 1523, 1524, 1526, 1532, 1537, 1538, 1539, 1541, 1545, 1546, 1548, 1554, 1555, 1556, 1557, 1564, 1565, 1566, 1567, 1568, 1570, 1576, 1582, 1583, 1584, 1586, 1590, 1591, 1593, 1600, 1607, 1608, 1609, 1610, 1612, 1618, 1619, 1620, 1622, 1623, 1625, 1626}", "lines": "{913, 1427, 1428, 665, 796, 413, 1566, 1567, 1441, 1442, 675, 421, 1325, 696, 1467, 1468, 709, 1355, 1100, 79, 723, 1620, 1365, 1374, 740, 1381, 1384, 751, 1391, 1394, 1270, 765}"}, "return_value": "[(79, 79), (413, 413), (421, 421), (665, 665), (675, 675), (696, 696), (709, 709), (723, 723), (740, 740), (751, 751), (765, 765), (796, 796), (913, 913), (1100, 1100), (1270, 1270), (1325, 1325), (1355, 1355), (1365, 1365), (1374, 1374), (1381, 1381), (1384, 1384), (1391, 1391), (1394, 1394), (1427, 1428), (1441, 1442), (1467, 1468), (1566, 1567), (1620, 1620)]"}, {"func_args": {"statements": "{128, 1, 129, 3, 132, 6, 11, 12, 139, 140, 142, 143, 144, 145, 20, 148, 152, 155, 29, 30, 31, 33, 34, 162, 163, 165, 166, 40, 44, 45, 46, 48, 49, 52, 61, 62, 63, 64, 65, 67, 68, 69, 70, 71, 72, 74, 77, 88, 90, 92, 93, 94, 95, 96, 97, 100, 104, 105, 108, 113, 116, 121, 124}", "lines": "{49}"}, "return_value": "[(49, 49)]"}, {"func_args": {"statements": "{1, 2, 4, 37, 70, 7, 39, 72, 42, 20, 21, 23, 57, 58, 60}", "lines": "{1, 2, 4, 37, 70, 7, 39, 72, 42, 20, 21, 23, 57, 58, 60}"}, "return_value": "[(1, 72)]"}], "text": "def _line_ranges(statements, lines):\n    \"\"\"Produce a list of ranges for `format_lines`.\"\"\"\n    statements = sorted(statements)\n    lines = sorted(lines)\n\n    pairs = []\n    start = None\n    lidx = 0\n    for stmt in statements:\n        if lidx >= len(lines):\n            break\n        if stmt == lines[lidx]:\n            lidx += 1\n            if not start:\n                start = stmt\n            end = stmt\n        elif start:\n            pairs.append((start, end))\n            start = None\n    if start:\n        pairs.append((start, end))\n    return pairs"}, "format_lines": {"line": 294, "args": [{"func_args": {"statements": "{1, 12, 13, 14, 16, 18, 19, 21, 22}", "lines": "set()", "arcs": "None"}, "return_value": "''"}, {"func_args": {"statements": "{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 20, 22, 23, 27, 36, 46, 49, 58, 59, 60, 61, 63, 77, 78, 79, 81, 82, 83, 84, 85, 87, 88, 89, 91, 92, 93, 95, 97, 98, 107, 108, 109, 110, 111, 112, 114, 121, 122, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 136, 138, 139, 140, 141, 142, 145, 146, 148, 149, 151, 152, 154, 155, 156, 157, 158, 160, 161, 162, 163, 164, 165, 166, 167, 168, 170, 174, 175, 176, 177, 179, 180, 181, 182, 183, 184, 186, 187, 188, 189, 190, 191, 193, 194, 195, 196, 197, 199, 201, 209, 210, 211, 212, 213, 214, 216, 224, 225, 227, 228, 230, 231, 232, 234, 237, 242, 251, 252, 253, 256, 259, 262, 265, 271, 273, 282, 283, 285, 291, 292, 293, 294, 296, 302, 303, 305, 316, 317, 318, 319, 320, 321, 323, 324, 325, 327, 336, 338, 339, 341, 342, 344, 345, 347, 348, 350, 351, 359, 361, 362, 363, 364, 365, 367, 369, 370, 388, 389, 390, 392, 394, 395, 396, 397, 398, 399, 400, 402, 405, 406, 407, 408, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 424, 434, 435, 436, 437, 439, 444, 447, 448, 450, 452, 453, 455, 457, 464, 466, 476, 477, 478, 479, 481, 486, 489, 490, 492, 494, 495, 497, 499, 507, 509, 519, 520, 521, 522, 524, 529, 532, 533, 535, 537, 538, 540, 542, 549, 551, 561, 562, 563, 564, 566, 571, 574, 575, 577, 579, 580, 582, 584, 591, 593, 594, 595, 596, 597, 598, 599, 600, 603, 608, 610, 617, 618, 620, 621, 622, 623, 624, 625, 627, 628, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 647, 648, 649, 650, 651, 652, 653, 654, 655, 657, 658, 665, 667, 668, 675, 678, 683, 685, 691, 693, 695, 696, 698, 699, 708, 709, 714, 716, 718, 719, 720, 721, 722, 723, 725, 727, 728, 739, 740, 745, 747, 748, 749, 750, 751, 752, 753, 755, 756, 757, 758, 760, 761, 762, 763, 764, 765, 767, 770, 775, 777, 790, 791, 792, 793, 795, 796, 798, 799, 808, 809, 814, 816, 817, 818, 820, 821, 822, 823, 824, 825, 827, 829, 830, 840, 841, 846, 848, 849, 850, 851, 852, 853, 854, 856, 857, 858, 859, 861, 862, 863, 864, 866, 867, 868, 869, 871, 872, 873, 874, 875, 876, 878, 881, 886, 888, 901, 903, 906, 909, 910, 912, 913, 915, 916, 920, 922, 931, 932, 934, 935, 936, 937, 938, 940, 941, 942, 944, 945, 948, 949, 951, 957, 960, 961, 962, 964, 965, 966, 967, 969, 970, 972, 974, 976, 977, 986, 987, 992, 994, 995, 996, 998, 999, 1000, 1001, 1002, 1003, 1005, 1015, 1016, 1027, 1028, 1033, 1034, 1035, 1036, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1054, 1055, 1056, 1057, 1059, 1060, 1061, 1062, 1063, 1064, 1066, 1070, 1075, 1077, 1091, 1092, 1093, 1096, 1097, 1099, 1100, 1102, 1103, 1112, 1113, 1118, 1120, 1121, 1123, 1125, 1126, 1127, 1128, 1129, 1130, 1137, 1138, 1139, 1140, 1141, 1142, 1144, 1154, 1155, 1165, 1166, 1171, 1172, 1173, 1174, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1194, 1195, 1197, 1198, 1199, 1200, 1202, 1203, 1204, 1205, 1206, 1207, 1209, 1220, 1224, 1226, 1240, 1241, 1242, 1243, 1244, 1246, 1247, 1256, 1257, 1262, 1263, 1265, 1266, 1267, 1268, 1269, 1270, 1272, 1273, 1274, 1275, 1276, 1277, 1284, 1286, 1294, 1295, 1307, 1308, 1313, 1314, 1315, 1316, 1318, 1320, 1321, 1322, 1323, 1324, 1325, 1327, 1328, 1329, 1330, 1331, 1332, 1339, 1348, 1349, 1351, 1352, 1354, 1355, 1358, 1359, 1361, 1362, 1364, 1365, 1368, 1369, 1370, 1371, 1373, 1374, 1377, 1378, 1380, 1381, 1383, 1384, 1387, 1388, 1390, 1391, 1393, 1394, 1397, 1402, 1404, 1406, 1410, 1411, 1412, 1414, 1416, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1431, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1445, 1452, 1453, 1454, 1455, 1456, 1457, 1459, 1465, 1466, 1467, 1468, 1469, 1471, 1477, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1494, 1498, 1499, 1501, 1507, 1515, 1516, 1517, 1519, 1523, 1524, 1526, 1532, 1537, 1538, 1539, 1541, 1545, 1546, 1548, 1554, 1555, 1556, 1557, 1564, 1565, 1566, 1567, 1568, 1570, 1576, 1582, 1583, 1584, 1586, 1590, 1591, 1593, 1600, 1607, 1608, 1609, 1610, 1612, 1618, 1619, 1620, 1622, 1623, 1625, 1626}", "lines": "{913, 1427, 1428, 665, 796, 413, 1566, 1567, 1441, 1442, 675, 421, 1325, 696, 1467, 1468, 709, 1355, 1100, 79, 723, 1620, 1365, 1374, 740, 1381, 1384, 751, 1391, 1394, 1270, 765}", "arcs": "None"}, "return_value": "'79, 413, 421, 665, 675, 696, 709, 723, 740, 751, 765, 796, 913, 1100, 1270, 1325, 1355, 1365, 1374, 1381, 1384, 1391, 1394, 1427-1428, 1441-1442, 1467-1468, 1566-1567, 1620'"}, {"func_args": {"statements": "{128, 1, 129, 3, 132, 6, 11, 12, 139, 140, 142, 143, 144, 145, 20, 148, 152, 155, 29, 30, 31, 33, 34, 162, 163, 165, 166, 40, 44, 45, 46, 48, 49, 52, 61, 62, 63, 64, 65, 67, 68, 69, 70, 71, 72, 74, 77, 88, 90, 92, 93, 94, 95, 96, 97, 100, 104, 105, 108, 113, 116, 121, 124}", "lines": "{49}", "arcs": "None"}, "return_value": "'49'"}, {"func_args": {"statements": "{1, 2, 4, 37, 70, 7, 39, 72, 42, 20, 21, 23, 57, 58, 60}", "lines": "{1, 2, 4, 37, 70, 7, 39, 72, 42, 20, 21, 23, 57, 58, 60}", "arcs": "None"}, "return_value": "'1-72'"}], "text": "def format_lines(statements, lines, arcs=None):\n    \"\"\"Nicely format a list of line numbers.\n\n    Format a list of line numbers for printing by coalescing groups of lines as\n    long as the lines represent consecutive statements.  This will coalesce\n    even if there are gaps between statements.\n\n    For example, if `statements` is [1,2,3,4,5,10,11,12,13,14] and\n    `lines` is [1,2,5,10,11,13,14] then the result will be \"1-2, 5-11, 13-14\".\n\n    Both `lines` and `statements` can be any iterable. All of the elements of\n    `lines` must be in `statements`, and all of the values must be positive\n    integers.\n\n    If `arcs` is provided, they are (start,[end,end,end]) pairs that will be\n    included in the output as long as start isn't in `lines`.\n\n    \"\"\"\n    line_items = [(pair[0], nice_pair(pair)) for pair in _line_ranges(statements, lines)]\n    if arcs:\n        line_exits = sorted(arcs)\n        for line, exits in line_exits:\n            for ex in sorted(exits):\n                if line not in lines and ex not in lines:\n                    dest = (ex if ex > 0 else \"exit\")\n                    line_items.append((line, f\"{line}->{dest}\"))\n\n    ret = ', '.join(t[-1] for t in sorted(line_items))\n    return ret"}, "source_encoding": {"line": 184, "args": [{"func_args": {"source": "b'__all__ = [\\n    \"__author__\",\\n    \"__copyright__\",\\n    \"__email__\",\\n    \"__license__\",\\n    \"__summary__\",\\n    \"__title__\",\\n    \"__uri__\",\\n    \"__version__\",\\n]\\n\\n__title__ = \"overpy\"\\n__summary__ = \"Python Wrapper to access the OpenStreepMap Overpass API\"\\n__uri__ = \"https://github.com/DinoTools/python-overpy\"\\n\\n__version__ = \"0.6\"\\n\\n__author__ = \"PhiBo (DinoTools)\"\\n__email__ = \"\"\\n\\n__license__ = \"MIT\"\\n__copyright__ = \"Copyright 2014-2021 %s\" % __author__\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from collections import OrderedDict\\nfrom datetime import datetime\\nfrom decimal import Decimal\\nfrom urllib.request import urlopen\\nfrom urllib.error import HTTPError\\nfrom xml.sax import handler, make_parser\\nimport xml.etree.ElementTree\\nimport json\\nimport re\\nimport time\\nfrom typing import Any, Callable, ClassVar, Dict, List, NoReturn, Optional, Tuple, Type, TypeVar, Union\\n\\nfrom overpy import exception\\n# Ignore flake8 F401 warning for unused vars\\nfrom overpy.__about__ import (  # noqa: F401\\n    __author__, __copyright__, __email__, __license__, __summary__, __title__,\\n    __uri__, __version__\\n)\\n\\nElementTypeVar = TypeVar(\"ElementTypeVar\", bound=\"Element\")\\n\\nXML_PARSER_DOM = 1\\nXML_PARSER_SAX = 2\\n\\n# Try to convert some common attributes\\n# http://wiki.openstreetmap.org/wiki/Elements#Common_attributes\\nGLOBAL_ATTRIBUTE_MODIFIERS: Dict[str, Callable] = {\\n    \"changeset\": int,\\n    \"timestamp\": lambda ts: datetime.strptime(ts, \"%Y-%m-%dT%H:%M:%SZ\"),\\n    \"uid\": int,\\n    \"version\": int,\\n    \"visible\": lambda v: v.lower() == \"true\"\\n}\\n\\n\\ndef is_valid_type(\\n        element: Union[\"Area\", \"Node\", \"Relation\", \"Way\"],\\n        cls: Type[Union[\"Area\", \"Element\", \"Node\", \"Relation\", \"Way\"]]) -> bool:\\n    \"\"\"\\n    Test if an element is of a given type.\\n\\n    :param element: The element instance to test\\n    :param cls: The element class to test\\n    :return: False or True\\n    \"\"\"\\n    return isinstance(element, cls) and element.id is not None\\n\\n\\nclass Overpass:\\n    \"\"\"\\n    Class to access the Overpass API\\n\\n    :cvar default_max_retry_count: Global max number of retries (Default: 0)\\n    :cvar default_read_chunk_size: Max size of each chunk read from the server response\\n    :cvar default_retry_timeout: Global time to wait between tries (Default: 1.0s)\\n    :cvar default_url: Default URL of the Overpass server\\n    \"\"\"\\n    default_max_retry_count: ClassVar[int] = 0\\n    default_read_chunk_size: ClassVar[int] = 4096\\n    default_retry_timeout: ClassVar[float] = 1.0\\n    default_url: ClassVar[str] = \"http://overpass-api.de/api/interpreter\"\\n\\n    def __init__(\\n            self,\\n            read_chunk_size: Optional[int] = None,\\n            url: Optional[str] = None,\\n            xml_parser: int = XML_PARSER_SAX,\\n            max_retry_count: int = None,\\n            retry_timeout: float = None):\\n        \"\"\"\\n        :param read_chunk_size: Max size of each chunk read from the server response\\n        :param url: Optional URL of the Overpass server. Defaults to http://overpass-api.de/api/interpreter\\n        :param xml_parser: The xml parser to use\\n        :param max_retry_count: Max number of retries (Default: default_max_retry_count)\\n        :param retry_timeout: Time to wait between tries (Default: default_retry_timeout)\\n        \"\"\"\\n        self.url = self.default_url\\n        if url is not None:\\n            self.url = url\\n\\n        self._regex_extract_error_msg = re.compile(br\"\\\\<p\\\\>(?P<msg>\\\\<strong\\\\s.*?)\\\\</p\\\\>\")\\n        self._regex_remove_tag = re.compile(b\"<[^>]*?>\")\\n        if read_chunk_size is None:\\n            read_chunk_size = self.default_read_chunk_size\\n        self.read_chunk_size = read_chunk_size\\n\\n        if max_retry_count is None:\\n            max_retry_count = self.default_max_retry_count\\n        self.max_retry_count = max_retry_count\\n\\n        if retry_timeout is None:\\n            retry_timeout = self.default_retry_timeout\\n        self.retry_timeout = retry_timeout\\n\\n        self.xml_parser = xml_parser\\n\\n    @staticmethod\\n    def _handle_remark_msg(msg: str) -> NoReturn:\\n        \"\"\"\\n        Try to parse the message provided with the remark tag or element.\\n\\n        :param msg: The message\\n        :raises overpy.exception.OverpassRuntimeError: If message starts with \\'runtime error:\\'\\n        :raises overpy.exception.OverpassRuntimeRemark: If message starts with \\'runtime remark:\\'\\n        :raises overpy.exception.OverpassUnknownError: If we are unable to identify the error\\n        \"\"\"\\n        msg = msg.strip()\\n        if msg.startswith(\"runtime error:\"):\\n            raise exception.OverpassRuntimeError(msg=msg)\\n        elif msg.startswith(\"runtime remark:\"):\\n            raise exception.OverpassRuntimeRemark(msg=msg)\\n        raise exception.OverpassUnknownError(msg=msg)\\n\\n    def query(self, query: Union[bytes, str]) -> \"Result\":\\n        \"\"\"\\n        Query the Overpass API\\n\\n        :param query: The query string in Overpass QL\\n        :return: The parsed result\\n        \"\"\"\\n        if not isinstance(query, bytes):\\n            query = query.encode(\"utf-8\")\\n\\n        retry_num: int = 0\\n        retry_exceptions: List[exception.OverPyException] = []\\n        do_retry: bool = True if self.max_retry_count > 0 else False\\n        while retry_num <= self.max_retry_count:\\n            if retry_num > 0:\\n                time.sleep(self.retry_timeout)\\n            retry_num += 1\\n            try:\\n                f = urlopen(self.url, query)\\n            except HTTPError as e:\\n                f = e\\n\\n            response = f.read(self.read_chunk_size)\\n            while True:\\n                data = f.read(self.read_chunk_size)\\n                if len(data) == 0:\\n                    break\\n                response = response + data\\n            f.close()\\n\\n            current_exception: exception.OverPyException\\n            if f.code == 200:\\n                content_type = f.getheader(\"Content-Type\")\\n\\n                if content_type == \"application/json\":\\n                    return self.parse_json(response)\\n\\n                if content_type == \"application/osm3s+xml\":\\n                    return self.parse_xml(response)\\n\\n                current_exception = exception.OverpassUnknownContentType(content_type)\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            if f.code == 400:\\n                msgs: List[str] = []\\n                for msg_raw in self._regex_extract_error_msg.finditer(response):\\n                    msg_clean_bytes = self._regex_remove_tag.sub(b\"\", msg_raw.group(\"msg\"))\\n                    try:\\n                        msg = msg_clean_bytes.decode(\"utf-8\")\\n                    except UnicodeDecodeError:\\n                        msg = repr(msg_clean_bytes)\\n                    msgs.append(msg)\\n\\n                current_exception = exception.OverpassBadRequest(\\n                    query,\\n                    msgs=msgs\\n                )\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            if f.code == 429:\\n                current_exception = exception.OverpassTooManyRequests()\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            if f.code == 504:\\n                current_exception = exception.OverpassGatewayTimeout()\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            current_exception = exception.OverpassUnknownHTTPStatusCode(f.code)\\n            if not do_retry:\\n                raise current_exception\\n            retry_exceptions.append(current_exception)\\n            continue\\n\\n        raise exception.MaxRetriesReached(retry_count=retry_num, exceptions=retry_exceptions)\\n\\n    def parse_json(self, data: Union[bytes, str], encoding: str = \"utf-8\") -> \"Result\":\\n        \"\"\"\\n        Parse raw response from Overpass service.\\n\\n        :param data: Raw JSON Data\\n        :param encoding: Encoding to decode byte string\\n        :return: Result object\\n        \"\"\"\\n        if isinstance(data, bytes):\\n            data = data.decode(encoding)\\n        data_parsed: dict = json.loads(data, parse_float=Decimal)\\n        if \"remark\" in data_parsed:\\n            self._handle_remark_msg(msg=data_parsed.get(\"remark\"))\\n        return Result.from_json(data_parsed, api=self)\\n\\n    def parse_xml(self, data: Union[bytes, str], encoding: str = \"utf-8\", parser: Optional[int] = None):\\n        \"\"\"\\n\\n        :param data: Raw XML Data\\n        :param encoding: Encoding to decode byte string\\n        :param parser: The XML parser to use\\n        :return: Result object\\n        \"\"\"\\n        if parser is None:\\n            parser = self.xml_parser\\n\\n        if isinstance(data, bytes):\\n            data = data.decode(encoding)\\n\\n        m = re.compile(\"<remark>(?P<msg>[^<>]*)</remark>\").search(data)\\n        if m:\\n            self._handle_remark_msg(m.group(\"msg\"))\\n\\n        return Result.from_xml(data, api=self, parser=parser)\\n\\n\\nclass Result:\\n    \"\"\"\\n    Class to handle the result.\\n    \"\"\"\\n\\n    def __init__(\\n            self,\\n            elements: Optional[List[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]] = None,\\n            api: Optional[Overpass] = None):\\n        \"\"\"\\n\\n        :param elements: List of elements to initialize the result with\\n        :param api: The API object to load additional resources and elements\\n        \"\"\"\\n        if elements is None:\\n            elements = []\\n        self._areas: Dict[int, Union[\"Area\", \"Node\", \"Relation\", \"Way\"]] = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Area)\\n        )\\n        self._nodes = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Node)\\n        )\\n        self._ways = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Way)\\n        )\\n        self._relations = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Relation)\\n        )\\n        self._class_collection_map: Dict[Any, Any] = {\\n            Node: self._nodes,\\n            Way: self._ways,\\n            Relation: self._relations,\\n            Area: self._areas\\n        }\\n        self.api = api\\n\\n    def expand(self, other: \"Result\"):\\n        \"\"\"\\n        Add all elements from an other result to the list of elements of this result object.\\n\\n        It is used by the auto resolve feature.\\n\\n        :param other: Expand the result with the elements from this result.\\n        :raises ValueError: If provided parameter is not instance of :class:`overpy.Result`\\n        \"\"\"\\n        if not isinstance(other, Result):\\n            raise ValueError(\"Provided argument has to be instance of overpy:Result()\")\\n\\n        other_collection_map: Dict[Type[\"Element\"], List[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]] = {\\n            Area: other.areas,\\n            Node: other.nodes,\\n            Relation: other.relations,\\n            Way: other.ways\\n        }\\n        for element_type, own_collection in self._class_collection_map.items():\\n            for element in other_collection_map[element_type]:\\n                if is_valid_type(element, element_type) and element.id not in own_collection:\\n                    own_collection[element.id] = element\\n\\n    def append(self, element: Union[\"Area\", \"Node\", \"Relation\", \"Way\"]):\\n        \"\"\"\\n        Append a new element to the result.\\n\\n        :param element: The element to append\\n        \"\"\"\\n        if is_valid_type(element, Element):\\n            self._class_collection_map[element.__class__].setdefault(element.id, element)\\n\\n    def get_elements(\\n            self,\\n            filter_cls: Type[ElementTypeVar],\\n            elem_id: Optional[int] = None) -> List[ElementTypeVar]:\\n        \"\"\"\\n        Get a list of elements from the result and filter the element type by a class.\\n\\n        :param filter_cls:\\n        :param elem_id: ID of the object\\n        :return: List of available elements\\n        \"\"\"\\n        result: List[ElementTypeVar] = []\\n        if elem_id is not None:\\n            try:\\n                result = [self._class_collection_map[filter_cls][elem_id]]\\n            except KeyError:\\n                result = []\\n        else:\\n            for e in self._class_collection_map[filter_cls].values():\\n                result.append(e)\\n        return result\\n\\n    def get_ids(\\n            self,\\n            filter_cls: Type[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]) -> List[int]:\\n        \"\"\"\\n        Get all Element IDs\\n\\n        :param filter_cls: Only IDs of elements with this type\\n        :return: List of IDs\\n        \"\"\"\\n        return list(self._class_collection_map[filter_cls].keys())\\n\\n    def get_node_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Node)\\n\\n    def get_way_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Way)\\n\\n    def get_relation_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Relation)\\n\\n    def get_area_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Area)\\n\\n    @classmethod\\n    def from_json(cls, data: dict, api: Optional[Overpass] = None) -> \"Result\":\\n        \"\"\"\\n        Create a new instance and load data from json object.\\n\\n        :param data: JSON data returned by the Overpass API\\n        :param api:\\n        :return: New instance of Result object\\n        \"\"\"\\n        result = cls(api=api)\\n        elem_cls: Type[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]\\n        for elem_cls in [Node, Way, Relation, Area]:\\n            for element in data.get(\"elements\", []):\\n                e_type = element.get(\"type\")\\n                if hasattr(e_type, \"lower\") and e_type.lower() == elem_cls._type_value:\\n                    result.append(elem_cls.from_json(element, result=result))\\n\\n        return result\\n\\n    @classmethod\\n    def from_xml(\\n            cls,\\n            data: Union[str, xml.etree.ElementTree.Element],\\n            api: Optional[Overpass] = None,\\n            parser: Optional[int] = None) -> \"Result\":\\n        \"\"\"\\n        Create a new instance and load data from xml data or object.\\n\\n        .. note::\\n            If parser is set to None, the functions tries to find the best parse.\\n            By default the SAX parser is chosen if a string is provided as data.\\n            The parser is set to DOM if an xml.etree.ElementTree.Element is provided as data value.\\n\\n        :param data: Root element\\n        :param api: The instance to query additional information if required.\\n        :param parser: Specify the parser to use(DOM or SAX)(Default: None = autodetect, defaults to SAX)\\n        :return: New instance of Result object\\n        \"\"\"\\n        if parser is None:\\n            if isinstance(data, str):\\n                parser = XML_PARSER_SAX\\n            else:\\n                parser = XML_PARSER_DOM\\n\\n        result = cls(api=api)\\n        if parser == XML_PARSER_DOM:\\n            import xml.etree.ElementTree as ET\\n            if isinstance(data, str):\\n                root = ET.fromstring(data)\\n            elif isinstance(data, ET.Element):\\n                root = data\\n            else:\\n                raise exception.OverPyException(\"Unable to detect data type.\")\\n\\n            elem_cls: Type[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]\\n            for elem_cls in [Node, Way, Relation, Area]:\\n                for child in root:\\n                    if child.tag.lower() == elem_cls._type_value:\\n                        result.append(elem_cls.from_xml(child, result=result))\\n\\n        elif parser == XML_PARSER_SAX:\\n            from io import StringIO\\n            if not isinstance(data, str):\\n                raise ValueError(\"data must be of type str if using the SAX parser\")\\n            source = StringIO(data)\\n            sax_handler = OSMSAXHandler(result)\\n            sax_parser = make_parser()\\n            sax_parser.setContentHandler(sax_handler)\\n            sax_parser.parse(source)\\n        else:\\n            # ToDo: better exception\\n            raise Exception(\"Unknown XML parser\")\\n        return result\\n\\n    def get_area(self, area_id: int, resolve_missing: bool = False) -> \"Area\":\\n        \"\"\"\\n        Get an area by its ID.\\n\\n        :param area_id: The area ID\\n        :param resolve_missing: Query the Overpass API if the area is missing in the result set.\\n        :return: The area\\n        :raises overpy.exception.DataIncomplete: The requested way is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and the area can\\'t be resolved.\\n        \"\"\"\\n        areas = self.get_areas(area_id=area_id)\\n        if len(areas) == 0:\\n            if resolve_missing is False:\\n                raise exception.DataIncomplete(\"Resolve missing area is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"area({area_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                area_id=area_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            areas = self.get_areas(area_id=area_id)\\n\\n        if len(areas) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve requested areas\")\\n\\n        return areas[0]\\n\\n    def get_areas(self, area_id: Optional[int] = None) -> List[\"Area\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Area\\n\\n        :param area_id: The Id of the area\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Area, elem_id=area_id)\\n\\n    def get_node(self, node_id: int, resolve_missing: bool = False) -> \"Node\":\\n        \"\"\"\\n        Get a node by its ID.\\n\\n        :param node_id: The node ID\\n        :param resolve_missing: Query the Overpass API if the node is missing in the result set.\\n        :return: The node\\n        :raises overpy.exception.DataIncomplete: At least one referenced node is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and at least one node can\\'t be resolved.\\n        \"\"\"\\n        nodes = self.get_nodes(node_id=node_id)\\n        if len(nodes) == 0:\\n            if not resolve_missing:\\n                raise exception.DataIncomplete(\"Resolve missing nodes is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"node({node_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                node_id=node_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            nodes = self.get_nodes(node_id=node_id)\\n\\n        if len(nodes) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve all nodes\")\\n\\n        return nodes[0]\\n\\n    def get_nodes(self, node_id: Optional[int] = None) -> List[\"Node\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Node()\\n\\n        :param node_id: The Id of the node\\n        :type node_id: Integer\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Node, elem_id=node_id)\\n\\n    def get_relation(self, rel_id: int, resolve_missing: bool = False) -> \"Relation\":\\n        \"\"\"\\n        Get a relation by its ID.\\n\\n        :param rel_id: The relation ID\\n        :param resolve_missing: Query the Overpass API if the relation is missing in the result set.\\n        :return: The relation\\n        :raises overpy.exception.DataIncomplete: The requested relation is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and the relation can\\'t be resolved.\\n        \"\"\"\\n        relations = self.get_relations(rel_id=rel_id)\\n        if len(relations) == 0:\\n            if resolve_missing is False:\\n                raise exception.DataIncomplete(\"Resolve missing relations is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"relation({relation_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                relation_id=rel_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            relations = self.get_relations(rel_id=rel_id)\\n\\n        if len(relations) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve requested reference\")\\n\\n        return relations[0]\\n\\n    def get_relations(self, rel_id: int = None) -> List[\"Relation\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Relation\\n\\n        :param rel_id: Id of the relation\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Relation, elem_id=rel_id)\\n\\n    def get_way(self, way_id: int, resolve_missing: bool = False) -> \"Way\":\\n        \"\"\"\\n        Get a way by its ID.\\n\\n        :param way_id: The way ID\\n        :param resolve_missing: Query the Overpass API if the way is missing in the result set.\\n        :return: The way\\n        :raises overpy.exception.DataIncomplete: The requested way is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and the way can\\'t be resolved.\\n        \"\"\"\\n        ways = self.get_ways(way_id=way_id)\\n        if len(ways) == 0:\\n            if resolve_missing is False:\\n                raise exception.DataIncomplete(\"Resolve missing way is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"way({way_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                way_id=way_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            ways = self.get_ways(way_id=way_id)\\n\\n        if len(ways) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve requested way\")\\n\\n        return ways[0]\\n\\n    def get_ways(self, way_id: Optional[int] = None) -> List[\"Way\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Way\\n\\n        :param way_id: The Id of the way\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Way, elem_id=way_id)\\n\\n    area_ids = property(get_area_ids)\\n    areas = property(get_areas)\\n    node_ids = property(get_node_ids)\\n    nodes = property(get_nodes)\\n    relation_ids = property(get_relation_ids)\\n    relations = property(get_relations)\\n    way_ids = property(get_way_ids)\\n    ways = property(get_ways)\\n\\n\\nclass Element:\\n    \"\"\"\\n    Base element\\n    \"\"\"\\n\\n    _type_value: str\\n\\n    def __init__(self, attributes: Optional[dict] = None, result: Optional[Result] = None, tags: Optional[Dict] = None):\\n        \"\"\"\\n        :param attributes: Additional attributes\\n        :param result: The result object this element belongs to\\n        :param tags: List of tags\\n        \"\"\"\\n\\n        self._result = result\\n        self.attributes = attributes\\n        # ToDo: Add option to modify attribute modifiers\\n        attribute_modifiers: Dict[str, Callable] = dict(GLOBAL_ATTRIBUTE_MODIFIERS.items())\\n        for n, m in attribute_modifiers.items():\\n            if n in self.attributes:\\n                self.attributes[n] = m(self.attributes[n])\\n        self.id: int\\n        self.tags = tags\\n\\n    @classmethod\\n    def get_center_from_json(cls, data: dict) -> Tuple[Decimal, Decimal]:\\n        \"\"\"\\n        Get center information from json data\\n\\n        :param data: json data\\n        :return: tuple with two elements: lat and lon\\n        \"\"\"\\n        center_lat = None\\n        center_lon = None\\n        center = data.get(\"center\")\\n        if isinstance(center, dict):\\n            center_lat = center.get(\"lat\")\\n            center_lon = center.get(\"lon\")\\n            if center_lat is None or center_lon is None:\\n                raise ValueError(\"Unable to get lat or lon of way center.\")\\n            center_lat = Decimal(center_lat)\\n            center_lon = Decimal(center_lon)\\n        return center_lat, center_lon\\n\\n    @classmethod\\n    def get_center_from_xml_dom(cls, sub_child: xml.etree.ElementTree.Element) -> Tuple[Decimal, Decimal]:\\n        center_lat_str: str = sub_child.attrib.get(\"lat\")\\n        center_lon_str: str = sub_child.attrib.get(\"lon\")\\n        if center_lat_str is None or center_lon_str is None:\\n            raise ValueError(\"Unable to get lat or lon of way center.\")\\n        center_lat = Decimal(center_lat_str)\\n        center_lon = Decimal(center_lon_str)\\n        return center_lat, center_lon\\n\\n    @classmethod\\n    def from_json(cls: Type[ElementTypeVar], data: dict, result: Optional[Result] = None) -> ElementTypeVar:\\n        \"\"\"\\n        Create new Element() from json data\\n        :param data:\\n        :param result:\\n        :return:\\n        \"\"\"\\n        raise NotImplementedError\\n\\n    @classmethod\\n    def from_xml(\\n            cls: Type[ElementTypeVar],\\n            child: xml.etree.ElementTree.Element,\\n            result: Optional[Result] = None) -> ElementTypeVar:\\n        \"\"\"\\n        Create new Element() element from XML data\\n        \"\"\"\\n        raise NotImplementedError\\n\\n\\nclass Area(Element):\\n    \"\"\"\\n    Class to represent an element of type area\\n    \"\"\"\\n\\n    _type_value = \"area\"\\n\\n    def __init__(self, area_id: Optional[int] = None, **kwargs):\\n        \"\"\"\\n        :param area_id: Id of the area element\\n        :param kwargs: Additional arguments are passed directly to the parent class\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        #: The id of the way\\n        self.id = area_id\\n\\n    def __repr__(self) -> str:\\n        return f\"<overpy.Area id={self.id}>\"\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Area\":\\n        \"\"\"\\n        Create new Area element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Way\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        area_id = data.get(\"id\")\\n\\n        attributes = {}\\n        ignore = [\"id\", \"tags\", \"type\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(area_id=area_id, attributes=attributes, tags=tags, result=result)\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Area\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If the ref attribute of the xml node is not provided\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n\\n        area_id_str: Optional[str] = child.attrib.get(\"id\")\\n        area_id: Optional[int] = None\\n        if area_id_str is not None:\\n            area_id = int(area_id_str)\\n\\n        attributes = {}\\n        ignore = [\"id\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(area_id=area_id, attributes=attributes, tags=tags, result=result)\\n\\n\\nclass Node(Element):\\n    \"\"\"\\n    Class to represent an element of type node\\n    \"\"\"\\n\\n    _type_value = \"node\"\\n\\n    def __init__(\\n            self,\\n            node_id: Optional[int] = None,\\n            lat: Optional[Union[Decimal, float]] = None,\\n            lon: Optional[Union[Decimal, float]] = None,\\n            **kwargs):\\n        \"\"\"\\n        :param lat: Latitude\\n        :param lon: Longitude\\n        :param node_id: Id of the node element\\n        :param kwargs: Additional arguments are passed directly to the parent class\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        self.id = node_id\\n        self.lat = lat\\n        self.lon = lon\\n\\n    def __repr__(self) -> str:\\n        return f\"<overpy.Node id={self.id} lat={self.lat} lon={self.lon}>\"\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Node\":\\n        \"\"\"\\n        Create new Node element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Node\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        node_id = data.get(\"id\")\\n        lat = data.get(\"lat\")\\n        lon = data.get(\"lon\")\\n\\n        attributes = {}\\n        ignore = [\"type\", \"id\", \"lat\", \"lon\", \"tags\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(node_id=node_id, lat=lat, lon=lon, tags=tags, attributes=attributes, result=result)\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Node\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n\\n        node_id: Optional[int] = None\\n        node_id_str: Optional[str] = child.attrib.get(\"id\")\\n        if node_id_str is not None:\\n            node_id = int(node_id_str)\\n\\n        lat: Optional[Decimal] = None\\n        lat_str: Optional[str] = child.attrib.get(\"lat\")\\n        if lat_str is not None:\\n            lat = Decimal(lat_str)\\n\\n        lon: Optional[Decimal] = None\\n        lon_str: Optional[str] = child.attrib.get(\"lon\")\\n        if lon_str is not None:\\n            lon = Decimal(lon_str)\\n\\n        attributes = {}\\n        ignore = [\"id\", \"lat\", \"lon\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(node_id=node_id, lat=lat, lon=lon, tags=tags, attributes=attributes, result=result)\\n\\n\\nclass Way(Element):\\n    \"\"\"\\n    Class to represent an element of type way\\n    \"\"\"\\n\\n    _type_value = \"way\"\\n\\n    def __init__(\\n            self,\\n            way_id: Optional[int] = None,\\n            center_lat: Optional[Union[Decimal, float]] = None,\\n            center_lon: Optional[Union[Decimal, float]] = None,\\n            node_ids: Optional[Union[List[int], Tuple[int]]] = None,\\n            **kwargs):\\n        \"\"\"\\n        :param node_ids: List of node IDs\\n        :param way_id: Id of the way element\\n        :param kwargs: Additional arguments are passed directly to the parent class\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        #: The id of the way\\n        self.id = way_id\\n\\n        #: List of Ids of the associated nodes\\n        self._node_ids = node_ids\\n\\n        #: The lat/lon of the center of the way (optional depending on query)\\n        self.center_lat = center_lat\\n        self.center_lon = center_lon\\n\\n    def __repr__(self):\\n        return f\"<overpy.Way id={self.id} nodes={self._node_ids}>\"\\n\\n    @property\\n    def nodes(self) -> List[Node]:\\n        \"\"\"\\n        List of nodes associated with the way.\\n        \"\"\"\\n        return self.get_nodes()\\n\\n    def get_nodes(self, resolve_missing: bool = False) -> List[Node]:\\n        \"\"\"\\n        Get the nodes defining the geometry of the way\\n\\n        :param resolve_missing: Try to resolve missing nodes.\\n        :return: List of nodes\\n        :raises overpy.exception.DataIncomplete: At least one referenced node is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and at least one node can\\'t be resolved.\\n        \"\"\"\\n        result = []\\n        resolved = False\\n\\n        for node_id in self._node_ids:\\n            try:\\n                node = self._result.get_node(node_id)\\n            except exception.DataIncomplete:\\n                node = None\\n\\n            if node is not None:\\n                result.append(node)\\n                continue\\n\\n            if not resolve_missing:\\n                raise exception.DataIncomplete(\"Resolve missing nodes is disabled\")\\n\\n            # We tried to resolve the data but some nodes are still missing\\n            if resolved:\\n                raise exception.DataIncomplete(\"Unable to resolve all nodes\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"way({way_id});\\\\n\"\\n                     \"node(w);\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                way_id=self.id\\n            )\\n            tmp_result = self._result.api.query(query)\\n            self._result.expand(tmp_result)\\n            resolved = True\\n\\n            try:\\n                node = self._result.get_node(node_id)\\n            except exception.DataIncomplete:\\n                node = None\\n\\n            if node is None:\\n                raise exception.DataIncomplete(\"Unable to resolve all nodes\")\\n\\n            result.append(node)\\n\\n        return result\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Way\":\\n        \"\"\"\\n        Create new Way element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Way\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        way_id = data.get(\"id\")\\n        node_ids = data.get(\"nodes\")\\n        (center_lat, center_lon) = cls.get_center_from_json(data=data)\\n\\n        attributes = {}\\n        ignore = [\"center\", \"id\", \"nodes\", \"tags\", \"type\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(\\n            attributes=attributes,\\n            center_lat=center_lat,\\n            center_lon=center_lon,\\n            node_ids=node_ids,\\n            tags=tags,\\n            result=result,\\n            way_id=way_id\\n        )\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Way\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If the ref attribute of the xml node is not provided\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n        node_ids = []\\n        center_lat = None\\n        center_lon = None\\n\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n            if sub_child.tag.lower() == \"nd\":\\n                ref_id_str = sub_child.attrib.get(\"ref\")\\n                if ref_id_str is None:\\n                    raise ValueError(\"Unable to find required ref value.\")\\n                ref_id: int = int(ref_id_str)\\n                node_ids.append(ref_id)\\n            if sub_child.tag.lower() == \"center\":\\n                (center_lat, center_lon) = cls.get_center_from_xml_dom(sub_child=sub_child)\\n\\n        way_id: Optional[int] = None\\n        way_id_str: Optional[str] = child.attrib.get(\"id\")\\n        if way_id_str is not None:\\n            way_id = int(way_id_str)\\n\\n        attributes = {}\\n        ignore = [\"id\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(way_id=way_id, center_lat=center_lat, center_lon=center_lon,\\n                   attributes=attributes, node_ids=node_ids, tags=tags, result=result)\\n\\n\\nclass Relation(Element):\\n    \"\"\"\\n    Class to represent an element of type relation\\n    \"\"\"\\n\\n    _type_value = \"relation\"\\n\\n    def __init__(\\n            self,\\n            rel_id: Optional[int] = None,\\n            center_lat: Optional[Union[Decimal, float]] = None,\\n            center_lon: Optional[Union[Decimal, float]] = None,\\n            members: Optional[List[\"RelationMember\"]] = None,\\n            **kwargs):\\n        \"\"\"\\n        :param members:\\n        :param rel_id: Id of the relation element\\n        :param kwargs:\\n        :return:\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        self.id = rel_id\\n        self.members = members\\n\\n        #: The lat/lon of the center of the way (optional depending on query)\\n        self.center_lat = center_lat\\n        self.center_lon = center_lon\\n\\n    def __repr__(self):\\n        return f\"<overpy.Relation id={self.id}>\"\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Relation\":\\n        \"\"\"\\n        Create new Relation element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Relation\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        rel_id = data.get(\"id\")\\n        (center_lat, center_lon) = cls.get_center_from_json(data=data)\\n\\n        members = []\\n\\n        supported_members = [RelationNode, RelationWay, RelationRelation]\\n        for member in data.get(\"members\", []):\\n            type_value = member.get(\"type\")\\n            for member_cls in supported_members:\\n                if member_cls._type_value == type_value:\\n                    members.append(\\n                        member_cls.from_json(\\n                            member,\\n                            result=result\\n                        )\\n                    )\\n\\n        attributes = {}\\n        ignore = [\"id\", \"members\", \"tags\", \"type\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(\\n            rel_id=rel_id,\\n            attributes=attributes,\\n            center_lat=center_lat,\\n            center_lon=center_lon,\\n            members=members,\\n            tags=tags,\\n            result=result\\n        )\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Relation\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n        members = []\\n        center_lat = None\\n        center_lon = None\\n\\n        supported_members = [RelationNode, RelationWay, RelationRelation, RelationArea]\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n            if sub_child.tag.lower() == \"member\":\\n                type_value = sub_child.attrib.get(\"type\")\\n                for member_cls in supported_members:\\n                    if member_cls._type_value == type_value:\\n                        members.append(\\n                            member_cls.from_xml(\\n                                sub_child,\\n                                result=result\\n                            )\\n                        )\\n            if sub_child.tag.lower() == \"center\":\\n                (center_lat, center_lon) = cls.get_center_from_xml_dom(sub_child=sub_child)\\n\\n        rel_id: Optional[int] = None\\n        rel_id_str: Optional[str] = child.attrib.get(\"id\")\\n        if rel_id_str is not None:\\n            rel_id = int(rel_id_str)\\n\\n        attributes = {}\\n        ignore = [\"id\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(\\n            rel_id=rel_id,\\n            attributes=attributes,\\n            center_lat=center_lat,\\n            center_lon=center_lon,\\n            members=members,\\n            tags=tags,\\n            result=result\\n        )\\n\\n\\nclass RelationMember:\\n    \"\"\"\\n    Base class to represent a member of a relation.\\n    \"\"\"\\n    _type_value: Optional[str] = None\\n\\n    def __init__(\\n            self,\\n            attributes: Optional[dict] = None,\\n            geometry: Optional[List[\"RelationWayGeometryValue\"]] = None,\\n            ref: Optional[int] = None,\\n            role: Optional[str] = None,\\n            result: Optional[Result] = None):\\n        \"\"\"\\n        :param ref: Reference Id\\n        :type ref: Integer\\n        :param role: The role of the relation member\\n        :type role: String\\n        :param result:\\n        \"\"\"\\n        self.ref = ref\\n        self._result = result\\n        self.role = role\\n        self.attributes = attributes\\n        self.geometry = geometry\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"RelationMember\":\\n        \"\"\"\\n        Create new RelationMember element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of RelationMember\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        ref = data.get(\"ref\")\\n        role = data.get(\"role\")\\n\\n        attributes = {}\\n        ignore = [\"geometry\", \"type\", \"ref\", \"role\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        geometry = data.get(\"geometry\")\\n        if isinstance(geometry, list):\\n            geometry_orig = geometry\\n            geometry = []\\n            for v in geometry_orig:\\n                geometry.append(\\n                    RelationWayGeometryValue(\\n                        lat=v.get(\"lat\"),\\n                        lon=v.get(\"lon\")\\n                    )\\n                )\\n        else:\\n            geometry = None\\n\\n        return cls(\\n            attributes=attributes,\\n            geometry=geometry,\\n            ref=ref,\\n            role=role,\\n            result=result\\n        )\\n\\n    @classmethod\\n    def from_xml(\\n            cls,\\n            child: xml.etree.ElementTree.Element,\\n            result: Optional[Result] = None) -> \"RelationMember\":\\n        \"\"\"\\n        Create new RelationMember from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this element belongs to\\n        :return: New relation member oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        \"\"\"\\n        if child.attrib.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        ref: Optional[int] = None\\n        ref_str: Optional[str] = child.attrib.get(\"ref\")\\n        if ref_str is not None:\\n            ref = int(ref_str)\\n\\n        role: Optional[str] = child.attrib.get(\"role\")\\n\\n        attributes = {}\\n        ignore = [\"geometry\", \"ref\", \"role\", \"type\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        geometry = None\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"nd\":\\n                if geometry is None:\\n                    geometry = []\\n                geometry.append(\\n                    RelationWayGeometryValue(\\n                        lat=Decimal(sub_child.attrib[\"lat\"]),\\n                        lon=Decimal(sub_child.attrib[\"lon\"])\\n                    )\\n                )\\n\\n        return cls(\\n            attributes=attributes,\\n            geometry=geometry,\\n            ref=ref,\\n            role=role,\\n            result=result\\n        )\\n\\n\\nclass RelationNode(RelationMember):\\n    _type_value = \"node\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Node:\\n        return self._result.get_node(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationNode ref={self.ref} role={self.role}>\"\\n\\n\\nclass RelationWay(RelationMember):\\n    _type_value = \"way\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Way:\\n        return self._result.get_way(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationWay ref={self.ref} role={self.role}>\"\\n\\n\\nclass RelationWayGeometryValue:\\n    def __init__(self, lat: Union[Decimal, float], lon: Union[Decimal, float]):\\n        self.lat = lat\\n        self.lon = lon\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationWayGeometryValue lat={self.lat} lon={self.lon}>\"\\n\\n\\nclass RelationRelation(RelationMember):\\n    _type_value = \"relation\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Relation:\\n        return self._result.get_relation(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationRelation ref={self.ref} role={self.role}>\"\\n\\n\\nclass RelationArea(RelationMember):\\n    _type_value = \"area\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Area:\\n        return self._result.get_area(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationArea ref={self.ref} role={self.role}>\"\\n\\n\\nclass OSMSAXHandler(handler.ContentHandler):\\n    \"\"\"\\n    SAX parser for Overpass XML response.\\n    \"\"\"\\n    #: Tuple of opening elements to ignore\\n    ignore_start: ClassVar = (\\'osm\\', \\'meta\\', \\'note\\', \\'bounds\\', \\'remark\\')\\n    #: Tuple of closing elements to ignore\\n    ignore_end: ClassVar = (\\'osm\\', \\'meta\\', \\'note\\', \\'bounds\\', \\'remark\\', \\'tag\\', \\'nd\\', \\'center\\')\\n\\n    def __init__(self, result: Result):\\n        \"\"\"\\n        :param result: Append results to this result set.\\n        \"\"\"\\n        handler.ContentHandler.__init__(self)\\n        self._result = result\\n        self._curr: Dict[str, Any] = {}\\n        #: Current relation member object\\n        self.cur_relation_member: Optional[RelationMember] = None\\n\\n    def startElement(self, name: str, attrs: dict):\\n        \"\"\"\\n        Handle opening elements.\\n\\n        :param name: Name of the element\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        if name in self.ignore_start:\\n            return\\n        try:\\n            handler = getattr(self, \\'_handle_start_%s\\' % name)\\n        except AttributeError:\\n            raise KeyError(\"Unknown element start \\'%s\\'\" % name)\\n        handler(attrs)\\n\\n    def endElement(self, name: str):\\n        \"\"\"\\n        Handle closing elements\\n\\n        :param name: Name of the element\\n        \"\"\"\\n        if name in self.ignore_end:\\n            return\\n        try:\\n            handler = getattr(self, \\'_handle_end_%s\\' % name)\\n        except AttributeError:\\n            raise KeyError(\"Unknown element end \\'%s\\'\" % name)\\n        handler()\\n\\n    def _handle_start_center(self, attrs: dict):\\n        \"\"\"\\n        Handle opening center element\\n\\n        :param attrs: Attributes of the element\\n        :type attrs: Dict\\n        \"\"\"\\n        center_lat = attrs.get(\"lat\")\\n        center_lon = attrs.get(\"lon\")\\n        if center_lat is None or center_lon is None:\\n            raise ValueError(\"Unable to get lat or lon of way center.\")\\n        self._curr[\"center_lat\"] = Decimal(center_lat)\\n        self._curr[\"center_lon\"] = Decimal(center_lon)\\n\\n    def _handle_start_tag(self, attrs: dict):\\n        \"\"\"\\n        Handle opening tag element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        try:\\n            tag_key = attrs[\\'k\\']\\n        except KeyError:\\n            raise ValueError(\"Tag without name/key.\")\\n        self._curr[\\'tags\\'][tag_key] = attrs.get(\\'v\\')\\n\\n    def _handle_start_node(self, attrs: dict):\\n        \"\"\"\\n        Handle opening node element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'attributes\\': dict(attrs),\\n            \\'lat\\': None,\\n            \\'lon\\': None,\\n            \\'node_id\\': None,\\n            \\'tags\\': {}\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'node_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n        if attrs.get(\\'lat\\', None) is not None:\\n            self._curr[\\'lat\\'] = Decimal(attrs[\\'lat\\'])\\n            del self._curr[\\'attributes\\'][\\'lat\\']\\n        if attrs.get(\\'lon\\', None) is not None:\\n            self._curr[\\'lon\\'] = Decimal(attrs[\\'lon\\'])\\n            del self._curr[\\'attributes\\'][\\'lon\\']\\n\\n    def _handle_end_node(self):\\n        \"\"\"\\n        Handle closing node element\\n        \"\"\"\\n        self._result.append(Node(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_way(self, attrs: dict):\\n        \"\"\"\\n        Handle opening way element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'center_lat\\': None,\\n            \\'center_lon\\': None,\\n            \\'attributes\\': dict(attrs),\\n            \\'node_ids\\': [],\\n            \\'tags\\': {},\\n            \\'way_id\\': None\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'way_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n\\n    def _handle_end_way(self):\\n        \"\"\"\\n        Handle closing way element\\n        \"\"\"\\n        self._result.append(Way(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_area(self, attrs: dict):\\n        \"\"\"\\n        Handle opening area element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'attributes\\': dict(attrs),\\n            \\'tags\\': {},\\n            \\'area_id\\': None\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'area_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n\\n    def _handle_end_area(self):\\n        \"\"\"\\n        Handle closing area element\\n        \"\"\"\\n        self._result.append(Area(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_nd(self, attrs: dict):\\n        \"\"\"\\n        Handle opening nd element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        if isinstance(self.cur_relation_member, RelationWay):\\n            if self.cur_relation_member.geometry is None:\\n                self.cur_relation_member.geometry = []\\n            self.cur_relation_member.geometry.append(\\n                RelationWayGeometryValue(\\n                    lat=Decimal(attrs[\"lat\"]),\\n                    lon=Decimal(attrs[\"lon\"])\\n                )\\n            )\\n        else:\\n            try:\\n                node_ref = attrs[\\'ref\\']\\n            except KeyError:\\n                raise ValueError(\"Unable to find required ref value.\")\\n            self._curr[\\'node_ids\\'].append(int(node_ref))\\n\\n    def _handle_start_relation(self, attrs: dict):\\n        \"\"\"\\n        Handle opening relation element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'attributes\\': dict(attrs),\\n            \\'members\\': [],\\n            \\'rel_id\\': None,\\n            \\'tags\\': {}\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'rel_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n\\n    def _handle_end_relation(self):\\n        \"\"\"\\n        Handle closing relation element\\n        \"\"\"\\n        self._result.append(Relation(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_member(self, attrs: dict):\\n        \"\"\"\\n        Handle opening member element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n\\n        params: Dict[str, Any] = {\\n            # ToDo: Parse attributes\\n            \\'attributes\\': {},\\n            \\'ref\\': None,\\n            \\'result\\': self._result,\\n            \\'role\\': None\\n        }\\n        if attrs.get(\\'ref\\', None):\\n            params[\\'ref\\'] = int(attrs[\\'ref\\'])\\n        if attrs.get(\\'role\\', None):\\n            params[\\'role\\'] = attrs[\\'role\\']\\n\\n        cls_map = {\\n            \"area\": RelationArea,\\n            \"node\": RelationNode,\\n            \"relation\": RelationRelation,\\n            \"way\": RelationWay\\n        }\\n        cls: Type[RelationMember] = cls_map.get(attrs[\"type\"])\\n        if cls is None:\\n            raise ValueError(\"Undefined type for member: \\'%s\\'\" % attrs[\\'type\\'])\\n\\n        self.cur_relation_member = cls(**params)\\n        self._curr[\\'members\\'].append(self.cur_relation_member)\\n\\n    def _handle_end_member(self):\\n        self.cur_relation_member = None\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'class OverPyException(Exception):\\n    \"\"\"OverPy base exception\"\"\"\\n    pass\\n\\n\\nclass DataIncomplete(OverPyException):\\n    \"\"\"\\n    Raised if the requested data isn\\'t available in the result.\\n    Try to improve the query or to resolve the missing data.\\n    \"\"\"\\n    def __init__(self, *args, **kwargs):\\n        OverPyException.__init__(\\n            self,\\n            \"Data incomplete try to improve the query to resolve the missing data\",\\n            *args,\\n            **kwargs\\n        )\\n\\n\\nclass ElementDataWrongType(OverPyException):\\n    \"\"\"\\n    Raised if the provided element does not match the expected type.\\n\\n    :param type_expected: The expected element type\\n    :type type_expected: String\\n    :param type_provided: The provided element type\\n    :type type_provided: String|None\\n    \"\"\"\\n    def __init__(self, type_expected, type_provided=None):\\n        self.type_expected = type_expected\\n        self.type_provided = type_provided\\n\\n    def __str__(self) -> str:\\n        return \"Type expected \\'{}\\' but \\'{}\\' provided\".format(\\n            self.type_expected,\\n            str(self.type_provided)\\n        )\\n\\n\\nclass MaxRetriesReached(OverPyException):\\n    \"\"\"\\n    Raised if max retries reached and the Overpass server didn\\'t respond with a result.\\n    \"\"\"\\n    def __init__(self, retry_count, exceptions):\\n        self.exceptions = exceptions\\n        self.retry_count = retry_count\\n\\n    def __str__(self) -> str:\\n        return \"Unable get any result from the Overpass API server after %d retries.\" % self.retry_count\\n\\n\\nclass OverpassBadRequest(OverPyException):\\n    \"\"\"\\n    Raised if the Overpass API service returns a syntax error.\\n\\n    :param query: The encoded query how it was send to the server\\n    :type query: Bytes\\n    :param msgs: List of error messages\\n    :type msgs: List\\n    \"\"\"\\n    def __init__(self, query, msgs=None):\\n        self.query = query\\n        if msgs is None:\\n            msgs = []\\n        self.msgs = msgs\\n\\n    def __str__(self) -> str:\\n        tmp_msgs = []\\n        for tmp_msg in self.msgs:\\n            if not isinstance(tmp_msg, str):\\n                tmp_msg = str(tmp_msg)\\n            tmp_msgs.append(tmp_msg)\\n\\n        return \"\\\\n\".join(tmp_msgs)\\n\\n\\nclass OverpassError(OverPyException):\\n    \"\"\"\\n    Base exception to report errors if the response returns a remark tag or element.\\n\\n    .. note::\\n        If you are not sure which of the subexceptions you should use, use this one and try to parse the message.\\n\\n        For more information have a look at https://github.com/DinoTools/python-overpy/issues/62\\n\\n    :param str msg: The message from the remark tag or element\\n    \"\"\"\\n    def __init__(self, msg=None):\\n        #: The message from the remark tag or element\\n        self.msg = msg\\n\\n    def __str__(self) -> str:\\n        if self.msg is None:\\n            return \"No error message provided\"\\n        if not isinstance(self.msg, str):\\n            return str(self.msg)\\n        return self.msg\\n\\n\\nclass OverpassGatewayTimeout(OverPyException):\\n    \"\"\"\\n    Raised if load of the Overpass API service is too high and it can\\'t handle the request.\\n    \"\"\"\\n    def __init__(self):\\n        OverPyException.__init__(self, \"Server load too high\")\\n\\n\\nclass OverpassRuntimeError(OverpassError):\\n    \"\"\"\\n    Raised if the server returns a remark-tag(xml) or remark element(json) with a message starting with\\n    \\'runtime error:\\'.\\n    \"\"\"\\n    pass\\n\\n\\nclass OverpassRuntimeRemark(OverpassError):\\n    \"\"\"\\n    Raised if the server returns a remark-tag(xml) or remark element(json) with a message starting with\\n    \\'runtime remark:\\'.\\n    \"\"\"\\n    pass\\n\\n\\nclass OverpassTooManyRequests(OverPyException):\\n    \"\"\"\\n    Raised if the Overpass API service returns a 429 status code.\\n    \"\"\"\\n    def __init__(self):\\n        OverPyException.__init__(self, \"Too many requests\")\\n\\n\\nclass OverpassUnknownContentType(OverPyException):\\n    \"\"\"\\n    Raised if the reported content type isn\\'t handled by OverPy.\\n\\n    :param content_type: The reported content type\\n    :type content_type: None or String\\n    \"\"\"\\n    def __init__(self, content_type):\\n        self.content_type = content_type\\n\\n    def __str__(self) -> str:\\n        if self.content_type is None:\\n            return \"No content type returned\"\\n        return \"Unknown content type: %s\" % self.content_type\\n\\n\\nclass OverpassUnknownError(OverpassError):\\n    \"\"\"\\n    Raised if the server returns a remark-tag(xml) or remark element(json) and we are unable to find any reason.\\n    \"\"\"\\n    pass\\n\\n\\nclass OverpassUnknownHTTPStatusCode(OverPyException):\\n    \"\"\"\\n    Raised if the returned HTTP status code isn\\'t handled by OverPy.\\n\\n    :param code: The HTTP status code\\n    :type code: Integer\\n    \"\"\"\\n    def __init__(self, code):\\n        self.code = code\\n\\n    def __str__(self) -> str:\\n        return \"Unknown/Unhandled status code: %d\" % self.code\\n'"}, "return_value": "'utf-8'"}, {"func_args": {"source": "b'from typing import List, Optional\\n__author__ = \\'mjob\\'\\n\\nimport overpy\\n\\n\\ndef get_street(\\n        street: str,\\n        areacode: str,\\n        api: Optional[overpy.Overpass] = None) -> overpy.Result:\\n    \"\"\"\\n    Retrieve streets in a given bounding area\\n\\n    :param street: Name of street\\n    :param areacode: The OSM id of the bounding area\\n    :param api: API object to fetch missing elements\\n    :return: Parsed result\\n    :raises overpy.exception.OverPyException: If something bad happens.\\n    \"\"\"\\n    if api is None:\\n        api = overpy.Overpass()\\n\\n    query = \"\"\"\\n        area(%s)->.location;\\n        (\\n            way[highway][name=\"%s\"](area.location);\\n            - (\\n                way[highway=service](area.location);\\n                way[highway=track](area.location);\\n            );\\n        );\\n        out body;\\n        >;\\n        out skel qt;\\n    \"\"\"\\n\\n    data = api.query(query % (areacode, street))\\n\\n    return data\\n\\n\\ndef get_intersection(\\n        street1: str,\\n        street2: str,\\n        areacode: str,\\n        api: Optional[overpy.Overpass] = None) -> List[overpy.Node]:\\n    \"\"\"\\n    Retrieve intersection of two streets in a given bounding area\\n\\n    :param street1: Name of first street of intersection\\n    :param street2: Name of second street of intersection\\n    :param areacode: The OSM id of the bounding area\\n    :param api: API object to fetch missing elements\\n    :return: List of intersections\\n    :raises overpy.exception.OverPyException: If something bad happens.\\n    \"\"\"\\n    if api is None:\\n        api = overpy.Overpass()\\n\\n    query = \"\"\"\\n        area(%s)->.location;\\n        (\\n            way[highway][name=\"%s\"](area.location); node(w)->.n1;\\n            way[highway][name=\"%s\"](area.location); node(w)->.n2;\\n        );\\n        node.n1.n2;\\n        out meta;\\n    \"\"\"\\n\\n    data = api.query(query % (areacode, street1, street2))\\n\\n    return data.get_nodes()\\n'"}, "return_value": "'utf-8'"}]}, "neuter_encoding_declaration": {"line": 214, "args": [{"func_args": {"source": "'__all__ = [\\n    \"__author__\",\\n    \"__copyright__\",\\n    \"__email__\",\\n    \"__license__\",\\n    \"__summary__\",\\n    \"__title__\",\\n    \"__uri__\",\\n    \"__version__\",\\n]\\n\\n__title__ = \"overpy\"\\n__summary__ = \"Python Wrapper to access the OpenStreepMap Overpass API\"\\n__uri__ = \"https://github.com/DinoTools/python-overpy\"\\n\\n__version__ = \"0.6\"\\n\\n__author__ = \"PhiBo (DinoTools)\"\\n__email__ = \"\"\\n\\n__license__ = \"MIT\"\\n__copyright__ = \"Copyright 2014-2021 %s\" % __author__\\n'"}, "return_value": "'__all__ = [\\n    \"__author__\",\\n    \"__copyright__\",\\n    \"__email__\",\\n    \"__license__\",\\n    \"__summary__\",\\n    \"__title__\",\\n    \"__uri__\",\\n    \"__version__\",\\n]\\n\\n__title__ = \"overpy\"\\n__summary__ = \"Python Wrapper to access the OpenStreepMap Overpass API\"\\n__uri__ = \"https://github.com/DinoTools/python-overpy\"\\n\\n__version__ = \"0.6\"\\n\\n__author__ = \"PhiBo (DinoTools)\"\\n__email__ = \"\"\\n\\n__license__ = \"MIT\"\\n__copyright__ = \"Copyright 2014-2021 %s\" % __author__\\n'"}, {"func_args": {"source": "'from collections import OrderedDict\\nfrom datetime import datetime\\nfrom decimal import Decimal\\nfrom urllib.request import urlopen\\nfrom urllib.error import HTTPError\\nfrom xml.sax import handler, make_parser\\nimport xml.etree.ElementTree\\nimport json\\nimport re\\nimport time\\nfrom typing import Any, Callable, ClassVar, Dict, List, NoReturn, Optional, Tuple, Type, TypeVar, Union\\n\\nfrom overpy import exception\\n# Ignore flake8 F401 warning for unused vars\\nfrom overpy.__about__ import (  # noqa: F401\\n    __author__, __copyright__, __email__, __license__, __summary__, __title__,\\n    __uri__, __version__\\n)\\n\\nElementTypeVar = TypeVar(\"ElementTypeVar\", bound=\"Element\")\\n\\nXML_PARSER_DOM = 1\\nXML_PARSER_SAX = 2\\n\\n# Try to convert some common attributes\\n# http://wiki.openstreetmap.org/wiki/Elements#Common_attributes\\nGLOBAL_ATTRIBUTE_MODIFIERS: Dict[str, Callable] = {\\n    \"changeset\": int,\\n    \"timestamp\": lambda ts: datetime.strptime(ts, \"%Y-%m-%dT%H:%M:%SZ\"),\\n    \"uid\": int,\\n    \"version\": int,\\n    \"visible\": lambda v: v.lower() == \"true\"\\n}\\n\\n\\ndef is_valid_type(\\n        element: Union[\"Area\", \"Node\", \"Relation\", \"Way\"],\\n        cls: Type[Union[\"Area\", \"Element\", \"Node\", \"Relation\", \"Way\"]]) -> bool:\\n    \"\"\"\\n    Test if an element is of a given type.\\n\\n    :param element: The element instance to test\\n    :param cls: The element class to test\\n    :return: False or True\\n    \"\"\"\\n    return isinstance(element, cls) and element.id is not None\\n\\n\\nclass Overpass:\\n    \"\"\"\\n    Class to access the Overpass API\\n\\n    :cvar default_max_retry_count: Global max number of retries (Default: 0)\\n    :cvar default_read_chunk_size: Max size of each chunk read from the server response\\n    :cvar default_retry_timeout: Global time to wait between tries (Default: 1.0s)\\n    :cvar default_url: Default URL of the Overpass server\\n    \"\"\"\\n    default_max_retry_count: ClassVar[int] = 0\\n    default_read_chunk_size: ClassVar[int] = 4096\\n    default_retry_timeout: ClassVar[float] = 1.0\\n    default_url: ClassVar[str] = \"http://overpass-api.de/api/interpreter\"\\n\\n    def __init__(\\n            self,\\n            read_chunk_size: Optional[int] = None,\\n            url: Optional[str] = None,\\n            xml_parser: int = XML_PARSER_SAX,\\n            max_retry_count: int = None,\\n            retry_timeout: float = None):\\n        \"\"\"\\n        :param read_chunk_size: Max size of each chunk read from the server response\\n        :param url: Optional URL of the Overpass server. Defaults to http://overpass-api.de/api/interpreter\\n        :param xml_parser: The xml parser to use\\n        :param max_retry_count: Max number of retries (Default: default_max_retry_count)\\n        :param retry_timeout: Time to wait between tries (Default: default_retry_timeout)\\n        \"\"\"\\n        self.url = self.default_url\\n        if url is not None:\\n            self.url = url\\n\\n        self._regex_extract_error_msg = re.compile(br\"\\\\<p\\\\>(?P<msg>\\\\<strong\\\\s.*?)\\\\</p\\\\>\")\\n        self._regex_remove_tag = re.compile(b\"<[^>]*?>\")\\n        if read_chunk_size is None:\\n            read_chunk_size = self.default_read_chunk_size\\n        self.read_chunk_size = read_chunk_size\\n\\n        if max_retry_count is None:\\n            max_retry_count = self.default_max_retry_count\\n        self.max_retry_count = max_retry_count\\n\\n        if retry_timeout is None:\\n            retry_timeout = self.default_retry_timeout\\n        self.retry_timeout = retry_timeout\\n\\n        self.xml_parser = xml_parser\\n\\n    @staticmethod\\n    def _handle_remark_msg(msg: str) -> NoReturn:\\n        \"\"\"\\n        Try to parse the message provided with the remark tag or element.\\n\\n        :param msg: The message\\n        :raises overpy.exception.OverpassRuntimeError: If message starts with \\'runtime error:\\'\\n        :raises overpy.exception.OverpassRuntimeRemark: If message starts with \\'runtime remark:\\'\\n        :raises overpy.exception.OverpassUnknownError: If we are unable to identify the error\\n        \"\"\"\\n        msg = msg.strip()\\n        if msg.startswith(\"runtime error:\"):\\n            raise exception.OverpassRuntimeError(msg=msg)\\n        elif msg.startswith(\"runtime remark:\"):\\n            raise exception.OverpassRuntimeRemark(msg=msg)\\n        raise exception.OverpassUnknownError(msg=msg)\\n\\n    def query(self, query: Union[bytes, str]) -> \"Result\":\\n        \"\"\"\\n        Query the Overpass API\\n\\n        :param query: The query string in Overpass QL\\n        :return: The parsed result\\n        \"\"\"\\n        if not isinstance(query, bytes):\\n            query = query.encode(\"utf-8\")\\n\\n        retry_num: int = 0\\n        retry_exceptions: List[exception.OverPyException] = []\\n        do_retry: bool = True if self.max_retry_count > 0 else False\\n        while retry_num <= self.max_retry_count:\\n            if retry_num > 0:\\n                time.sleep(self.retry_timeout)\\n            retry_num += 1\\n            try:\\n                f = urlopen(self.url, query)\\n            except HTTPError as e:\\n                f = e\\n\\n            response = f.read(self.read_chunk_size)\\n            while True:\\n                data = f.read(self.read_chunk_size)\\n                if len(data) == 0:\\n                    break\\n                response = response + data\\n            f.close()\\n\\n            current_exception: exception.OverPyException\\n            if f.code == 200:\\n                content_type = f.getheader(\"Content-Type\")\\n\\n                if content_type == \"application/json\":\\n                    return self.parse_json(response)\\n\\n                if content_type == \"application/osm3s+xml\":\\n                    return self.parse_xml(response)\\n\\n                current_exception = exception.OverpassUnknownContentType(content_type)\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            if f.code == 400:\\n                msgs: List[str] = []\\n                for msg_raw in self._regex_extract_error_msg.finditer(response):\\n                    msg_clean_bytes = self._regex_remove_tag.sub(b\"\", msg_raw.group(\"msg\"))\\n                    try:\\n                        msg = msg_clean_bytes.decode(\"utf-8\")\\n                    except UnicodeDecodeError:\\n                        msg = repr(msg_clean_bytes)\\n                    msgs.append(msg)\\n\\n                current_exception = exception.OverpassBadRequest(\\n                    query,\\n                    msgs=msgs\\n                )\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            if f.code == 429:\\n                current_exception = exception.OverpassTooManyRequests()\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            if f.code == 504:\\n                current_exception = exception.OverpassGatewayTimeout()\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            current_exception = exception.OverpassUnknownHTTPStatusCode(f.code)\\n            if not do_retry:\\n                raise current_exception\\n            retry_exceptions.append(current_exception)\\n            continue\\n\\n        raise exception.MaxRetriesReached(retry_count=retry_num, exceptions=retry_exceptions)\\n\\n    def parse_json(self, data: Union[bytes, str], encoding: str = \"utf-8\") -> \"Result\":\\n        \"\"\"\\n        Parse raw response from Overpass service.\\n\\n        :param data: Raw JSON Data\\n        :param encoding: Encoding to decode byte string\\n        :return: Result object\\n        \"\"\"\\n        if isinstance(data, bytes):\\n            data = data.decode(encoding)\\n        data_parsed: dict = json.loads(data, parse_float=Decimal)\\n        if \"remark\" in data_parsed:\\n            self._handle_remark_msg(msg=data_parsed.get(\"remark\"))\\n        return Result.from_json(data_parsed, api=self)\\n\\n    def parse_xml(self, data: Union[bytes, str], encoding: str = \"utf-8\", parser: Optional[int] = None):\\n        \"\"\"\\n\\n        :param data: Raw XML Data\\n        :param encoding: Encoding to decode byte string\\n        :param parser: The XML parser to use\\n        :return: Result object\\n        \"\"\"\\n        if parser is None:\\n            parser = self.xml_parser\\n\\n        if isinstance(data, bytes):\\n            data = data.decode(encoding)\\n\\n        m = re.compile(\"<remark>(?P<msg>[^<>]*)</remark>\").search(data)\\n        if m:\\n            self._handle_remark_msg(m.group(\"msg\"))\\n\\n        return Result.from_xml(data, api=self, parser=parser)\\n\\n\\nclass Result:\\n    \"\"\"\\n    Class to handle the result.\\n    \"\"\"\\n\\n    def __init__(\\n            self,\\n            elements: Optional[List[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]] = None,\\n            api: Optional[Overpass] = None):\\n        \"\"\"\\n\\n        :param elements: List of elements to initialize the result with\\n        :param api: The API object to load additional resources and elements\\n        \"\"\"\\n        if elements is None:\\n            elements = []\\n        self._areas: Dict[int, Union[\"Area\", \"Node\", \"Relation\", \"Way\"]] = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Area)\\n        )\\n        self._nodes = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Node)\\n        )\\n        self._ways = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Way)\\n        )\\n        self._relations = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Relation)\\n        )\\n        self._class_collection_map: Dict[Any, Any] = {\\n            Node: self._nodes,\\n            Way: self._ways,\\n            Relation: self._relations,\\n            Area: self._areas\\n        }\\n        self.api = api\\n\\n    def expand(self, other: \"Result\"):\\n        \"\"\"\\n        Add all elements from an other result to the list of elements of this result object.\\n\\n        It is used by the auto resolve feature.\\n\\n        :param other: Expand the result with the elements from this result.\\n        :raises ValueError: If provided parameter is not instance of :class:`overpy.Result`\\n        \"\"\"\\n        if not isinstance(other, Result):\\n            raise ValueError(\"Provided argument has to be instance of overpy:Result()\")\\n\\n        other_collection_map: Dict[Type[\"Element\"], List[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]] = {\\n            Area: other.areas,\\n            Node: other.nodes,\\n            Relation: other.relations,\\n            Way: other.ways\\n        }\\n        for element_type, own_collection in self._class_collection_map.items():\\n            for element in other_collection_map[element_type]:\\n                if is_valid_type(element, element_type) and element.id not in own_collection:\\n                    own_collection[element.id] = element\\n\\n    def append(self, element: Union[\"Area\", \"Node\", \"Relation\", \"Way\"]):\\n        \"\"\"\\n        Append a new element to the result.\\n\\n        :param element: The element to append\\n        \"\"\"\\n        if is_valid_type(element, Element):\\n            self._class_collection_map[element.__class__].setdefault(element.id, element)\\n\\n    def get_elements(\\n            self,\\n            filter_cls: Type[ElementTypeVar],\\n            elem_id: Optional[int] = None) -> List[ElementTypeVar]:\\n        \"\"\"\\n        Get a list of elements from the result and filter the element type by a class.\\n\\n        :param filter_cls:\\n        :param elem_id: ID of the object\\n        :return: List of available elements\\n        \"\"\"\\n        result: List[ElementTypeVar] = []\\n        if elem_id is not None:\\n            try:\\n                result = [self._class_collection_map[filter_cls][elem_id]]\\n            except KeyError:\\n                result = []\\n        else:\\n            for e in self._class_collection_map[filter_cls].values():\\n                result.append(e)\\n        return result\\n\\n    def get_ids(\\n            self,\\n            filter_cls: Type[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]) -> List[int]:\\n        \"\"\"\\n        Get all Element IDs\\n\\n        :param filter_cls: Only IDs of elements with this type\\n        :return: List of IDs\\n        \"\"\"\\n        return list(self._class_collection_map[filter_cls].keys())\\n\\n    def get_node_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Node)\\n\\n    def get_way_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Way)\\n\\n    def get_relation_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Relation)\\n\\n    def get_area_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Area)\\n\\n    @classmethod\\n    def from_json(cls, data: dict, api: Optional[Overpass] = None) -> \"Result\":\\n        \"\"\"\\n        Create a new instance and load data from json object.\\n\\n        :param data: JSON data returned by the Overpass API\\n        :param api:\\n        :return: New instance of Result object\\n        \"\"\"\\n        result = cls(api=api)\\n        elem_cls: Type[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]\\n        for elem_cls in [Node, Way, Relation, Area]:\\n            for element in data.get(\"elements\", []):\\n                e_type = element.get(\"type\")\\n                if hasattr(e_type, \"lower\") and e_type.lower() == elem_cls._type_value:\\n                    result.append(elem_cls.from_json(element, result=result))\\n\\n        return result\\n\\n    @classmethod\\n    def from_xml(\\n            cls,\\n            data: Union[str, xml.etree.ElementTree.Element],\\n            api: Optional[Overpass] = None,\\n            parser: Optional[int] = None) -> \"Result\":\\n        \"\"\"\\n        Create a new instance and load data from xml data or object.\\n\\n        .. note::\\n            If parser is set to None, the functions tries to find the best parse.\\n            By default the SAX parser is chosen if a string is provided as data.\\n            The parser is set to DOM if an xml.etree.ElementTree.Element is provided as data value.\\n\\n        :param data: Root element\\n        :param api: The instance to query additional information if required.\\n        :param parser: Specify the parser to use(DOM or SAX)(Default: None = autodetect, defaults to SAX)\\n        :return: New instance of Result object\\n        \"\"\"\\n        if parser is None:\\n            if isinstance(data, str):\\n                parser = XML_PARSER_SAX\\n            else:\\n                parser = XML_PARSER_DOM\\n\\n        result = cls(api=api)\\n        if parser == XML_PARSER_DOM:\\n            import xml.etree.ElementTree as ET\\n            if isinstance(data, str):\\n                root = ET.fromstring(data)\\n            elif isinstance(data, ET.Element):\\n                root = data\\n            else:\\n                raise exception.OverPyException(\"Unable to detect data type.\")\\n\\n            elem_cls: Type[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]\\n            for elem_cls in [Node, Way, Relation, Area]:\\n                for child in root:\\n                    if child.tag.lower() == elem_cls._type_value:\\n                        result.append(elem_cls.from_xml(child, result=result))\\n\\n        elif parser == XML_PARSER_SAX:\\n            from io import StringIO\\n            if not isinstance(data, str):\\n                raise ValueError(\"data must be of type str if using the SAX parser\")\\n            source = StringIO(data)\\n            sax_handler = OSMSAXHandler(result)\\n            sax_parser = make_parser()\\n            sax_parser.setContentHandler(sax_handler)\\n            sax_parser.parse(source)\\n        else:\\n            # ToDo: better exception\\n            raise Exception(\"Unknown XML parser\")\\n        return result\\n\\n    def get_area(self, area_id: int, resolve_missing: bool = False) -> \"Area\":\\n        \"\"\"\\n        Get an area by its ID.\\n\\n        :param area_id: The area ID\\n        :param resolve_missing: Query the Overpass API if the area is missing in the result set.\\n        :return: The area\\n        :raises overpy.exception.DataIncomplete: The requested way is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and the area can\\'t be resolved.\\n        \"\"\"\\n        areas = self.get_areas(area_id=area_id)\\n        if len(areas) == 0:\\n            if resolve_missing is False:\\n                raise exception.DataIncomplete(\"Resolve missing area is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"area({area_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                area_id=area_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            areas = self.get_areas(area_id=area_id)\\n\\n        if len(areas) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve requested areas\")\\n\\n        return areas[0]\\n\\n    def get_areas(self, area_id: Optional[int] = None) -> List[\"Area\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Area\\n\\n        :param area_id: The Id of the area\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Area, elem_id=area_id)\\n\\n    def get_node(self, node_id: int, resolve_missing: bool = False) -> \"Node\":\\n        \"\"\"\\n        Get a node by its ID.\\n\\n        :param node_id: The node ID\\n        :param resolve_missing: Query the Overpass API if the node is missing in the result set.\\n        :return: The node\\n        :raises overpy.exception.DataIncomplete: At least one referenced node is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and at least one node can\\'t be resolved.\\n        \"\"\"\\n        nodes = self.get_nodes(node_id=node_id)\\n        if len(nodes) == 0:\\n            if not resolve_missing:\\n                raise exception.DataIncomplete(\"Resolve missing nodes is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"node({node_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                node_id=node_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            nodes = self.get_nodes(node_id=node_id)\\n\\n        if len(nodes) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve all nodes\")\\n\\n        return nodes[0]\\n\\n    def get_nodes(self, node_id: Optional[int] = None) -> List[\"Node\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Node()\\n\\n        :param node_id: The Id of the node\\n        :type node_id: Integer\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Node, elem_id=node_id)\\n\\n    def get_relation(self, rel_id: int, resolve_missing: bool = False) -> \"Relation\":\\n        \"\"\"\\n        Get a relation by its ID.\\n\\n        :param rel_id: The relation ID\\n        :param resolve_missing: Query the Overpass API if the relation is missing in the result set.\\n        :return: The relation\\n        :raises overpy.exception.DataIncomplete: The requested relation is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and the relation can\\'t be resolved.\\n        \"\"\"\\n        relations = self.get_relations(rel_id=rel_id)\\n        if len(relations) == 0:\\n            if resolve_missing is False:\\n                raise exception.DataIncomplete(\"Resolve missing relations is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"relation({relation_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                relation_id=rel_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            relations = self.get_relations(rel_id=rel_id)\\n\\n        if len(relations) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve requested reference\")\\n\\n        return relations[0]\\n\\n    def get_relations(self, rel_id: int = None) -> List[\"Relation\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Relation\\n\\n        :param rel_id: Id of the relation\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Relation, elem_id=rel_id)\\n\\n    def get_way(self, way_id: int, resolve_missing: bool = False) -> \"Way\":\\n        \"\"\"\\n        Get a way by its ID.\\n\\n        :param way_id: The way ID\\n        :param resolve_missing: Query the Overpass API if the way is missing in the result set.\\n        :return: The way\\n        :raises overpy.exception.DataIncomplete: The requested way is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and the way can\\'t be resolved.\\n        \"\"\"\\n        ways = self.get_ways(way_id=way_id)\\n        if len(ways) == 0:\\n            if resolve_missing is False:\\n                raise exception.DataIncomplete(\"Resolve missing way is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"way({way_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                way_id=way_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            ways = self.get_ways(way_id=way_id)\\n\\n        if len(ways) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve requested way\")\\n\\n        return ways[0]\\n\\n    def get_ways(self, way_id: Optional[int] = None) -> List[\"Way\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Way\\n\\n        :param way_id: The Id of the way\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Way, elem_id=way_id)\\n\\n    area_ids = property(get_area_ids)\\n    areas = property(get_areas)\\n    node_ids = property(get_node_ids)\\n    nodes = property(get_nodes)\\n    relation_ids = property(get_relation_ids)\\n    relations = property(get_relations)\\n    way_ids = property(get_way_ids)\\n    ways = property(get_ways)\\n\\n\\nclass Element:\\n    \"\"\"\\n    Base element\\n    \"\"\"\\n\\n    _type_value: str\\n\\n    def __init__(self, attributes: Optional[dict] = None, result: Optional[Result] = None, tags: Optional[Dict] = None):\\n        \"\"\"\\n        :param attributes: Additional attributes\\n        :param result: The result object this element belongs to\\n        :param tags: List of tags\\n        \"\"\"\\n\\n        self._result = result\\n        self.attributes = attributes\\n        # ToDo: Add option to modify attribute modifiers\\n        attribute_modifiers: Dict[str, Callable] = dict(GLOBAL_ATTRIBUTE_MODIFIERS.items())\\n        for n, m in attribute_modifiers.items():\\n            if n in self.attributes:\\n                self.attributes[n] = m(self.attributes[n])\\n        self.id: int\\n        self.tags = tags\\n\\n    @classmethod\\n    def get_center_from_json(cls, data: dict) -> Tuple[Decimal, Decimal]:\\n        \"\"\"\\n        Get center information from json data\\n\\n        :param data: json data\\n        :return: tuple with two elements: lat and lon\\n        \"\"\"\\n        center_lat = None\\n        center_lon = None\\n        center = data.get(\"center\")\\n        if isinstance(center, dict):\\n            center_lat = center.get(\"lat\")\\n            center_lon = center.get(\"lon\")\\n            if center_lat is None or center_lon is None:\\n                raise ValueError(\"Unable to get lat or lon of way center.\")\\n            center_lat = Decimal(center_lat)\\n            center_lon = Decimal(center_lon)\\n        return center_lat, center_lon\\n\\n    @classmethod\\n    def get_center_from_xml_dom(cls, sub_child: xml.etree.ElementTree.Element) -> Tuple[Decimal, Decimal]:\\n        center_lat_str: str = sub_child.attrib.get(\"lat\")\\n        center_lon_str: str = sub_child.attrib.get(\"lon\")\\n        if center_lat_str is None or center_lon_str is None:\\n            raise ValueError(\"Unable to get lat or lon of way center.\")\\n        center_lat = Decimal(center_lat_str)\\n        center_lon = Decimal(center_lon_str)\\n        return center_lat, center_lon\\n\\n    @classmethod\\n    def from_json(cls: Type[ElementTypeVar], data: dict, result: Optional[Result] = None) -> ElementTypeVar:\\n        \"\"\"\\n        Create new Element() from json data\\n        :param data:\\n        :param result:\\n        :return:\\n        \"\"\"\\n        raise NotImplementedError\\n\\n    @classmethod\\n    def from_xml(\\n            cls: Type[ElementTypeVar],\\n            child: xml.etree.ElementTree.Element,\\n            result: Optional[Result] = None) -> ElementTypeVar:\\n        \"\"\"\\n        Create new Element() element from XML data\\n        \"\"\"\\n        raise NotImplementedError\\n\\n\\nclass Area(Element):\\n    \"\"\"\\n    Class to represent an element of type area\\n    \"\"\"\\n\\n    _type_value = \"area\"\\n\\n    def __init__(self, area_id: Optional[int] = None, **kwargs):\\n        \"\"\"\\n        :param area_id: Id of the area element\\n        :param kwargs: Additional arguments are passed directly to the parent class\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        #: The id of the way\\n        self.id = area_id\\n\\n    def __repr__(self) -> str:\\n        return f\"<overpy.Area id={self.id}>\"\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Area\":\\n        \"\"\"\\n        Create new Area element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Way\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        area_id = data.get(\"id\")\\n\\n        attributes = {}\\n        ignore = [\"id\", \"tags\", \"type\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(area_id=area_id, attributes=attributes, tags=tags, result=result)\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Area\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If the ref attribute of the xml node is not provided\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n\\n        area_id_str: Optional[str] = child.attrib.get(\"id\")\\n        area_id: Optional[int] = None\\n        if area_id_str is not None:\\n            area_id = int(area_id_str)\\n\\n        attributes = {}\\n        ignore = [\"id\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(area_id=area_id, attributes=attributes, tags=tags, result=result)\\n\\n\\nclass Node(Element):\\n    \"\"\"\\n    Class to represent an element of type node\\n    \"\"\"\\n\\n    _type_value = \"node\"\\n\\n    def __init__(\\n            self,\\n            node_id: Optional[int] = None,\\n            lat: Optional[Union[Decimal, float]] = None,\\n            lon: Optional[Union[Decimal, float]] = None,\\n            **kwargs):\\n        \"\"\"\\n        :param lat: Latitude\\n        :param lon: Longitude\\n        :param node_id: Id of the node element\\n        :param kwargs: Additional arguments are passed directly to the parent class\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        self.id = node_id\\n        self.lat = lat\\n        self.lon = lon\\n\\n    def __repr__(self) -> str:\\n        return f\"<overpy.Node id={self.id} lat={self.lat} lon={self.lon}>\"\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Node\":\\n        \"\"\"\\n        Create new Node element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Node\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        node_id = data.get(\"id\")\\n        lat = data.get(\"lat\")\\n        lon = data.get(\"lon\")\\n\\n        attributes = {}\\n        ignore = [\"type\", \"id\", \"lat\", \"lon\", \"tags\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(node_id=node_id, lat=lat, lon=lon, tags=tags, attributes=attributes, result=result)\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Node\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n\\n        node_id: Optional[int] = None\\n        node_id_str: Optional[str] = child.attrib.get(\"id\")\\n        if node_id_str is not None:\\n            node_id = int(node_id_str)\\n\\n        lat: Optional[Decimal] = None\\n        lat_str: Optional[str] = child.attrib.get(\"lat\")\\n        if lat_str is not None:\\n            lat = Decimal(lat_str)\\n\\n        lon: Optional[Decimal] = None\\n        lon_str: Optional[str] = child.attrib.get(\"lon\")\\n        if lon_str is not None:\\n            lon = Decimal(lon_str)\\n\\n        attributes = {}\\n        ignore = [\"id\", \"lat\", \"lon\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(node_id=node_id, lat=lat, lon=lon, tags=tags, attributes=attributes, result=result)\\n\\n\\nclass Way(Element):\\n    \"\"\"\\n    Class to represent an element of type way\\n    \"\"\"\\n\\n    _type_value = \"way\"\\n\\n    def __init__(\\n            self,\\n            way_id: Optional[int] = None,\\n            center_lat: Optional[Union[Decimal, float]] = None,\\n            center_lon: Optional[Union[Decimal, float]] = None,\\n            node_ids: Optional[Union[List[int], Tuple[int]]] = None,\\n            **kwargs):\\n        \"\"\"\\n        :param node_ids: List of node IDs\\n        :param way_id: Id of the way element\\n        :param kwargs: Additional arguments are passed directly to the parent class\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        #: The id of the way\\n        self.id = way_id\\n\\n        #: List of Ids of the associated nodes\\n        self._node_ids = node_ids\\n\\n        #: The lat/lon of the center of the way (optional depending on query)\\n        self.center_lat = center_lat\\n        self.center_lon = center_lon\\n\\n    def __repr__(self):\\n        return f\"<overpy.Way id={self.id} nodes={self._node_ids}>\"\\n\\n    @property\\n    def nodes(self) -> List[Node]:\\n        \"\"\"\\n        List of nodes associated with the way.\\n        \"\"\"\\n        return self.get_nodes()\\n\\n    def get_nodes(self, resolve_missing: bool = False) -> List[Node]:\\n        \"\"\"\\n        Get the nodes defining the geometry of the way\\n\\n        :param resolve_missing: Try to resolve missing nodes.\\n        :return: List of nodes\\n        :raises overpy.exception.DataIncomplete: At least one referenced node is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and at least one node can\\'t be resolved.\\n        \"\"\"\\n        result = []\\n        resolved = False\\n\\n        for node_id in self._node_ids:\\n            try:\\n                node = self._result.get_node(node_id)\\n            except exception.DataIncomplete:\\n                node = None\\n\\n            if node is not None:\\n                result.append(node)\\n                continue\\n\\n            if not resolve_missing:\\n                raise exception.DataIncomplete(\"Resolve missing nodes is disabled\")\\n\\n            # We tried to resolve the data but some nodes are still missing\\n            if resolved:\\n                raise exception.DataIncomplete(\"Unable to resolve all nodes\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"way({way_id});\\\\n\"\\n                     \"node(w);\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                way_id=self.id\\n            )\\n            tmp_result = self._result.api.query(query)\\n            self._result.expand(tmp_result)\\n            resolved = True\\n\\n            try:\\n                node = self._result.get_node(node_id)\\n            except exception.DataIncomplete:\\n                node = None\\n\\n            if node is None:\\n                raise exception.DataIncomplete(\"Unable to resolve all nodes\")\\n\\n            result.append(node)\\n\\n        return result\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Way\":\\n        \"\"\"\\n        Create new Way element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Way\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        way_id = data.get(\"id\")\\n        node_ids = data.get(\"nodes\")\\n        (center_lat, center_lon) = cls.get_center_from_json(data=data)\\n\\n        attributes = {}\\n        ignore = [\"center\", \"id\", \"nodes\", \"tags\", \"type\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(\\n            attributes=attributes,\\n            center_lat=center_lat,\\n            center_lon=center_lon,\\n            node_ids=node_ids,\\n            tags=tags,\\n            result=result,\\n            way_id=way_id\\n        )\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Way\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If the ref attribute of the xml node is not provided\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n        node_ids = []\\n        center_lat = None\\n        center_lon = None\\n\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n            if sub_child.tag.lower() == \"nd\":\\n                ref_id_str = sub_child.attrib.get(\"ref\")\\n                if ref_id_str is None:\\n                    raise ValueError(\"Unable to find required ref value.\")\\n                ref_id: int = int(ref_id_str)\\n                node_ids.append(ref_id)\\n            if sub_child.tag.lower() == \"center\":\\n                (center_lat, center_lon) = cls.get_center_from_xml_dom(sub_child=sub_child)\\n\\n        way_id: Optional[int] = None\\n        way_id_str: Optional[str] = child.attrib.get(\"id\")\\n        if way_id_str is not None:\\n            way_id = int(way_id_str)\\n\\n        attributes = {}\\n        ignore = [\"id\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(way_id=way_id, center_lat=center_lat, center_lon=center_lon,\\n                   attributes=attributes, node_ids=node_ids, tags=tags, result=result)\\n\\n\\nclass Relation(Element):\\n    \"\"\"\\n    Class to represent an element of type relation\\n    \"\"\"\\n\\n    _type_value = \"relation\"\\n\\n    def __init__(\\n            self,\\n            rel_id: Optional[int] = None,\\n            center_lat: Optional[Union[Decimal, float]] = None,\\n            center_lon: Optional[Union[Decimal, float]] = None,\\n            members: Optional[List[\"RelationMember\"]] = None,\\n            **kwargs):\\n        \"\"\"\\n        :param members:\\n        :param rel_id: Id of the relation element\\n        :param kwargs:\\n        :return:\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        self.id = rel_id\\n        self.members = members\\n\\n        #: The lat/lon of the center of the way (optional depending on query)\\n        self.center_lat = center_lat\\n        self.center_lon = center_lon\\n\\n    def __repr__(self):\\n        return f\"<overpy.Relation id={self.id}>\"\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Relation\":\\n        \"\"\"\\n        Create new Relation element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Relation\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        rel_id = data.get(\"id\")\\n        (center_lat, center_lon) = cls.get_center_from_json(data=data)\\n\\n        members = []\\n\\n        supported_members = [RelationNode, RelationWay, RelationRelation]\\n        for member in data.get(\"members\", []):\\n            type_value = member.get(\"type\")\\n            for member_cls in supported_members:\\n                if member_cls._type_value == type_value:\\n                    members.append(\\n                        member_cls.from_json(\\n                            member,\\n                            result=result\\n                        )\\n                    )\\n\\n        attributes = {}\\n        ignore = [\"id\", \"members\", \"tags\", \"type\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(\\n            rel_id=rel_id,\\n            attributes=attributes,\\n            center_lat=center_lat,\\n            center_lon=center_lon,\\n            members=members,\\n            tags=tags,\\n            result=result\\n        )\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Relation\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n        members = []\\n        center_lat = None\\n        center_lon = None\\n\\n        supported_members = [RelationNode, RelationWay, RelationRelation, RelationArea]\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n            if sub_child.tag.lower() == \"member\":\\n                type_value = sub_child.attrib.get(\"type\")\\n                for member_cls in supported_members:\\n                    if member_cls._type_value == type_value:\\n                        members.append(\\n                            member_cls.from_xml(\\n                                sub_child,\\n                                result=result\\n                            )\\n                        )\\n            if sub_child.tag.lower() == \"center\":\\n                (center_lat, center_lon) = cls.get_center_from_xml_dom(sub_child=sub_child)\\n\\n        rel_id: Optional[int] = None\\n        rel_id_str: Optional[str] = child.attrib.get(\"id\")\\n        if rel_id_str is not None:\\n            rel_id = int(rel_id_str)\\n\\n        attributes = {}\\n        ignore = [\"id\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(\\n            rel_id=rel_id,\\n            attributes=attributes,\\n            center_lat=center_lat,\\n            center_lon=center_lon,\\n            members=members,\\n            tags=tags,\\n            result=result\\n        )\\n\\n\\nclass RelationMember:\\n    \"\"\"\\n    Base class to represent a member of a relation.\\n    \"\"\"\\n    _type_value: Optional[str] = None\\n\\n    def __init__(\\n            self,\\n            attributes: Optional[dict] = None,\\n            geometry: Optional[List[\"RelationWayGeometryValue\"]] = None,\\n            ref: Optional[int] = None,\\n            role: Optional[str] = None,\\n            result: Optional[Result] = None):\\n        \"\"\"\\n        :param ref: Reference Id\\n        :type ref: Integer\\n        :param role: The role of the relation member\\n        :type role: String\\n        :param result:\\n        \"\"\"\\n        self.ref = ref\\n        self._result = result\\n        self.role = role\\n        self.attributes = attributes\\n        self.geometry = geometry\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"RelationMember\":\\n        \"\"\"\\n        Create new RelationMember element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of RelationMember\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        ref = data.get(\"ref\")\\n        role = data.get(\"role\")\\n\\n        attributes = {}\\n        ignore = [\"geometry\", \"type\", \"ref\", \"role\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        geometry = data.get(\"geometry\")\\n        if isinstance(geometry, list):\\n            geometry_orig = geometry\\n            geometry = []\\n            for v in geometry_orig:\\n                geometry.append(\\n                    RelationWayGeometryValue(\\n                        lat=v.get(\"lat\"),\\n                        lon=v.get(\"lon\")\\n                    )\\n                )\\n        else:\\n            geometry = None\\n\\n        return cls(\\n            attributes=attributes,\\n            geometry=geometry,\\n            ref=ref,\\n            role=role,\\n            result=result\\n        )\\n\\n    @classmethod\\n    def from_xml(\\n            cls,\\n            child: xml.etree.ElementTree.Element,\\n            result: Optional[Result] = None) -> \"RelationMember\":\\n        \"\"\"\\n        Create new RelationMember from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this element belongs to\\n        :return: New relation member oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        \"\"\"\\n        if child.attrib.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        ref: Optional[int] = None\\n        ref_str: Optional[str] = child.attrib.get(\"ref\")\\n        if ref_str is not None:\\n            ref = int(ref_str)\\n\\n        role: Optional[str] = child.attrib.get(\"role\")\\n\\n        attributes = {}\\n        ignore = [\"geometry\", \"ref\", \"role\", \"type\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        geometry = None\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"nd\":\\n                if geometry is None:\\n                    geometry = []\\n                geometry.append(\\n                    RelationWayGeometryValue(\\n                        lat=Decimal(sub_child.attrib[\"lat\"]),\\n                        lon=Decimal(sub_child.attrib[\"lon\"])\\n                    )\\n                )\\n\\n        return cls(\\n            attributes=attributes,\\n            geometry=geometry,\\n            ref=ref,\\n            role=role,\\n            result=result\\n        )\\n\\n\\nclass RelationNode(RelationMember):\\n    _type_value = \"node\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Node:\\n        return self._result.get_node(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationNode ref={self.ref} role={self.role}>\"\\n\\n\\nclass RelationWay(RelationMember):\\n    _type_value = \"way\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Way:\\n        return self._result.get_way(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationWay ref={self.ref} role={self.role}>\"\\n\\n\\nclass RelationWayGeometryValue:\\n    def __init__(self, lat: Union[Decimal, float], lon: Union[Decimal, float]):\\n        self.lat = lat\\n        self.lon = lon\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationWayGeometryValue lat={self.lat} lon={self.lon}>\"\\n\\n\\nclass RelationRelation(RelationMember):\\n    _type_value = \"relation\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Relation:\\n        return self._result.get_relation(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationRelation ref={self.ref} role={self.role}>\"\\n\\n\\nclass RelationArea(RelationMember):\\n    _type_value = \"area\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Area:\\n        return self._result.get_area(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationArea ref={self.ref} role={self.role}>\"\\n\\n\\nclass OSMSAXHandler(handler.ContentHandler):\\n    \"\"\"\\n    SAX parser for Overpass XML response.\\n    \"\"\"\\n    #: Tuple of opening elements to ignore\\n    ignore_start: ClassVar = (\\'osm\\', \\'meta\\', \\'note\\', \\'bounds\\', \\'remark\\')\\n    #: Tuple of closing elements to ignore\\n    ignore_end: ClassVar = (\\'osm\\', \\'meta\\', \\'note\\', \\'bounds\\', \\'remark\\', \\'tag\\', \\'nd\\', \\'center\\')\\n\\n    def __init__(self, result: Result):\\n        \"\"\"\\n        :param result: Append results to this result set.\\n        \"\"\"\\n        handler.ContentHandler.__init__(self)\\n        self._result = result\\n        self._curr: Dict[str, Any] = {}\\n        #: Current relation member object\\n        self.cur_relation_member: Optional[RelationMember] = None\\n\\n    def startElement(self, name: str, attrs: dict):\\n        \"\"\"\\n        Handle opening elements.\\n\\n        :param name: Name of the element\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        if name in self.ignore_start:\\n            return\\n        try:\\n            handler = getattr(self, \\'_handle_start_%s\\' % name)\\n        except AttributeError:\\n            raise KeyError(\"Unknown element start \\'%s\\'\" % name)\\n        handler(attrs)\\n\\n    def endElement(self, name: str):\\n        \"\"\"\\n        Handle closing elements\\n\\n        :param name: Name of the element\\n        \"\"\"\\n        if name in self.ignore_end:\\n            return\\n        try:\\n            handler = getattr(self, \\'_handle_end_%s\\' % name)\\n        except AttributeError:\\n            raise KeyError(\"Unknown element end \\'%s\\'\" % name)\\n        handler()\\n\\n    def _handle_start_center(self, attrs: dict):\\n        \"\"\"\\n        Handle opening center element\\n\\n        :param attrs: Attributes of the element\\n        :type attrs: Dict\\n        \"\"\"\\n        center_lat = attrs.get(\"lat\")\\n        center_lon = attrs.get(\"lon\")\\n        if center_lat is None or center_lon is None:\\n            raise ValueError(\"Unable to get lat or lon of way center.\")\\n        self._curr[\"center_lat\"] = Decimal(center_lat)\\n        self._curr[\"center_lon\"] = Decimal(center_lon)\\n\\n    def _handle_start_tag(self, attrs: dict):\\n        \"\"\"\\n        Handle opening tag element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        try:\\n            tag_key = attrs[\\'k\\']\\n        except KeyError:\\n            raise ValueError(\"Tag without name/key.\")\\n        self._curr[\\'tags\\'][tag_key] = attrs.get(\\'v\\')\\n\\n    def _handle_start_node(self, attrs: dict):\\n        \"\"\"\\n        Handle opening node element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'attributes\\': dict(attrs),\\n            \\'lat\\': None,\\n            \\'lon\\': None,\\n            \\'node_id\\': None,\\n            \\'tags\\': {}\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'node_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n        if attrs.get(\\'lat\\', None) is not None:\\n            self._curr[\\'lat\\'] = Decimal(attrs[\\'lat\\'])\\n            del self._curr[\\'attributes\\'][\\'lat\\']\\n        if attrs.get(\\'lon\\', None) is not None:\\n            self._curr[\\'lon\\'] = Decimal(attrs[\\'lon\\'])\\n            del self._curr[\\'attributes\\'][\\'lon\\']\\n\\n    def _handle_end_node(self):\\n        \"\"\"\\n        Handle closing node element\\n        \"\"\"\\n        self._result.append(Node(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_way(self, attrs: dict):\\n        \"\"\"\\n        Handle opening way element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'center_lat\\': None,\\n            \\'center_lon\\': None,\\n            \\'attributes\\': dict(attrs),\\n            \\'node_ids\\': [],\\n            \\'tags\\': {},\\n            \\'way_id\\': None\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'way_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n\\n    def _handle_end_way(self):\\n        \"\"\"\\n        Handle closing way element\\n        \"\"\"\\n        self._result.append(Way(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_area(self, attrs: dict):\\n        \"\"\"\\n        Handle opening area element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'attributes\\': dict(attrs),\\n            \\'tags\\': {},\\n            \\'area_id\\': None\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'area_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n\\n    def _handle_end_area(self):\\n        \"\"\"\\n        Handle closing area element\\n        \"\"\"\\n        self._result.append(Area(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_nd(self, attrs: dict):\\n        \"\"\"\\n        Handle opening nd element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        if isinstance(self.cur_relation_member, RelationWay):\\n            if self.cur_relation_member.geometry is None:\\n                self.cur_relation_member.geometry = []\\n            self.cur_relation_member.geometry.append(\\n                RelationWayGeometryValue(\\n                    lat=Decimal(attrs[\"lat\"]),\\n                    lon=Decimal(attrs[\"lon\"])\\n                )\\n            )\\n        else:\\n            try:\\n                node_ref = attrs[\\'ref\\']\\n            except KeyError:\\n                raise ValueError(\"Unable to find required ref value.\")\\n            self._curr[\\'node_ids\\'].append(int(node_ref))\\n\\n    def _handle_start_relation(self, attrs: dict):\\n        \"\"\"\\n        Handle opening relation element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'attributes\\': dict(attrs),\\n            \\'members\\': [],\\n            \\'rel_id\\': None,\\n            \\'tags\\': {}\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'rel_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n\\n    def _handle_end_relation(self):\\n        \"\"\"\\n        Handle closing relation element\\n        \"\"\"\\n        self._result.append(Relation(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_member(self, attrs: dict):\\n        \"\"\"\\n        Handle opening member element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n\\n        params: Dict[str, Any] = {\\n            # ToDo: Parse attributes\\n            \\'attributes\\': {},\\n            \\'ref\\': None,\\n            \\'result\\': self._result,\\n            \\'role\\': None\\n        }\\n        if attrs.get(\\'ref\\', None):\\n            params[\\'ref\\'] = int(attrs[\\'ref\\'])\\n        if attrs.get(\\'role\\', None):\\n            params[\\'role\\'] = attrs[\\'role\\']\\n\\n        cls_map = {\\n            \"area\": RelationArea,\\n            \"node\": RelationNode,\\n            \"relation\": RelationRelation,\\n            \"way\": RelationWay\\n        }\\n        cls: Type[RelationMember] = cls_map.get(attrs[\"type\"])\\n        if cls is None:\\n            raise ValueError(\"Undefined type for member: \\'%s\\'\" % attrs[\\'type\\'])\\n\\n        self.cur_relation_member = cls(**params)\\n        self._curr[\\'members\\'].append(self.cur_relation_member)\\n\\n    def _handle_end_member(self):\\n        self.cur_relation_member = None\\n'"}, "return_value": "'from collections import OrderedDict\\nfrom datetime import datetime\\nfrom decimal import Decimal\\nfrom urllib.request import urlopen\\nfrom urllib.error import HTTPError\\nfrom xml.sax import handler, make_parser\\nimport xml.etree.ElementTree\\nimport json\\nimport re\\nimport time\\nfrom typing import Any, Callable, ClassVar, Dict, List, NoReturn, Optional, Tuple, Type, TypeVar, Union\\n\\nfrom overpy import exception\\n# Ignore flake8 F401 warning for unused vars\\nfrom overpy.__about__ import (  # noqa: F401\\n    __author__, __copyright__, __email__, __license__, __summary__, __title__,\\n    __uri__, __version__\\n)\\n\\nElementTypeVar = TypeVar(\"ElementTypeVar\", bound=\"Element\")\\n\\nXML_PARSER_DOM = 1\\nXML_PARSER_SAX = 2\\n\\n# Try to convert some common attributes\\n# http://wiki.openstreetmap.org/wiki/Elements#Common_attributes\\nGLOBAL_ATTRIBUTE_MODIFIERS: Dict[str, Callable] = {\\n    \"changeset\": int,\\n    \"timestamp\": lambda ts: datetime.strptime(ts, \"%Y-%m-%dT%H:%M:%SZ\"),\\n    \"uid\": int,\\n    \"version\": int,\\n    \"visible\": lambda v: v.lower() == \"true\"\\n}\\n\\n\\ndef is_valid_type(\\n        element: Union[\"Area\", \"Node\", \"Relation\", \"Way\"],\\n        cls: Type[Union[\"Area\", \"Element\", \"Node\", \"Relation\", \"Way\"]]) -> bool:\\n    \"\"\"\\n    Test if an element is of a given type.\\n\\n    :param element: The element instance to test\\n    :param cls: The element class to test\\n    :return: False or True\\n    \"\"\"\\n    return isinstance(element, cls) and element.id is not None\\n\\n\\nclass Overpass:\\n    \"\"\"\\n    Class to access the Overpass API\\n\\n    :cvar default_max_retry_count: Global max number of retries (Default: 0)\\n    :cvar default_read_chunk_size: Max size of each chunk read from the server response\\n    :cvar default_retry_timeout: Global time to wait between tries (Default: 1.0s)\\n    :cvar default_url: Default URL of the Overpass server\\n    \"\"\"\\n    default_max_retry_count: ClassVar[int] = 0\\n    default_read_chunk_size: ClassVar[int] = 4096\\n    default_retry_timeout: ClassVar[float] = 1.0\\n    default_url: ClassVar[str] = \"http://overpass-api.de/api/interpreter\"\\n\\n    def __init__(\\n            self,\\n            read_chunk_size: Optional[int] = None,\\n            url: Optional[str] = None,\\n            xml_parser: int = XML_PARSER_SAX,\\n            max_retry_count: int = None,\\n            retry_timeout: float = None):\\n        \"\"\"\\n        :param read_chunk_size: Max size of each chunk read from the server response\\n        :param url: Optional URL of the Overpass server. Defaults to http://overpass-api.de/api/interpreter\\n        :param xml_parser: The xml parser to use\\n        :param max_retry_count: Max number of retries (Default: default_max_retry_count)\\n        :param retry_timeout: Time to wait between tries (Default: default_retry_timeout)\\n        \"\"\"\\n        self.url = self.default_url\\n        if url is not None:\\n            self.url = url\\n\\n        self._regex_extract_error_msg = re.compile(br\"\\\\<p\\\\>(?P<msg>\\\\<strong\\\\s.*?)\\\\</p\\\\>\")\\n        self._regex_remove_tag = re.compile(b\"<[^>]*?>\")\\n        if read_chunk_size is None:\\n            read_chunk_size = self.default_read_chunk_size\\n        self.read_chunk_size = read_chunk_size\\n\\n        if max_retry_count is None:\\n            max_retry_count = self.default_max_retry_count\\n        self.max_retry_count = max_retry_count\\n\\n        if retry_timeout is None:\\n            retry_timeout = self.default_retry_timeout\\n        self.retry_timeout = retry_timeout\\n\\n        self.xml_parser = xml_parser\\n\\n    @staticmethod\\n    def _handle_remark_msg(msg: str) -> NoReturn:\\n        \"\"\"\\n        Try to parse the message provided with the remark tag or element.\\n\\n        :param msg: The message\\n        :raises overpy.exception.OverpassRuntimeError: If message starts with \\'runtime error:\\'\\n        :raises overpy.exception.OverpassRuntimeRemark: If message starts with \\'runtime remark:\\'\\n        :raises overpy.exception.OverpassUnknownError: If we are unable to identify the error\\n        \"\"\"\\n        msg = msg.strip()\\n        if msg.startswith(\"runtime error:\"):\\n            raise exception.OverpassRuntimeError(msg=msg)\\n        elif msg.startswith(\"runtime remark:\"):\\n            raise exception.OverpassRuntimeRemark(msg=msg)\\n        raise exception.OverpassUnknownError(msg=msg)\\n\\n    def query(self, query: Union[bytes, str]) -> \"Result\":\\n        \"\"\"\\n        Query the Overpass API\\n\\n        :param query: The query string in Overpass QL\\n        :return: The parsed result\\n        \"\"\"\\n        if not isinstance(query, bytes):\\n            query = query.encode(\"utf-8\")\\n\\n        retry_num: int = 0\\n        retry_exceptions: List[exception.OverPyException] = []\\n        do_retry: bool = True if self.max_retry_count > 0 else False\\n        while retry_num <= self.max_retry_count:\\n            if retry_num > 0:\\n                time.sleep(self.retry_timeout)\\n            retry_num += 1\\n            try:\\n                f = urlopen(self.url, query)\\n            except HTTPError as e:\\n                f = e\\n\\n            response = f.read(self.read_chunk_size)\\n            while True:\\n                data = f.read(self.read_chunk_size)\\n                if len(data) == 0:\\n                    break\\n                response = response + data\\n            f.close()\\n\\n            current_exception: exception.OverPyException\\n            if f.code == 200:\\n                content_type = f.getheader(\"Content-Type\")\\n\\n                if content_type == \"application/json\":\\n                    return self.parse_json(response)\\n\\n                if content_type == \"application/osm3s+xml\":\\n                    return self.parse_xml(response)\\n\\n                current_exception = exception.OverpassUnknownContentType(content_type)\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            if f.code == 400:\\n                msgs: List[str] = []\\n                for msg_raw in self._regex_extract_error_msg.finditer(response):\\n                    msg_clean_bytes = self._regex_remove_tag.sub(b\"\", msg_raw.group(\"msg\"))\\n                    try:\\n                        msg = msg_clean_bytes.decode(\"utf-8\")\\n                    except UnicodeDecodeError:\\n                        msg = repr(msg_clean_bytes)\\n                    msgs.append(msg)\\n\\n                current_exception = exception.OverpassBadRequest(\\n                    query,\\n                    msgs=msgs\\n                )\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            if f.code == 429:\\n                current_exception = exception.OverpassTooManyRequests()\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            if f.code == 504:\\n                current_exception = exception.OverpassGatewayTimeout()\\n                if not do_retry:\\n                    raise current_exception\\n                retry_exceptions.append(current_exception)\\n                continue\\n\\n            current_exception = exception.OverpassUnknownHTTPStatusCode(f.code)\\n            if not do_retry:\\n                raise current_exception\\n            retry_exceptions.append(current_exception)\\n            continue\\n\\n        raise exception.MaxRetriesReached(retry_count=retry_num, exceptions=retry_exceptions)\\n\\n    def parse_json(self, data: Union[bytes, str], encoding: str = \"utf-8\") -> \"Result\":\\n        \"\"\"\\n        Parse raw response from Overpass service.\\n\\n        :param data: Raw JSON Data\\n        :param encoding: Encoding to decode byte string\\n        :return: Result object\\n        \"\"\"\\n        if isinstance(data, bytes):\\n            data = data.decode(encoding)\\n        data_parsed: dict = json.loads(data, parse_float=Decimal)\\n        if \"remark\" in data_parsed:\\n            self._handle_remark_msg(msg=data_parsed.get(\"remark\"))\\n        return Result.from_json(data_parsed, api=self)\\n\\n    def parse_xml(self, data: Union[bytes, str], encoding: str = \"utf-8\", parser: Optional[int] = None):\\n        \"\"\"\\n\\n        :param data: Raw XML Data\\n        :param encoding: Encoding to decode byte string\\n        :param parser: The XML parser to use\\n        :return: Result object\\n        \"\"\"\\n        if parser is None:\\n            parser = self.xml_parser\\n\\n        if isinstance(data, bytes):\\n            data = data.decode(encoding)\\n\\n        m = re.compile(\"<remark>(?P<msg>[^<>]*)</remark>\").search(data)\\n        if m:\\n            self._handle_remark_msg(m.group(\"msg\"))\\n\\n        return Result.from_xml(data, api=self, parser=parser)\\n\\n\\nclass Result:\\n    \"\"\"\\n    Class to handle the result.\\n    \"\"\"\\n\\n    def __init__(\\n            self,\\n            elements: Optional[List[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]] = None,\\n            api: Optional[Overpass] = None):\\n        \"\"\"\\n\\n        :param elements: List of elements to initialize the result with\\n        :param api: The API object to load additional resources and elements\\n        \"\"\"\\n        if elements is None:\\n            elements = []\\n        self._areas: Dict[int, Union[\"Area\", \"Node\", \"Relation\", \"Way\"]] = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Area)\\n        )\\n        self._nodes = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Node)\\n        )\\n        self._ways = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Way)\\n        )\\n        self._relations = OrderedDict(\\n            (element.id, element) for element in elements if is_valid_type(element, Relation)\\n        )\\n        self._class_collection_map: Dict[Any, Any] = {\\n            Node: self._nodes,\\n            Way: self._ways,\\n            Relation: self._relations,\\n            Area: self._areas\\n        }\\n        self.api = api\\n\\n    def expand(self, other: \"Result\"):\\n        \"\"\"\\n        Add all elements from an other result to the list of elements of this result object.\\n\\n        It is used by the auto resolve feature.\\n\\n        :param other: Expand the result with the elements from this result.\\n        :raises ValueError: If provided parameter is not instance of :class:`overpy.Result`\\n        \"\"\"\\n        if not isinstance(other, Result):\\n            raise ValueError(\"Provided argument has to be instance of overpy:Result()\")\\n\\n        other_collection_map: Dict[Type[\"Element\"], List[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]] = {\\n            Area: other.areas,\\n            Node: other.nodes,\\n            Relation: other.relations,\\n            Way: other.ways\\n        }\\n        for element_type, own_collection in self._class_collection_map.items():\\n            for element in other_collection_map[element_type]:\\n                if is_valid_type(element, element_type) and element.id not in own_collection:\\n                    own_collection[element.id] = element\\n\\n    def append(self, element: Union[\"Area\", \"Node\", \"Relation\", \"Way\"]):\\n        \"\"\"\\n        Append a new element to the result.\\n\\n        :param element: The element to append\\n        \"\"\"\\n        if is_valid_type(element, Element):\\n            self._class_collection_map[element.__class__].setdefault(element.id, element)\\n\\n    def get_elements(\\n            self,\\n            filter_cls: Type[ElementTypeVar],\\n            elem_id: Optional[int] = None) -> List[ElementTypeVar]:\\n        \"\"\"\\n        Get a list of elements from the result and filter the element type by a class.\\n\\n        :param filter_cls:\\n        :param elem_id: ID of the object\\n        :return: List of available elements\\n        \"\"\"\\n        result: List[ElementTypeVar] = []\\n        if elem_id is not None:\\n            try:\\n                result = [self._class_collection_map[filter_cls][elem_id]]\\n            except KeyError:\\n                result = []\\n        else:\\n            for e in self._class_collection_map[filter_cls].values():\\n                result.append(e)\\n        return result\\n\\n    def get_ids(\\n            self,\\n            filter_cls: Type[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]) -> List[int]:\\n        \"\"\"\\n        Get all Element IDs\\n\\n        :param filter_cls: Only IDs of elements with this type\\n        :return: List of IDs\\n        \"\"\"\\n        return list(self._class_collection_map[filter_cls].keys())\\n\\n    def get_node_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Node)\\n\\n    def get_way_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Way)\\n\\n    def get_relation_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Relation)\\n\\n    def get_area_ids(self) -> List[int]:\\n        return self.get_ids(filter_cls=Area)\\n\\n    @classmethod\\n    def from_json(cls, data: dict, api: Optional[Overpass] = None) -> \"Result\":\\n        \"\"\"\\n        Create a new instance and load data from json object.\\n\\n        :param data: JSON data returned by the Overpass API\\n        :param api:\\n        :return: New instance of Result object\\n        \"\"\"\\n        result = cls(api=api)\\n        elem_cls: Type[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]\\n        for elem_cls in [Node, Way, Relation, Area]:\\n            for element in data.get(\"elements\", []):\\n                e_type = element.get(\"type\")\\n                if hasattr(e_type, \"lower\") and e_type.lower() == elem_cls._type_value:\\n                    result.append(elem_cls.from_json(element, result=result))\\n\\n        return result\\n\\n    @classmethod\\n    def from_xml(\\n            cls,\\n            data: Union[str, xml.etree.ElementTree.Element],\\n            api: Optional[Overpass] = None,\\n            parser: Optional[int] = None) -> \"Result\":\\n        \"\"\"\\n        Create a new instance and load data from xml data or object.\\n\\n        .. note::\\n            If parser is set to None, the functions tries to find the best parse.\\n            By default the SAX parser is chosen if a string is provided as data.\\n            The parser is set to DOM if an xml.etree.ElementTree.Element is provided as data value.\\n\\n        :param data: Root element\\n        :param api: The instance to query additional information if required.\\n        :param parser: Specify the parser to use(DOM or SAX)(Default: None = autodetect, defaults to SAX)\\n        :return: New instance of Result object\\n        \"\"\"\\n        if parser is None:\\n            if isinstance(data, str):\\n                parser = XML_PARSER_SAX\\n            else:\\n                parser = XML_PARSER_DOM\\n\\n        result = cls(api=api)\\n        if parser == XML_PARSER_DOM:\\n            import xml.etree.ElementTree as ET\\n            if isinstance(data, str):\\n                root = ET.fromstring(data)\\n            elif isinstance(data, ET.Element):\\n                root = data\\n            else:\\n                raise exception.OverPyException(\"Unable to detect data type.\")\\n\\n            elem_cls: Type[Union[\"Area\", \"Node\", \"Relation\", \"Way\"]]\\n            for elem_cls in [Node, Way, Relation, Area]:\\n                for child in root:\\n                    if child.tag.lower() == elem_cls._type_value:\\n                        result.append(elem_cls.from_xml(child, result=result))\\n\\n        elif parser == XML_PARSER_SAX:\\n            from io import StringIO\\n            if not isinstance(data, str):\\n                raise ValueError(\"data must be of type str if using the SAX parser\")\\n            source = StringIO(data)\\n            sax_handler = OSMSAXHandler(result)\\n            sax_parser = make_parser()\\n            sax_parser.setContentHandler(sax_handler)\\n            sax_parser.parse(source)\\n        else:\\n            # ToDo: better exception\\n            raise Exception(\"Unknown XML parser\")\\n        return result\\n\\n    def get_area(self, area_id: int, resolve_missing: bool = False) -> \"Area\":\\n        \"\"\"\\n        Get an area by its ID.\\n\\n        :param area_id: The area ID\\n        :param resolve_missing: Query the Overpass API if the area is missing in the result set.\\n        :return: The area\\n        :raises overpy.exception.DataIncomplete: The requested way is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and the area can\\'t be resolved.\\n        \"\"\"\\n        areas = self.get_areas(area_id=area_id)\\n        if len(areas) == 0:\\n            if resolve_missing is False:\\n                raise exception.DataIncomplete(\"Resolve missing area is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"area({area_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                area_id=area_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            areas = self.get_areas(area_id=area_id)\\n\\n        if len(areas) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve requested areas\")\\n\\n        return areas[0]\\n\\n    def get_areas(self, area_id: Optional[int] = None) -> List[\"Area\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Area\\n\\n        :param area_id: The Id of the area\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Area, elem_id=area_id)\\n\\n    def get_node(self, node_id: int, resolve_missing: bool = False) -> \"Node\":\\n        \"\"\"\\n        Get a node by its ID.\\n\\n        :param node_id: The node ID\\n        :param resolve_missing: Query the Overpass API if the node is missing in the result set.\\n        :return: The node\\n        :raises overpy.exception.DataIncomplete: At least one referenced node is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and at least one node can\\'t be resolved.\\n        \"\"\"\\n        nodes = self.get_nodes(node_id=node_id)\\n        if len(nodes) == 0:\\n            if not resolve_missing:\\n                raise exception.DataIncomplete(\"Resolve missing nodes is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"node({node_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                node_id=node_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            nodes = self.get_nodes(node_id=node_id)\\n\\n        if len(nodes) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve all nodes\")\\n\\n        return nodes[0]\\n\\n    def get_nodes(self, node_id: Optional[int] = None) -> List[\"Node\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Node()\\n\\n        :param node_id: The Id of the node\\n        :type node_id: Integer\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Node, elem_id=node_id)\\n\\n    def get_relation(self, rel_id: int, resolve_missing: bool = False) -> \"Relation\":\\n        \"\"\"\\n        Get a relation by its ID.\\n\\n        :param rel_id: The relation ID\\n        :param resolve_missing: Query the Overpass API if the relation is missing in the result set.\\n        :return: The relation\\n        :raises overpy.exception.DataIncomplete: The requested relation is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and the relation can\\'t be resolved.\\n        \"\"\"\\n        relations = self.get_relations(rel_id=rel_id)\\n        if len(relations) == 0:\\n            if resolve_missing is False:\\n                raise exception.DataIncomplete(\"Resolve missing relations is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"relation({relation_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                relation_id=rel_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            relations = self.get_relations(rel_id=rel_id)\\n\\n        if len(relations) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve requested reference\")\\n\\n        return relations[0]\\n\\n    def get_relations(self, rel_id: int = None) -> List[\"Relation\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Relation\\n\\n        :param rel_id: Id of the relation\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Relation, elem_id=rel_id)\\n\\n    def get_way(self, way_id: int, resolve_missing: bool = False) -> \"Way\":\\n        \"\"\"\\n        Get a way by its ID.\\n\\n        :param way_id: The way ID\\n        :param resolve_missing: Query the Overpass API if the way is missing in the result set.\\n        :return: The way\\n        :raises overpy.exception.DataIncomplete: The requested way is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and the way can\\'t be resolved.\\n        \"\"\"\\n        ways = self.get_ways(way_id=way_id)\\n        if len(ways) == 0:\\n            if resolve_missing is False:\\n                raise exception.DataIncomplete(\"Resolve missing way is disabled\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"way({way_id});\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                way_id=way_id\\n            )\\n            tmp_result = self.api.query(query)\\n            self.expand(tmp_result)\\n\\n            ways = self.get_ways(way_id=way_id)\\n\\n        if len(ways) == 0:\\n            raise exception.DataIncomplete(\"Unable to resolve requested way\")\\n\\n        return ways[0]\\n\\n    def get_ways(self, way_id: Optional[int] = None) -> List[\"Way\"]:\\n        \"\"\"\\n        Alias for get_elements() but filter the result by Way\\n\\n        :param way_id: The Id of the way\\n        :return: List of elements\\n        \"\"\"\\n        return self.get_elements(Way, elem_id=way_id)\\n\\n    area_ids = property(get_area_ids)\\n    areas = property(get_areas)\\n    node_ids = property(get_node_ids)\\n    nodes = property(get_nodes)\\n    relation_ids = property(get_relation_ids)\\n    relations = property(get_relations)\\n    way_ids = property(get_way_ids)\\n    ways = property(get_ways)\\n\\n\\nclass Element:\\n    \"\"\"\\n    Base element\\n    \"\"\"\\n\\n    _type_value: str\\n\\n    def __init__(self, attributes: Optional[dict] = None, result: Optional[Result] = None, tags: Optional[Dict] = None):\\n        \"\"\"\\n        :param attributes: Additional attributes\\n        :param result: The result object this element belongs to\\n        :param tags: List of tags\\n        \"\"\"\\n\\n        self._result = result\\n        self.attributes = attributes\\n        # ToDo: Add option to modify attribute modifiers\\n        attribute_modifiers: Dict[str, Callable] = dict(GLOBAL_ATTRIBUTE_MODIFIERS.items())\\n        for n, m in attribute_modifiers.items():\\n            if n in self.attributes:\\n                self.attributes[n] = m(self.attributes[n])\\n        self.id: int\\n        self.tags = tags\\n\\n    @classmethod\\n    def get_center_from_json(cls, data: dict) -> Tuple[Decimal, Decimal]:\\n        \"\"\"\\n        Get center information from json data\\n\\n        :param data: json data\\n        :return: tuple with two elements: lat and lon\\n        \"\"\"\\n        center_lat = None\\n        center_lon = None\\n        center = data.get(\"center\")\\n        if isinstance(center, dict):\\n            center_lat = center.get(\"lat\")\\n            center_lon = center.get(\"lon\")\\n            if center_lat is None or center_lon is None:\\n                raise ValueError(\"Unable to get lat or lon of way center.\")\\n            center_lat = Decimal(center_lat)\\n            center_lon = Decimal(center_lon)\\n        return center_lat, center_lon\\n\\n    @classmethod\\n    def get_center_from_xml_dom(cls, sub_child: xml.etree.ElementTree.Element) -> Tuple[Decimal, Decimal]:\\n        center_lat_str: str = sub_child.attrib.get(\"lat\")\\n        center_lon_str: str = sub_child.attrib.get(\"lon\")\\n        if center_lat_str is None or center_lon_str is None:\\n            raise ValueError(\"Unable to get lat or lon of way center.\")\\n        center_lat = Decimal(center_lat_str)\\n        center_lon = Decimal(center_lon_str)\\n        return center_lat, center_lon\\n\\n    @classmethod\\n    def from_json(cls: Type[ElementTypeVar], data: dict, result: Optional[Result] = None) -> ElementTypeVar:\\n        \"\"\"\\n        Create new Element() from json data\\n        :param data:\\n        :param result:\\n        :return:\\n        \"\"\"\\n        raise NotImplementedError\\n\\n    @classmethod\\n    def from_xml(\\n            cls: Type[ElementTypeVar],\\n            child: xml.etree.ElementTree.Element,\\n            result: Optional[Result] = None) -> ElementTypeVar:\\n        \"\"\"\\n        Create new Element() element from XML data\\n        \"\"\"\\n        raise NotImplementedError\\n\\n\\nclass Area(Element):\\n    \"\"\"\\n    Class to represent an element of type area\\n    \"\"\"\\n\\n    _type_value = \"area\"\\n\\n    def __init__(self, area_id: Optional[int] = None, **kwargs):\\n        \"\"\"\\n        :param area_id: Id of the area element\\n        :param kwargs: Additional arguments are passed directly to the parent class\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        #: The id of the way\\n        self.id = area_id\\n\\n    def __repr__(self) -> str:\\n        return f\"<overpy.Area id={self.id}>\"\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Area\":\\n        \"\"\"\\n        Create new Area element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Way\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        area_id = data.get(\"id\")\\n\\n        attributes = {}\\n        ignore = [\"id\", \"tags\", \"type\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(area_id=area_id, attributes=attributes, tags=tags, result=result)\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Area\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If the ref attribute of the xml node is not provided\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n\\n        area_id_str: Optional[str] = child.attrib.get(\"id\")\\n        area_id: Optional[int] = None\\n        if area_id_str is not None:\\n            area_id = int(area_id_str)\\n\\n        attributes = {}\\n        ignore = [\"id\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(area_id=area_id, attributes=attributes, tags=tags, result=result)\\n\\n\\nclass Node(Element):\\n    \"\"\"\\n    Class to represent an element of type node\\n    \"\"\"\\n\\n    _type_value = \"node\"\\n\\n    def __init__(\\n            self,\\n            node_id: Optional[int] = None,\\n            lat: Optional[Union[Decimal, float]] = None,\\n            lon: Optional[Union[Decimal, float]] = None,\\n            **kwargs):\\n        \"\"\"\\n        :param lat: Latitude\\n        :param lon: Longitude\\n        :param node_id: Id of the node element\\n        :param kwargs: Additional arguments are passed directly to the parent class\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        self.id = node_id\\n        self.lat = lat\\n        self.lon = lon\\n\\n    def __repr__(self) -> str:\\n        return f\"<overpy.Node id={self.id} lat={self.lat} lon={self.lon}>\"\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Node\":\\n        \"\"\"\\n        Create new Node element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Node\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        node_id = data.get(\"id\")\\n        lat = data.get(\"lat\")\\n        lon = data.get(\"lon\")\\n\\n        attributes = {}\\n        ignore = [\"type\", \"id\", \"lat\", \"lon\", \"tags\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(node_id=node_id, lat=lat, lon=lon, tags=tags, attributes=attributes, result=result)\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Node\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n\\n        node_id: Optional[int] = None\\n        node_id_str: Optional[str] = child.attrib.get(\"id\")\\n        if node_id_str is not None:\\n            node_id = int(node_id_str)\\n\\n        lat: Optional[Decimal] = None\\n        lat_str: Optional[str] = child.attrib.get(\"lat\")\\n        if lat_str is not None:\\n            lat = Decimal(lat_str)\\n\\n        lon: Optional[Decimal] = None\\n        lon_str: Optional[str] = child.attrib.get(\"lon\")\\n        if lon_str is not None:\\n            lon = Decimal(lon_str)\\n\\n        attributes = {}\\n        ignore = [\"id\", \"lat\", \"lon\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(node_id=node_id, lat=lat, lon=lon, tags=tags, attributes=attributes, result=result)\\n\\n\\nclass Way(Element):\\n    \"\"\"\\n    Class to represent an element of type way\\n    \"\"\"\\n\\n    _type_value = \"way\"\\n\\n    def __init__(\\n            self,\\n            way_id: Optional[int] = None,\\n            center_lat: Optional[Union[Decimal, float]] = None,\\n            center_lon: Optional[Union[Decimal, float]] = None,\\n            node_ids: Optional[Union[List[int], Tuple[int]]] = None,\\n            **kwargs):\\n        \"\"\"\\n        :param node_ids: List of node IDs\\n        :param way_id: Id of the way element\\n        :param kwargs: Additional arguments are passed directly to the parent class\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        #: The id of the way\\n        self.id = way_id\\n\\n        #: List of Ids of the associated nodes\\n        self._node_ids = node_ids\\n\\n        #: The lat/lon of the center of the way (optional depending on query)\\n        self.center_lat = center_lat\\n        self.center_lon = center_lon\\n\\n    def __repr__(self):\\n        return f\"<overpy.Way id={self.id} nodes={self._node_ids}>\"\\n\\n    @property\\n    def nodes(self) -> List[Node]:\\n        \"\"\"\\n        List of nodes associated with the way.\\n        \"\"\"\\n        return self.get_nodes()\\n\\n    def get_nodes(self, resolve_missing: bool = False) -> List[Node]:\\n        \"\"\"\\n        Get the nodes defining the geometry of the way\\n\\n        :param resolve_missing: Try to resolve missing nodes.\\n        :return: List of nodes\\n        :raises overpy.exception.DataIncomplete: At least one referenced node is not available in the result cache.\\n        :raises overpy.exception.DataIncomplete: If resolve_missing is True and at least one node can\\'t be resolved.\\n        \"\"\"\\n        result = []\\n        resolved = False\\n\\n        for node_id in self._node_ids:\\n            try:\\n                node = self._result.get_node(node_id)\\n            except exception.DataIncomplete:\\n                node = None\\n\\n            if node is not None:\\n                result.append(node)\\n                continue\\n\\n            if not resolve_missing:\\n                raise exception.DataIncomplete(\"Resolve missing nodes is disabled\")\\n\\n            # We tried to resolve the data but some nodes are still missing\\n            if resolved:\\n                raise exception.DataIncomplete(\"Unable to resolve all nodes\")\\n\\n            query = (\"\\\\n\"\\n                     \"[out:json];\\\\n\"\\n                     \"way({way_id});\\\\n\"\\n                     \"node(w);\\\\n\"\\n                     \"out body;\\\\n\"\\n                     )\\n            query = query.format(\\n                way_id=self.id\\n            )\\n            tmp_result = self._result.api.query(query)\\n            self._result.expand(tmp_result)\\n            resolved = True\\n\\n            try:\\n                node = self._result.get_node(node_id)\\n            except exception.DataIncomplete:\\n                node = None\\n\\n            if node is None:\\n                raise exception.DataIncomplete(\"Unable to resolve all nodes\")\\n\\n            result.append(node)\\n\\n        return result\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Way\":\\n        \"\"\"\\n        Create new Way element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Way\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        way_id = data.get(\"id\")\\n        node_ids = data.get(\"nodes\")\\n        (center_lat, center_lon) = cls.get_center_from_json(data=data)\\n\\n        attributes = {}\\n        ignore = [\"center\", \"id\", \"nodes\", \"tags\", \"type\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(\\n            attributes=attributes,\\n            center_lat=center_lat,\\n            center_lon=center_lon,\\n            node_ids=node_ids,\\n            tags=tags,\\n            result=result,\\n            way_id=way_id\\n        )\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Way\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If the ref attribute of the xml node is not provided\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n        node_ids = []\\n        center_lat = None\\n        center_lon = None\\n\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n            if sub_child.tag.lower() == \"nd\":\\n                ref_id_str = sub_child.attrib.get(\"ref\")\\n                if ref_id_str is None:\\n                    raise ValueError(\"Unable to find required ref value.\")\\n                ref_id: int = int(ref_id_str)\\n                node_ids.append(ref_id)\\n            if sub_child.tag.lower() == \"center\":\\n                (center_lat, center_lon) = cls.get_center_from_xml_dom(sub_child=sub_child)\\n\\n        way_id: Optional[int] = None\\n        way_id_str: Optional[str] = child.attrib.get(\"id\")\\n        if way_id_str is not None:\\n            way_id = int(way_id_str)\\n\\n        attributes = {}\\n        ignore = [\"id\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(way_id=way_id, center_lat=center_lat, center_lon=center_lon,\\n                   attributes=attributes, node_ids=node_ids, tags=tags, result=result)\\n\\n\\nclass Relation(Element):\\n    \"\"\"\\n    Class to represent an element of type relation\\n    \"\"\"\\n\\n    _type_value = \"relation\"\\n\\n    def __init__(\\n            self,\\n            rel_id: Optional[int] = None,\\n            center_lat: Optional[Union[Decimal, float]] = None,\\n            center_lon: Optional[Union[Decimal, float]] = None,\\n            members: Optional[List[\"RelationMember\"]] = None,\\n            **kwargs):\\n        \"\"\"\\n        :param members:\\n        :param rel_id: Id of the relation element\\n        :param kwargs:\\n        :return:\\n        \"\"\"\\n\\n        Element.__init__(self, **kwargs)\\n        self.id = rel_id\\n        self.members = members\\n\\n        #: The lat/lon of the center of the way (optional depending on query)\\n        self.center_lat = center_lat\\n        self.center_lon = center_lon\\n\\n    def __repr__(self):\\n        return f\"<overpy.Relation id={self.id}>\"\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"Relation\":\\n        \"\"\"\\n        Create new Relation element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of Relation\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        tags = data.get(\"tags\", {})\\n\\n        rel_id = data.get(\"id\")\\n        (center_lat, center_lon) = cls.get_center_from_json(data=data)\\n\\n        members = []\\n\\n        supported_members = [RelationNode, RelationWay, RelationRelation]\\n        for member in data.get(\"members\", []):\\n            type_value = member.get(\"type\")\\n            for member_cls in supported_members:\\n                if member_cls._type_value == type_value:\\n                    members.append(\\n                        member_cls.from_json(\\n                            member,\\n                            result=result\\n                        )\\n                    )\\n\\n        attributes = {}\\n        ignore = [\"id\", \"members\", \"tags\", \"type\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(\\n            rel_id=rel_id,\\n            attributes=attributes,\\n            center_lat=center_lat,\\n            center_lon=center_lon,\\n            members=members,\\n            tags=tags,\\n            result=result\\n        )\\n\\n    @classmethod\\n    def from_xml(cls, child: xml.etree.ElementTree.Element, result: Optional[Result] = None) -> \"Relation\":\\n        \"\"\"\\n        Create new way element from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this node belongs to\\n        :return: New Way oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        :raises ValueError: If a tag doesn\\'t have a name\\n        \"\"\"\\n        if child.tag.lower() != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        tags = {}\\n        members = []\\n        center_lat = None\\n        center_lon = None\\n\\n        supported_members = [RelationNode, RelationWay, RelationRelation, RelationArea]\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"tag\":\\n                name = sub_child.attrib.get(\"k\")\\n                if name is None:\\n                    raise ValueError(\"Tag without name/key.\")\\n                value = sub_child.attrib.get(\"v\")\\n                tags[name] = value\\n            if sub_child.tag.lower() == \"member\":\\n                type_value = sub_child.attrib.get(\"type\")\\n                for member_cls in supported_members:\\n                    if member_cls._type_value == type_value:\\n                        members.append(\\n                            member_cls.from_xml(\\n                                sub_child,\\n                                result=result\\n                            )\\n                        )\\n            if sub_child.tag.lower() == \"center\":\\n                (center_lat, center_lon) = cls.get_center_from_xml_dom(sub_child=sub_child)\\n\\n        rel_id: Optional[int] = None\\n        rel_id_str: Optional[str] = child.attrib.get(\"id\")\\n        if rel_id_str is not None:\\n            rel_id = int(rel_id_str)\\n\\n        attributes = {}\\n        ignore = [\"id\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        return cls(\\n            rel_id=rel_id,\\n            attributes=attributes,\\n            center_lat=center_lat,\\n            center_lon=center_lon,\\n            members=members,\\n            tags=tags,\\n            result=result\\n        )\\n\\n\\nclass RelationMember:\\n    \"\"\"\\n    Base class to represent a member of a relation.\\n    \"\"\"\\n    _type_value: Optional[str] = None\\n\\n    def __init__(\\n            self,\\n            attributes: Optional[dict] = None,\\n            geometry: Optional[List[\"RelationWayGeometryValue\"]] = None,\\n            ref: Optional[int] = None,\\n            role: Optional[str] = None,\\n            result: Optional[Result] = None):\\n        \"\"\"\\n        :param ref: Reference Id\\n        :type ref: Integer\\n        :param role: The role of the relation member\\n        :type role: String\\n        :param result:\\n        \"\"\"\\n        self.ref = ref\\n        self._result = result\\n        self.role = role\\n        self.attributes = attributes\\n        self.geometry = geometry\\n\\n    @classmethod\\n    def from_json(cls, data: dict, result: Optional[Result] = None) -> \"RelationMember\":\\n        \"\"\"\\n        Create new RelationMember element from JSON data\\n\\n        :param data: Element data from JSON\\n        :param result: The result this element belongs to\\n        :return: New instance of RelationMember\\n        :raises overpy.exception.ElementDataWrongType: If type value of the passed JSON data does not match.\\n        \"\"\"\\n        if data.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=data.get(\"type\")\\n            )\\n\\n        ref = data.get(\"ref\")\\n        role = data.get(\"role\")\\n\\n        attributes = {}\\n        ignore = [\"geometry\", \"type\", \"ref\", \"role\"]\\n        for n, v in data.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        geometry = data.get(\"geometry\")\\n        if isinstance(geometry, list):\\n            geometry_orig = geometry\\n            geometry = []\\n            for v in geometry_orig:\\n                geometry.append(\\n                    RelationWayGeometryValue(\\n                        lat=v.get(\"lat\"),\\n                        lon=v.get(\"lon\")\\n                    )\\n                )\\n        else:\\n            geometry = None\\n\\n        return cls(\\n            attributes=attributes,\\n            geometry=geometry,\\n            ref=ref,\\n            role=role,\\n            result=result\\n        )\\n\\n    @classmethod\\n    def from_xml(\\n            cls,\\n            child: xml.etree.ElementTree.Element,\\n            result: Optional[Result] = None) -> \"RelationMember\":\\n        \"\"\"\\n        Create new RelationMember from XML data\\n\\n        :param child: XML node to be parsed\\n        :param result: The result this element belongs to\\n        :return: New relation member oject\\n        :raises overpy.exception.ElementDataWrongType: If name of the xml child node doesn\\'t match\\n        \"\"\"\\n        if child.attrib.get(\"type\") != cls._type_value:\\n            raise exception.ElementDataWrongType(\\n                type_expected=cls._type_value,\\n                type_provided=child.tag.lower()\\n            )\\n\\n        ref: Optional[int] = None\\n        ref_str: Optional[str] = child.attrib.get(\"ref\")\\n        if ref_str is not None:\\n            ref = int(ref_str)\\n\\n        role: Optional[str] = child.attrib.get(\"role\")\\n\\n        attributes = {}\\n        ignore = [\"geometry\", \"ref\", \"role\", \"type\"]\\n        for n, v in child.attrib.items():\\n            if n in ignore:\\n                continue\\n            attributes[n] = v\\n\\n        geometry = None\\n        for sub_child in child:\\n            if sub_child.tag.lower() == \"nd\":\\n                if geometry is None:\\n                    geometry = []\\n                geometry.append(\\n                    RelationWayGeometryValue(\\n                        lat=Decimal(sub_child.attrib[\"lat\"]),\\n                        lon=Decimal(sub_child.attrib[\"lon\"])\\n                    )\\n                )\\n\\n        return cls(\\n            attributes=attributes,\\n            geometry=geometry,\\n            ref=ref,\\n            role=role,\\n            result=result\\n        )\\n\\n\\nclass RelationNode(RelationMember):\\n    _type_value = \"node\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Node:\\n        return self._result.get_node(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationNode ref={self.ref} role={self.role}>\"\\n\\n\\nclass RelationWay(RelationMember):\\n    _type_value = \"way\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Way:\\n        return self._result.get_way(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationWay ref={self.ref} role={self.role}>\"\\n\\n\\nclass RelationWayGeometryValue:\\n    def __init__(self, lat: Union[Decimal, float], lon: Union[Decimal, float]):\\n        self.lat = lat\\n        self.lon = lon\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationWayGeometryValue lat={self.lat} lon={self.lon}>\"\\n\\n\\nclass RelationRelation(RelationMember):\\n    _type_value = \"relation\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Relation:\\n        return self._result.get_relation(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationRelation ref={self.ref} role={self.role}>\"\\n\\n\\nclass RelationArea(RelationMember):\\n    _type_value = \"area\"\\n\\n    def resolve(self, resolve_missing: bool = False) -> Area:\\n        return self._result.get_area(self.ref, resolve_missing=resolve_missing)\\n\\n    def __repr__(self):\\n        return f\"<overpy.RelationArea ref={self.ref} role={self.role}>\"\\n\\n\\nclass OSMSAXHandler(handler.ContentHandler):\\n    \"\"\"\\n    SAX parser for Overpass XML response.\\n    \"\"\"\\n    #: Tuple of opening elements to ignore\\n    ignore_start: ClassVar = (\\'osm\\', \\'meta\\', \\'note\\', \\'bounds\\', \\'remark\\')\\n    #: Tuple of closing elements to ignore\\n    ignore_end: ClassVar = (\\'osm\\', \\'meta\\', \\'note\\', \\'bounds\\', \\'remark\\', \\'tag\\', \\'nd\\', \\'center\\')\\n\\n    def __init__(self, result: Result):\\n        \"\"\"\\n        :param result: Append results to this result set.\\n        \"\"\"\\n        handler.ContentHandler.__init__(self)\\n        self._result = result\\n        self._curr: Dict[str, Any] = {}\\n        #: Current relation member object\\n        self.cur_relation_member: Optional[RelationMember] = None\\n\\n    def startElement(self, name: str, attrs: dict):\\n        \"\"\"\\n        Handle opening elements.\\n\\n        :param name: Name of the element\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        if name in self.ignore_start:\\n            return\\n        try:\\n            handler = getattr(self, \\'_handle_start_%s\\' % name)\\n        except AttributeError:\\n            raise KeyError(\"Unknown element start \\'%s\\'\" % name)\\n        handler(attrs)\\n\\n    def endElement(self, name: str):\\n        \"\"\"\\n        Handle closing elements\\n\\n        :param name: Name of the element\\n        \"\"\"\\n        if name in self.ignore_end:\\n            return\\n        try:\\n            handler = getattr(self, \\'_handle_end_%s\\' % name)\\n        except AttributeError:\\n            raise KeyError(\"Unknown element end \\'%s\\'\" % name)\\n        handler()\\n\\n    def _handle_start_center(self, attrs: dict):\\n        \"\"\"\\n        Handle opening center element\\n\\n        :param attrs: Attributes of the element\\n        :type attrs: Dict\\n        \"\"\"\\n        center_lat = attrs.get(\"lat\")\\n        center_lon = attrs.get(\"lon\")\\n        if center_lat is None or center_lon is None:\\n            raise ValueError(\"Unable to get lat or lon of way center.\")\\n        self._curr[\"center_lat\"] = Decimal(center_lat)\\n        self._curr[\"center_lon\"] = Decimal(center_lon)\\n\\n    def _handle_start_tag(self, attrs: dict):\\n        \"\"\"\\n        Handle opening tag element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        try:\\n            tag_key = attrs[\\'k\\']\\n        except KeyError:\\n            raise ValueError(\"Tag without name/key.\")\\n        self._curr[\\'tags\\'][tag_key] = attrs.get(\\'v\\')\\n\\n    def _handle_start_node(self, attrs: dict):\\n        \"\"\"\\n        Handle opening node element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'attributes\\': dict(attrs),\\n            \\'lat\\': None,\\n            \\'lon\\': None,\\n            \\'node_id\\': None,\\n            \\'tags\\': {}\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'node_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n        if attrs.get(\\'lat\\', None) is not None:\\n            self._curr[\\'lat\\'] = Decimal(attrs[\\'lat\\'])\\n            del self._curr[\\'attributes\\'][\\'lat\\']\\n        if attrs.get(\\'lon\\', None) is not None:\\n            self._curr[\\'lon\\'] = Decimal(attrs[\\'lon\\'])\\n            del self._curr[\\'attributes\\'][\\'lon\\']\\n\\n    def _handle_end_node(self):\\n        \"\"\"\\n        Handle closing node element\\n        \"\"\"\\n        self._result.append(Node(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_way(self, attrs: dict):\\n        \"\"\"\\n        Handle opening way element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'center_lat\\': None,\\n            \\'center_lon\\': None,\\n            \\'attributes\\': dict(attrs),\\n            \\'node_ids\\': [],\\n            \\'tags\\': {},\\n            \\'way_id\\': None\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'way_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n\\n    def _handle_end_way(self):\\n        \"\"\"\\n        Handle closing way element\\n        \"\"\"\\n        self._result.append(Way(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_area(self, attrs: dict):\\n        \"\"\"\\n        Handle opening area element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'attributes\\': dict(attrs),\\n            \\'tags\\': {},\\n            \\'area_id\\': None\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'area_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n\\n    def _handle_end_area(self):\\n        \"\"\"\\n        Handle closing area element\\n        \"\"\"\\n        self._result.append(Area(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_nd(self, attrs: dict):\\n        \"\"\"\\n        Handle opening nd element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        if isinstance(self.cur_relation_member, RelationWay):\\n            if self.cur_relation_member.geometry is None:\\n                self.cur_relation_member.geometry = []\\n            self.cur_relation_member.geometry.append(\\n                RelationWayGeometryValue(\\n                    lat=Decimal(attrs[\"lat\"]),\\n                    lon=Decimal(attrs[\"lon\"])\\n                )\\n            )\\n        else:\\n            try:\\n                node_ref = attrs[\\'ref\\']\\n            except KeyError:\\n                raise ValueError(\"Unable to find required ref value.\")\\n            self._curr[\\'node_ids\\'].append(int(node_ref))\\n\\n    def _handle_start_relation(self, attrs: dict):\\n        \"\"\"\\n        Handle opening relation element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n        self._curr = {\\n            \\'attributes\\': dict(attrs),\\n            \\'members\\': [],\\n            \\'rel_id\\': None,\\n            \\'tags\\': {}\\n        }\\n        if attrs.get(\\'id\\', None) is not None:\\n            self._curr[\\'rel_id\\'] = int(attrs[\\'id\\'])\\n            del self._curr[\\'attributes\\'][\\'id\\']\\n\\n    def _handle_end_relation(self):\\n        \"\"\"\\n        Handle closing relation element\\n        \"\"\"\\n        self._result.append(Relation(result=self._result, **self._curr))\\n        self._curr = {}\\n\\n    def _handle_start_member(self, attrs: dict):\\n        \"\"\"\\n        Handle opening member element\\n\\n        :param attrs: Attributes of the element\\n        \"\"\"\\n\\n        params: Dict[str, Any] = {\\n            # ToDo: Parse attributes\\n            \\'attributes\\': {},\\n            \\'ref\\': None,\\n            \\'result\\': self._result,\\n            \\'role\\': None\\n        }\\n        if attrs.get(\\'ref\\', None):\\n            params[\\'ref\\'] = int(attrs[\\'ref\\'])\\n        if attrs.get(\\'role\\', None):\\n            params[\\'role\\'] = attrs[\\'role\\']\\n\\n        cls_map = {\\n            \"area\": RelationArea,\\n            \"node\": RelationNode,\\n            \"relation\": RelationRelation,\\n            \"way\": RelationWay\\n        }\\n        cls: Type[RelationMember] = cls_map.get(attrs[\"type\"])\\n        if cls is None:\\n            raise ValueError(\"Undefined type for member: \\'%s\\'\" % attrs[\\'type\\'])\\n\\n        self.cur_relation_member = cls(**params)\\n        self._curr[\\'members\\'].append(self.cur_relation_member)\\n\\n    def _handle_end_member(self):\\n        self.cur_relation_member = None\\n'"}, {"func_args": {"source": "'class OverPyException(Exception):\\n    \"\"\"OverPy base exception\"\"\"\\n    pass\\n\\n\\nclass DataIncomplete(OverPyException):\\n    \"\"\"\\n    Raised if the requested data isn\\'t available in the result.\\n    Try to improve the query or to resolve the missing data.\\n    \"\"\"\\n    def __init__(self, *args, **kwargs):\\n        OverPyException.__init__(\\n            self,\\n            \"Data incomplete try to improve the query to resolve the missing data\",\\n            *args,\\n            **kwargs\\n        )\\n\\n\\nclass ElementDataWrongType(OverPyException):\\n    \"\"\"\\n    Raised if the provided element does not match the expected type.\\n\\n    :param type_expected: The expected element type\\n    :type type_expected: String\\n    :param type_provided: The provided element type\\n    :type type_provided: String|None\\n    \"\"\"\\n    def __init__(self, type_expected, type_provided=None):\\n        self.type_expected = type_expected\\n        self.type_provided = type_provided\\n\\n    def __str__(self) -> str:\\n        return \"Type expected \\'{}\\' but \\'{}\\' provided\".format(\\n            self.type_expected,\\n            str(self.type_provided)\\n        )\\n\\n\\nclass MaxRetriesReached(OverPyException):\\n    \"\"\"\\n    Raised if max retries reached and the Overpass server didn\\'t respond with a result.\\n    \"\"\"\\n    def __init__(self, retry_count, exceptions):\\n        self.exceptions = exceptions\\n        self.retry_count = retry_count\\n\\n    def __str__(self) -> str:\\n        return \"Unable get any result from the Overpass API server after %d retries.\" % self.retry_count\\n\\n\\nclass OverpassBadRequest(OverPyException):\\n    \"\"\"\\n    Raised if the Overpass API service returns a syntax error.\\n\\n    :param query: The encoded query how it was send to the server\\n    :type query: Bytes\\n    :param msgs: List of error messages\\n    :type msgs: List\\n    \"\"\"\\n    def __init__(self, query, msgs=None):\\n        self.query = query\\n        if msgs is None:\\n            msgs = []\\n        self.msgs = msgs\\n\\n    def __str__(self) -> str:\\n        tmp_msgs = []\\n        for tmp_msg in self.msgs:\\n            if not isinstance(tmp_msg, str):\\n                tmp_msg = str(tmp_msg)\\n            tmp_msgs.append(tmp_msg)\\n\\n        return \"\\\\n\".join(tmp_msgs)\\n\\n\\nclass OverpassError(OverPyException):\\n    \"\"\"\\n    Base exception to report errors if the response returns a remark tag or element.\\n\\n    .. note::\\n        If you are not sure which of the subexceptions you should use, use this one and try to parse the message.\\n\\n        For more information have a look at https://github.com/DinoTools/python-overpy/issues/62\\n\\n    :param str msg: The message from the remark tag or element\\n    \"\"\"\\n    def __init__(self, msg=None):\\n        #: The message from the remark tag or element\\n        self.msg = msg\\n\\n    def __str__(self) -> str:\\n        if self.msg is None:\\n            return \"No error message provided\"\\n        if not isinstance(self.msg, str):\\n            return str(self.msg)\\n        return self.msg\\n\\n\\nclass OverpassGatewayTimeout(OverPyException):\\n    \"\"\"\\n    Raised if load of the Overpass API service is too high and it can\\'t handle the request.\\n    \"\"\"\\n    def __init__(self):\\n        OverPyException.__init__(self, \"Server load too high\")\\n\\n\\nclass OverpassRuntimeError(OverpassError):\\n    \"\"\"\\n    Raised if the server returns a remark-tag(xml) or remark element(json) with a message starting with\\n    \\'runtime error:\\'.\\n    \"\"\"\\n    pass\\n\\n\\nclass OverpassRuntimeRemark(OverpassError):\\n    \"\"\"\\n    Raised if the server returns a remark-tag(xml) or remark element(json) with a message starting with\\n    \\'runtime remark:\\'.\\n    \"\"\"\\n    pass\\n\\n\\nclass OverpassTooManyRequests(OverPyException):\\n    \"\"\"\\n    Raised if the Overpass API service returns a 429 status code.\\n    \"\"\"\\n    def __init__(self):\\n        OverPyException.__init__(self, \"Too many requests\")\\n\\n\\nclass OverpassUnknownContentType(OverPyException):\\n    \"\"\"\\n    Raised if the reported content type isn\\'t handled by OverPy.\\n\\n    :param content_type: The reported content type\\n    :type content_type: None or String\\n    \"\"\"\\n    def __init__(self, content_type):\\n        self.content_type = content_type\\n\\n    def __str__(self) -> str:\\n        if self.content_type is None:\\n            return \"No content type returned\"\\n        return \"Unknown content type: %s\" % self.content_type\\n\\n\\nclass OverpassUnknownError(OverpassError):\\n    \"\"\"\\n    Raised if the server returns a remark-tag(xml) or remark element(json) and we are unable to find any reason.\\n    \"\"\"\\n    pass\\n\\n\\nclass OverpassUnknownHTTPStatusCode(OverPyException):\\n    \"\"\"\\n    Raised if the returned HTTP status code isn\\'t handled by OverPy.\\n\\n    :param code: The HTTP status code\\n    :type code: Integer\\n    \"\"\"\\n    def __init__(self, code):\\n        self.code = code\\n\\n    def __str__(self) -> str:\\n        return \"Unknown/Unhandled status code: %d\" % self.code\\n'"}, "return_value": "'class OverPyException(Exception):\\n    \"\"\"OverPy base exception\"\"\"\\n    pass\\n\\n\\nclass DataIncomplete(OverPyException):\\n    \"\"\"\\n    Raised if the requested data isn\\'t available in the result.\\n    Try to improve the query or to resolve the missing data.\\n    \"\"\"\\n    def __init__(self, *args, **kwargs):\\n        OverPyException.__init__(\\n            self,\\n            \"Data incomplete try to improve the query to resolve the missing data\",\\n            *args,\\n            **kwargs\\n        )\\n\\n\\nclass ElementDataWrongType(OverPyException):\\n    \"\"\"\\n    Raised if the provided element does not match the expected type.\\n\\n    :param type_expected: The expected element type\\n    :type type_expected: String\\n    :param type_provided: The provided element type\\n    :type type_provided: String|None\\n    \"\"\"\\n    def __init__(self, type_expected, type_provided=None):\\n        self.type_expected = type_expected\\n        self.type_provided = type_provided\\n\\n    def __str__(self) -> str:\\n        return \"Type expected \\'{}\\' but \\'{}\\' provided\".format(\\n            self.type_expected,\\n            str(self.type_provided)\\n        )\\n\\n\\nclass MaxRetriesReached(OverPyException):\\n    \"\"\"\\n    Raised if max retries reached and the Overpass server didn\\'t respond with a result.\\n    \"\"\"\\n    def __init__(self, retry_count, exceptions):\\n        self.exceptions = exceptions\\n        self.retry_count = retry_count\\n\\n    def __str__(self) -> str:\\n        return \"Unable get any result from the Overpass API server after %d retries.\" % self.retry_count\\n\\n\\nclass OverpassBadRequest(OverPyException):\\n    \"\"\"\\n    Raised if the Overpass API service returns a syntax error.\\n\\n    :param query: The encoded query how it was send to the server\\n    :type query: Bytes\\n    :param msgs: List of error messages\\n    :type msgs: List\\n    \"\"\"\\n    def __init__(self, query, msgs=None):\\n        self.query = query\\n        if msgs is None:\\n            msgs = []\\n        self.msgs = msgs\\n\\n    def __str__(self) -> str:\\n        tmp_msgs = []\\n        for tmp_msg in self.msgs:\\n            if not isinstance(tmp_msg, str):\\n                tmp_msg = str(tmp_msg)\\n            tmp_msgs.append(tmp_msg)\\n\\n        return \"\\\\n\".join(tmp_msgs)\\n\\n\\nclass OverpassError(OverPyException):\\n    \"\"\"\\n    Base exception to report errors if the response returns a remark tag or element.\\n\\n    .. note::\\n        If you are not sure which of the subexceptions you should use, use this one and try to parse the message.\\n\\n        For more information have a look at https://github.com/DinoTools/python-overpy/issues/62\\n\\n    :param str msg: The message from the remark tag or element\\n    \"\"\"\\n    def __init__(self, msg=None):\\n        #: The message from the remark tag or element\\n        self.msg = msg\\n\\n    def __str__(self) -> str:\\n        if self.msg is None:\\n            return \"No error message provided\"\\n        if not isinstance(self.msg, str):\\n            return str(self.msg)\\n        return self.msg\\n\\n\\nclass OverpassGatewayTimeout(OverPyException):\\n    \"\"\"\\n    Raised if load of the Overpass API service is too high and it can\\'t handle the request.\\n    \"\"\"\\n    def __init__(self):\\n        OverPyException.__init__(self, \"Server load too high\")\\n\\n\\nclass OverpassRuntimeError(OverpassError):\\n    \"\"\"\\n    Raised if the server returns a remark-tag(xml) or remark element(json) with a message starting with\\n    \\'runtime error:\\'.\\n    \"\"\"\\n    pass\\n\\n\\nclass OverpassRuntimeRemark(OverpassError):\\n    \"\"\"\\n    Raised if the server returns a remark-tag(xml) or remark element(json) with a message starting with\\n    \\'runtime remark:\\'.\\n    \"\"\"\\n    pass\\n\\n\\nclass OverpassTooManyRequests(OverPyException):\\n    \"\"\"\\n    Raised if the Overpass API service returns a 429 status code.\\n    \"\"\"\\n    def __init__(self):\\n        OverPyException.__init__(self, \"Too many requests\")\\n\\n\\nclass OverpassUnknownContentType(OverPyException):\\n    \"\"\"\\n    Raised if the reported content type isn\\'t handled by OverPy.\\n\\n    :param content_type: The reported content type\\n    :type content_type: None or String\\n    \"\"\"\\n    def __init__(self, content_type):\\n        self.content_type = content_type\\n\\n    def __str__(self) -> str:\\n        if self.content_type is None:\\n            return \"No content type returned\"\\n        return \"Unknown content type: %s\" % self.content_type\\n\\n\\nclass OverpassUnknownError(OverpassError):\\n    \"\"\"\\n    Raised if the server returns a remark-tag(xml) or remark element(json) and we are unable to find any reason.\\n    \"\"\"\\n    pass\\n\\n\\nclass OverpassUnknownHTTPStatusCode(OverPyException):\\n    \"\"\"\\n    Raised if the returned HTTP status code isn\\'t handled by OverPy.\\n\\n    :param code: The HTTP status code\\n    :type code: Integer\\n    \"\"\"\\n    def __init__(self, code):\\n        self.code = code\\n\\n    def __str__(self) -> str:\\n        return \"Unknown/Unhandled status code: %d\" % self.code\\n'"}, {"func_args": {"source": "'from typing import List, Optional\\n__author__ = \\'mjob\\'\\n\\nimport overpy\\n\\n\\ndef get_street(\\n        street: str,\\n        areacode: str,\\n        api: Optional[overpy.Overpass] = None) -> overpy.Result:\\n    \"\"\"\\n    Retrieve streets in a given bounding area\\n\\n    :param street: Name of street\\n    :param areacode: The OSM id of the bounding area\\n    :param api: API object to fetch missing elements\\n    :return: Parsed result\\n    :raises overpy.exception.OverPyException: If something bad happens.\\n    \"\"\"\\n    if api is None:\\n        api = overpy.Overpass()\\n\\n    query = \"\"\"\\n        area(%s)->.location;\\n        (\\n            way[highway][name=\"%s\"](area.location);\\n            - (\\n                way[highway=service](area.location);\\n                way[highway=track](area.location);\\n            );\\n        );\\n        out body;\\n        >;\\n        out skel qt;\\n    \"\"\"\\n\\n    data = api.query(query % (areacode, street))\\n\\n    return data\\n\\n\\ndef get_intersection(\\n        street1: str,\\n        street2: str,\\n        areacode: str,\\n        api: Optional[overpy.Overpass] = None) -> List[overpy.Node]:\\n    \"\"\"\\n    Retrieve intersection of two streets in a given bounding area\\n\\n    :param street1: Name of first street of intersection\\n    :param street2: Name of second street of intersection\\n    :param areacode: The OSM id of the bounding area\\n    :param api: API object to fetch missing elements\\n    :return: List of intersections\\n    :raises overpy.exception.OverPyException: If something bad happens.\\n    \"\"\"\\n    if api is None:\\n        api = overpy.Overpass()\\n\\n    query = \"\"\"\\n        area(%s)->.location;\\n        (\\n            way[highway][name=\"%s\"](area.location); node(w)->.n1;\\n            way[highway][name=\"%s\"](area.location); node(w)->.n2;\\n        );\\n        node.n1.n2;\\n        out meta;\\n    \"\"\"\\n\\n    data = api.query(query % (areacode, street1, street2))\\n\\n    return data.get_nodes()\\n'"}, "return_value": "'from typing import List, Optional\\n__author__ = \\'mjob\\'\\n\\nimport overpy\\n\\n\\ndef get_street(\\n        street: str,\\n        areacode: str,\\n        api: Optional[overpy.Overpass] = None) -> overpy.Result:\\n    \"\"\"\\n    Retrieve streets in a given bounding area\\n\\n    :param street: Name of street\\n    :param areacode: The OSM id of the bounding area\\n    :param api: API object to fetch missing elements\\n    :return: Parsed result\\n    :raises overpy.exception.OverPyException: If something bad happens.\\n    \"\"\"\\n    if api is None:\\n        api = overpy.Overpass()\\n\\n    query = \"\"\"\\n        area(%s)->.location;\\n        (\\n            way[highway][name=\"%s\"](area.location);\\n            - (\\n                way[highway=service](area.location);\\n                way[highway=track](area.location);\\n            );\\n        );\\n        out body;\\n        >;\\n        out skel qt;\\n    \"\"\"\\n\\n    data = api.query(query % (areacode, street))\\n\\n    return data\\n\\n\\ndef get_intersection(\\n        street1: str,\\n        street2: str,\\n        areacode: str,\\n        api: Optional[overpy.Overpass] = None) -> List[overpy.Node]:\\n    \"\"\"\\n    Retrieve intersection of two streets in a given bounding area\\n\\n    :param street1: Name of first street of intersection\\n    :param street2: Name of second street of intersection\\n    :param areacode: The OSM id of the bounding area\\n    :param api: API object to fetch missing elements\\n    :return: List of intersections\\n    :raises overpy.exception.OverPyException: If something bad happens.\\n    \"\"\"\\n    if api is None:\\n        api = overpy.Overpass()\\n\\n    query = \"\"\"\\n        area(%s)->.location;\\n        (\\n            way[highway][name=\"%s\"](area.location); node(w)->.n1;\\n            way[highway][name=\"%s\"](area.location); node(w)->.n2;\\n        );\\n        node.n1.n2;\\n        out meta;\\n    \"\"\"\\n\\n    data = api.query(query % (areacode, street1, street2))\\n\\n    return data.get_nodes()\\n'"}]}}